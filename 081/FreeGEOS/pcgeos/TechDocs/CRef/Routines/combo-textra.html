<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><meta http-equiv="Content-Type" content="text/html; charset=utf8">
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>GEOS Cルーチンリファレンス</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">このドキュメントは<A HREF="index.htm">複数ページのドキュメント</A>簡単な印刷に適しています。<A NAME="index.htm"></A><DIV>
</DIV>
<H1>GEOS Cルーチンリファレンス</H1>
<P>このマニュアルには、ほとんどのGEOSシステムルーチンの参照情報が記載されています。 このドキュメントおよびその他のGEOS SDKドキュメントの情報は、次のサイトで参照できます。<A HREF="../../docIndexes/bigIndex/indexA.htm">インデックス</A>このリファレンスを参照する場合は、次のいずれかのリンクを選択してください。各テキストは、ドキュメントのページに記載されている最初のルーチンの名前です。</P>
<P CLASS="sectionlinks">
          <STRONG>
            <A HREF="#R_1.htm">AccessPointCommit().</A>
            <BR>
            <A HREF="#R_2.htm">AccessPointGetStringPropertyBlock() ……………………</A>
            <BR>
            <A HREF="#R_3.htm">ArrayQuickSort().</A>
            <BR>
            <A HREF="#R_4.htm">CCB().</A>
            <BR>
            <A HREF="#R_5.htm">CFatalError() ……………………</A>
            <BR>
            <A HREF="#R_6.htm">ChunkArrayDelete() ……………………</A>
            <BR>
            <A HREF="#R_7.htm">ChunkArrayElementToPtr() ……………………</A>
            <BR>
            <A HREF="#R_8.htm">ChunkArrayGetCountHandles() ……………………</A>
            <BR>
            <A HREF="#R_9.htm">ChunkArraySort().</A>
            <BR>
            <A HREF="#R_a.htm">ClipboardClearQuickTransferNotification() ……………………</A>
            <BR>
            <A HREF="#R_b.htm">ClipboardQueryItem() ……………………</A>
            <BR>
            <A HREF="#R_c.htm">ClipboardSetQuickTransferFeedback() ……………………</A>
            <BR>
            <A HREF="#R_d.htm">ConstructOptr() ……………………</A>
            <BR>
            <A HREF="#R_e.htm">ContactGetDBHandle() ……………………</A>
            <BR>
            <A HREF="#R_f.htm">ContactMatchNumber().</A>
            <BR>
            <A HREF="#R_10.htm">DataStoreCreate() ……………………</A>
            <BR>
            <A HREF="#R_11.htm">DataStoreDiscardRecord().</A>
            <BR>
            <A HREF="#R_12.htm">DataStoreGetFieldChunk().</A>
            <BR>
            <A HREF="#R_13.htm">DataStoreGetRecordCount() ……………………</A>
            <BR>
            <A HREF="#R_14.htm">DataStoreNewRecord().</A>
            <BR>
            <A HREF="#R_15.htm">DataStoreSetField() ……………………</A>
            <BR>
            <A HREF="#R_16.htm">DBAlloc().</A>
            <BR>
            <A HREF="#R_17.htm">DBDeref().</A>
            <BR>
            <A HREF="#R_18.htm">Dブロック() ……………………</A>
            <BR>
            <A HREF="#R_19.htm">DiskCheckInUse() ……………………</A>
            <BR>
            <A HREF="#R_1a.htm">DiskForEach() ……………………</A>
            <BR>
            <A HREF="#R_1b.htm">DiskGetDrive() ……………………</A>
            <BR>
            <A HREF="#R_1c.htm">DiskSave()メソッド ……………………</A>
            <BR>
            <A HREF="#R_1d.htm">DriveGetDefaultMedia().</A>
            <BR>
            <A HREF="#R_1e.htm">EC().</A>
            <BR>
            <A HREF="#R_1f.htm">ECCheckHugeArray().</A>
            <BR>
            <A HREF="#R_20.htm">ECCheckProcessHandle() ……………………</A>
            <BR>
            <A HREF="#R_21.htm">ECVMCheckVMBlockHandle() ……………………</A>
            <BR>
            <A HREF="#R_22.htm">ElementArrayDelete() ……………………</A>
            <BR>
            <A HREF="#R_23.htm">ElementArrayRemoveReference() ……………………</A>
            <BR>
            <A HREF="#R_24.htm">FatalError()[致命的エラー] ……………………</A>
            <BR>
            <A HREF="#R_25.htm">FileCreate()関数 ……………………</A>
            <BR>
            <A HREF="#R_26.htm">FileDeleteDir() ……………………</A>
            <BR>
            <A HREF="#R_27.htm">FileEnum() ……………………</A>
            <BR>
            <A HREF="#R_28.htm">FileEnumLocateAttr() ……………………</A>
            <BR>
            <A HREF="#R_29.htm">FileGetDiskHandle() ……………………</A>
            <BR>
            <A HREF="#R_2a.htm">ファイルを開く() ……………………</A>
            <BR>
            <A HREF="#R_2b.htm">FileRename()[ファイル名を変更] ……………………</A>
            <BR>
            <A HREF="#R_2c.htm">FileSetHandleExtAttributes() ……………………</A>
            <BR>
            <A HREF="#R_2d.htm">FileTruncate() ……………………</A>
            <BR>
            <A HREF="#R_2e.htm">FloatFloatToAscii() ……………………</A>
            <BR>
            <A HREF="#R_FoamDBAdd.htm">FoamDBAddFieldToRecord().</A>
            <BR>
            <A HREF="#R_FoamDBGetCurrent.htm">FoamDBGetCurrentRecordID().</A>
            <BR>
            <A HREF="#R_FoamDBResumeUpdates.htm">FoamDBResumeUpdates() ……………………</A>
            <BR>
            <A HREF="#R_2f.htm">FormatIDFromManufacturerAndType…</A>
            <BR>
            <A HREF="#R_30.htm">GCNListAdd() ……………………</A>
            <BR>
            <A HREF="#R_31.htm">GCNListSend() ……………………</A>
            <BR>
            <A HREF="#R_32.htm">GenCopyChunk().</A>
            <BR>
            <A HREF="#R_33.htm">GeodeAllocQueue() ……………………</A>
            <BR>
            <A HREF="#R_34.htm">GeodeGetAppObject().</A>
            <BR>
            <A HREF="#R_35.htm">GeodeLoadDGroup…</A>
            <BR>
            <A HREF="#R_36.htm">GeoFree関数() ……………………</A>
            <BR>
            <A HREF="#R_37.htm">GrApplyTranslation() ……………………</A>
            <BR>
            <A HREF="#R_38.htm">GrClearBitmap().</A>
            <BR>
            <A HREF="#R_39.htm">GrDestroyBitmap().</A>
            <BR>
            <A HREF="#R_3a.htm">GrDrawCurve() ……………………</A>
            <BR>
            <A HREF="#R_3b.htm">GrDrawLine() ……………………</A>
            <BR>
            <A HREF="#R_3c.htm">GrDrawRect() ……………………</A>
            <BR>
            <A HREF="#R_3d.htm">GrDrawRoundRect() ……………………</A>
            <BR>
            <A HREF="#R_3e.htm">GrEndGString() ……………………</A>
            <BR>
            <A HREF="#R_3f.htm">GrFillEllipse() ……………………</A>
            <BR>
            <A HREF="#R_40.htm">GrGetAreaColor() ……………………</A>
            <BR>
            <A HREF="#R_41.htm">GrGetDefFontID().</A>
            <BR>
            <A HREF="#R_42.htm">GrGetLineMask() ……………………</A>
            <BR>
            <A HREF="#R_43.htm">GrGetPtrRegBounds() ……………………</A>
            <BR>
            <A HREF="#R_44.htm">GrInitDefaultTransform().</A>
            <BR>
            <A HREF="#R_45.htm">GrNewPage() ……………………</A>
            <BR>
            <A HREF="#R_46.htm">GrSDivDWFByWWF().</A>
            <BR>
            <A HREF="#R_47.htm">GrSetClipPath() ……………………</A>
            <BR>
            <A HREF="#R_48.htm">GrSetLineAttr() ……………………</A>
            <BR>
            <A HREF="#R_49.htm">GrSetPalette() ……………………</A>
            <BR>
            <A HREF="#R_4a.htm">GrSetTextMode() ……………………</A>
            <BR>
            <A HREF="#R_4b.htm">GrTestPointInPath() ……………………</A>
            <BR>
            <A HREF="#R_4c.htm">GrUDivWWFixed() ……………………</A>
            <BR>
            <A HREF="#R_4d.htm">GSCloseSubPath() ……………………</A>
            <BR>
            <A HREF="#R_4e.htm">GSDrawEllipse() ……………………</A>
            <BR>
            <A HREF="#R_4f.htm">GSDrawSpline() ……………………</A>
            <BR>
            <A HREF="#R_50.htm">GSFillBitmap().</A>
            <BR>
            <A HREF="#R_51.htm">GSMoveTo().</A>
            <BR>
            <A HREF="#R_52.htm">GSSetCustomLineMask() ……………………</A>
            <BR>
            <A HREF="#R_53.htm">GSSetLineEnd() ……………………</A>
            <BR>
            <A HREF="#R_54.htm">GSSetSubscriptAttr() ……………………</A>
            <BR>
            <A HREF="#R_55.htm">関数HAL_COUNT() ……………………</A>
            <BR>
            <A HREF="#R_56.htm">HandleV().</A>
            <BR>
            <A HREF="#R_57.htm">HugeArrayDestroy().</A>
            <BR>
            <A HREF="#R_58.htm">HugeArrayPrev() ……………………</A>
            <BR>
            <A HREF="#R_59.htm">IACPProcessMessage() ……………………</A>
            <BR>
            <A HREF="#R_5a.htm">ImpexExportToMetafile() ……………………</A>
            <BR>
            <A HREF="#R_5b.htm">InitFileEnumStringSection() ……………………</A>
            <BR>
            <A HREF="#R_5c.htm">InitFileReadStringBlock() ……………………</A>
            <BR>
            <A HREF="#R_5d.htm">InitFileRevert().</A>
            <BR>
            <A HREF="#R_5e.htm">InkDBGetDisplayInfo().</A>
            <BR>
            <A HREF="#R_5f.htm">InkFolderGetNumChildren() ……………………</A>
            <BR>
            <A HREF="#R_60.htm">InkNoteGetCreationDate() ……………………</A>
            <BR>
            <A HREF="#R_61.htm">InkNoteSetModificationDate() ……………………</A>
            <BR>
            <A HREF="#R_62.htm">isalnum()も参照下さい。 ……………………</A>
            <BR>
            <A HREF="#R_63.htm">LMemAlloc().</A>
            <BR>
            <A HREF="#R_64.htm">LMemGetChunkSize() ……………………</A>
            <BR>
            <A HREF="#R_65.htm">LMemReAlloc().</A>
            <BR>
            <A HREF="#R_66.htm">LocalAsciiToFixed() ……………………</A>
            <BR>
            <A HREF="#R_67.htm">LocalCustomParseDateTime() ……………………</A>
            <BR>
            <A HREF="#R_68.htm">LocalGeosToCodePage() ……………………</A>
            <BR>
            <A HREF="#R_69.htm">LocalLexicalValue() ……………………</A>
            <BR>
            <A HREF="#R_MailboxAck.htm">MailboxAcknowledgeMessageReceipt() ……………………</A>
            <BR>
            <A HREF="#R_MailboxGetBodyFormat.htm">MailboxGetBodyFormat() ……………………</A>
            <BR>
            <A HREF="#R_MailboxGetVMFile.htm">MailboxGetVMFile() ……………………</A>
            <BR>
            <A HREF="#R_6a.htm">MakeWWFixed() ……………………</A>
            <BR>
            <A HREF="#R_6b.htm">MemAlloc()関数.</A>
            <BR>
            <A HREF="#R_6c.htm">MemDowngradeExclLock() ……………………</A>
            <BR>
            <A HREF="#R_6d.htm">MemLock()関数 ……………………</A>
            <BR>
            <A HREF="#R_6e.htm">MemModifyFlags() ……………………</A>
            <BR>
            <A HREF="#R_6f.htm">MemThreadGrab() ……………………</A>
            <BR>
            <A HREF="#R_70.htm">MemUnlock() ……………………</A>
            <BR>
            <A HREF="#R_71.htm">ModemAnswerCall() ……………………</A>
            <BR>
            <A HREF="#R_72.htm">ModemSetMessageDataNotify().</A>
            <BR>
            <A HREF="#R_73.htm">NameArrayAdd() ……………………</A>
            <BR>
            <A HREF="#R_74.htm">NameArrayFind() ……………………</A>
            <BR>
            <A HREF="#R_75.htm">ObjCompFindChildByOptr() ……………………</A>
            <BR>
            <A HREF="#R_76.htm">ObjCompProcessChildren() ……………………</A>
            <BR>
            <A HREF="#R_77.htm">ObjDeref().</A>
            <BR>
            <A HREF="#R_78.htm">ObjDoRelocation() ……………………</A>
            <BR>
            <A HREF="#R_79.htm">ObjFreeChunk().</A>
            <BR>
            <A HREF="#R_7a.htm">ObjInitDetach() ……………………</A>
            <BR>
            <A HREF="#R_7b.htm">ObjIsClassADescendant() ……………………</A>
            <BR>
            <A HREF="#R_7c.htm">ObjResizeMaster().</A>
            <BR>
            <A HREF="#R_7d.htm">ObjVarAddData().</A>
            <BR>
            <A HREF="#R_7e.htm">ObjVarDeleteDataAt().</A>
            <BR>
            <A HREF="#R_7f.htm">ObjVarScanData().</A>
            <BR>
            <A HREF="#R_80.htm">ParallelClose() ……………………</A>
            <BR>
            <A HREF="#R_81.htm">PCCOMABORT() ……………………</A>
            <BR>
            <A HREF="#R_82.htm">並べ替え.</A>
            <BR>
            <A HREF="#R_83.htm">参照):realloc().</A>
            <BR>
            <A HREF="#R_84.htm">SerialGetFormat() ……………………</A>
            <BR>
            <A HREF="#R_85.htm">SGC_MACHINE(マシン).</A>
            <BR>
            <A HREF="#R_86.htm">SocketBind() ……………………</A>
            <BR>
            <A HREF="#R_87.htm">SocketClose() ……………………</A>
            <BR>
            <A HREF="#R_88.htm">SocketGetAddressController().</A>
            <BR>
            <A HREF="#R_89.htm">SocketInterrupt() ……………………</A>
            <BR>
            <A HREF="#R_8a.htm">SocketRemoveLoadOnMsg() ……………………</A>
            <BR>
            <A HREF="#R_8b.htm">SoundAllocMusic().</A>
            <BR>
            <A HREF="#R_8c.htm">SoundFreeMusic().</A>
            <BR>
            <A HREF="#R_8d.htm">SoundPlayToMusicStream().</A>
            <BR>
            <A HREF="#R_8e.htm">SpeedDialGetNumber().</A>
            <BR>
            <A HREF="#R_8f.htm">SpoolGetNumPaperSizes() ……………………</A>
            <BR>
            <A HREF="#R_90.htm">SpoolModifyPriority() ……………………</A>
            <BR>
            <A HREF="#R_91.htm">StreamOpen()[ストリームを開く] ……………………</A>
            <BR>
            <A HREF="#R_92.htm">StreamWrite()関数 ……………………</A>
            <BR>
            <A HREF="#R_93.htm">SysGetPenMode() ……………………</A>
            <BR>
            <A HREF="#R_94.htm">SysShutdown() ……………………</A>
            <BR>
            <A HREF="#R_95.htm">TextSearchInString() ……………………</A>
            <BR>
            <A HREF="#R_96.htm">ThreadAttachToQueue() ……………………</A>
            <BR>
            <A HREF="#R_97.htm">ThreadGetError() ……………………</A>
            <BR>
            <A HREF="#R_98.htm">ThreadPSem() ……………………</A>
            <BR>
            <A HREF="#R_99.htm">TimerSleep().</A>
            <BR>
            <A HREF="#R_9a.htm">TocNameArrayFind() ……………………</A>
            <BR>
            <A HREF="#R_9b.htm">TokenDefineToken() ……………………</A>
            <BR>
            <A HREF="#R_9c.htm">TokenLoadMonikerBuffer().</A>
            <BR>
            <A HREF="#R_9d.htm">TokenLoadTokenChunk().</A>
            <BR>
            <A HREF="#R_9e.htm">UserAllocObjBlock…</A>
            <BR>
            <A HREF="#R_9f.htm">UserRemoveAutoExec().</A>
            <BR>
            <A HREF="#R_a0.htm">UtilAsciiToHex32() ……………………</A>
            <BR>
            <A HREF="#R_a1.htm">VirtualSerialSetFormat() ……………………</A>
            <BR>
            <A HREF="#R_a2.htm">VMClose() ……………………</A>
            <BR>
            <A HREF="#R_a3.htm">VMGetMapBlock() ……………………</A>
            <BR>
            <A HREF="#R_a4.htm">VMPreserveBlocksHandle() ……………………</A>
            <BR>
            <A HREF="#R_a5.htm">WinAckUpdate().</A>
            <BR>
            <A HREF="#R_a6.htm">WinGeodeSetInputObj() ……………………</A>
            <BR>
            <A HREF="#R_a7.htm">WinScroll() ……………………</A>
            <BR>
          </STRONG>
        </P> <!-- end of sectionlinks blob -->
<HR>
          <A NAME="R_1.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_1.htm_IX_AccessPointCommit()"></A>
        <H1 CLASS="refHeading">AccessPointCommit()</H1>
<PRE CLASS="syntax">void AccessPointCommit x</PRE>
<P>このルーチンは、アクセスポイントのデータ変更を永続的なストレージにコミットします。 AccPntライブラリは通常、デバイスがシャットダウンしたときにこのルーチンを呼び出します。したがって、アプリケーションはこのルーチンを呼び出す必要はありません。 変更がコミットされる前にシステムをクラッシュさせる可能性のあるバグを追跡しようとしている場合は、このルーチンが役立つことがあります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
</DIV>
<DIV>
          <A NAME="R_1.htm_IX_AccessPointCompareStandardProperty()"></A>
        <H1 CLASS="refHeading">AccessPointCompareStandardProperty()</H1>
<PRE CLASS="syntax">ボイドAccessPointCompareStandardProperty(AccessPointStandardPropertyプロップ、char*str)</PRE>
<P>このルーチンは、渡された文字列を、渡されたプロパティの名前と比較します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
</DIV>
<DIV>
          <A NAME="R_1.htm_IX_AccessPointCreateEntry()"></A>
        <H1 CLASS="refHeading">AccessPointCreateEntry()</H1>
<PRE CLASS="syntax">word AccessPointCreateEntry(word loc, AccessPointType apt);</PRE>
<P>このルーチンは、新しいアクセスポイントを作成します。</P>
<P>このルーチンを呼び出した後は<CODE>AccessPointSet.プロパティ()</CODE>新しいアクセスポイントに関する情報を提供するルーチン。</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>パス:</STRONG>
          </STRONG>
        </P>
<DL>
<DT>
          <STRONG>位置</STRONG>
        </DT><DD>新しいアクセスポイントを挿入するアクセスポイントを指定します。 リストの最後に新しいアクセスポイントを追加するには、0を渡します。</DD>
<DT>
          <STRONG>適切な</STRONG>
        </DT><DD>の<CODE>AccessPointType</CODE>新しいアクセスポイントの ISPの場合はAPT_INTERNET、ダイアルアップの場合はAPT_TERMINALなど。</DD>
</DL>
<P CLASS="refField"><STRONG><STRONG>戻る:</STRONG></STRONG>新しいアクセスポイントのID番号。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetStringProperty()">AccessPointSetStringProperty()</A></CODE><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetIntegerProperty()">AccessPointSetIntegerProperty()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_1.htm_IX_AccessPointDestroyEntry()"></A>
        <H1 CLASS="refHeading">AccessPointDestroyEntry()</H1>
<PRE CLASS="syntax">ブール値AccessPointDestroyEntry(単語ID);</PRE>
<P>このルーチンは、アクセスポイントの情報を削除します。 0以外の値が返された場合は、エラーが発生しています。 (アクセスポイントがロックされていたか、存在しなかった可能性があります)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
</DIV>
<DIV>
          <A NAME="R_1.htm_IX_AccessPointDestroyProperty()"></A>
        <H1 CLASS="refHeading">AccessPointDestroyProperty()</H1>
<PRE CLASS="syntax">Boolean AccessPointDestroyProperty(word id, char*prop);</PRE>
<P>このルーチンは、アクセスポイントのプロパティの1つを破棄します。</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>パス:</STRONG>
          </STRONG>
        </P>
<DL>
<DT>
          <STRONG>イド</STRONG>
        </DT><DD>アクセスポイントのID番号。</DD>
<DT>
          <STRONG>プロップ</STRONG>
        </DT><DD>次のいずれか<CODE>AccessPointStandardProperty</CODE>値、またはプロパティ名を含むバッファへのポインタ。</DD>
</DL>
<P CLASS="refField"><STRONG><STRONG>戻る:</STRONG></STRONG>エラーが発生しなかった場合は0、発生した場合はtrue(該当するアクセスポイントがない、該当するプロパティがない、アクセスポイントがロックされている)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetStringProperty()">AccessPointSetStringProperty()</A></CODE><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetIntegerProperty()">AccessPointSetIntegerProperty()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_1.htm_IX_AccessPointGetEntries()"></A>
        <H1 CLASS="refHeading">AccessPointGetEntries()</H1>
<PRE CLASS="syntax">ChunkHandle AccessPointGetEntries(MemHandle mh、ChunkHandleチャンク、AccessPointType apt);</PRE>
<P>このルーチンは、指定されたアクセスポイントに対応するすべてのアクセスポイントIDのチャンク配列を取得します。<CODE>AccessPointType</CODE>arraayの各要素は文字サイズです。</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>パス:</STRONG>
          </STRONG>
        </P>
<DL>
<DT>
          <STRONG>モデム</STRONG>
        </DT><DD>チャンク配列が存在するメモリブロック。</DD>
<DT>
          <STRONG>チャンク</STRONG>
        </DT><DD>チャンク配列のChunkHandle、またはライブラリにチャンク配列の割り当てを要求する場合は0。</DD>
<DT>
          <STRONG>適切な</STRONG>
        </DT><DD>の<CODE>AccessPointType</CODE>APT_INTERNETやAPT_TERMINALなどです。</DD>
</DL>
<P CLASS="refField"><STRONG><STRONG>戻る:</STRONG></STRONG>の<CODE>ChunkHandle</CODE>チャンク配列の</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
</DIV>
<DIV>
          <A NAME="R_1.htm_IX_AccessPointGetIntegerProperty()"></A>
        <H1 CLASS="refHeading">AccessPointGetIntegerProperty()</H1>
<PRE CLASS="syntax">Boolean AccessPointGetIntegerProperty(word id, char*prop, int*val);</PRE>
<P>このルーチンは、アクセスポイントのプロパティのいずれかの値を取得し、その値を整数で表します。</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>パス:</STRONG>
          </STRONG>
        </P>
<DL>
<DT>
          <STRONG>イド</STRONG>
        </DT><DD>アクセスポイントのID番号。</DD>
<DT>
          <STRONG>プロップ</STRONG>
        </DT><DD>次のいずれか<CODE>AccessPointStandardProperty</CODE>値、またはプロパティ名を含むバッファへのポインタ。</DD>
<DT>
          <STRONG>値</STRONG>
        </DT><DD>整数へのポインタ。ルーチンはこの整数にプロパティの値を設定します。</DD>
</DL>
<P CLASS="refField"><STRONG><STRONG>戻る:</STRONG></STRONG>エラーがなかった場合はゼロ、(そのようなアクセスポイントがない、そのようなプロパティがない)場合はtrueです。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointGetStringPropertyBuffer()">AccessPointGetStringPropertyBuffer()</A></CODE><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointGetStringPropertyBlock()">AccessPointGetStringPropertyBlock()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_2.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_2.htm_IX_AccessPointGetStringPropertyBlock()"></A>
        <H1 CLASS="refHeading">AccessPointGetStringPropertyBlock()</H1>
<PRE CLASS="syntax">BooleanAccessPointGetStringPropertyBlock(word id, char*prop, MemHandle*data, int*datalen);</PRE>
<P>このルーチンは、アクセスポイントのプロパティの1つの値を取得し、メモリブロック内の文字列として値を返します。</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>パス:</STRONG>
          </STRONG>
        </P>
<DL>
<DT>
          <STRONG>イド</STRONG>
        </DT><DD>アクセスポイントのID番号。</DD>
<DT>
          <STRONG>プロップ</STRONG>
        </DT><DD>次のいずれか<CODE>AccessPointStandardProperty</CODE>値、またはプロパティ名を含むバッファへのポインタ。</DD>
<DT>
          <STRONG>データ#データ#</STRONG>
        </DT><DD><CODE>MemHandle</CODE>(ブロックの割り当てを要求するには0を渡します)。</DD>
<DT>
          <STRONG>データ長</STRONG>
        </DT><DD>整数へのポインタ。ルーチンは、後続のNULLを除いた値文字列の長さをこの整数に設定します。</DD>
</DL>
<P CLASS="refField"><STRONG><STRONG>戻る:</STRONG></STRONG>エラーがなかった場合はゼロ、(そのようなアクセスポイントがない、そのようなプロパティがない)場合はtrueです。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointGetStringPropertyBuffer()">AccessPointGetStringPropertyBuffer()</A></CODE><CODE><A HREF="../../CRef/Routines/R_1.htm#IX_AccessPointGetIntegerProperty()">AccessPointGetIntegerProperty()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_2.htm_IX_AccessPointGetStringPropertyBuffer()"></A>
        <H1 CLASS="refHeading">AccessPointGetStringPropertyBuffer()</H1>
<PRE CLASS="syntax">Boolean AccessPointGetStringPropertyBuffer(word id, char*prop, char*buf, int*datalen);</PRE>
<P>このルーチンは、アクセスポイントのプロパティの1つの値を取得し、その値を文字列としてメモリのバッファに返します。</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>パス:</STRONG>
          </STRONG>
        </P>
<DL>
<DT>
          <STRONG>イド</STRONG>
        </DT><DD>アクセスポイントのID番号。</DD>
<DT>
          <STRONG>プロップ</STRONG>
        </DT><DD>次のいずれか<CODE>AccessPointStandardProperty</CODE>値、またはプロパティ名を含むバッファへのポインタ。</DD>
<DT>
          <STRONG>バッファ</STRONG>
        </DT><DD>値を格納するバッファへのポインタ。</DD>
<DT>
          <STRONG>データ長</STRONG>
        </DT><DD>整数へのポインタ。bufのサイズを渡す。 ルーチンは、この整数に値文字列の長さを設定します。</DD>
</DL>
<P CLASS="refField"><STRONG><STRONG>戻る:</STRONG></STRONG>エラーがなかった場合はゼロ、(そのようなアクセスポイントがない、そのようなプロパティがない)場合はtrueです。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointGetStringPropertyBlock()">AccessPointGetStringPropertyBlock()</A></CODE><CODE><A HREF="../../CRef/Routines/R_1.htm#IX_AccessPointGetIntegerProperty()">AccessPointGetIntegerProperty()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_2.htm_IX_AccessPointGetType()"></A>
        <H1 CLASS="refHeading">AccessPointGetType()</H1>
<PRE CLASS="syntax">AccessPointType AccessPointCommit(word id)</PRE>
<P>このルーチンは、アクセスポイントのタイプ(APT_INTERNET、APT_TELNETなど)を返します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
</DIV>


<DIV>
          <A NAME="R_2.htm_IX_AccessPointInUse()"></A>
        <H1 CLASS="refHeading">AccessPointInUse()</H1>
<PRE CLASS="syntax">ブール値AccessPointInUse(単語ID);</PRE>
<P>IDを持つアクセスポイントが<EM>イド</EM>が接続で使用されている場合、このルーチンは以下を返す。<CODE>真</CODE>(ゼロ以外)。それ以外の場合は<CODE>偽</CODE>(ゼロ)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
</DIV>


<DIV>
          <A NAME="R_2.htm_IX_AccessPointIsEntryValid()"></A>
        <H1 CLASS="refHeading">AccessPointIsEntryValid()</H1>
<PRE CLASS="syntax">ブール値AccessPointIsEntryValid(単語ID);</PRE>
<P>このルーチンは、渡されたアクセスポイントが存在しない場合は0を返し、存在する場合は0以外の値を返します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
</DIV>
<DIV>
          <A NAME="R_2.htm_IX_AccessPointLock()"></A>
        <H1 CLASS="refHeading">AccessPointLock()</H1>
<PRE CLASS="syntax">void AccessPointLock(word id)</PRE>
<P>このルーチンは、アクセスポイントをロックして変更できないようにします。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointUnlock()">AccessPointUnlock()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_2.htm_IX_AccessPointSetIntegerProperty()"></A>
        <H1 CLASS="refHeading">AccessPointSetIntegerProperty()</H1>
<PRE CLASS="syntax">ブール値AccessPointSetIntegerProperty(word id, char+*prop, int val);</PRE>
<P>このルーチンは、アクセスポイントのプロパティの1つの値を整数に設定します。</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>パス:</STRONG>
          </STRONG>
        </P>
<DL>
<DT>
          <STRONG>イド</STRONG>
        </DT><DD>アクセスポイントのID番号。</DD>
<DT>
          <STRONG>プロップ</STRONG>
        </DT><DD>次のいずれか<CODE>AccessPointStandardProperty</CODE>値、またはプロパティ名を含むバッファへのポインタ。</DD>
<DT>
          <STRONG>値</STRONG>
        </DT><DD>プロパティの新しい値。</DD>
</DL>
<P CLASS="refField"><STRONG><STRONG>戻る:</STRONG></STRONG>エラーがなかった場合は0、エラーがあった場合はtrue(該当するアクセスポイントがない、アクセスポイントがロックされている)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetStringProperty()">AccessPointSetStringProperty()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_2.htm_IX_AccessPointSetStringProperty()"></A>
        <H1 CLASS="refHeading">AccessPointSetStringProperty()</H1>
<PRE CLASS="syntax">Boolean AccessPointSetStringProperty(word id, char*prop, char*val);</PRE>
<P>このルーチンは、アクセスポイントのプロパティの1つの値を文字列に設定します。</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>パス:</STRONG>
          </STRONG>
        </P>
<DL>
<DT>
          <STRONG>イド</STRONG>
        </DT><DD>アクセスポイントのID番号。</DD>
<DT>
          <STRONG>プロップ</STRONG>
        </DT><DD>次のいずれか<CODE>AccessPointStandardProperty</CODE>値、またはプロパティ名を含むバッファへのポインタ。</DD>
<DT>
          <STRONG>値</STRONG>
        </DT><DD>プロパティの新しい値。</DD>
</DL>
<P CLASS="refField"><STRONG><STRONG>戻る:</STRONG></STRONG>エラーがなかった場合は0、エラーがあった場合はtrue(該当するアクセスポイントがない、アクセスポイントがロックされている)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetIntegerProperty()">AccessPointSetIntegerProperty()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_2.htm_IX_AccessPointUnlock()"></A>
        <H1 CLASS="refHeading">AccessPointUnlock()</H1>
<PRE CLASS="syntax">void AccessPointUnlock(word id)</PRE>
<P>このルーチンは、以前にロックされたアクセスポイントのロックを解除します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointLock()">AccessPointLock()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_3.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_3.htm_IX_ArrayQuickSort()"></A>
        <H1 CLASS="refHeading">ArrayQuickSort()</H1>
<PRE CLASS="syntax">void ArrayQuickSort(void*配列,/*配列の先頭へのポインタ*/ワードカウント,/*配列内の要素数*/ワードelementSize, /*各要素のサイズ(バイト単位)*/ワードvalueForCallback, /*コールバックルーチンに渡される*/QuickSortParameters*パラメータ);</PRE>
<P>このルーチンは、一定サイズのエレメントの配列をソートします。 これは修正されたQuickSortアルゴリズムを使用し、特定のサイズ以下のサブ配列に対して挿入ソートを使用する。 このルーチンはコールバックルーチンを呼び出して、実際に要素を比較します。</P>
<P><CODE>ArrayQuickSort()</CODE>には5つの引数が渡されます。 配列の最初の要素へのポインタ、配列内の要素の数、各要素のバイト単位のサイズ、データのワード(すべてのコールバックルーチンに渡される)<CODE>QuickSortParameters</CODE>構造。</P>
<P>変更前<CODE>ArrayQuickSort()</CODE>任意のエレメントを検査または変更した後<CODE>QuickSortParameters</CODE>構造。 このルーチンは、必要に応じて要素をロックし、必要な準備手順を実行します。 同様に<CODE>ArrayQuickSort()</CODE>がルーチンで終了した場合は<CODE>QuickSortParameters</CODE>これらの各ルーチンには、要素へのポインタと<CODE>ArrayQuickSort()</CODE>ボタンをクリックし</P>
<P>ソートルーチンは要素を比較しません。 代わりに<CODE>QuickSortParameters</CODE>このコールバックルーチンは、_pascalと宣言する必要があります。 いつでも<CODE>ArrayQuickSort()</CODE>は2つの要素を比較する必要があるため、コールバックルーチンを呼び出し、要素のアドレスと<CODE>valueForCallback</CODE>渡された単語<CODE><A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArraySort()">ChunkArraySort()</A></CODE>コールバックルーチンの戻り値によって、ソートされた配列内で最初に現れる要素が決まります。</P>
<UL>
<LI>If要素<CODE>エル1</CODE>前に来るべきである<EM>エル2 color</EM>配列では、コールバックルーチンは負の整数を返します。</LI>
<LI>If要素<CODE>エル1</CODE>後に来るべきである<EM>エル2 color</EM>の場合、コールバックルーチンは正の整数を返す必要があります。</LI>
<LI>もし<CODE>エル1</CODE>前または後に来る<EM>エル2 color</EM>配列では、コールバックルーチンは0を返します。</LI>
</UL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>場合によっては、異なる基準に基づいて配列をソートする必要があります。 これを行う最も簡単な方法は、汎用のコールバックルーチンを1つ作成し<CODE>valueForCallback</CODE>wordはソートの実行方法を決定します。 たとえば、同じコールバックルーチンが配列を昇順または降順にソートすることができます。<CODE>valueForCallback</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上の配列をロックします(固定メモリ内にない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>コールバックルーチンに、配列へのポインタを無効にするような処理を行わせないでください。 たとえば、配列がチャンク内にある場合、チャンクのサイズを変更したり、同じLMemヒープ内に他のチャンクを割り当てたりしないでください。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_2f.htm#IX_QuickSortParameters">QuickSortParameters</A></CODE><CODE><A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArraySort()">ChunkArraySort()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_3.htm_IX_BlockFromTransferBlockID() macro"></A>
        <H1 CLASS="refHeading">BlockFromTransferBlockID</H1>
<PRE CLASS="syntax">VMBlockHandle BlockFromTransferBlockID(id);TransferBlockID id;</PRE>
<P>このマクロは、VMBlockHandleを<CODE>TransferBlockID</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_3.htm_IX_BlockIDFromFileAndBlock() macro"></A>
        <H1 CLASS="refHeading">BlockIDFromFileAndBlock</H1>
<PRE CLASS="syntax">TransferBlockID BlockIDFromFileAndBlock(ファイル、ブロック);VMFileHandleファイル;VMBlockHandleブロック;</PRE>
<P>このマクロはdword型を作成します。<CODE>TransferBlockID</CODE>VMFileHandleとVMBlockHandleからです</P>
</DIV>
<DIV>
          <A NAME="R_3.htm_IX_bsearch()"></A>
          <A NAME="R_3.htm_IX_Binary search"></A>
        <H1 CLASS="refHeading">関数bsearch()</H1>
<PRE CLASS="syntax">extern void*_pascal bsearch(const void*key, const void*array, word count, word elementSize, PCB(int, compare, (const void*,const void*)));</PRE>
<P>これは標準的なバイナリ検索ルーチンです。 コールバックルーチンは、_pascalと宣言する必要があります。</P>
</DIV>
<DIV>
          <A NAME="R_3.htm_IX_calloc()"></A>
        <H1 CLASS="refHeading">関数calloc()</H1>
<PRE CLASS="syntax">void*calloc(word n, /*割り当てる構造体の数*/size_t size);/*各構造体のサイズ(バイト単位)*/</PRE>
<P>の<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>ファミリーのルーチンが標準Cとの互換性のために提供されている。 geodeが少量の固定メモリを必要とする場合、ルーチンの1つを呼び出すことができます。 カーネルはgeodeの値を満足する固定ブロックを割り当てます。<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>はこのブロックからメモリを割り当てる。 ブロックがいっぱいになると、別の固定malloc-blockが割り当てられます。 ブロック内のすべてのメモリが解放されると、メモリマネージャは自動的にブロックを解放します。</P>
<P>ジオードが<CODE>関数calloc()</CODE>の場合、指定されたサイズの構造体の指定された数に十分な大きさのメモリの連続セクションが割り当てられます。 メモリはmallocブロックから割り当てられ、メモリの先頭のアドレスが返されます。 メモリはゼロ初期化されます。 要求を満たすことができない場合<CODE>関数calloc()</CODE>はNULLポインタを返す。 メモリは、解放されるまで移動されないことが保証されています(<CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">関数free()</A></CODE>)またはリサイズ(<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">参照):realloc()</A></CODE>)をクリックします。 GEOSがシャットダウンすると、すべての固定ブロックが解放され<CODE>関数calloc()</CODE>が失われました。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>別のgeodeのmalloc-blockにメモリを割り当てるには、次の関数を呼び出す。<CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE>ただし、他のgeodeが終了すると、そのブロックは解放されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>mallocブロックに収まるサイズを要求します。つまり、構造体のサイズに要求される構造体の数を掛けた値は、64Kよりも多少小さくなければなりません。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>で割り当てられたすべてのメモリ<CODE>関数calloc()</CODE>は、GEOSのシャットダウン時に解放されます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">関数free()</A></CODE><CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">参照):realloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_4.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_4.htm_IX_CCB() macro"></A>
          <A NAME="R_4.htm_IX_callback routines:CCB() macro"></A>
        <H1 CLASS="refHeading">CCB()様</H1>
<PRE CLASS="syntax">#define CCB(return_type, pointer_name, args)\return_type_cdecl(*pointer_name)args</PRE>
<P>このマクロは、Cの呼び出し規約を使用する関数へのポインタを宣言するのに便利です。 例えば、2つの文字列を渡されて整数を返す関数へのポインタを宣言するには、次のように記述します。</P>
<PRE>CCB(int, func_ptr, (const char*,const char*));という文字列を返します。</PRE>
<P>これは次のように拡張されます。</P>
<PRE>int_cdecl(*func_ptr)(const char*,const char*);という文字列を返します。</PRE>
<P>コンパイラが異なれば、_cdeclキーワードの構文も異なります。 このマクロを使用すると、コールバックがコンパイラに依存しなくなります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_80.htm#IX_PCB()">プリント基板()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_4.htm_IX_CellDeref()"></A>
        <H1 CLASS="refHeading">CellDeref()</H1>
<PRE CLASS="syntax">void*CellDeref(optr CellRef);</PRE>
<P>このルーチンは、セルへのoptrをセルのアドレスに変換します。 このルーチンは<CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <CODE>セル.h</CODE>
        </P>
</DIV>
<DIV>
          <A NAME="R_4.htm_IX_CellDirty()"></A>
        <H1 CLASS="refHeading">CellDirty()</H1>
<PRE CLASS="syntax">void CellDirty(void*ptr);/*ロックされたセル内の任意の場所へのポインタ*/</PRE>
<P>このルーチンは、セルを「ダーティ」とマークします。つまり、セルはメモリからディスクにコピーされる必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <CODE>セル.h</CODE>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>項目ブロック内のすべてのセルは、一度にダーティとマークされます。したがって、同じ項目ブロック内の複数のセルに対して、このルーチンを一度だけ呼び出すことができます。 ポインタのセグメント部分のみが重要であるため、セル内の任意の場所にポインタを渡すことができます。 これは、セルへのポインタをインクリメントした場合に便利です。</P>
</DIV>
<DIV>
          <A NAME="R_4.htm_IX_CellGetDBItem()"></A>
        <H1 CLASS="refHeading">CellGetDBItem()</H1>
<PRE CLASS="syntax">DBGroupAndItem CellGetDBItem(CellFunctionParameters*cfp, word row, /*Get handles of cell in this row*/byte column);/*.and this column*/</PRE>
<P>すべてのセルは、グループ化されていないDB項目として保存されます。 標準のDBルーチンでセルを操作する場合は、そのハンドルを知っている必要があります。 このルーチンには<CODE>CellFunctionParameters</CODE>目的のセルの行インデックスと列インデックスです。 この関数は<CODE>DBGroupAndItem</CODE>値を入力します。 指定した座標にセルがない場合は、NULLを返します。<CODE>DBGroupAndItem</CODE>ルーチンは、セルをロックしたり、変更したりしません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <CODE>セル.h</CODE>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_d.htm#IX_DBGroupAndItem">DBGroupAndItem</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_4.htm_IX_CellGetExtent()"></A>
        <H1 CLASS="refHeading">CellGetExtent()</H1>
<PRE CLASS="syntax">void boundary(CellFunctionParameters*cfp, RangeEnumParams*rep);/*REP_boundsフィールドにCellGetExtentを書き込む*/</PRE>
<P>このルーチンは、セルファイルの使用されている部分の境界を返します。 このルーチンには、セルファイルの<CODE>CellFunctionParameters</CODE>構造) 結果は<CODE>REP境界</CODE>渡されたフィールド<CODE>RangeEnumParams</CODE>構造。 セルを含む最初の行のインデックスが書き込まれます。<CODE>REP境界.R_top</CODE>;最後に占有された行のインデックスが書き込まれる<CODE>REP境界.R_bottom</CODE>;最初に占有されたカラムのインデックスが書き込まれる<CODE>REP境界.R_left</CODE>;最後に占有された行のインデックスが書き込まれる<CODE>REP境界.R_right</CODE>セルファイルにセルが含まれていない場合、4つのフィールドはすべて-1に設定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4.htm_IX_CellLock()"></A>
        <H1 CLASS="refHeading">CellLock()</H1>
<PRE CLASS="syntax">void*CellLock(CellFunctionParameters*cfp, word row, /*この行のセルをロック.*/word column);/*.and this column*/</PRE>
<P>このルーチンには<CODE>CellFunctionParameters</CODE>と、セルの行インデックスと列インデックスです。 セルをロックし、そのセルへのポインタを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellLockGetRef()">CellLockGetRef()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_4.htm_IX_CellLockGetRef()"></A>
        <H1 CLASS="refHeading">CellLockGetRef()</H1>
<PRE CLASS="syntax">void*CellLockGetRef(CellFunctionParameters*cfp, word row, /*この行のセルをロック.*/word column, /*.and this column*/optr*ref);/*ここにハンドルを書き込む*/</PRE>
<P>このルーチンには<CODE>CellFunctionParameters</CODE>と、セルの行インデックスと列インデックスです。 セルをロックし、そのセルへのポインタを返します。 また、ロックされたセルのitem-blockハンドルとchunkハンドルをoptrに書き込みます。 セルが移動した場合(別のセルが割り当てられた場合など)、optr構造体をポインタに変換するには、optr構造体を<CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellDeref()">CellDeref()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>セルのロックが解除されると、optrは無効になります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellGetDBItem()">CellGetDBItem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellLock()">CellLock()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_4.htm_IX_CellReplace()"></A>
        <H1 CLASS="refHeading">CellReplace()</H1>
<PRE CLASS="syntax">void CellReplace{CellFunctionParameters*cfp, word row, /*この行にセルを挿入/置換.*/word column, /*.and this column*/const void*cellData, /*このデータを新しいセルにコピー*/word size);/*新しいセルのサイズ(バイト単位)*/</PRE>
<P>このルーチンは、セル・ファイル内のセルの作成、削除および置換に使用されます。 セルを作成または置換するには<EM>セルデータ</EM>をクリックして新しいセルにコピーするデータを指定し<EM>寸法</EM>セルの長さ(バイト単位)<EM>列</EM>および<EM>柱</EM>セルの座標。 (いつものように<EM>CFP</EM>は、セルファイルの<CODE>CellFunctionParameters</CODE>構造) 指定した座標にある既存のセルは自動的に解放され、新しいセルが作成されます。</P>
<P>セルを削除するには<EM>寸法</EM>ゼロです 指定した座標にセルがある場合は、そのセルが解放されます。 (<EM>セルデータ</EM>引き数は無視される)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>セルが割り当てられるか置換されると、そのVMファイル内のグループ化されていないすべての項目(セルを含む)へのポインタが無効になる場合があります。 の<CODE>CellFunctionParameters</CODE>構造体は、呼び出し中に移動してはなりません。このため、グループ化されていないDB項目には配置できません。 ロックされたセルを置換または解放しないでください。置換または解放すると、セルのアイテムブロックのロックカウントが減少しないため、ブロックのロックが解除されなくなります。</P>
</DIV>
<DIV>
          <A NAME="R_4.htm_IX_CellUnlock()"></A>
        <H1 CLASS="refHeading">CellUnlock()</H1>
<PRE CLASS="syntax">void CellUnlock(void*ptr);/*ロックされたセル内の任意の場所へのポインタ*/</PRE>
<P>このルーチンは、が指すセルのロックを解除します。<EM>ポインタ</EM>1つのセルが複数回ロックされる場合があることに注意してください。 項目ブロック内のすべてのセルのすべてのロックが解除されると、ブロックをディスクにスワップバックできます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>DBマネージャは、個々の項目のロックを追跡するのではなく、項目ブロック内のすべての項目のロックの総数をカウントします。 このため、セルのセグメントアドレスだけが重要になります。したがって、セル内のどこか(または直後)にポインタを渡してロックを解除できます。 これは、セルへのポインタをインクリメントした場合に便利です。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>セルを変更した場合は<CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellDirty()">CellDirty()</A></CODE>)をクリックし<EM>前に</EM>ロックを解除します。</P>
</DIV>
<HR>
          <A NAME="R_5.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_5.htm_IX_CFatalError()"></A>
        <H1 CLASS="refHeading">CFatalError()</H1>
<PRE CLASS="syntax">void CFatalError(ワードコード)</PRE>
<P>このルーチンは、致命的なエラーを生成します。 デバッガが使用するために渡されたエラーコードを格納します。</P>
</DIV>
<DIV>
          <A NAME="R_5.htm_IX_ChunkArrayAppend()"></A>
        <H1 CLASS="refHeading">ChunkArrayAppend()</H1>
<PRE CLASS="syntax">void*ChunkArrayAppend(optr array, /*optr to chunk array*/word elementSize)/*新しい要素のサイズ(*elementsが同じサイズの場合は無視されます)*/</PRE>
<P>このルーチンは、チャンク配列の末尾に新しい要素を追加します。 自動的にチャンクを展開して要素のためのスペースを作り<CODE>ChunkArrayHeader</CODE>新しい要素へのポインタを返します。</P>
<P>引数の1つは、新しい要素のサイズです。 この引数は、配列に可変サイズの要素が含まれている場合に重要です。 エレメントのサイズが均一の場合、この引数は無視されます。 配列はoptrで指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(ロックされていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンはチャンクのサイズを変更します。つまり、ヒープの圧縮やサイズ変更が発生する可能性があります。 したがって、LMemヒープ内の既存のポインタはすべて無効になります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_5.htm_IX_ChunkArrayAppendHandles()"></A>
        <H1 CLASS="refHeading">ChunkArrayAppendHandles()</H1>
<PRE CLASS="syntax">void*ChunkArrayAppendHandles(MemHandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandle ch, /*チャンク配列のハンドル*/ワードサイズ)/*新しい要素のサイズ(*要素が均一サイズの場合は無視されます)*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayAppend()">ChunkArrayAppend()</A></CODE>ただし、チャンク配列はoptrではなく、グローバルハンドルとローカルハンドルで指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(ロックされていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンはチャンクのサイズを変更します。つまり、ヒープの圧縮やサイズ変更が発生する可能性があります。 したがって、LMemヒープ内の既存のポインタはすべて無効になります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_5.htm_IX_ChunkArrayCreate()"></A>
        <H1 CLASS="refHeading">ChunkArrayCreate()</H1>
<PRE CLASS="syntax">ChunkHandle ChunkArrayCreate(MemHandle mh, /*LMemヒープのブロックのハンドル*/word elementSize, /*各要素のサイズ(要素が*可変サイズの場合は0)*/</PRE>
<PRE CLASS="syntax">word headerSize, /*ヘッダーに使用するチャンクの量(*デフォルトサイズの場合はゼロ)*/</PRE>
<PRE CLASS="syntax">ObjChunkFlags ocf)</PRE>
<P>このルーチンは、指定されたLMemヒープにチャンク配列を設定します。 ヒープはすでに正常に初期化されている必要があります。 このルーチンはチャンクを割り当て、その中にチャンク配列を設定します。 チャンクのハンドルを返します。 チャンク配列を作成できない場合は、NULLハンドルを返します。</P>
<P>チャンク配列に均一サイズの要素が含まれる場合は、チャンク配列を作成するときに要素サイズを指定する必要があります。 これを変更することはできません。 配列に可変サイズの要素が含まれる場合は、要素サイズとしてゼロを渡します。</P>
<P>チャンク配列は、常に<CODE>ChunkArrayHeader</CODE>ヘッダーの合計サイズを指定できます。これは、余分なデータを含む特別なヘッダーでチャンク配列を開始する場合に便利です。 ただし、ヘッダーは<CODE>ChunkArrayHeader</CODE>これにより、チャンクが開始されます。 ヘッダー構造を定義する場合は、その最初のエレメントが<CODE>ChunkArrayHeader</CODE>チャンク配列コードのみが実際の<CODE>ChunkArrayHeader</CODE>合格した場合<CODE>ヘッダーサイズ</CODE>0の場合、デフォルトのヘッダサイズが使用されます(つまり<CODE>sizeof(ChunkArrayHeader)</CODE>)をクリックします。 0以外の値を渡した場合<CODE>ヘッダーサイズ</CODE>の間に任意のスペースを入れます。<CODE>ChunkArrayHeader</CODE>ヒープはゼロ初期化されます。</P>
<P>チャンク配列を解放するには、次を呼び出します。<CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemFree()">LMemFree()</A></CODE>どんな塊でも同じです</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>0以外の値を渡した場合の結果は予測できません。<CODE>ヘッダーサイズ</CODE>より小さい引数<CODE>sizeof(ChunkArrayHeader)</CODE>ルーチンはチャンクを割り当てるため、ヒープの圧縮やサイズ変更が発生する可能性があります。ブロック内へのすべてのポインタは無効になります。</P>
</DIV>
<DIV>
          <A NAME="R_5.htm_IX_ChunkArrayCreateAt()"></A>
        <H1 CLASS="refHeading">ChunkArrayCreateAt()</H1>
<PRE CLASS="syntax">ChunkHandle ChunkArrayCreateAt(optr配列,/*このチャンクにチャンク配列を作成*/word elementSize, /*各要素のサイズ(要素が*可変サイズの場合は0)*/</PRE>
<PRE CLASS="syntax">word headerSize, /*ヘッダーに使用するチャンクの量(*デフォルトサイズの場合はゼロ)*/</PRE>
<PRE CLASS="syntax">ObjChunkFlags ocf)</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayCreate()">ChunkArrayCreate()</A></CODE>ただし、チャンク配列にするチャンクを指定する点が異なります。 チャンクはoptrで指定されます。 チャンク内にすでに存在するデータは上書きされることに注意してください。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>チャンクのサイズを変更すると、LMemヒープ内へのすべてのポインタが無効になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5.htm_IX_ChunkArrayCreateAtHandles()"></A>
        <H1 CLASS="refHeading">ChunkArrayCreateAtHandles()</H1>
<PRE CLASS="syntax">ChunkHandle ChunkArrayCreateAtHandles(MemHandle mh、ChunkHandle ch、word elementSize、word headerSize、ObjChunkFlags ocf);</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayCreate()">ChunkArrayCreate()</A></CODE>ただし、チャンクはoptrではなく、グローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ヌルのチャンクハンドルを渡すと、新しいチャンクが割り当てられます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>チャンクのサイズが変更されると、LMemヒープ内へのすべてのポインタが無効になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_6.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_6.htm_IX_ChunkArrayDelete()"></A>
        <H1 CLASS="refHeading">ChunkArrayDelete()</H1>
<PRE CLASS="syntax">void ChunkArrayDelete(optr array, /*optr to chunk array*/void*element);/*削除する要素のアドレス*/</PRE>
<P>このルーチンは、チャンク配列から要素を削除します。 その要素のアドレスと、配列のoptrが渡されます。</P>
<P>チャンクのサイズが縮小されるため、ルーチンはヒープの圧縮やサイズ変更を行わないことが保証されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>optrのチャンク・ハンドル部分のみが重要です。メモリー・ブロックは、要素へのポインタから決定されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>削除された要素の後にあるすべての要素のアドレスが変更されます。 ブロック内の他のアドレスは影響を受けません。 渡されたアドレスが配列内の要素のアドレスでない場合、結果は定義されません。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayAppend()">ChunkArrayAppend()</A></CODE><CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt()</A></CODE><CODE><A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArrayZero()">ChunkArrayZero()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6.htm_IX_ChunkArrayDeleteHandle()"></A>
        <H1 CLASS="refHeading">ChunkArrayDeleteHandle()</H1>
<PRE CLASS="syntax">void ChunkArrayDeleteHandle(ChunkHandle ch, /*チャンク配列のハンドル*/void*el);/*削除する要素のアドレス*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>ただし、chunk配列はoptrではなくchunkハンドルで指定されます。 メモリーブロックは要素へのポインタに暗黙的に含まれているため、グローバルメモリーハンドルは必要ありません。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_6.htm_IX_ChunkArrayDeleteRange()"></A>
        <H1 CLASS="refHeading">ChunkArrayDeleteRange()</H1>
<PRE CLASS="syntax">void ChunkArrayDeleteRange(optr array, /*optr to chunk array*/word firstElement, /*削除する最初の要素のインデックス*/word count);/*削除する要素の数(*配列の終わりまで削除するには-1)*/</PRE>
<P>このルーチンは、チャンク配列から連続する複数の要素を削除します。 このルーチンには、チャンク配列のoptr、削除する最初の要素のインデックス、および削除する要素の数が渡されます。 このルーチンは、ヒープの圧縮やサイズ変更を行わないことが保証されているため、配列内の他の要素へのポインタは有効なままになります。</P>
</DIV>
<DIV>
          <A NAME="R_6.htm_IX_ChunkArrayElementResize()"></A>
        <H1 CLASS="refHeading">ChunkArrayElementResize()</H1>
<PRE CLASS="syntax">void ChunkArrayElementResize(optr array, /*optr to chunk array*/word element, /*Index of element to resize*/word newSize);/*要素の新しいサイズ(バイト単位)*/</PRE>
<P>このルーチンは、チャンク配列内の要素のサイズを変更します。 チャンク配列には、可変サイズの要素が必要です。 このルーチンは、optrをチャンク配列(グローバルヒープ上でロックされている必要があります)に渡すとともに、サイズを変更する要素のインデックスと新しいサイズ(バイト単位)を渡します。 何も返しません。</P>
<P>新しいサイズが古いサイズより大きい場合は、要素の末尾にNULLバイトが追加されます。 新しいサイズが古いサイズよりも小さい場合、要素を新しいサイズに切り詰めるために末尾からバイトが削除されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>要素のサイズが大きく変更された場合、チャンク配列はLMemヒープ内を移動する可能性があり、ヒープ自体はグローバルヒープ上を移動する可能性がある。したがって、LMemヒープ内へのすべてのポインタは無効になる。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_6.htm_IX_ChunkArrayElementResizeHandles()"></A>
        <H1 CLASS="refHeading">ChunkArrayElementResizeHandles()</H1>
<PRE CLASS="syntax">void ChunkArrayElementResizeHandles(Memhandle mh, /*LMemヒープのグローバルハンドル*/ChunkHandle ch, /*チャンク配列のチャンクハンドル*/word el, /*サイズを変更する要素のインデックス*/word ns);/*要素の新しいサイズ(バイト単位)*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayElementResize()">ChunkArrayElementResize()</A></CODE>ただし、チャンク配列はoptrではなく、そのグローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>要素のサイズが古いものよりも大きく変更された場合、チャンク配列はLMemヒープ内を移動する可能性があり、ヒープ自体はグローバルヒープ上を移動する可能性がある。したがって、LMemヒープ内へのすべてのポインタは無効になる。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_7.htm"></A>
        <DIV>
</DIV>

<DIV>
<HR>
<P><H1 CLASS="refHeading">
          <A NAME="R_7.htm_IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A>
        </H1>
<PRE>void*ChunkArrayElementToPtr(optr array, /*optr to chunk array*/word elementNumber, /*Element to get address of*/void*elementSize);/*要素のサイズをここに書き込む*/</PRE>
<P>このルーチンは、要素のインデックスをその要素のアドレスに変換します。 このルーチンには、チャンク配列へのoptr、対象となる要素のインデックス、およびワードサイズの変数へのポインタが渡されます。 これは、要素へのポインタを返します。 配列内の要素のサイズが可変の場合は、その要素のサイズを<EM>要素サイズ</EM>ポインタ。 エレメントのサイズが均一である場合、この処理は行われません。</P>
<P>配列インデックスが範囲外の場合、ルーチンは配列内の最後の要素へのポインタを返します。 このルーチンは、定数CA_LAST_ELEMENTを渡した場合にもこれを行います。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>要素のサイズに関心がない場合は、3番目の引数としてNULLポインタを渡します。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>エラーチェックバージョンfatal-errorsがインデックスCA_NULL_ELEMENT(つまり、0 xffffまたは-1)を渡された場合。</P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_7.htm_IX_ChunkArrayElementToPtrHandles()">ChunkArrayElementToPtrHandles()</A>
        </H1>
<PRE>void*ChunkArrayElementToPtrHandles(Memhandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandleチャンク,/*チャンク配列のハンドル*/word elementNumber, /*アドレスを取得する要素*/void*elementSize);/*要素のサイズをここに書き込む*/</PRE>
<P>このルーチンは次のようなものです。<A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A>ただし、チャンク配列はoptrではなく、そのグローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>要素のサイズに関心がない場合は、4番目の引数としてNULLポインタを渡します。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>エラーチェックバージョンfatal-errorsがインデックスCA_NULL_ELEMENT(つまり、0 xffffまたは-1)を渡された場合。</P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_7.htm_IX_ChunkArrayEnum()">ChunkArrayEnum()</A>
        </H1>
<PRE>Boolean ChunkArrayEnum(optr array, /*optr to chunk array*/void*enumData, /*これはコールバックルーチンに渡されます*/Boolean_pascal(*callback)(void*element, void*enumData));/*各要素に対してコールバックが呼び出されます;停止するにはTRUEを返します*/</PRE>
<P>このルーチンを使用すると、チャンク配列内のすべての要素にプロシージャを適用できます。 このルーチンは、optrをチャンク配列に、ポインター(コールバック・ルーチンに渡される)を、そしてBooleanコールバック・ルーチンへのポインターを渡します。 コールバックルーチンは、配列内の各要素に対して1回呼び出され、要素へのポインタと渡されたポインタの2つの引数が渡されます。<CODE>ChunkArrayEnum()</CODE>コールバックルーチンが<EM>真</EM>このようなシナリオの場合<CODE>ChunkArrayEnum()</CODE>その要素で停止して戻る<EM>真</EM>すべての要素をアボートせずに列挙すると<EM>偽の</EM>ボタンをクリックし</P>

<P>コールバックルーチンは、次のルーチンを呼び出すことができます。<A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayAppend()">ChunkArrayAppend()</A><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt x</A>および<A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A>ボタンをクリックし<CODE>ChunkArrayEnum()</CODE>は全ての要素が正確に一度だけ列挙されるようにします。 コールバックルーチンは<CODE>ChunkArrayEnum()</CODE>ネストされた呼び出しは、外部呼び出しが次の要素に移動する前に、すべての要素に対して完了します。 コールバックルーチンは_pascalと宣言する必要があります。</P>
          <A NAME="R_7.htm_IX_CHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS"></A>
        <P>複数の実行スレッドが1つのChunkArrayにアクセスしており、これらのスレッドの一方または両方がChunkArrayEnum.()ルーチンの1つを使用している場合、問題が発生する可能性があります。 エラー・チェック・バージョンのカーネルはこの状況を検出し、検出した場合にCHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS警告を生成します。 コードにこの警告が表示される場合は、スレッド間の同期を追加する必要があります。 一方のスレッドがチャンク配列内のチャンクを列挙している間、もう一方のスレッドは同じ配列を列挙したり、配列を変更したりすることは何もしません。</P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。</P></DIV>

<DIV> 
<H1 CLASS="refHeading">
          <A NAME="R_7.htm_IX_ChunkArrayEnumHandles()">ChunkArrayEnumHandles()</A>
        </H1>
<PRE>Boolean ChunkArrayEnumHandles(MemHandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandle ch, /*チャンク配列のハンドル*/void*enumData, /*コールバックルーチンで使用されるバッファ*/Boolean_pascal(*callback)(void*element, void*enumData));/*各要素に対して呼び出されるコールバック;停止するにはTRUEを返す*/</PRE>
<P>このルーチンは<A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnum()">ChunkArrayEnum()</A>ただし、チャンク配列は(optrではなく)グローバルハンドルとチャンクハンドルで指定されます。</P>

<P>複数の実行スレッドが1つのChunkArrayにアクセスしており、これらのスレッドの一方または両方がChunkArrayEnum.()ルーチンの1つを使用している場合、問題が発生する可能性があります。 エラー・チェック・バージョンのカーネルはこの状況を検出し、検出した場合にCHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS警告を生成します。 コードにこの警告が表示される場合は、スレッド間の同期を追加する必要があります。 一方のスレッドがチャンク配列内のチャンクを列挙している間、もう一方のスレッドは同じ配列を列挙したり、配列を変更したりすることは何もしません。</P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>chunkarr.h</STRONG>
        </P></DIV>

<DIV> 
<H1 CLASS="refHeading">
          <A NAME="R_7.htm_IX_ChunkArrayEnumRange()">ChunkArrayEnumRange()</A>
        </H1>
<PRE>Boolean ChunkArrayEnumRange(optr array, /*optr to chunk array*/word startElement, /*Start enumeration with this element*/word count, /*Process this many elements*/void*enumData, /*This is passed to the callback routine*/Boolean_pascal(*callback)/*Return TRUE to halt enumeration*/(void*element, void*enumData));</PRE>
<P>このルーチンは<A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnum()">ChunkArrayEnum()</A>ただし、配列の限られた部分に作用する点が異なります。 さらに、開始要素のインデックスと処理する要素の数という2つの引数が渡されます。 指定された要素から列挙を開始します(チャンク配列の最初の要素のインデックスは0であることに注意してください)。渡されたカウントが配列の末尾を超えて列挙される場合は<CODE>ChunkArrayEnumRange()</CODE>は最後の要素で自動的に停止します。 指示することができる<CODE>ChunkArrayEnumRange()</CODE>を渡してすべてのエレメントを処理します。<CODE>数える</CODE>CA_LAST_ELEMENTの</P>

<P>複数の実行スレッドが1つのChunkArrayにアクセスしており、これらのスレッドの一方または両方がChunkArrayEnum.()ルーチンの1つを使用している場合、問題が発生する可能性があります。 エラー・チェック・バージョンのカーネルはこの状況を検出し、検出した場合にCHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS警告を生成します。 コードにこの警告が表示される場合は、スレッド間の同期を追加する必要があります。 一方のスレッドがチャンク配列内のチャンクを列挙している間、もう一方のスレッドは同じ配列を列挙したり、配列を変更したりすることは何もしません。</P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>開始要素は配列の境界内になければなりません。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnum()">ChunkArrayEnum()</A>ボタンをクリックし</P></DIV>

<DIV>
<H1 CLASS="refHeading">
          <A NAME="R_7.htm_IX_ChunkArrayEnumRangeHandles()">ChunkArrayEnumRangeHandles()</A>
        </H1>
<PRE>Boolean ChunkArrayEnumRangeHandles(MemHandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandle ch, /*チャンク配列のハンドル*/word startElement, /*この要素で列挙を開始*/word count, /*この数の要素を処理*/void*enumData, /*これはコールバックルーチンに渡されます*/Boolean_pascal(*callback)/*列挙を停止するにはTRUEを返します*/(void*element, void*enumData));</PRE>
<P>このルーチンは<A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnumRange()">ChunkArrayEnumRange()</A>ただし、チャンク配列は(optrではなく)グローバルハンドルとチャンクハンドルで指定されます。</P>

<P>複数の実行スレッドが1つのChunkArrayにアクセスしており、これらのスレッドの一方または両方がChunkArrayEnum.()ルーチンの1つを使用している場合、問題が発生する可能性があります。 エラー・チェック・バージョンのカーネルはこの状況を検出し、検出した場合にCHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS警告を生成します。 コードにこの警告が表示される場合は、スレッド間の同期を追加する必要があります。 一方のスレッドがチャンク配列内のチャンクを列挙している間、もう一方のスレッドは同じ配列を列挙したり、配列を変更したりすることは何もしません。</P>
</DIV>

<DIV> 
<H1 CLASS="refHeading">
          <A NAME="R_7.htm_IX_ChunkArrayGetCount()">ChunkArrayGetCount()</A>
        </H1>
<PRE>word ChunkArrayGetCount(optr配列);/*チャンク配列のoptr*/</PRE>
<P>このルーチンは、指定されたチャンク配列の要素数を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>通常はCAHを調べる方が速い<CODE>カウント(_C)</CODE>の<CODE>ChunkArrayHeader</CODE>このフィールドは<CODE>ChunkArrayHeader</CODE>(したがってチャンクの)。 これには、チャンク配列内の要素数が含まれます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><A HREF="../../CRef/Structs/S_6.htm#IX_ChunkArrayHeader">ChunkArrayHeader</A>ボタンをクリックし</P></DIV>
<HR>
<P>
          <A NAME="R_8.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_8.htm_IX_ChunkArrayGetCountHandles()"></A>
        <H1 CLASS="refHeading">ChunkArrayGetCountHandles()</H1>
<PRE CLASS="syntax">word ChunkArrayGetCountHandles(MemHandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandle ch);/*チャンク配列のハンドル*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayGetCount()">ChunkArrayGetCount()</A></CODE>ただし、チャンク配列は(optrではなく)グローバルハンドルとローカルハンドルで指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8.htm_IX_ChunkArrayGetElement()"></A>
        <H1 CLASS="refHeading">ChunkArrayGetElement()</H1>
<PRE CLASS="syntax">void ChunkArrayGetElement(optr array, /*optr to chunk array*/word elementNumber, /*コピーする要素のインデックス*/void*buffer);/*コピーする要素のアドレス*/</PRE>
<P>このルーチンは、チャンク配列内の要素を渡されたバッファにコピーします。 バッファが要素を保持するのに十分な大きさであることを確認するのは、あなたの責任です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。 バッファが要素を保持するのに十分な大きさであることを確認します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_8.htm_IX_ChunkArrayGetElementHandles()"></A>
        <H1 CLASS="refHeading">ChunkArrayGetElementHandles()</H1>
<PRE CLASS="syntax">void ChunkArrayGetElementHandles(Memhandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandle配列,/*チャンク配列のハンドル*/word elementNumber, /*コピーする要素のインデックス*/void*バッファ);/*コピー先のアドレス*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayGetElement()">ChunkArrayGetElement()</A></CODE>ただし、チャンク配列は(optrではなく)グローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>LMemヒープのブロックをグローバルヒープにロックします(固定されていない場合)。 バッファが要素を保持するのに十分な大きさであることを確認します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_8.htm_IX_ChunkArrayInsertAt()"></A>
        <H1 CLASS="refHeading">ChunkArrayInsertAt()</H1>
<PRE CLASS="syntax">void*ChunkArrayInsertAt(optr配列,/*チャンク配列のハンドル*/void*insertPointer, /**要素を挿入するアドレス*/</PRE>
<PRE CLASS="syntax">word elementSize);/*新しい要素のサイズ(*要素のサイズが均一の場合は無視されます)*/</PRE>
<P>このルーチンは、チャンク配列に新しい要素を挿入します。 位置を指定するには、要素へのポインタを渡します。 新しい要素はその場所に割り当てられます。したがって、ポイントされていた要素はシフトされ、新しい要素の直後に終了します。 新しい要素はゼロ初期化されます。</P>
<P>このルーチンには、配列のoptr、新しい要素が挿入されるアドレス、新しい要素のサイズという3つの引数が渡されます。 (配列が均一サイズの要素の場合、size引数は無視されます)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>optrのチャンク・ハンドル部分のみが重要です。メモリー・ブロックは、要素へのポインタに暗黙的に含まれます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(ロックされていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>渡されたアドレスが、チャンク配列内に既に存在する要素のアドレスでない場合、結果は未定義になります。 このルーチンはヒープの圧縮やサイズ変更を引き起こす可能性があり、ブロック内のすべてのポインタが無効になります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayAppend()">ChunkArrayAppend()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_8.htm_IX_ChunkArrayInsertAtHandle()"></A>
        <H1 CLASS="refHeading">ChunkArrayInsertAtHandle()</H1>
<PRE CLASS="syntax">void*ChunkArrayInsertAtHandle(ChunkHandleチャンク、/*チャンク配列のハンドル*/void*insertPointer、/**要素を挿入するアドレス*/</PRE>
<PRE CLASS="syntax">word elementSize);/*新しい要素のサイズ(*要素のサイズが均一の場合は無視されます)*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt()</A></CODE>ただし、チャンク配列はそのチャンクハンドルによって指定されます。 (グローバルブロックは、渡されるポインタに暗黙的に含まれます)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8.htm_IX_ChunkArrayPtrToElement()"></A>
        <H1 CLASS="refHeading">ChunkArrayPtrToElement()</H1>
<PRE CLASS="syntax">word ChunkArrayPtrToElement(optr配列,/*チャンク配列のハンドル*/void*要素);/*要素のアドレス*/</PRE>
<P>このルーチンは、チャンク配列内の要素のアドレスと、配列へのoptrを取得します。 要素のゼロベースのインデックスを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>optrのチャンク・ハンドル部分のみが重要です。メモリー・ブロックは、要素へのポインタに暗黙的に含まれます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>渡されたアドレスが要素の先頭のアドレスでない場合、結果は予測できません。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_8.htm_IX_ChunkArrayPtrToElementHandle()"></A>
        <H1 CLASS="refHeading">ChunkArrayPtrToElementHandle()</H1>
<PRE CLASS="syntax">word ChunkArrayPtrToElementHandle(ChunkHandle配列,/*チャンク配列のチャンクハンドル*/void*要素);/*削除する要素へのポインタ*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A></CODE>ただし、チャンク配列はそのチャンクハンドルによって示されます。 (グローバルブロックは、渡されるポインタに暗黙的に含まれます)。</P>
</DIV>
<HR>
          <A NAME="R_9.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_9.htm_IX_ChunkArraySort()"></A>
        <H1 CLASS="refHeading">ChunkArraySort()</H1>
<PRE CLASS="syntax">void ChunkArraySort(optr array, /*optr to chunk array*/word valueForCallback, /*コールバックルーチンに渡される*/sword_pascal(*callback)(void*el1, void*el2, word valueForCallback))/*戻り値の符号が要素の順序を決定する*/</PRE>
<P>これは、チャンク配列の汎用ソートルーチンです。 これは、特定のサイズ以下のサブ配列に対して挿入ソートを使用して、配列に対して修正されたクイックソートを実行します。</P>
<P>ソートルーチンは要素を比較しません。 代わりに<CODE>コールバック</CODE>パラメータを指定します。 2つの要素を比較する必要がある場合は、コールバックルーチンを呼び出し、要素のアドレスと<CODE>valueForCallback</CODE>渡された単語<CODE>ChunkArraySort()</CODE>コールバックルーチンは_pascalと宣言する必要があります。 コールバックルーチンの戻り値によって、ソートされた配列内で最初に現れる要素が決まります。</P>
<UL>
<LI>If要素<CODE>エル1</CODE>前に来るべきである<EM>エル2 color</EM>配列では、コールバックルーチンは負の整数を返します。</LI>
<LI>If要素<CODE>エル1</CODE>後に来るべきである<EM>エル2 color</EM>の場合、コールバックルーチンは正の整数を返す必要があります。</LI>
<LI>もし<CODE>エル1</CODE>前または後に来る<EM>エル2 color</EM>ソートされた配列では、コールバックルーチンは0を返します。</LI>
</UL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>場合によっては、異なる基準に基づいて配列をソートする必要があります。 これを行う最も簡単な方法は、汎用のコールバックルーチンを1つ作成し<CODE>valueForCallback</CODE>wordはソートの実行方法を決定します。 たとえば、同じコールバックルーチンが配列を昇順または降順にソートすることができます。<CODE>valueForCallback</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>コールバックルーチンに、配列へのポインタを無効にするような処理(新しいチャンクや要素の割り当てなど)を行わせないでください。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3.htm#IX_ArrayQuickSort()">ArrayQuickSort()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_9.htm_IX_ChunkArraySortHandles()"></A>
        <H1 CLASS="refHeading">ChunkArraySortHandles()</H1>
<PRE CLASS="syntax">void ChunkArraySortHandles(MemHandle MemHandle、/*LMemヒープのブロックのハンドル*/ChunkHandle ChunkHandle、/*チャンク配列のハンドル*/ワードvalueForCallback、/*コールバックルーチンに渡される*/sword_pascal(*callback)(void*el1, void*el2, ワードvalueForCallback)/*戻り値の符号が要素の順序を決定する*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArraySort()">ChunkArraySort()</A></CODE>ただし、チャンク配列は(optrではなく)グローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9.htm_IX_ChunkArrayZero()"></A>
        <H1 CLASS="refHeading">ChunkArrayZero()</H1>
<PRE CLASS="syntax">void ChunkArrayZero(optr配列);/*optrからchunk配列*/</PRE>
<P>このルーチンは、配列内のすべての要素を破棄します。 これは<CODE>ChunkArrayHeader</CODE>とエレメントです。 ヒープの圧縮やサイズ変更を引き起こさないことが保証されているため、他のチャンクへのポインタは有効なままである。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_9.htm_IX_ChunkArrayZeroHandles()"></A>
        <H1 CLASS="refHeading">ChunkArrayZeroHandles()</H1>
<PRE CLASS="syntax">void ChunkArrayZeroHandles(MemHandle mh/*LMemヒープのグローバルハンドル*/ChunkHandle ch);/*チャンク配列のチャンクハンドル*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArrayZero()">ChunkArrayZero()</A></CODE>ただし、チャンク配列は(optrではなく)グローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9.htm_IX_ClipboardAbortQuickTransfer()"></A>
        <H1 CLASS="refHeading">ClipboardAbortQuickTransfer()</H1>
<PRE CLASS="syntax">void ClipboardAbortQuickTransfer(void)</PRE>
<P>このルーチンは、実行中のクイック転送操作をキャンセルします。 これは通常、クイック転送に関係するオブジェクトがシャットダウンしているとき、またはクイック転送でエラーが発生したときに使用されます。 このルーチンは、通常、クイック転送を開始したオブジェクトまたはプロセスによってのみ使用されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9.htm_IX_ClipboardAddToNotificationList()"></A>
        <H1 CLASS="refHeading">ClipboardAddToNotificationList()</H1>
<PRE CLASS="syntax">ボイドClipboardAddToNotificationList(optr notificationOD)</PRE>
<P>このルーチンは、渡されたオブジェクトまたはプロセスをクイック転送通知用に登録します。 このルーチンは通常、オブジェクトの<CODE>MSG_META_INITIALIZE(メタ初期化)</CODE>ハンドラ内またはProcessオブジェクトの<CODE>MSG_GEN_PROCESS_OPEN_APPLICATION(プロセスを開くアプリケーション)</CODE>ハンドラ。 Processオブジェクトを登録する場合は、オブジェクトのoptrまたはgeodeハンドルを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRemoveFromNotificationList()">ClipboardRemoveFromNotificationList()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardClearQuickTransferNotification()"></A>
        <H1 CLASS="refHeading">ClipboardClearQuickTransferNotification()</H1>
<PRE CLASS="syntax">ボイドClipboardClearQuickTransferNotification(optr notificationOD)</PRE>
<P>このルーチンは、オブジェクトまたはプロセスをクイック転送通知から削除します。 これは通常、オブジェクトの<CODE>MSG_META_DETACH(メタデタッチ)</CODE>ハンドラまたはProcessオブジェクトの<CODE>MSG_GEN_PROCESS_CLOSE_APPLICATION(プロセスクローズアプリケーション)</CODE>デタッチした後に通知されないようにします。</P>
<P>通知を受け取るように指定されたオブジェクトのoptrを渡します。<CODE><A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardStartQuickTransfer()">ClipboardStartQuickTransfer()</A></CODE>(プロセスの場合はgeodeハンドル)。</P>
<P>オブジェクトは、デタッチ時にクイック転送が実行中かどうかを確認し、実行中の場合は中止することもできます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardDoneWithItem()"></A>
        <H1 CLASS="refHeading">ClipboardDoneWithItem()</H1>
<PRE CLASS="syntax">ボイドClipboardDoneWithItem(TransferBlockIDヘッダー)</PRE>
<P>このルーチンは、オブジェクトまたはプロセスが転送項目を使用して完了したときに呼び出されます。 呼び出し元が以前に呼び出した後、アイテムの転送VMファイルへの排他的アクセスを放棄します。<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardEndQuickTransfer()"></A>
        <H1 CLASS="refHeading">ClipboardEndQuickTransfer()</H1>
<PRE CLASS="syntax">無効ClipboardEndQuickTransfer(ClipboardQuickNotifyFlagsフラグ)</PRE>
<P>このルーチンは、ポインタイメージをリセットし、クイック転送領域をクリアし、クイック転送アイテムをクリアし、転送完了の必要な通知を送信することによって、クイック転送操作を終了する。</P>
<P>このルーチンに次のレコードを渡します。<CODE>ClipboardQuickNotifyFlags</CODE>操作が完了し、移動であった場合は値CQNF_MOVEを渡し、操作が完了し、コピーであった場合はCQNF_COPYを渡します。 操作を完了できなかった場合(データ型に互換性がない場合など)は、CQNF_NO_OPERATIONまたはCQNF_ERRORを渡します。</P>
<P>UIによって送信される通知は、次のメッセージ形式になります。<CODE>MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_TERMINATED(MSG_META_CLIPBOARD_NOTIFY</CODE>このメッセージは、転送アイテムの発信者に操作のタイプを通知します。発信者は必要に応じて応答できます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardEnumItemFormats()"></A>
        <H1 CLASS="refHeading">ClipboardEnumItemFormats()</H1>
<PRE CLASS="syntax">word ClipboardEnumItemFormats(TransferBlockIDヘッダー、word maxNumFormats、ClipboardFormatID*バッファ);</PRE>
<P>このルーチンは、現在の転送項目でサポートされているすべての形式のリストを返します。 特定の形式がサポートされているかどうかを確認するには<CODE><A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardTestItemFormat()">ClipboardTestItemFormat()</A></CODE>見出しページを開きます。</P>
<P>このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>ヘッダー#ヘッダー#</CODE>
        </DT><DD>によって返される転送アイテムヘッダー<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>ボタンをクリックし</DD>
<DT><CODE>maxNumFormats</DT><DD></CODE>返されるフォーマットの最大数。 このサイズをサポートするのに十分な大きさのリターンバッファ(下記参照)を設定する必要があります。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>フォーマットのコピー先となる、ロックされたバッファまたは固定バッファへのポインタ。 返されると、バッファには適切な数の<CODE>クリップボード形式ID</CODE>構造体(使用可能なフォーマットごとに1つ)。 このバッファは、少なくとも<CODE>maxNumFormats</CODE>ボタンをクリックし</DD>
</DL>
<P>戻り値は、返されたフォーマットの総数です。 この数は、渡された数以下になります。<CODE>maxNumFormats</CODE>このルーチンは、渡されたバッファを返します。<CODE>クリップボード形式ID</CODE>構造。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardTestItemFormat()">ClipboardTestItemFormat()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardGetClipboardFile()"></A>
        <H1 CLASS="refHeading">ClipboardGetClipboardFile()</H1>
<PRE CLASS="syntax">VMFileHandle ClipboardGetClipboardFile(ボイド)</PRE>
<P>このルーチンは、現在のデフォルト転送VMファイルのVMファイルハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardGetItemInfo()"></A>
        <H1 CLASS="refHeading">ClipboardGetItemInfo()</H1>
<PRE CLASS="syntax">optr ClipboardGetItemInfo(TransferBlockIDヘッダー)</PRE>
<P>このルーチンは、ソース識別子(CIH<CODE>ソースID</CODE>)をクリックします。 によって返された転送アイテムのヘッダーを渡します。<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardGetNormalItemInfo()"></A>
        <H1 CLASS="refHeading">ClipboardGetNormalItemInfo()</H1>
<PRE CLASS="syntax">TransferBlockID ClipboardGetNormalItemInfo(ボイド)</PRE>
<P>このルーチンは、通常の転送項目に関する情報を返します。 を返します。<CODE>TransferBlockID</CODE>このファイルには、転送ファイルのVMファイルハンドルと、転送アイテムのヘッダーブロックのVMブロックハンドルが含まれています。</P>
<P>戻り値からファイルハンドルを抽出するには、マクロを使用します。<CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileFromTransferBlockID() macro">FileFromTransferBlockID()</A></CODE>ブロックハンドルを抽出するには、マクロを使用します。<CODE><A HREF="../../CRef/Routines/R_3.htm#IX_BlockFromTransferBlockID() macro">BlockFromTransferBlockID()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardGetQuickItemInfo()"></A>
        <H1 CLASS="refHeading">ClipboardGetQuickItemInfo()</H1>
<PRE CLASS="syntax">TransferBlockID ClipboardGetQuickItemInfo(ボイド)</PRE>
<P>このルーチンは、クイック転送転送アイテムに関する情報を返します。 を返します。<CODE>TransferBlockID</CODE>このファイルには、転送ファイルのVMファイルハンドルと、転送アイテムのヘッダーブロックのVMブロックハンドルが含まれています。</P>
<P>戻り値からファイルハンドルを抽出するには、マクロを使用します。<CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileFromTransferBlockID() macro">FileFromTransferBlockID()</A></CODE>ブロックハンドルを抽出するには、マクロを使用します。<CODE><A HREF="../../CRef/Routines/R_3.htm#IX_BlockFromTransferBlockID() macro">BlockFromTransferBlockID()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardGetQuickTransferStatus()"></A>
        <H1 CLASS="refHeading">ClipboardGetQuickTransferStatus()</H1>
<PRE CLASS="syntax">ブール値ClipboardGetQuickTransferStatus(void);</PRE>
<P>このルーチンは<CODE>真</CODE>クイック転送操作が進行中の場合<CODE>偽の</CODE>そうでなければ。 多くの場合、オブジェクトまたはプロセスがシャットダウンしているときに呼び出されます。これは、呼び出し元が発信したクイック転送を中止するためです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a.htm_IX_ClipboardGetUndoItemInfo()"></A>
        <H1 CLASS="refHeading">ClipboardGetUndoItemInfo()</H1>
<PRE CLASS="syntax">TransferBlockID ClipboardGetUndoItemInfo(ボイド)</PRE>
<P>このルーチンは、転送を元に戻す項目に関する情報を返します。 を返します。<CODE>TransferBlockID</CODE>このファイルには、転送ファイルのVMファイルハンドルと、転送アイテムのヘッダーブロックのVMブロックハンドルが含まれています。</P>
<P>戻り値からファイルハンドルを抽出するには、マクロを使用します。<CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileFromTransferBlockID() macro">FileFromTransferBlockID()</A></CODE>ブロックハンドルを抽出するには、マクロを使用します。<CODE><A HREF="../../CRef/Routines/R_3.htm#IX_BlockFromTransferBlockID() macro">BlockFromTransferBlockID()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_b.htm_IX_ClipboardQueryItem()"></A>
          <A NAME="R_b.htm_IX_ClipboardQueryArgs"></A>
          <A NAME="R_b.htm_IX_CQA_&ldots;"></A>
        <H1 CLASS="refHeading">ClipboardQueryItem()</H1>
<PRE CLASS="syntax">void ClipboardQueryItem(ClipboardItemFlagsの旗、ClipboardQueryArgs*retValues)</PRE>
<P>このルーチンは、呼び出し側の排他的アクセスのために転送アイテムをロックし、現在の転送アイテムに関する情報を返します。 このルーチンは、貼り付けまたはクリップボードの照会操作を開始するときに呼び出す必要があります。 クリップボードの内容を変更する操作では、代わりにルーチンを使用する必要があります。<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRegisterItem()">ClipboardRegisterItem()</A></CODE>ボタンをクリックし</P>
<P>次の値を渡します。</P>
<DL>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>ClipboardItemFlags</CODE>照会する転送項目を示します。 CIF_QUICKを使用してクイック転送項目の情報を取得し、ゼロ(またはTIF_NORMAL)を渡して標準転送項目の情報を取得します。</DD>
<DT><CODE>retValues</CODE>空のへのポインタ<CODE>ClipboardQueryArgs</CODE>転送アイテムに関する戻り情報が渡される構造体。 この構造は、次のように定義されます。</DT>
<PRE>typedef struct{word CQA_numFormats;optr CQA_owner;TransferBlockID CQA_header;}ClipboardQueryArgs;</PRE>
</DL>
<P>の<CODE>CQA_ヘッダー</CODE>フィールド<CODE>ClipboardQueryArgs</CODE>は、他のいくつかのクリップボードルーチンへのパス値として使用されます。 これには、転送VMファイルのVMファイルハンドルと、転送アイテムのヘッダーブロックのVMブロックハンドルが含まれます。 の<CODE>CQA_オーナー</CODE>fieldは、転送アイテムを生成したオブジェクトのoptrです。 の<CODE>CQA_numFormats</CODE>フィールドには、この転送アイテムで使用可能なフォーマットの総数を指定します。 特定のフォーマットが転送アイテムでサポートされているかどうかを確認するには、ルーチンを呼び出します。<CODE><A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardTestItemFormat()">ClipboardTestItemFormat()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>を呼び出す必要があります。<CODE><A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardDoneWithItem()">ClipboardDoneWithItem()</A></CODE>転送アイテムへのアクセスが完了したとき。 このルーチンは、転送VMファイルへの排他的アクセスを放棄します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRequestItemFormat()">ClipboardRequestItemFormat()</A></CODE><CODE><A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardDoneWithItem()">ClipboardDoneWithItem()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_b.htm_IX_ClipboardRegisterItem()"></A>
        <H1 CLASS="refHeading">ClipboardRegisterItem()</H1>
<PRE CLASS="syntax">ブーリアンClipboardRegisterItem(TransferBlockIDヘッダー、ClipboardItemFlagsフラグ);</PRE>
<P>このルーチンは、転送アイテムへの変更を完了します。 クリップボードに何かをコピーしたり切り取ったりするとき、または何かをクイック転送項目として添付するときは、このルーチンを使用する必要があります。</P>
<P>このルーチンは<CODE>ヘッダー#ヘッダー#</CODE>を転送VMファイルにコピーします。 ファイル内にすでに存在する可能性のあるすべての転送項目を解放します。 このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>ヘッダー#ヘッダー#</CODE>
        </DT><DD>項目のヘッダー情報。転送VMファイルハンドルと、新しい転送項目を含むブロックのVMブロックハンドルで構成されます。 を作成します。<CODE>TransferBlockID</CODE>マクロを使った構造<CODE><A HREF="../../CRef/Routines/R_3.htm#IX_BlockIDFromFileAndBlock() macro">BlockIDFromFileAndBlock()</A></CODE>ボタンをクリックし</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>ClipboardItemFlags</CODE>クリップボード項目とクイック転送項目のどちらを登録しているかを示します。 フラグCIF_QUICKは、アイテムがクイック転送アイテムであることを示します。ゼロ(またはTIF_NORMAL)は、アイテムが通常のクリップボードアイテムであることを示します。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRequestItemFormat()">ClipboardRequestItemFormat()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_b.htm_IX_ClipboardRemoveFromNotificationList()"></A>
        <H1 CLASS="refHeading">ClipboardRemoveFromNotificationList()</H1>
<PRE CLASS="syntax">ブーリアンClipboardRemoveFromNotificationList(optr notificationOD);</PRE>
<P>このルーチンは、クリップボードの変更通知リストからオブジェクトまたはプロセスを削除します。 通常、オブジェクトまたはプロセスが分離または破棄されるときに呼び出されます。 通知リストに追加されたのと同じoptrを<CODE>ClipboardAddToNotificationList</CODE>()を参照してください。</P>
<P>このルーチンは、エラーフラグを返します。 フラグは次のようになります。<CODE>真</CODE>オブジェクトが通知リストに見つからなかった場合<CODE>偽の</CODE>オブジェクトがリストから正常に削除された場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_9.htm#IX_ClipboardAddToNotificationList()">ClipboardAddToNotificationList()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_b.htm_IX_ClipboardRequestItemFormat()"></A>
          <A NAME="R_b.htm_IX_ClipboardRequestArgs"></A>
          <A NAME="R_b.htm_IX_CRA_&ldots;"></A>
        <H1 CLASS="refHeading">ClipboardRequestItemFormat()</H1>
<PRE CLASS="syntax">void ClipboardRequestItemFormat(ClipboardItemFormatID形式、TransferBlockIDヘッダー、ClipboardRequestArgs*retValue);</PRE>
<P>このルーチンは、特定の転送アイテムに関する特定の情報を返します。 渡された情報の一部は<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>を呼び出す必要があります。<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>このルーチンを呼び出す前に</P>
<P>このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>書式</CODE>
        </DT><DD>転送VMファイルに格納される新しい転送アイテムの製造元IDとフォーマットタイプ。 を作成します。<CODE>ClipboardItemFormatID</CODE>マクロの値<CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_FormatIDFromManufacturerAndType()">FormatIDFromManufacturerAndType()</A></CODE>ボタンをクリックし</DD>
<DT>
          <CODE>ヘッダー#ヘッダー#</CODE>
        </DT><DD>項目のヘッダー情報。転送VMファイルハンドルと、新しい転送項目を含むブロックのVMブロックハンドルで構成されます。 を作成します。<CODE>TransferBlockID</CODE>マクロを使った構造<CODE><A HREF="../../CRef/Routines/R_3.htm#IX_BlockIDFromFileAndBlock() macro">BlockIDFromFileAndBlock()</A></CODE>戻された情報の使用<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>ボタンをクリックし</DD>
<DT><CODE>戻り値</CODE>空のへのポインタ<CODE>ClipboardRequestArgs</CODE>ルーチンによって埋められる構造体。 この構造は、次のように定義されます。</DT>
<PRE>typedef struct{VMFileHandle CRA_file;VMChain CRA_data;word CRA_extra1;word CRA_extra2;}ClipboardRequestArgs;</PRE>
</DL>
<P>戻り次第<CODE>CRAファイル(CRA_file)</CODE>フィールドには、転送VMファイルのVMファイルハンドルと<CODE>CRAデータ</CODE>フィールドには、転送アイテムのヘッダーブロックのVMブロックハンドルが含まれます。 転送項目がない場合は<CODE>CRAデータ</CODE>は0になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRegisterItem()">ClipboardRegisterItem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_c.htm_IX_ClipboardSetQuickTransferFeedback()"></A>
        <H1 CLASS="refHeading">ClipboardSetQuickTransferFeedback()</H1>
<PRE CLASS="syntax">void ClipboardSetQuickTransferFeedback(ClipboardQuickTransferFeedbackカーソル、UIFunctionsActive buttonFlags)</PRE>
<P>このルーチンは、クイック転送操作中のマウスポインタのイメージを設定します。 このルーチンを使用して、クイック転送中にユーザに視覚的なフィードバックを提供します。 たとえば、クイック転送項目を受け入れることができないオブジェクトは、マウスポインタがその境界上にある間、「操作なし」カーソルを設定します。</P>
<P>次の2つの値を渡します。</P>
<DL>
<DT>
          <CODE>カーソル</CODE>
        </DT><DD>の値<CODE>ClipboardQuickTransferFeedback</CODE>設定するカーソルの種類を示します。 使用可能な値を以下に示します。</DD>
<DT>
          <CODE>buttonFlags</CODE>
        </DT><DD>の記録<CODE>UIFunctionsActive</CODE>フラグ。 これらのフラグは入力マネージャ(Input Manager)セクションで定義され、移動/コピー動作のユーザオーバーライドを処理します。</DD>
</DL>
<P>カーソルパラメータに次の値が含まれています<CODE>ClipboardQuickTransferFeedback</CODE>これは、設定するカーソルを定義する列挙型で、次の値を持ちます。</P>
<DL>
<DT>CQTF_移動</DT><DD>これにより、カーソルが特定のUIの移動カーソルに設定されます。</DD>
<DT>CQTF_コピー</DT><DD>これにより、カーソルが特定のUIのコピーカーソルに設定されます。</DD>
<DT>CQTF_CLEAR</DT><DD>これにより、カーソルがクリアされ、特定のUIのモーダルな「操作なし」カーソルに設定されます。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_c.htm_IX_ClipboardStartQuickTransfer()"></A>
          <A NAME="R_c.htm_IX_ClipboardQuickTransferFlags"></A>
          <A NAME="R_c.htm_IX_CQTF_&ldots;"></A>
          <A NAME="R_c.htm_IX_CQTRI_&ldots;"></A>
          <A NAME="R_c.htm_IX_ClipboardQuickTransferRegionInfo"></A>
        <H1 CLASS="refHeading">ClipboardStartQuickTransfer()</H1>
<PRE CLASS="syntax">ブールClipboardStartQuickTransfer(ClipboardQuickTransferFlagsフラッグ、ClipboardQuickTransferFeedback initialCursor、ワードmouseXPos、ワードmouseYPos、ClipboardQuickTransferRegionInfo*regionParams、optr notificationOD);</PRE>
<P>このルーチンは、クイック転送操作の開始を通知します。 通常、オブジェクトまたはプロセスは<CODE>MSG_META_START_MOVE_COPY[コピー開始]</CODE>ハンドラ。</P>
<P>次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>ClipboardQuickTransferFlags</CODE>追加のグラフィック領域がカーソルに添付されるかどうか、および呼び出し側が転送完了の通知を希望するかどうかを示します。 使用可能なフラグは、パラメータリストの後に表示されます。</DD>
<DT><CODE>initialCursor</DT><DD></CODE>ユーザーへの視覚的なフィードバックに使用する初期カーソル。 次の値です。<CODE>ClipboardQuickTransferFeedback</CODE>、CQTF_MOVEまたはCQTF_COPYのいずれかです。 このパラメータに-1が渡された場合、初期カーソルはデフォルトの無操作カーソルになります(つまり、転送元が転送先として機能しない場合があります)。</DD>
<DT>
          <CODE>mouseXPos</CODE>
        </DT><DD>このフィールドは、CQTF_USE_REGIONが渡された場合にのみ使用されます。<CODE>フラグふらぐ</CODE>画面座標でのマウスの水平位置です。</DD>
<DT>
          <CODE>mouseYPos</CODE>
        </DT><DD>このフィールドは、CQTF_USE_REGIONが渡された場合にのみ使用されます。<CODE>フラグふらぐ</CODE>これは、画面座標におけるマウスの垂直位置です。</DD>
<DT><CODE>regionParams</DT><DD></CODE>へのポインタ<CODE>ClipboardQuickTransferRegionInfo</CODE>転送操作中にカーソルに付加されるグラフィカル領域を定義する構造。 この構造体は、REGION_USE_REGIONが渡された場合にのみ必要です。CQTF_USE_REGION<CODE>フラグふらぐ</CODE>以下に定義されています。</DD>
<DT><CODE>notificationOD</DT><DD></CODE>転送完了時に通知されるオブジェクトのoptr。 指定したオブジェクトが通知メッセージを受信します<CODE>MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_TERMINATED(MSG_META_CLIPBOARD_NOTIFY</CODE>および<CODE>MSG_._フィードバック</CODE>ボタンをクリックし</DD>
</DL>
<P>許可された<CODE>ClipboardQuickTransferFlags</CODE>以下にリストします。</P>
<DL>
<DT>CQTF_コピーのみ</DT><DD>ソースはコピーのみをサポートします(切り取りはサポートしません)。</DD>
<DT>「領域使用」(REGION_USE_CQTF)</DT><DD>ソースが、クイック転送カーソルの末尾にアタッチされるグラフィカル領域の定義を渡しました。</DD>
<DT>CQTF_通知</DT><DD>ソースは、元のデータを削除したり、その他のフィードバックを提供するために、転送の完了を通知する必要があります。</DD>
</DL>
<P>グラフィック領域をクイック転送カーソルにアタッチする場合は<CODE>ClipboardQuickTransferRegionInfo</CODE>見出しページを開きます。<CODE>regionParams</CODE>パラメータを指定します。 この構造は、以下で定義されます。</P>
<PRE>typedef struct{word CQTRI_paramAX;word CQTRI_paramBX;word CQTRI_paramCX;word CQTRI_paramDX;Point CQTRI_regionPos;dword CQTRI_strategy;dword CQTRI_region;}ClipboardQuickTransferRegionInfo;</PRE>
<P>この構造体はスタック上でルーチンに渡されます。 最初の4つのフィールドは、領域の定義パラメータを表します。<CODE>CQTRI_regionPos</CODE>は<CODE>[点]</CODE>領域が配置される場所(画面座標内)を示す構造体。<CODE>CQTRI_方針</CODE>は領域戦略ルーチンへのポインタである。<CODE>CQTRI_方針</CODE>ビデオドライバー戦略であるべきです ウィンドウに関連付けられているビデオドライバの方針を確認するには、オブジェクトにMSG_VIS_VUP_QUERYとVUQ_VIDEO_DRIVERを送信します。 取得したハンドルを<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeInfoDriver()">GeodeInfoDriver()</A></CODE>これにより、戦略が返されます。</P>
<P>このルーチンは、エラーフラグを返します。 クイック転送がすでに実行中の場合、戻りは次のようになります。<CODE>真</CODE>クイック転送が正常に開始された場合、エラーフラグは<CODE>偽の</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_c.htm_IX_ClipboardTestItemFormat()"></A>
        <H1 CLASS="refHeading">ClipboardTestItemFormat()</H1>
<PRE CLASS="syntax">ブーリアンClipboardTestItemFormat(TransferBlockIDヘッダー、ClipboardFormatID形式);</PRE>
<P>このルーチンは、指定したフォーマットが指定した転送項目でサポートされているかどうかをテストします。 戻ります<CODE>真</CODE>フォーマットがサポートされている場合<CODE>偽の</CODE>形式がサポートされていない場合。 次の値を渡します。</P>
<DL>
<DT>
          <CODE>ヘッダー#ヘッダー#</CODE>
        </DT><DD>ア<CODE>TransferBlockID</CODE>チェックする転送項目のVMファイルハンドルとVMブロックハンドルを指定します。 これはルーチンによって返されます。<CODE><A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardGetNormalItemInfo()">ClipboardGetNormalItemInfo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardGetQuickItemInfo()">ClipboardGetQuickItemInfo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardGetUndoItemInfo()">ClipboardGetUndoItemInfo()</A></CODE>、および<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>ほとんどの場合、次のルーチンを使用するのが適切です。<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>ボタンをクリックし</DD>
<DT>
          <CODE>書式</CODE>
        </DT><DD>ア<CODE>クリップボード形式ID</CODE>チェックするフォーマットのタイプとメーカーIDを指定します。 このパラメータは、マクロを使用して個々のパーツから作成することをお勧めします。<CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_FormatIDFromManufacturerAndType()">FormatIDFromManufacturerAndType()</A></CODE>ボタンをクリックし</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_c.htm_IX_ClipboardUnregisterItem()"></A>
        <H1 CLASS="refHeading">ClipboardUnregisterItem()</H1>
<PRE CLASS="syntax">void owner(optr ClipboardUnregisterItem)</PRE>
<P>このルーチンは、転送項目を最後の<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRegisterItem()">ClipboardRegisterItem()</A></CODE>呼び出し側のoptrに渡します。</P>
<P>転送項目を最後に登録したオブジェクトだけが、その項目の登録を解除できます。 転送アイテムが別のオブジェクトによって所有されている場合、または転送アイテムがない場合は、何も行われません。 転送アイテムが呼び出し元によって所有されている場合、転送アイテムは登録解除され、クリップボードは以前の状態に復元されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">クリップボードゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_d.htm_IX_ConstructOptr() macro"></A>
          <A NAME="R_d.htm_IX_optr:ConstructOptr() macro"></A>
        <H1 CLASS="refHeading">ConstructOptr()</H1>
<PRE CLASS="syntax">optr ConstructOptr(ハンドルハン、ChunkHandleチ)</PRE>
<P>このマクロは、指定されたハンドル(通常はMemHandle)とチャンクハンドルからoptr型を構成します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleToOptr() macro">HandleToOptr()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToHandle()">OptrToHandle()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToChunk()">OptrToChunk()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_d.htm_IX_ContactCompareNumbers()"></A>
        <H1 CLASS="refHeading">ContactCompareNumbers()</H1>
<PRE CLASS="syntax">Boolean ContactCompareNumbers(TCHAR*数値1,TCHAR*数値2);</PRE>
<P>この関数は、2つの電話番号文字列の等価性を比較します。 スペースなどの無関係な文字は無視されます。 同じ数値の場合は0を返し、それ以外の場合は0以外の値を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_d.htm_IX_ContactCreateRecordFromTemplate()"></A>
        <H1 CLASS="refHeading">ContactCreateRecordFromTemplate()</H1>
<PRE CLASS="syntax">MemHandle ContactCreateRecordFromTemplate(ボイド)</PRE>
<P>この関数は、連絡先データベースに新しい連絡先レコードを作成します。新しいレコードのハンドルを返します。 レコードに必要な変更を加えてから<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactSaveRecord()">ContactSaveRecord()</A></CODE>レコードを保存するには<CODE>FoamDBDiscardRecord()</CODE>をクリックして変更を破棄します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactSaveRecord()">ContactSaveRecord()</A></CODE><CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactSetTemplateRecord()">ContactSetTemplateRecord()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_d.htm_IX_ContactEnsureEmptyField()"></A>
        <H1 CLASS="refHeading">ContactEnsureEmptyField()</H1>
<PRE CLASS="syntax">FieldID ContactEnsureEmptyField(MemHandleレコード、optr fieldName、ContdbFieldType fieldType);</PRE>
<P>この関数はレコードにフィールドを作成し、その名前の既存のフィールドがすでに存在する場合は、そのフィールドからdatをクリアします。 この関数は、次のarguemntsを取ります。</P>
<DL>
<DT>
          <EM>記録</EM>
        </DT><DD>によって返される、レコードのハンドル<CODE>FoamDBGetRecordFromID()</CODE>または<CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactCreateRecordFromTemplate()">ContactCreateRecordFromTemplate()</A></CODE>ボタンをクリックし</DD>
<DT>
          <EM>フィールド名</EM>
        </DT><DD>NULLで終端された名前文字列を含むチャンクのoptr<CODE>NullOptr</CODE>を使用して、渡された<CODE>ContdbFieldType</CODE>ボタンをクリックし</DD>
<DT>
          <EM>フィールドタイプ</EM>
        </DT><DD>検索するフィールドの種類を指定します。 CFT_NAME、CFT_COMPANY、CFT_TITLE、CFT_ADDRESS、CFT_PHONE、CFT_FAX、CFT_EMAIL、CFT_DTMF、CFT_NOTESのいずれか。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactEnsureField()">ContactEnsureField()</A></CODE><CODE>FoamDBSetFieldData()</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_d.htm_IX_ContactEnsureField()"></A>
        <H1 CLASS="refHeading">ContactEnsureField()</H1>
<PRE CLASS="syntax">FieldID ContactEnsureField(MemHandleレコード、optr fieldName、ContdbFieldType fieldType);</PRE>
<P>この関数は<CODE>フィールドID</CODE>フィールドが見つからない場合は、そのフィールドを作成します。 この関数は、次のarguemntsを取ります。</P>
<DL>
<DT>
          <EM>記録</EM>
        </DT><DD>によって返される、レコードのハンドル<CODE>FoamDBGetRecordFromID()</CODE>または<CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactCreateRecordFromTemplate()">ContactCreateRecordFromTemplate()</A></CODE>ボタンをクリックし</DD>
<DT>
          <EM>フィールド名</EM>
        </DT><DD>NULLで終端された名前文字列を含むチャンクのoptr<CODE>NullOptr</CODE>を使用して、渡された<CODE>ContdbFieldType</CODE>ボタンをクリックし</DD>
<DT>
          <EM>フィールドタイプ</EM>
        </DT><DD>検索するフィールドの種類を指定します。 CFT_NAME、CFT_COMPANY、CFT_TITLE、CFT_ADDRESS、CFT_PHONE、CFT_FAX、CFT_EMAIL、CFT_DTMF、CFT_NOTESのいずれか。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactEnsureEmptyField()">ContactEnsureEmptyField()</A></CODE><CODE>FoamDBSetFieldData()</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_d.htm_IX_ContactExportDBToTextFile()"></A>
        <H1 CLASS="refHeading">ContactExportDBToTextFile()</H1>
<PRE CLASS="syntax">ContactExportStatus ContactExportDBToTextFile(hptr fileExport, dword startElement, dword numOfRecords);</PRE>
<P>この関数は、ContactデータベースのデータをASCIIファイルとしてエクスポートします。 成功した場合、この関数はCES_NO_ERRORを返します。それ以外の場合はCES_FILE_ERRORを返します。この関数は次の引数を取ります。</P>
<DL>
<DT>
          <EM>ファイルエクスポート</EM>
        </DT><DD>エクスポートされたテキストを保持する、開かれたファイルのハンドル。</DD>
<DT><EM>開始エレメント</DT><DD></EM>の<CODE>レコードID</CODE>最初にエクスポートするレコードの</DD>
<DT><EM>レコード数</DT><DD></EM>この引数は、エクスポートするレコードの範囲を決定します。 RecordID以上のすべてのレコード<EM>開始エレメント</EM>より小さい<EM>開始エレメント</EM>+を入力し<EM>レコード数</EM>がエクスポートされます。</DD>
</DL>
<P>すべてのレコードをエクスポートするには<EM>開始エレメント</EM>ゼロとaの<EM>レコード数</EM>CONTACT_EXPORT_ALL_RECORDSの</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactExportDBToTextFile()">ContactExportDBToTextFile()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_e.htm_IX_ContactGetDBHandle()"></A>
        <H1 CLASS="refHeading">ContactGetDBHandle()</H1>
<PRE CLASS="syntax">VMFileHandle ContactGetDBHandle(ボイド)</PRE>
<P>この関数は、Contactデータベースのハンドルを返します。このデータベースには<STRONG CLASS="fileName">contdb</STRONG>ライブラリ。 このハンドルは、ライブラリのさまざまな操作に必要です。 ハンドルの操作が完了したら<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactReleaseDBHandle()">ContactReleaseDBHandle()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandleNoBlock()">ContactGetDBHandleNoBlock()</A></CODE><CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactReleaseDBHandle()">ContactReleaseDBHandle()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_e.htm_IX_ContactGetDBHandleNoBlock()"></A>
        <H1 CLASS="refHeading">ContactGetDBHandleNoBlock()</H1>
<PRE CLASS="syntax">VMFileHandle ContactGetDBHandleNoBlock(ボイド)</PRE>
<P>この関数の動作は、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>ただし、ハンドルを取得できない場合は、ハンドルが使用可能になるまで待つのではなく、0を返します。ハンドルの操作が完了したら、忘れずに<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactReleaseDBHandle()">ContactReleaseDBHandle()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_e.htm_IX_ContactGetName()"></A>
        <H1 CLASS="refHeading">ContactGetName()</H1>
<PRE CLASS="syntax">Boolean ContactGetName(MemHandleレコード,TCHAR*dest);</PRE>
<P>この関数は、レコードに関連付けられた名前を取得し<EM>宛先</EM>バッファ。 レコードに名前がない場合、この関数は0以外の値を返します。それ以外の場合は0を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_e.htm_IX_ContactGetTruncatedName()"></A>
        <H1 CLASS="refHeading">ContactGetTruncatedName()</H1>
<PRE CLASS="syntax">Boolean ContactGetTrunactedName(MemHandleレコード,TCHAR*dest, word destSize);/*destバッファのサイズ*/</PRE>
<P>この関数は、レコードに関連付けられた名前を取得し<EM>宛先</EM>バッファ。 必要に応じて名前を切り詰め、バッファ内に収まるようにします。 必要なバッファの大きさを決定する際には、ヌルターミネータ用のスペースを残しておくことを忘れないでください。 レコードに名前がない場合、この関数は0以外の値を返します。それ以外の場合は0を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_e.htm_IX_ContactGetUserDataID()"></A>
        <H1 CLASS="refHeading">ContactGetUserDataID()</H1>
<PRE CLASS="syntax">RecordID ContactGetUserDataID(無効)</PRE>
<P>この関数は<CODE>レコードID</CODE>ユーザ自身の連絡先データを含む特別なContactsデータベースレコードの</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>FoamDBGetRecordFromID()</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_e.htm_IX_ContactImportDBFromTextFile()"></A>
        <H1 CLASS="refHeading">ContactImportDBFromTextFile()</H1>
<PRE CLASS="syntax">void ContactImportDBFromTextFile(hptr fileImport);/*ファイルのハンドル*/</PRE>
<P>この関数は、ASCIIテキストファイルから連絡先データベース情報をインポートします。 このファイルのフォーマットを以下に示します。 この関数は、インポートされたレコードを連絡先データベース内の既存のレコードと比較します。 同一のレコードはすべて結合されます。</P>
<P>短いサンプルファイルを以下に示します。</P>
<PRE>[RECORD][FIELD]名前[FIELD-NAME][FIELD-DATA]Hudson W. [FIELD-END][FIELD]</PRE>
<PRE>会社[FIELD-NAME][FIELD-DATA]宇宙海兵隊[FIELD-END][FIELD]タイトル[FIELD-NAME][FIELD-DATA]プライベート[FIELD-END][RECORD-END]</PRE>
<PRE>[RECORD][FIELD]名前[FIELD-NAME][FIELD-DATA]</PRE>
<PRE>Adams、ジョン・クインシー[FIELD-END][FIELD]Tel[FIELD-NAME][FIELD-DATA]1 617 438 1776[FIELD-END][FIELD][FIELD-NAME]会社[FIELD-DATA][FIELD-END]米国政府[FIELD]メモ[FIELD-NAME]メモ(誕生日)[FIELD-DATA]1767年7月11日ギフトアイデア:花[FIELD-END][RECORD-END]</PRE>
<P>ASCIIファイルは、次の規則に従います。</P>
<UL>
<LI>このページは、&quot;Latin 1&quot;コード・ページ(番号819)を使用したDOSテキスト・ファイルです。</LI>
<LI>テキストの各行は改行で終わることができます。改行の前には、オプションのキャリッジリターンを指定できます。</LI>
<LI>各レコードに対応するデータは、先頭の[RECORD]行と末尾の[RECORD-END]行で区切られます。 これらの区切り文字の外側に表示されるテキストはすべて失われます。</LI>
<LI>各レコードは、1つ以上のフィールドで構成されます。 各フィールドは、行番号[FIELD]と行番号[FIELD-END]で区切られます。</LI>
<LI>各フィールドについて、[FIELD]行の後の最初の行は、フィールドのタイプを指定する次の文字列のいずれかで構成されます。<BR>名前、会社、役職、住所、電話、ファックス、メール、DTMF、メモ。</LI>
<LI>[FIELD-NAME]行と[FIELD-DATA]行の間にテキスト行がある場合があります。 このようなテキスト行がない場合は、フィールド名がそのデータ型の既定の名前になります。 このようなテキスト行がある場合は、この行のテキストを括弧で囲み、その前にフィールドのデフォルト名を付けることで、フィールド名を形成できます。 上記の「Birthday」の例では、完全なフィールド名は「Note(Birthday)」になります。<BR>の<EM>例外</EM>電話番号フィールドに「GSM/PCN」と表示されます。 テキストの行が「GSM/PCN」の場合は、「GSM」であるかのように処理します。 完全なフィールド名は、おそらく「Tel(GSM)」または「Fax(GSM)」です。</LI>
<LI>[FIELD-DATA]行と[FIELD-END]行の間のテキスト行には、フィールドのデータ(存在する場合)が含まれます。 テキスト行がない場合は、フィールドにデータが含まれていないことを意味します。 テキストは複数行になる場合があります。</LI>
</UL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactExportDBToTextFile()">ContactExportDBToTextFile()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_e.htm_IX_ContactMatchName()"></A>
        <H1 CLASS="refHeading">ContactMatchName()</H1>
<PRE CLASS="syntax">RecordID Field(TCHAR名,ContdbFieldTypeタイプ,Boolean stopEarly, FieldID*フィールド,単語*numMatches);ContactMatchName</PRE>
<P>この関数はanameを取り、Contactデータベースのすべてのレコード内の指定された型のすべてのフィールドを検索し<CODE>レコードID</CODE>および<CODE>フィールドID</CODE>一致するフィールドがある場合は、そのフィールドの値を返します。一致するフィールドがない場合は、-1を返します。</P>
<P>名前の比較では、大文字と小文字は区別されません。</P>
<P>この関数は、次の引数を取ります。</P>
<DL>
<DT>
          <EM>人名</EM>
        </DT><DD>照合する名前を含む文字列。</DD>
<DT>
          <EM>種類</EM>
        </DT><DD>照合する電話番号のタイプ。CFT_NAME、CFT_COMPANY CFT_TITLE、CFT_ADDRESS、CFT_PHONE、CFT_FAX、CFT_EMAIL、CFT_DTMF、CFT_NOTESのいずれかです。</DD>
<DT>
          <EM>stopEarly</EM>
        </DT><DD>このフラグを設定<EM>真</EM>最初に一致する名前が見つかったら検索を停止するには、その名前を設定します。<EM>偽の</EM>一致する名前の数を調べます。</DD>
<DT>
          <EM>畑</EM>
        </DT><DD>へのポインタ<CODE>フィールドID</CODE>バッファ。 この関数は、このバッファに<CODE>フィールドID</CODE>一致するフィールドがある場合は、そのフィールドの</DD>
<DT><EM>numMatches</DT><DD></EM>ワードバッファへのポインタ。 この関数は、見つかった一致するレコードの数でこのバッファを埋めます。 この番号が意味を持つのは、stopEarlyフラグが<EM>偽の</EM>ボタンをクリックし</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactEnsureEmptyField()">ContactEnsureEmptyField()</A></CODE><CODE>FoamDBSetFieldData()</CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_f.htm_IX_ContactMatchNumber()"></A>
        <H1 CLASS="refHeading">ContactMatchNumber()</H1>
<PRE CLASS="syntax">RecordID field(TCHAR number, ContdbCallType type, FieldID*field, word*numMatches);RecordID field(TCHAR number, type, FieldID*field, word*);ContactMatchNumber</PRE>
<P>この関数は電話番号を受け取り、Contactデータベースのすべてのレコード内の指定されたタイプのすべてのフィールドを検索して<CODE>レコードID</CODE>および<CODE>フィールドID</CODE>一致するフィールドがある場合は、そのフィールドの値を返します。一致するフィールドがない場合は、-1を返します。</P>
<P>この関数は、次の引数を取ります。</P>
<DL>
<DT>
          <EM>数</EM>
        </DT><DD>照合する電話番号を含む文字列。</DD>
<DT>
          <EM>種類</EM>
        </DT><DD>照合する電話番号のタイプ。CCT_PHONE、CCT_SMS、CCT_FAX、CCT_EMAIL、CCT_GSM_FAX、CCT_ANYのいずれかです。</DD>
<DT>
          <EM>畑</EM>
        </DT><DD>へのポインタ<CODE>フィールドID</CODE>バッファ。 この関数は、このバッファに<CODE>フィールドID</CODE>一致するフィールドがある場合は、そのフィールドの</DD>
<DT><EM>numMatches</DT><DD></EM>ワードバッファへのポインタ。 この関数は、見つかった一致するレコードの数でこのバッファを埋めます。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactEnsureEmptyField()">ContactEnsureEmptyField()</A></CODE><CODE>FoamDBSetFieldData()</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_f.htm_IX_ContactRecreateFieldLabel()"></A>
        <H1 CLASS="refHeading">ContactRecreateFieldLabel()</H1>
<PRE CLASS="syntax">void field(TCHAR*subLabel, TCHAR*destination, int ContdbRecreateFieldLabel Type);</PRE>
<P>このユーティリティ関数は、フィールドのサブラベル(例:「GSM/PCN」)とフィールドタイプを受け取り、それらからラベルを作成します(例:「Tel(GSM)」)。 標準ラベルを英語からユーザーの言語に翻訳します。 (「Tel(GSM)」の「GSM」など、一部のフィールドサブラベルは標準であり、変換されます。ユーザのカスタムサブラベルは変換されません。) この関数は、次の引数を取ります。</P>
<DL>
<DT>
          <EM>サブラベル</EM>
        </DT><DD>サブラベル文字列。</DD>
<DT>
          <EM>着側</EM>
        </DT><DD>フィールド名を保持する文字列バッファ。</DD>
<DT>
          <EM>フィールドタイプ</EM>
        </DT><DD>の<CODE>ContdbFieldType</CODE>フィールドの値。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactImportDBFromTextFile()">ContactImportDBFromTextFile()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_f.htm_IX_ContactReleaseDBHandle()"></A>
        <H1 CLASS="refHeading">ContactReleaseDBHandle()</H1>
<PRE CLASS="syntax">void ContactReleaseDBHandle(void)</PRE>
<P>この関数はContactデータベースのハンドルを解放し、アプリケーションがこの時点でデータベースを終了したことを通知します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE><CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactReleaseDBHandle()">ContactReleaseDBHandle()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_f.htm_IX_ContactSaveRecord()"></A>
        <H1 CLASS="refHeading">ContactSaveRecord()</H1>
<PRE CLASS="syntax">dワードContactSaveRecord(MemHandle記録)</PRE>
<P>これにより、渡されたレコードがデータベースにfunctionsavesされ、適切なソート順で挿入されます。 レコードの<CODE>レコードID</CODE>番号を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>FoamDBDiscardRecord()</CODE><CODE>FoamDBDeleteRecord()</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_f.htm_IX_ContactSetTemplateRecord()"></A>
        <H1 CLASS="refHeading">ContactSetTemplateRecord()</H1>
<PRE CLASS="syntax">空のContactSetTemplateRecord(MemHandle記録)</PRE>
<P>これにより、渡されたレコードが連絡先データベースのテンプレートレコードにfunctionmakesされます。また、その連絡先のハンドルも解放されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactCreateRecordFromTemplate()">ContactCreateRecordFromTemplate()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_f.htm_IX_ContdbTranslateSubFieldLabelToEnglish()"></A>
        <H1 CLASS="refHeading">ContdbTranslateSubFieldLabelToEnglish()</H1>
<PRE CLASS="syntax">void ContdbTranslateSubFieldLabelToEnglish(TCHAR*subLabel, TCHAR*destination);</PRE>
<P>この関数は、外部サブラベルを英語のサブラベルに変換します。 この関数は、特定の「標準」サブラベルのみを認識します。ユーザのカスタムラベルは変換されません。 この関数は、変換する文字列を含むバッファと、変換を保持する文字列バッファの2つの引数を取ります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_16.htm#IX_DBAllocUngrouped()">DBAllocUngrouped()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_f.htm_IX_DataStoreAddField()"></A>
        <H1 CLASS="refHeading">DataStoreAddField()</H1>
<PRE CLASS="syntax">DataStoreStructureError DataStoreAddField(ワードdsToken、FieldDescriptor*fieldDescPtr、FieldID*fieldIDPtr);</PRE>
<P>データストアにフィールドを追加し、新しいフィールドの<CODE>フィールドID</CODE>と<EM>fieldIDPtr</EM>を返します。<CODE>DataStoreStructureError</CODE>値(成功した場合はDSSE_NO_ERROR)。 次の引数を取ります。</P>
<DL>
<DT>
          <EM>dsToken</EM>
        </DT><DD>開かれたデータストアへのセッショントークン。</DD>
<DT><EM>fieldDescPtr</DT><DD></EM>へのポインタ<CODE>FieldDescriptor</CODE>構造。 FDの設定<CODE>ふらぐ</CODE>フィールドがキーの一部である場合は、FF_PRIMARY_KEYに変更します。</DD>
<PRE>typedef struct{FieldData FD_data;TCHAR*FD_name;}FieldDescriptor;</PRE>
<PRE>typedef struct{FieldType FD_type;FieldCategory FD_category;FieldFlags FD_flags;}FieldData;と入力します。</PRE>
<DT>fieldIDPtr</DT><DD>へのポインタ<CODE>フィールドID</CODE>をクリックします。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_f.htm_IX_DataStoreBuildIndex()"></A>
        <H1 CLASS="refHeading">DataStoreBuildIndex()</H1>
<PRE CLASS="syntax">DataStoreStructureError DataStoreBuildIndex(単語dsToken、MemHandle*indexBlockHan、単語dataSize、DataStoreIndexCallbackParams*paramsPtr、sword_pascal(*CallbackRoutine)(単語dsToken、DataStoreIndexCallbackParams*paramsPtr));</PRE>
<P>のインデックスを作成します。<CODE>RecordNum</CODE>s(下位ワードのみ)は、指定されたフィールドまたはコールバック関数のいずれかに基づきます。 を返します。<CODE>DataStoreStructureError</CODE>値(成功した場合はDSSE_NO_ERROR)。 次の引数を取ります。</P>
<DL>
<DT>
          <EM>dsToken</EM>
        </DT><DD>開かれたデータストアへのセッショントークン。</DD>
<DT><EM>indexBlockHan</DT><DD></EM>インデックスブロックのハンドルへのポインタ。</DD>
<DT><EM>データサイズ</DT><DD></EM>インデックス・ブロックに書き込むデータのバイト数。</DD>
<DT><EM>paramsPtr</DT><DD></EM>へのポインタ<CODE>DataStoreIndexCallbackParams</CODE>構造。 フィールドにインデックスを作成するには、DSICPでフィールドを指定します。<CODE>_indexField</CODE>DSICPを設定<CODE>並べ替え順序(_O)</CODE>SO_ASCENDINGまたはSO_DESCENDINGに変更します。 コールバックを指定すると、発信者はDSICPを渡します。<CODE>CBデータ(_D)</CODE>,DSICP<CODE>レコード1</CODE>およびDSICP<CODE>レコード2</CODE>をコールバックに追加します。</DD>
<PRE>typedef struct{FieldID DSICP_indexField;sortOrder DSICP_sortOrder;void*DSICP_cbData;RecordHeader*DSICP_rec1;RecordHeader*DSICP_rec1;}DataStoreIndexCallbackParams;</PRE>
<DT><EM>CallbackRoutine</DT><DD></EM>渡された2つのレコードのうち、どちらが他方よりも前に来るかを決定するサブルーチン。 この関数は次の値を返します。<BR><BR>-1の場合<CODE>DSICP_rec1</CODE>前に来る<CODE>DSICP_rec2<BR></CODE>1の場合<CODE>DSICP_rec1</CODE>後に来る<CODE>DSICP_rec2</CODE></DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>4,000を超えるレコードを含むデータストアでこのルーチンを呼び出すことはできません(DSSE_INDEX_RECORD_NUMBER_LIMIT_EXCEEDEDが返されます)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_f.htm_IX_DataStoreClose()"></A>
        <H1 CLASS="refHeading">DataStoreClose()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreClose(ワードdsToken);/*開かれたデータストアへのセッショントークン*/</PRE>
<P>他のアプリケーションが開いていない場合は、データストアを閉じます。それ以外の場合は<EM>dsToken</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>呼び出し元セッションにロックされたレコードがある場合は、DSE_CLOSE_WITH_LOCKED_RECORDを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_10.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_10.htm_IX_DataStoreCreate()"></A>
        <H1 CLASS="refHeading">DataStoreCreate()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreCreate(DataStoreCreateParams*paramsPtr、dsTokenという言葉);</PRE>
<P>新しいデータストアを作成し、そのデータストアへのセッションを開き、セッショントークンを<EM>dsToken</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。 次の引数を取ります。</P>
<DL>
<DT><EM>paramsPtr</DT><DD></EM>へのポインタ<CODE>DataStoreCreateParams</CODE>構造。<CODE>DSCP名</CODE>には、データストアの名前が入ります。 DSF_PRIVATE、DSF_TIMESTAMPまたはDSF_NO_PRIMARY_KEY(あるいはその両方)を<CODE>DSCP_flagsです。 DSCPキーリスト</CODE>および<CODE>DSCPキー数</CODE>には、キーフィールドのリストと番号がそれぞれ含まれます。 データストア変更の通知を受け取るオブジェクトを指定してください<CODE>DSCP_notifObject</CODE>ボタンをクリックし</DD>
<PRE>typedef struct{TCHAR*DSCP_name;DataStoreFlags DSCP_flags;FieldDescriptor*DSCP_keyList;word DSCP_keyCount;optr DSCP_notifObject;}DataStoreCreateParams;</PRE>
<DT>
          <EM>dsToken</EM>
        </DT><DD>開かれたデータストアへのセッショントークン。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_10.htm_IX_DataStoreDelete()"></A>
        <H1 CLASS="refHeading">DataStoreDelete()</H1>
<PRE CLASS="syntax">DataStoreError・DataStoreDelete(TCHAR*dsNamePtr)</PRE>
<P>他のアプリケーションが開いていない場合、指定されたデータストアを削除します。 を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_10.htm_IX_DataStoreDeleteField()"></A>
        <H1 CLASS="refHeading">DataStoreDeleteField()</H1>
<PRE CLASS="syntax">DataStoreStructureError DataStoreDeleteField(ワードdsToken, /*セッショントークンからオープンされたデータストア*/TCHAR*fieldNamePtr, FieldID FieldID);</PRE>
<P>渡されたフィールドをデータストアから削除します。 を返します。<CODE>DataStoreStructureError</CODE>値(成功した場合はDSSE_NO_ERROR)。</P>
<P>フィールドは名前で参照することも<CODE>フィールドID</CODE>名前で参照する場合は<EM>フィールドID</EM>;参照元が<CODE>フィールドID</CODE>にNULLを渡します。<EM>fieldNamePtr</EM>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>キーフィールドを削除できません。</P>
<P>アプリケーションがデータストア内のレコードをロックしている場合、フィールドを削除できません(DSSE_ACCESS_DENIEDが返されます)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_14.htm#IX_DataStoreRemoveFieldFromRecord()">DataStoreRemoveFieldFromRecord()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_10.htm_IX_DataStoreDeleteRecord()"></A>
        <H1 CLASS="refHeading">DataStoreDeleteRecord()</H1>
<PRE CLASS="syntax">DataStoreDataError・DataStoreDeleteRecord(ワード・dsToken、/*オープンされたデータストアへのセッション・トークン*/recordID recordID)</PRE>
<P>渡されたレコードを削除します(<CODE>レコードID</CODE>)、カレントレコードの場合はレコードバッファからフラッシュします。 を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>ロックされているか、メモリに読み込まれているレコードは削除できません(DSDE_RECORD_IN_USEが返されます)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_10.htm#IX_DataStoreDeleteRecordNum()">DataStoreDeleteRecordNum()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_10.htm_IX_DataStoreDeleteRecordNum()"></A>
        <H1 CLASS="refHeading">DataStoreDeleteRecordNum()</H1>
<PRE CLASS="syntax">DataStoreDataError・DataStoreDeleteRecordNum(ワード・dsToken、/*セッション・トークンからオープンされたデータストアへ*/recordNum・recordNum)</PRE>
<P>渡されたレコードを削除します(<CODE>RecordNum</CODE>)、カレントレコードの場合はレコードバッファからフラッシュします。 を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>ロックされているか、メモリに読み込まれているレコードは削除できません(DSDE_RECORD_IN_USEが返されます)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_10.htm#IX_DataStoreDeleteRecord()">DataStoreDeleteRecord()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_11.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_11.htm_IX_DataStoreDiscardRecord()"></A>
        <H1 CLASS="refHeading">DataStoreDiscardRecord()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreDiscardRecord(ワードdsToken);/*開かれたデータストアへのセッショントークン*/</PRE>
<P>レコードバッファから現在のレコードを(変更を保存せずに)フラッシュします。 を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_14.htm#IX_DataStoreSaveRecord()">DataStoreSaveRecord()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_11.htm_IX_DataStoreFieldEnum()"></A>
        <H1 CLASS="refHeading">DataStoreFieldEnum()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreFieldEnum(単語dsToken, RecordHeader*recordPtr, void*enumDataPtr, Boolean_pascal(*CallbackRoutine)(void*fieldDataPtr, 単語fieldDataSize, FieldType FieldType,FieldCategory fieldCat, FieldID FieldID,FieldFlags flags, void*enumDataPtr));</PRE>
<P>渡されたレコードのフィールドを列挙します。 コールバックがTRUEを返すと、列挙を停止し、DSE_NO_ERRORを返します。 次の引数を取ります。recordPtr</P>
<DL>
<DT>
          <EM>dsToken</EM>
        </DT><DD>開かれたデータストアへのセッショントークン。</DD>
<DT><EM>recordPtr</DT><DD></EM>へのポインタ<CODE>RecordHeader</CODE>構造。</DD>
<PRE>typedef struct{RecordID RH_id;word RH_size;byte RH_fieldCount;}フィールド;RecordHeader</PRE>
<DT><EM>enumDataPtr</DT><DD></EM>呼び出し側がコールバックに渡すデータへのポインタ。</DD>
<DT><EM>CallbackRoutine</DT><DD></EM>列挙を終了するタイミングを決定するBooleanサブルーチン。</DD>
</DL>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>レコードを最初にロックする<CODE><A HREF="../../CRef/Routines/R_13.htm#IX_DataStoreLockRecord()">DataStoreLockRecord()</A></CODE>このルーチンを呼び出す前に</P>
<P CLASS="refField"><STRONG>警告:</STRONG>コールバックは渡されたデータを修正できる<EM>enumDataPtr</EM>実際のフィールドデータを変更することはできません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_14.htm#IX_DataStoreRecordEnum()">DataStoreRecordEnum()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_11.htm_IX_DataStoreFieldIDToName()"></A>
        <H1 CLASS="refHeading">DataStoreFieldIDToName()</H1>
<PRE CLASS="syntax">DataStoreStructureError DataStoreFieldIDToName(word dsToken, /*セッショントークンを開いたデータストアに*/FieldID FieldID,TCHAR*fieldNamePtr, word*nameSizePtr);</PRE>
<P>渡されたオブジェクトに対応するフィールド名を書き込みます。<CODE>フィールドID</CODE>(の<EM>フィールドID</EM>)から<EM>fieldNamePtr</EM>以下の部数<EM>nameSizePtr</EM>バイトをコピーし、実際にコピーされたバイト数でこの同じパラメータを上書きします。 を返します。<CODE>DataStoreStructureError</CODE>値(成功した場合はDSSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_11.htm#IX_DataStoreFieldNameToID()">DataStoreFieldNameToID()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_11.htm_IX_DataStoreFieldNameToID()"></A>
        <H1 CLASS="refHeading">DataStoreFieldNameToID()</H1>
<PRE CLASS="syntax">DataStoreStructureError DataStoreFieldNameToID(ワードdsToken、/*オープンされたデータストアへのセッショントークン*/TCHAR*fieldNamePtr、FieldID*fieldIDPtr);</PRE>
<P>書き込み<CODE>フィールドID</CODE>渡されたフィールド名に対応する<EM>(fieldNamePtr</EM>)から<EM>fieldIDPtr</EM>を返します。<CODE>DataStoreStructureError</CODE>値(成功した場合はDSSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_11.htm#IX_DataStoreFieldIDToName()">DataStoreFieldIDToName()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_11.htm_IX_DataStoreGetExtraData()"></A>
        <H1 CLASS="refHeading">DataStoreGetExtraData()</H1>
<PRE CLASS="syntax">DataStoreError・DataStoreGetExtraData(ワード・dsToken、/*オープンされたデータストアへのセッション・トークン*/void*dataPtr、/*ファイル・ヘッダーから読み取られたデータ*/word*dataSizePtr);</PRE>
<P>このデータストアのすべての追加データを<EM>データPtr</EM>にコピーしたバイト数を書き込みます。<EM>dataSizePtr</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_11.htm_IX_DataStoreGetField()"></A>
        <H1 CLASS="refHeading">DataStoreGetField()</H1>
<PRE CLASS="syntax">DataStoreDataError・DataStoreGetField(ワード・dsToken、/*オープンされたデータストアへのセッション・トークン*/TCHAR*fieldNamePtr、FieldID FieldID、void**blockPtrPtr、ワード*blockSizePtr、MemHandle*blockHanPtr);</PRE>
<P>渡されたフィールドの内容をブロックに書き込みます。 次の場合<EM>blockPtrPtr</EM>がNULLの場合、ブロックを割り当て、そのハンドルを<EM>blockHanPtr</EM>そのサイズを<EM>blockSizePtr</EM>の場合<EM>blockPtrPtr</EM>がNULLでなく、フィールド・データがブロック・サイズを超えている場合<EM>blockSizePtr</EM>バイトをブロックに格納し、DSDE_EXCEEDS_BUFFER_SIZEを返します。 を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P>フィールドを名前で参照する場合は<EM>フィールドID</EM>;フィールドを参照する場合<CODE>フィールドID</CODE>にNULLを渡します。<EM>fieldNamePtr</EM>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>渡されたフィールドが存在しない場合は<EM>blockSizePtr</EM>DSDE_NO_ERRORを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_12.htm#IX_DataStoreGetFieldChunk()">DataStoreGetFieldChunk()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_12.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_12.htm_IX_DataStoreGetFieldChunk()"></A>
        <H1 CLASS="refHeading">DataStoreGetFieldChunk()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreGetFieldChunk(ワードdsToken、/*オープンされたデータストアへのセッショントークン*/TCHAR*fieldNamePtr、FieldID FieldID、MemHandle blockHan、ChunkHandle*chunkHanPtr、ワード*dataSizePtr);</PRE>
<P>渡されたフィールドの内容を、渡されたブロック内のチャンクに書き込みます。 次の場合<EM>chunkHanPtr</EM>がNULLの場合、チャンクを割り当て、そのハンドルを<EM>chunkHanPtr</EM>の場合<EM>chunkHanPtr</EM>がNULLでない場合、dataSizePtrandフィールドdataはchunk sizeを超え、chunkのサイズを変更し、コピーされたバイト数を書き込む。<EM>dataSizePtr</EM>を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P>フィールドを名前で参照する場合は<EM>フィールドID</EM>;フィールドを参照する場合<CODE>フィールドID</CODE>にNULLを渡します。<EM>fieldNamePtr</EM>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>渡されたフィールドが存在しない場合は<EM>dataSizePtr</EM>DSDE_NO_ERRORを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_11.htm#IX_DataStoreGetField()">DataStoreGetField()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_12.htm_IX_DataStoreGetFieldCount()"></A>
        <H1 CLASS="refHeading">DataStoreGetFieldCount()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreGetFieldCount(word dsToken, /*セッショントークンからオープンされたデータストアへ*/word*fieldCountPtr);</PRE>
<P>このデータストアに対して定義されているフィールドの数を<EM>fieldCountPtr</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_13.htm#IX_DataStoreGetRecordCount()">DataStoreGetRecordCount()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_12.htm_IX_DataStoreGetFieldInfo()"></A>
        <H1 CLASS="refHeading">DataStoreGetFieldInfo()</H1>
<PRE CLASS="syntax">DataStoreStructureError DataStoreGetFieldInfo(word dsToken, /*セッショントークンからオープンされたデータストアへ*/FieldDescriptor*fieldDescPtr, FieldID FieldID,word fieldNameSize);</PRE>
<P>書き込み<CODE>FieldDescriptor</CODE>に渡されたフィールド<EM>fieldDescPtr</EM>の場合<CODE>FD名</CODE>、書き込み<CODE>fieldNameSize</CODE>バイトのみ。「0」を渡し(<CODE>FD名</CODE>をNULLに設定します)。 を返します。<CODE>DataStoreStructureError</CODE>値(成功した場合はDSSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_12.htm_IX_DataStoreGetFieldPtr()"></A>
        <H1 CLASS="refHeading">DataStoreGetFieldPtr()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreGetFieldPtr(word dsToken, /*セッショントークンからオープンされたデータストアへ*/RecordHeader*recordPtr, FieldID FieldID,void**fieldContentPtrPtr, FieldType*fieldTypePtr, word*fieldSizePtr);</PRE>
<P>で指定されたフィールドへのポインタを取得します。<EM>フィールドID</EM>フィールドの内容を<EM>fieldContentPtrPtr</EM>、その<CODE>フィールドタイプ</CODE>と<EM>fieldTypePtr</EM>、そのサイズを<EM>fieldSizePtr</EM>を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_12.htm_IX_DataStoreGetFieldSize()"></A>
        <H1 CLASS="refHeading">DataStoreGetFieldSize()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreGetFieldSize(word dsToken, /*セッショントークンからオープンされたデータストアへ*/TCHAR*fieldNamePtr, FieldID FieldID,word*fieldSizePtr);</PRE>
<P>渡されたフィールドのバイト数を<EM>fieldSizePtr</EM>を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P>フィールドを名前で参照する場合は<EM>フィールドID</EM>;フィールドを参照する場合<CODE>フィールドID</CODE>にNULLを渡します。<EM>fieldNamePtr</EM>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>フィールドが存在しない場合は<EM>fieldSizePtr</EM>DSDE_NO_ERRORを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_12.htm_IX_DataStoreGetFlags()"></A>
        <H1 CLASS="refHeading">DataStoreGetFlags()</H1>
<PRE CLASS="syntax">DataStoreError・DataStoreGetFlags(ワード・dsToken、/*セッション・トークンからオープンされたデータストアへ*/DataStoreFlags*FlagPtr)</PRE>
<P>書き込み<CODE>DataStoreFlags</CODE>このデータストアに設定する<EM>flagPtr</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_12.htm_IX_DataStoreGetNextRecordID()"></A>
        <H1 CLASS="refHeading">DataStoreGetNextRecordID()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreGetNextRecordID(ワードdsToken, /*セッショントークンからオープンされたデータストアへ*/RecordID*nextIDPtr);</PRE>
<P>次の<CODE>レコードID</CODE>割り当て先<EM>nextIDPtr</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_12.htm_IX_DataStoreGetNumFields()"></A>
        <H1 CLASS="refHeading">DataStoreGetNumFields()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreGetNumFields(word dsToken, /*セッショントークンからオープンされたデータストアへ*/word*fieldCountPtr);</PRE>
<P>現在のレコードのフィールド数をに書き込みます<EM>fieldCountPtr</EM>を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_12.htm_IX_DataStoreGetOwner()"></A>
        <H1 CLASS="refHeading">DataStoreGetOwner()</H1>
<PRE CLASS="syntax">DataStoreError・DataStoreGetOwner(ワード・dsToken、/*セッション・トークンからオープンされたデータストアへ*/GeodeToken*tokenPtr)</PRE>
<P>データストアを作成したアプリケーションのGeodeTokenを<EM>tokenPtr</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_13.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_13.htm_IX_DataStoreGetRecordCount()"></A>
        <H1 CLASS="refHeading">DataStoreGetRecordCount()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreGetRecordCount(word dsToken, /*セッショントークンから開いたデータストアへ*/dword*RecordCountPtr);</PRE>
<P>データストア内のレコード数をに書き込みます。<EM>recordCountPtr</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>まだ保存されていない新しいレコードはカウントされません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_12.htm#IX_DataStoreGetFieldCount()">DataStoreGetFieldCount()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_13.htm_IX_DataStoreGetRecordID()"></A>
        <H1 CLASS="refHeading">DataStoreGetRecordID()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreGetRecordID(ワードdsToken, /*セッショントークンからオープンされたデータストアへ*/RecordID*recordIDPtr);</PRE>
<P>書き込み<CODE>レコードID</CODE>現在のレコードの<EM>recordIDPtr</EM>を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>レコードがロードされていない場合は、DSDE_RECORD_BUFFER_EMPTYを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_13.htm_IX_DataStoreGetTimeStamp()"></A>
        <H1 CLASS="refHeading">DataStoreGetTimeStamp()</H1>
<PRE CLASS="syntax">DataStoreError・DataStoreGetTimeStamp(ワード・dsToken、/*セッション・トークンからオープンされたデータストアへ*/FileDateAndTime*timestampPtr)</PRE>
<P>データストアが最後に変更された日時を書き込みます。<EM>timestampPtr</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_13.htm_IX_DataStoreGetVersion()"></A>
        <H1 CLASS="refHeading">DataStoreGetVersion()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreGetVersion(word dsToken, /*セッショントークンからオープンされたデータストアへ*/ProtocolNumber*versionPtr);</PRE>
<P>データストアのプロトコル番号をに書き込みます。<EM>versionPtr</EM>ボタンをクリックし (プロトコル番号は、データストアの異なるバージョンを追跡するのに便利です)。 を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_13.htm_IX_DataStoreLoadRecord()"></A>
        <H1 CLASS="refHeading">DataStoreLoadRecord()</H1>
<PRE CLASS="syntax">DataStoreDataError・DataStoreLoadRecord(ワード・dsToken、/*オープンされたデータストアへのセッション・トークン*/recordID recordID、RecordNum*recordNumPtr);</PRE>
<P>によって参照されるレコードをロードします。<EM>レコードID</EM>現在のレコードにします。 書き込み<CODE>RecordNum</CODE>ロードされたレコードの<EM>recordNumPtr</EM>を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>セッションのレコードバッファに既にレコードがロードされている場合は、DSDE_RECORD_BUFFER_NOT_EMPTYを返します。</P>
<P>該当するレコードがない場合は、DSDE_INVALID_RECORD_NUMBERを返します。</P>
<P>別のセッションがすでにレコードをロックしている場合は、DSDE_RECORD_IN_USEを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_13.htm#IX_DataStoreLoadRecordNum()">DataStoreLoadRecordNum()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_13.htm_IX_DataStoreLoadRecordNum()"></A>
        <H1 CLASS="refHeading">DataStoreLoadRecordNum()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreLoadRecordNum(ワードdsToken、/*オープンされたデータストアへのセッショントークン*/recordNum recordNum、RecordID*recordIDPtr);</PRE>
<P>によって参照されるレコードをロードします。<EM>recordNum</EM>現在のレコードにします。 書き込み<CODE>レコードID</CODE>ロードされたレコードの<EM>recordIDPtr</EM>を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>セッションのレコードバッファに既にレコードがロードされている場合は、DSDE_RECORD_BUFFER_NOT_EMPTYを返します。</P>
<P>該当するレコードがない場合は、DSDE_INVALID_RECORD_NUMBERを返します。</P>
<P>別のセッションがすでにレコードをロックしている場合は、DSDE_RECORD_IN_USEを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_13.htm#IX_DataStoreLoadRecord()">DataStoreLoadRecord()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_13.htm_IX_DataStoreLockRecord()"></A>
        <H1 CLASS="refHeading">DataStoreLockRecord()</H1>
<PRE CLASS="syntax">DataStoreDataError・DataStoreLockRecord(ワード・dsToken、/*セッション・トークンからオープンされたデータストアへ*/RecordHeader**recordPtrPtr);</PRE>
<P>現在のレコードをロックします。 主に電話をかけるときに使用<CODE><A HREF="../../CRef/Routines/R_11.htm#IX_DataStoreFieldEnum()">DataStoreFieldEnum()</A></CODE>を呼び出すときにも使用されます。<CODE><A HREF="../../CRef/Routines/R_12.htm#IX_DataStoreGetFieldPtr()">DataStoreGetFieldPtr()</A></CODE>を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ロックされたレコードのロックを解除する<CODE><A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreUnlockRecord()">DataStoreUnlockRecord()</A></CODE>記録が終わったときです</P>
<P CLASS="refField"><STRONG>警告:</STRONG>バッファにロードされたレコードがない場合は、DSDE_RECORD_BUFFER_EMPTYを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreUnlockRecord()">DataStoreUnlockRecord()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_13.htm_IX_DataStoreMapRecordNumToID()"></A>
        <H1 CLASS="refHeading">DataStoreMapRecordNumToID()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreMapRecordNumToID(ワードdsToken、/*オープンされたデータストアへのセッショントークン*/recordNum recordNum、RecordID*recordIDPtr);</PRE>
<P>書き込み<CODE>レコードID</CODE>渡された<CODE>RecordNum</CODE>と<EM>recordIDPtr</EM>を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_14.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_14.htm_IX_DataStoreNewRecord()"></A>
        <H1 CLASS="refHeading">DataStoreNewRecord()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreNewRecord(ワードdsToken);/*開かれたデータストアへのセッショントークン*/</PRE>
<P>新しい(空の)レコードを作成し、それを現在のレコードにします。 を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>新しいレコードは、保存された後にのみ、datatstoreの永続的な一部になります(<CODE><A HREF="../../CRef/Routines/R_14.htm#IX_DataStoreSaveRecord()">DataStoreSaveRecord()</A></CODE>)をクリックします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_14.htm_IX_DataStoreOpen()"></A>
        <H1 CLASS="refHeading">DataStoreOpen()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreOpen(TCHAR*dsNamePtr、optr notifyObject、DataStoreOpenFlags openFlag、word*dsTokenPtr);</PRE>
<P>によって参照されるデータストアを開きます。<EM>dsNamePtr</EM>セッション・トークンを<EM>dsTokenPtr</EM>DSOF_EXCLUSIVEを<EM>openFlag</EM>呼び出し元にアクセスを制限してデータストアを開きます。別のアプリケーションがすでにデータストアを開いている場合は、DSE_ACCESS_DENIEDを返します。 NullOptrの通過<EM>notifyObject</EM>は、どのオブジェクトもGWNT_DATASTORE_CHANGE通知を受信しないことを意味します。 を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_14.htm_IX_DataStoreRecordEnum()"></A>
        <H1 CLASS="refHeading">DataStoreRecordEnum()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreRecordEnum(ワードdsToken、RecordNum*startRecordPtr、DataStoreRecordEnumFlagsフラッグ、ボイド*enumDataPtr、ブール_パスカル(*CallbackRoutine)(RecordHeaderレコード、ボイド*enumDataPtr));</PRE>
<P>データストアのレコードをストレージ順に列挙します。 次の場合<EM>CallbackRoutine</EM>TRUEを返し、列挙を停止し、更新します。<EM>startRecordPtr</EM>と<CODE>RecordNum</CODE>を返し、DSE_NO_ERRORを返す。(列挙を続けるには<EM>startRecordPtr</EM>」を参照してください。 最初または最後のレコードに到達した場合、DSE_NO_MORE_RECORDSを返します。</P>
<P>次の引数を取ります。</P>
<DL>
<DT>dsToken</DT><DD>開かれたデータストアへのセッショントークン。</DD>
<DT><EM>startRecordPtr</DT><DD></EM>へのポインタ<CODE>RecordNum</CODE>(DSREF_START_AT_ENDが渡されていない場合)<EM>フラグふらぐ</EM>]この場合、この引数は無視されます)。</DD>
<DT>
          <EM>フラグふらぐ</EM>
        </DT><DD><CODE>DataStoreRecordEnumFlags</CODE>通過します。 DSREF_BACKWARDSを渡すと、列挙が逆方向になります。 DSREF_BACKWARDSを指定してDSREF_START_AT_ENDを渡すと、列挙は最後のレコードから逆方向に行われます。 (DSREF_BACKWARDSを指定せずにDSREF_START_AT_ENDを渡すと、列挙は最初のレコードから開始され<EM>startRecordPtr</EM>」を参照してください。</DD>
<DT><EM>enumDataPtr</DT><DD></EM>呼び出し側がコールバック・ルーチンに渡すデータへのポインタ。</DD>
<DT><EM>CallbackRoutine</DT><DD></EM>ブールサブルーチン。 発信者が<CODE>RecordHeader</CODE>現在のレコードの<EM>enumDataPtr</EM>TRUEを返すと列挙は終了します。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>コールバックは渡されたデータを修正できる<EM>enumDataPtr</EM>レコード内の実際のデータを変更することはできません。</P>
<P>列挙中にデータストアを変更することはできません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_11.htm#IX_DataStoreFieldEnum()">DataStoreFieldEnum()</A></CODE><CODE><A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreStringSearch()">DataStoreStringSearch()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_14.htm_IX_DataStoreRemoveFieldFromRecord()"></A>
        <H1 CLASS="refHeading">DataStoreRemoveFieldFromRecord()</H1>
<PRE CLASS="syntax">DataStoreDataError DataStoreRemoveFieldFromRecord(ワードdsToken, /*セッショントークンからオープンされたデータストア*/TCHAR*fieldNamePtr, FieldID FieldID);</PRE>
<P>渡されたフィールドを現在のレコードから削除します。 を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P>フィールドを名前で参照する場合は<EM>フィールドID</EM>;フィールドを参照する場合<CODE>フィールドID</CODE>にNULLを渡します。<EM>fieldNamePtr</EM>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_10.htm#IX_DataStoreDeleteField()">DataStoreDeleteField()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_14.htm_IX_DataStoreRename()"></A>
        <H1 CLASS="refHeading">DataStoreRename()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreRename(TCHAR*oldNamePtr、TCHAR*newNamePtr);</PRE>
<P>データストアの名前を<EM>oldNamePtr</EM>と<EM>newNamePtr</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_14.htm_IX_DataStoreRenameField()"></A>
        <H1 CLASS="refHeading">DataStoreRenameField()</H1>
<PRE CLASS="syntax">DataStoreStructureError DataStoreRenameField(ワードdsToken、/*オープンされたデータストアへのセッショントークン*/TCHAR*newNamePtr、TCHAR*oldNamePtr、FieldID FieldID);</PRE>
<P>フィールドの名前を<EM>oldNamePtr</EM>と<EM>newNamePtr</EM>を返します。<CODE>DataStoreStructureError</CODE>値(成功した場合はDSSE_NO_ERROR)。</P>
<P>フィールドを名前で参照する場合は<EM>フィールドID</EM>;フィールドを参照する場合<CODE>フィールドID</CODE>にNULLを渡します。<EM>oldNamePtr</EM>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>新しい名前がMAX_FIELD_NAME_LENGTHを超える場合、DSSE_FIELD_NAME_TOO_LONG(<EM>例:</EM>,40*sizeof(TCHAR))。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_14.htm_IX_DataStoreSaveRecord()"></A>
        <H1 CLASS="refHeading">DataStoreSaveRecord()</H1>
<PRE CLASS="syntax">DataStoreDataError・DataStoreSaveRecord(単語dsToken、void*dataPtr、sword_pascal(*CallbackRoutine)(RecordHeader*Rec1Ptr、RecordHeader*Rec2Ptr、単語dsToken、void*dataPtr)、RecordNum*recordNumPtr、RecordID*recordIDPtr);</PRE>
<P>現在のレコードをデータストアに書き込み(レコードに加えられたすべての変更を保存)、バッファからレコードをフラッシュします。 CallbackRoutineが「0」の場合、保存されたレコードをキーに挿入するか(キーが存在する場合)、キーが存在しない場合はデータストアの最後にレコードを追加します。 書き込み<CODE>RecordNum</CODE>および<CODE>レコードID</CODE>保存されたレコードの<EM>recordNumPtr</EM>および<EM>recordIDPtr</EM>にあります。 を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。 次の引数を取ります。</P>
<DL>
<DT><EM>dsToken</DT><DD></EM>開かれたデータストアへのセッショントークン。</DD>
<DT>
          <EM>データPtr</EM>
        </DT><DD>呼び出し側がコールバックに渡すデータへのポインタ。</DD>
<DT><EM>CallbackRoutine</DT><DD></EM>保存されたレコードを挿入する場所を決定するサブルーチン。 発信者パス<CODE>RecordHeader</CODE>比較する2つのレコードの。 呼び出し側は<EM>データPtr</EM>関数は次の値を返します。<BR><BR>-1の場合<EM>レコード1(Rec1Ptr)</EM>前に来る<EM>Rec2Ptr(Rec 2</EM><BR>0の場合<EM>レコード1(Rec1Ptr)</EM>等しい<EM>Rec2Ptr(Rec 2</EM><BR>1の場合<EM>レコード1(Rec1Ptr)</EM>後に来る<EM>Rec2Ptr(Rec 2</EM></DD>
<DT><EM>recordNumPtr</DT><DD></EM>へのポインタ<CODE>RecordNum</CODE>ファイル形式で保存されます。</DD>
<DT><EM>recordIDPtr</DT><DD></EM>へのポインタ<CODE>レコードID</CODE>ファイル形式で保存されます。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_11.htm#IX_DataStoreDiscardRecord()">DataStoreDiscardRecord()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_14.htm_IX_DataStoreSetExtraData()"></A>
        <H1 CLASS="refHeading">DataStoreSetExtraData()</H1>
<PRE CLASS="syntax">DataStoreError・DataStoreSetExtraData(ワード・dsToken、/*データストアを開くためのセッション・トークン*/void*extraDataPtr、/*ファイル・ヘッダーに書き込むデータ*/ワード・extraDataSize);</PRE>
<P>書き込み<EM>extraDataSize</EM>バイトの追加データをデータストアファイルヘッダーに追加し、既存の追加データを置き換えます。 に&quot;0&quot;を渡しています<EM>extraDataSize</EM>既存の余分なデータが削除されます。 を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_15.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_15.htm_IX_DataStoreSetField()"></A>
        <H1 CLASS="refHeading">DataStoreSetField()</H1>
<PRE CLASS="syntax">DataStoreDataError・DataStoreSetField(ワード・dsToken、/*オープンされたデータストアへのセッション・トークン*/TCHAR*fieldNamePtr、FieldID FieldID、void*dataPtr、ワードdataSize);</PRE>
<P>書き込み<EM>データサイズ</EM>バイトのデータ(<EM>データPtr</EM>)を渡されたフィールドにコピーします。 に&quot;0&quot;を渡しています<EM>データサイズ</EM>レコードからフィールドが削除されます。 を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P>フィールドを名前で参照する場合は<EM>フィールドID</EM>;フィールドを参照する場合<CODE>フィールドID</CODE>にNULLを渡します。<EM>fieldNamePtr</EM>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データトルhblockHan</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_15.htm_IX_DataStoreSetNextRecordID()"></A>
        <H1 CLASS="refHeading">DataStoreSetNextRecordID()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreSetNextRecordID(ワードdsToken, /*セッショントークンからオープンされたデータストアへ*/RecordID nextID);</PRE>
<P>次の<CODE>レコードID</CODE>割り当て先<EM>次のID</EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreSetRecordID()">DataStoreSetRecordID()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_15.htm_IX_DataStoreSetRecordID()"></A>
        <H1 CLASS="refHeading">DataStoreSetRecordID()</H1>
<PRE CLASS="syntax">DataStoreDataError・DataStoreSetRecordID(ワード・dsToken、/*オープンされたデータストアへのセッション・トークン*/recordID recordID)</PRE>
<P>を設定します。<CODE>レコードID</CODE>現在のレコードの<EM>レコードID</EM>;データストアは排他アクセス用に開かれている必要があります。 合格した場合<CODE>レコードID</CODE>次の値より大きい<CODE>レコードID</CODE>を割り当て、後者を渡された<CODE>レコードID</CODE>+1を返します。<CODE>DataStoreDataError</CODE>値(成功した場合はDSDE_NO_ERROR)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>既存のレコードを同じで上書きします<CODE>レコードID</CODE>と入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreSetNextRecordID()">DataStoreSetNextRecordID()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_15.htm_IX_DataStoreSetTimeStamp()"></A>
        <H1 CLASS="refHeading">DataStoreSetTimeStamp()</H1>
<PRE CLASS="syntax">DataStoreError DataStoreSetTimeStamp(ワードdsToken, /*セッショントークンからオープンされたデータストアへ*/FileDateAndTimeタイムスタンプ);</PRE>
<P>データストアが最後に変更された日時を設定します<EM>タイムスタンプ</EM>ボタンをクリックし<EM></EM>を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_15.htm_IX_DataStoreSetVersion()"></A>
        <H1 CLASS="refHeading">DataStoreSetVersion()</H1>
<PRE CLASS="syntax">DataStoreError・DataStoreSetVersion(ワード・dsToken、/*オープンされたデータストアへのセッション・トークン*/ProtocolNumberバージョン)</PRE>
<P>データストアのプロトコル番号を設定します。これは、データストアの異なるバージョンを追跡する場合に便利です。 を返します。<CODE>DataStoreError</CODE>値(成功した場合はDSE_NO_ERROR)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_15.htm_IX_DataStoreStringSearch()"></A>
        <H1 CLASS="refHeading">DataStoreStringSearch()</H1>
<PRE CLASS="syntax">DataStoreError・DataStoreStringSearch(ワード・dsToken、/*セッション・トークンからオープンされたデータストアへ*/SearchParams*paramsPtr)</PRE>
<P>データストアで文字列検索を実行します。 一致が検出された場合、SPを更新<EM>_startRecord[レコード開始]</EM>と<CODE>RecordNum</CODE>DSE_NO_ERRORを返します。 一致するレコードが見つからずに最初または最後のレコードに到達した場合は、DSE_NO_MORE_RECORDSが戻されます。 次の引数を取ります。</P>
<DL>
<DT>
          <EM>dsToken</EM>
        </DT><DD>開かれたデータストアへのセッショントークン。</DD>
<DT>
          <EM>paramsPtr</EM>
        </DT><DD>へのポインタ<CODE>SearchParams</CODE>構造。</DD>
<PRE>typedef struct{searchType SP_searchType;RecordNum SP_startRecord;dword SP_maxRecords;FieldID SP_startField;FieldCategory SP_category;TCHAR*SP_searchString;SearchFlags SP_flags;}SearchParams;</PRE>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>レコード数が4,000を超えるデータストアでこのルーチンを呼び出すと、DSSE_INDEX_RECORD_NUMBER_LIMIT_EXCEEDEDが返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_14.htm#IX_DataStoreRecordEnum()">DataStoreRecordEnum()</A></CODE><CODE><A HREF="../../CRef/Routines/R_11.htm#IX_DataStoreFieldEnum()">DataStoreFieldEnum()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_15.htm_IX_DataStoreUnlockRecord()"></A>
        <H1 CLASS="refHeading">DataStoreUnlockRecord()</H1>
<PRE CLASS="syntax">void DataStoreUnlockRecord(word dsToken);/*開かれたデータストアへのセッショントークン*/</PRE>
<P>現在のレコードをロック解除します。 次の方法でレコードをロックした場合<CODE>DataStoreLock()</CODE>このルーチンを使用してロックを解除する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">datastor.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_13.htm#IX_DataStoreLockRecord()">DataStoreLockRecord()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_16.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_16.htm_IX_DBAlloc()"></A>
        <H1 CLASS="refHeading">DBAlloc()</H1>
<PRE CLASS="syntax">DBItem DBAlloc(VMFileHandleファイル、DBGroupグループ、ワードサイズ);</PRE>
<P>このルーチンは、指定されたファイルとグループに項目を割り当てます。 新しいアイテムを含むファイルとグループのハンドルが渡されます。 新しい項目のitem-handleを返します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>グループ内の項目へのすべてのポインタを無効にできます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_16.htm#IX_DBAllocUngrouped()">DBAllocUngrouped()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_16.htm_IX_DBAllocUngrouped()"></A>
        <H1 CLASS="refHeading">DBAllocUngrouped()</H1>
<PRE CLASS="syntax">DBGroupAndItem DBAllocUngrouped(VMFileHandleファイル、ワードサイズ)</PRE>
<P>このルーチンは、グループ化されていない項目を指定されたファイルに割り当てます。 新しい項目を含むファイルのハンドルが渡されます。 アイテムの<CODE>DBGroupAndItem</CODE>値を入力します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>グループ化されていない項目へのポインタは、すべて無効にできます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_16.htm#IX_DBAlloc()">DBAlloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_16.htm_IX_DBCombineGroupAndItem() macro"></A>
        <H1 CLASS="refHeading">DBCombineGroupAndItem()</H1>
<PRE CLASS="syntax">DBGroupAndItem DBCombineGroupAndItem(DBGroupグループ、DBItem産)</PRE>
<P>このマクロは、グループハンドルと項目ハンドルを結合して、dワードサイズの<CODE>DBGroupAndItem</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBGroupFromGroupAndItem() macro">DBGroupFromGroupAndItem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBItemFromGroupAndItem() macro">DBItemFromGroupAndItem()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_16.htm_IX_DBCopyDBItem()"></A>
        <H1 CLASS="refHeading">DBCopyDBItem()</H1>
<PRE CLASS="syntax">DBItem DBCopyDBItem(VMFileHandle srcFile、DBGroup srcGroup、DBItem srcItem、VMFileHandle destFile、DBGroup destGroup);</PRE>
<P>このルーチンは、指定されたDBファイルとグループにDB項目の複製を作成します。 ソース・アイテムのファイル・ハンドル、グループ・ハンドル、アイテム・ハンドル、および宛先グループのファイル・ハンドルとグループ・ハンドルが渡されます。 DB項目のコピーを作成し<CODE>DBItem</CODE>ハンドル。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>宛先グループ内の項目へのすべてのポインタを無効にできます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a2.htm#IX_VMCopyVMChain()">VMCopyVMChain()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_16.htm_IX_DBCopyDBItemUngrouped()"></A>
        <H1 CLASS="refHeading">DBCopyDBItemUngrouped()</H1>
<PRE CLASS="syntax">DBGroupAndItem DBCopyDBItemUngrouped(VMFileHandle srcFile, DBGroupAndItem srcID, /*ソースアイテム*/VMFileHandle destFile);</PRE>
<P>このルーチンは、指定されたDB項目の複製を作成します。 ファイルハンドルが渡され<CODE>DBGroupAndItem</CODE>ソース・アイテムを指定する値、および宛先ファイルのファイル・ハンドル。 この関数は、指定されたファイル内で項目をグループ化されていない項目として割り当て<CODE>DBGroupAndItem</CODE>値を入力します。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>元のアイテムがグループ解除されていない場合は、グループハンドルとアイテムハンドルを組み合わせて<CODE>DBGroupAndItem</CODE>マクロの呼び出しによる値<CODE><A HREF="../../CRef/Routines/R_16.htm#IX_DBCombineGroupAndItem() macro">DBCombineGroupAndItem()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>宛先ファイル内のグループ化されていない項目へのすべてのポインタが無効になる場合があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a2.htm#IX_VMCopyVMChain()">VMCopyVMChain()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_16.htm_IX_DBDeleteAt()"></A>
        <H1 CLASS="refHeading">DBDeleteAt()</H1>
<PRE CLASS="syntax">void DBDeleteAt(VMFileHandleファイル、DBGroupグループ、DBItemアイテム、deleteOffsetという言葉、deleteCountという言葉);</PRE>
<P>このルーチンは、項目内から一連のバイトを削除します。 他の項目へのポインタは無効にしません。 このルーチンには、項目を指定するファイル、グループ、および項目ハンドル、項目内のオフセット、および削除するバイト数が渡されます。 指定したオフセットのバイトから開始して、指定したバイト数を項目内から削除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_16.htm_IX_DBDeleteAtUngrouped()"></A>
        <H1 CLASS="refHeading">DBDeleteAtUngrouped()</H1>
<PRE CLASS="syntax">void DBDeleteAtUngrouped(VMFileHandleファイル、DBGroupAndItem id、単語deleteOffset、単語deleteCount);</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_16.htm#IX_DBDeleteAt()">DBDeleteAt()</A></CODE>が渡されますが<CODE>DBGroupAndItem</CODE>値を使用します。 他の項目へのポインタは無効にしません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_17.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBDeref()"></A>
        <H1 CLASS="refHeading">DBDeref()</H1>
<PRE CLASS="syntax">void*DBDeref(optr*ref);</PRE>
<P>このルーチンは、ロックされたDB項目にoptrを渡します。 このルーチンは、項目のアドレスを返します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>DB項目がロック解除されると、optrは無効になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBDirty()"></A>
        <H1 CLASS="refHeading">DBDirty()</H1>
<PRE CLASS="syntax">void DBUnlock(const void*ptr);</PRE>
<P>このルーチンは、DB項目をダーティとしてマークします。これにより、VMマネージャーは、メモリーを解放する前に、その項目ブロックをディスクにコピーします。 このルーチンには、項目内の任意の場所へのポインタが渡されます。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>項目ブロック内のすべての項目は、一度にダーティとマークされます。したがって、同じ項目ブロック内の複数の項目に対して、このルーチンを1回だけ呼び出すことができます。 ポインタのセグメント部分のみが重要であるため、ポインタを項目内の任意の場所に渡すことができます。 これは、項目へのポインタをインクリメントした場合に便利です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBFree()"></A>
        <H1 CLASS="refHeading">DBFree()[DBフリー]</H1>
<PRE CLASS="syntax">void DBFree(VMFileHandleファイル、DBGroupグループ、DBItem項目);</PRE>
<P>このルーチンは、指定された項目を解放します。 グループ内の他の項目へのポインタは無効になりません。 アイテムを指定するファイル、グループ、およびアイテムハンドルが渡されます。何も返しません。</P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG><BR>呼び出しを行わない<CODE>DBFree()[DBフリー]</CODE>ロックされたアイテム これを行うと、item-blockのロックカウントはデクリメントされず、itemブロックが適切にロック解除されなくなります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBFreeUngrouped()">DBFreeUngrouped()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBFreeUngrouped()"></A>
        <H1 CLASS="refHeading">DBFreeUngrouped()</H1>
<PRE CLASS="syntax">void DBFreeUngrouped(VMFileHandleファイル、DBGroupAndItem ID)</PRE>
<P>このルーチンは、指定された項目を解放します。 グループ化されていない他の項目へのポインタは無効になりません。 ファイルハンドルが渡され<CODE>DBGroupAndItem</CODE>アイテムを指定する値。何も返しません。</P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG>呼び出しを行わない<CODE>DBFreeUngrouped()</CODE>ロックされたアイテム これを行うと、item-blockのロックカウントはデクリメントされず、itemブロックが適切にロック解除されなくなります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBFree()">DBFree()[DBフリー]</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBGetMap()"></A>
        <H1 CLASS="refHeading">DBGetMap()</H1>
<PRE CLASS="syntax">DBGroupAndItem DBGetmap(VMFileHandleファイル)</PRE>
<P>このルーチンは<CODE>DBGroupAndItem</CODE>渡されたファイルのmap項目の構造体。 マップ項目がない場合は、ヌルハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBSetMap()">DBSetMap()</A></CODE><CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLockMap()">DBLockMap()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBGroupAlloc()"></A>
        <H1 CLASS="refHeading">DBGroupAlloc()</H1>
<PRE CLASS="syntax">DBGroup DBGroupAlloc(VMFileHandleファイル)</PRE>
<P>このルーチンは、指定されたファイルに新しいDBグループを割り当て、そのハンドルを返します。 グループを割り当てることができない場合は<CODE>DBGroupAlloc()</CODE>はNULLハンドルを返す。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBGroupFree()"></A>
        <H1 CLASS="refHeading">DBGroupFree()</H1>
<PRE CLASS="syntax">void DBGroupFree(VMFileHandleファイル、DBGroupグループ)</PRE>
<P>このルーチンは、指定されたグループを解放します。 これにより、グループに関連付けられているすべての項目と項目ブロックが削除されます。 グループを指定するファイルとグループハンドルが渡されます。 一部の項目がロックされている場合でも、グループを解放できます。ロックされている項目も解放されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBGroupFromGroupAndItem() macro"></A>
        <H1 CLASS="refHeading">DBGroupFromGroupAndItem()</H1>
<PRE CLASS="syntax">DBGroup・DBGroupFromGroupAndItem(DBGroupAndItem id)</PRE>
<P>このマクロは<CODE>DBGroup</CODE>の一部<CODE>DBGroupAndItem</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBInsertAt()"></A>
        <H1 CLASS="refHeading">DBInsertAt()</H1>
<PRE CLASS="syntax">void DBInsertAt(VMFileHandleファイル、DBGroupグループ、DBItemアイテム、単語insertOffset、単語insertCount);</PRE>
<P>このルーチンは、DB項目内の指定されたオフセットにバイトを挿入します。 バイトはゼロ初期化されます。 DB項目を指定するファイル、グループ、および項目ハンドル、セル内のオフセット、および挿入するバイト数が渡されます。 指定されたオフセットから始まる指定されたバイト数を挿入します。渡されたオフセットにあったデータは、挿入されたバイトの直後で終了します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、同じグループ内の他の項目へのポインタを無効にします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBInsertAtUngrouped()"></A>
        <H1 CLASS="refHeading">DBInsertAtUngrouped()</H1>
<PRE CLASS="syntax">void DBInsertAtUngrouped(VMFileHandleファイル,DBGroupAndItem id, word insertOffset, word insertCount);</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBInsertAt()">DBInsertAt()</A></CODE>が渡されますが<CODE>DBGroupAndItem</CODE>値を使用します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、グループ化されていない他の項目へのポインタを無効にします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_17.htm_IX_DBItemFromGroupAndItem() macro"></A>
        <H1 CLASS="refHeading">DBItemFromGroupAndItem()</H1>
<PRE CLASS="syntax">DBItem・DBItemFromGroupAndItem(DBGroupAndItem id)</PRE>
<P>このマクロは<CODE>DBItem</CODE>の一部<CODE>DBGroupAndItem</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_18.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBLock()"></A>
        <H1 CLASS="refHeading">Dブロック()</H1>
<PRE CLASS="syntax">void*DBLock(VMFileHandleファイル、DBGroupグループ、DBItemアイテム);</PRE>
<P>このルーチンは、指定された項目をロックし、その項目へのポインタを返します。 DB項目を指定するファイル、グループ、および項目ハンドルが渡されます。 失敗した場合は、ヌルポインタを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLockGetRef()">DBLockGetRef()</A></CODE><CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLockUngrouped()">DBLockUngrouped()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBLockGetRef()"></A>
        <H1 CLASS="refHeading">DBLockGetRef()</H1>
<PRE CLASS="syntax">void*DBLockGetRef(VMFileHandleファイル、DBGroupグループ、DBItemアイテム、optr*ref);</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLock()">Dブロック()</A></CODE>ただし、渡されたアドレスにアイテムのoptrを書き込む点が異なります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>optrは、DB項目がロック解除されるまでのみ有効です。</P>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBLockGetRefUngrouped()"></A>
        <H1 CLASS="refHeading">DBLockGetRefUngrouped()</H1>
<PRE CLASS="syntax">void*DBLockGetRefUngrouped(VMFileHandleファイル、DBGroupAndItem id、optr*ref);</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLockGetRef()">DBLockGetRef()</A></CODE>が渡されますが<CODE>DBGroupAndItem</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBLockMap()"></A>
        <H1 CLASS="refHeading">DBLockMap()</H1>
<PRE CLASS="syntax">void*DBLockMap(VMFileHandleファイル)</PRE>
<P>このルーチンは、指定されたファイルのマップ項目をロックし、そのアドレスを返します。 マップ項目のロックを解除するには<CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBUnlock()">DBUnlock()</A></CODE>通常。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLockMap()">DBLockMap()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBLockUngrouped()"></A>
        <H1 CLASS="refHeading">DBLockUngrouped()</H1>
<PRE CLASS="syntax">void*DBLockUngrouped(VMFileHandleファイル、DBGroupAndItem ID)</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLock()">Dブロック()</A></CODE>が渡されますが<CODE>DBGroupAndItem</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBReAlloc()"></A>
        <H1 CLASS="refHeading">DBReAlloc()</H1>
<PRE CLASS="syntax">void DBReAlloc(VMFileHandleファイル、DBGroupグループ、DBItemアイテム、ワードサイズ)</PRE>
<P>このルーチンは、DB項目のサイズを変更します。 DB項目を指定するファイル、グループ、および項目ハンドルと、項目の新しいサイズ(バイト単位)が渡されます。 新しいサイズが古いサイズより大きい場合は、項目の末尾にスペースが追加されます。新しいサイズが古いサイズより小さい場合は、項目は収まるように切り捨てられます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>新しいサイズが古いサイズより大きい場合、グループ内の項目を指すすべてのポインタが無効になります。 追加された領域はゼロ初期化されていません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBReAllocUngrouped()"></A>
        <H1 CLASS="refHeading">DBReAllocUngrouped()</H1>
<PRE CLASS="syntax">void DBReAllocUngrouped(VMFileHandleファイル、DBGroupAndItem id、ワードサイズ)</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBReAlloc()">DBReAlloc()</A></CODE>が渡されますが<CODE>DBGroupAndItem</CODE>値を使用します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>新しいサイズが古いサイズよりも大きい場合、グループ化されていない項目へのポインタはすべて無効になります。 追加された領域はゼロ初期化されていません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBSetMap()"></A>
        <H1 CLASS="refHeading">DBSetMap()</H1>
<PRE CLASS="syntax">void DBSetMap(VMFileHandleファイル、DBGroupグループ、DBItemアイテム);</PRE>
<P>このルーチンは、DBマップ項目を設定します。 後で<CODE>DBGroupAndItem</CODE>を呼び出してこの項目を識別する構造体<CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBGetMap()">DBGetMap()</A></CODE>このルーチンには、新しいマップ項目を指定するファイル、グループ、および項目ハンドルが渡されます。何も返しません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBSetMapUngrouped()"></A>
        <H1 CLASS="refHeading">DBSetMapUngrouped()</H1>
<PRE CLASS="syntax">void DBSetMapUngrouped(VMFileHandleファイル、DBGroupAndItem ID)</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBSetMap()">DBSetMap()</A></CODE>が渡されますが<CODE>DBGroupAndItem</CODE>値を使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_18.htm_IX_DBUnlock()"></A>
        <H1 CLASS="refHeading">DBUnlock()</H1>
<PRE CLASS="syntax">void DBUnlock(void*ptr);/*ロック解除する項目のアドレス*/</PRE>
<P>このルーチンは、アドレスが渡されたDB項目のロックを解除します。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ポインタのセグメントアドレスだけが重要です。 したがって、ロックを解除するために、アイテム内のどこか(またはその直後)にポインタを渡すことができます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>アイテムが変更されている場合は、必ず<CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBDirty()">DBDirty()</A></CODE><EM>前に</EM>ロックを解除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">データベース.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_19.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_19.htm_IX_DiskCheckInUse()"></A>
        <H1 CLASS="refHeading">DiskCheckInUse()</H1>
<PRE CLASS="syntax">ブーリアンDiskCheckInUse(DiskHandleディスク);</PRE>
<P>このルーチンは、登録済みディスクが使用されているかどうかをチェックします。 そのディスク上のファイルがオープンされている場合、あるいはそのディスク上のパスがスレッドのディレクトリスタック上にある場合、ルーチンは以下を返す。<EM>真</EM>(つまり、0以外)。それ以外の場合は<EM>偽の</EM>(すなわちゼロ)。 ディスクは、現在どのドライブにもない場合でも、「使用中」である可能性があることに注意してください。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>標準のパス定数を渡すと、このルーチンはメインのパスを含むディスクに関する情報を返します。<STRONG CLASS="fileName">geos.iniファイル</STRONG>ファイル(使用中であることが保証されています)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_19.htm_IX_DiskCheckUnnamed()"></A>
        <H1 CLASS="refHeading">DiskCheckUnnamed()</H1>
<PRE CLASS="syntax">Boolean DiskCheckUnnamed(/*戻り値<EM>真</EM>ディスクに名前がない場合*/DiskHandle disk);</PRE>
<P>このルーチンは、登録されたディスクに永続的な名前があるかどうかをチェックします。 ディスクに名前がない場合、ルーチンは以下を返します。<EM>真</EM>(つまり0以外の値)を返します。<EM>偽の</EM>GEOSは、名前のないディスクを登録するときに、一時的な名前を割り当てます。 ディスクの一時的な名前または永続的な名前を調べるには<CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeName()">DiskGetVolumeName()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>標準のパス定数を渡すと、このルーチンはメインのパスを含むディスクに関する情報を返します。<STRONG CLASS="fileName">geos.iniファイル</STRONG>ファイルを開きます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeName()">DiskGetVolumeName()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_19.htm_IX_DiskCheckWritable()"></A>
        <H1 CLASS="refHeading">DiskCheckWritable()</H1>
<PRE CLASS="syntax">ブーリアンDiskCheckWritable(DiskHandleディスク);</PRE>
<P><CODE>DiskCheckWritable()</CODE>は、ディスクが現在書き込み可能かどうかをチェックします。 戻ります<EM>偽の</EM>(つまり0)は、ディスクが本来書き込み可能でない場合(例えばCD-ROMディスク)や、書き込み禁止タブがオンになっている場合に返されます。<EM>真</EM>(すなわち、非ゼロ)。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>標準のパス定数を渡すと、このルーチンはメインのパスを含むディスクに関する情報を返します。<STRONG CLASS="fileName">geos.iniファイル</STRONG>ファイルを開きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_19.htm_IX_DiskCopy()"></A>
          <A NAME="R_19.htm_IX_CALLBACK_&ldots;"></A>
          <A NAME="R_19.htm_IX_DiskCopyCallback"></A>
          <A NAME="R_19.htm_IX_DiskCopyError"></A>
          <A NAME="R_19.htm_IX_ERR_&ldots;  (DiskCopyError)"></A>
        <H1 CLASS="refHeading">DiskCopy(コマンド)</H1>
<PRE CLASS="syntax">DiskCopyError DiskCopy(word source, word dest, Boolean_pascal(*callback)(DiskCopyCallback code, DiskHandle disk, word param));</PRE>
<P>このルーチンは、あるディスクを別のディスクにコピーします。 ターゲットディスクは、ソースディスクと同じタイプにフォーマット可能である必要があります。 最初の2つの引数は、ソースドライブとデスティネーションドライブを指定します。 これらのドライブは、同じである場合とそうでない場合があります。 異なる場合は、互換性のあるディスクを使用する必要があります。</P>
<P>ディスク・コピーには、ユーザーとの頻繁な対話が必要です。 たとえば、コピー・ルーチンは、必要に応じてディスクを交換するようユーザーに促す必要があります。 このため<CODE><A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy(コマンド)</A></CODE>にはコールバックルーチンへのポインタが渡される。 このルーチンは、ユーザーとのすべての対話を処理します。 _pascalと宣言する必要があります。 呼び出されるたびに、3つの引数が渡されます。 1つ目は<CODE>DiskCopyCallback</CODE>この引数は、コールバックルーチンが実行する内容を指定します。 2番目の引数はディスクハンドルです。<CODE>DiskCopyCallback</CODE>引数を指定します。 3番目の引数は、ワードサイズのデータで、その重要度は<CODE>DiskCopyCallback</CODE>引数を指定します。 これらの引数のいずれかがNULL値になることがあります。<CODE>DiskCopyCallback</CODE>引数を指定します。</P>
<P>コールバックルーチンは、次のようにしてコピーを中止できます。<EM>真</EM>(つまり0以外)。それ以外の場合は<EM>偽の</EM>(すなわちゼロ)。 コールバックルーチンは、次の値で識別されるいくつかの状況で呼び出されます。<CODE>DiskCopyCallback</CODE>関連付けられています。</P>
<DL>
<DT>CALLBACK_GET_SOURCE_DISK(コールバック_GET_ソース_ディスク)</DT><DD>コールバックルーチンは、ソースディスクを適切なドライブに挿入するようユーザーに求める必要があります。 2番目の引数は、この呼び出しでは意味がありません。 3番目の引数はドライブを識別する番号です。<CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetName()">DriveGetName()</A></CODE>このドライブの名前を検索します。</DD>
<DT>CALLBACK_GET_DEST_DISK(コールバック_GET_DEST_ディスク)</DT><DD>コールバックルーチンは、宛先ディスクを適切なドライブに挿入するようユーザに要求する必要があります。 2番目の引数は、この呼び出しでは意味がありません。 3番目の引数は、ドライブを識別する番号です。</DD>
<DT>CALLBACK_REPORT_NUM_SWAPS[コールバックレポート番号スワップ]</DT><DD>2番目の引数は、この呼び出しでは意味がありません。 3番目の引数は、必要なディスクスワップの回数です。 コールバックルーチンは、この番号をユーザに報告し、確認を求めることができます。</DD>
<DT>CALLBACK_VERIFY_DEST_DESTRUCTION(コールバック検証宛先破壊)</DT><DD>コピー先のディスクがすでにフォーマットされている場合は、このパラメータを使用してコールバックルーチンが呼び出されます。 コールバックルーチンは、宛先ディスクが消去されることをユーザに思い出させたい場合があります。 2番目の引数は、宛先ディスクのハンドルです。これは、たとえば、ディスクの名前を報告する場合に便利です。 3番目の引数は、デスティネーションドライブの番号です。 この時点でコールバックルーチンが0以外の値を返してコピーを中止しても、コピー先のディスクは影響を受けません。</DD>
<DT>CALLBACK_REPORT_FORMAT_PCT[コールバックレポート形式PCT]</DT><DD>コピー先のディスクをフォーマットする必要がある場合は<CODE><A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy(コマンド)</A></CODE>は、このパラメータを使用してコールバックルーチンを定期的に呼び出します。 コールバックルーチンは、フォーマットがどのように進行しているかをユーザに通知することを望むかもしれない。 この場合、2番目の引数は意味がありません。3番目のパラメータは、フォーマットされたデスティネーションディスクの割合です。 コールバックルーチンは、フォーマットがどのように進行しているかをユーザに通知することを望むかもしれない。</DD>
<DT>CALLBACK_REPORT_COPY_PCT[コールバックレポートのコピー]</DT><DD>コピーが行われている間<CODE><A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy(コマンド)</A></CODE>は、このパラメータを使用してコールバックルーチンを定期的に呼び出します。 コールバック・ルーチンは、コピーがどのように進行しているかをユーザーに通知することができます。 この場合、2番目のパラメータは意味を持ちません。3番目のパラメータは、完了したコピーのパーセンテージです。</DD>
</DL>
<P>コピーが成功した場合は<CODE><A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy(コマンド)</A></CODE>は0を返します。 それ以外の場合は<CODE>DiskCopyError</CODE>列挙型。 このタイプには、次のメンバがあります。</P>
<DL>
<DT>ERR_DISKCOPY_INSUFFICIENT_MEM(メモリ不足)</DT><DD>ルーチンが十分なメモリを確保できなかった場合に返されます。</DD>
<DT>ERR_CANT_COPY_FIXED_DISKS(固定ディスクのコピーエラー)</DT>
<DT>ERR_CANT_READ_FROM_SOURCE(ソースからの読み取りエラー)</DT>
<DT>ERR_CANT_WRITE_TO_DEST(宛先への書き込みエラー)</DT>
<DT>ERR_INCOMPATIBLE_FORMATS(互換性のないフォーマット</DT><DD>デスティネーションドライブは、ソースディスクとまったく同じ形式でディスクに書き込むことができる必要があります。 ソース・ドライブとデスティネーション・ドライブが同じ場合もあることに注意してください。</DD>
<DT>ERR_OPERATION_CANCELLED(キャンセルされた操作)</DT><DD>コールバックルーチンが0以外の値を返したためにコピーが中止された場合に返されます。</DD>
<DT>ERR_CANT_FORMAT_DEST(エラー出力先)</DT>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_19.htm_IX_DiskFind()"></A>
          <A NAME="R_19.htm_IX_DiskFindResult"></A>
          <A NAME="R_19.htm_IX_DFR_&ldots;"></A>
        <H1 CLASS="refHeading">DiskFind()</H1>
<PRE CLASS="syntax">DiskHandle DiskFind(const char*fname, /*Nullで終端されたボリューム名*/DiskFindResult*code);/*ここにDiskFindResultが書かれています*/</PRE>
<P>このルーチンは、指定された名前のディスクのハンドルを返します。 指定した名前のディスクが登録されていない場合は<CODE>DiskFind()</CODE>はNULLハンドルを返す。 ディスクハンドルは一意ですが、ボリューム名は一意ではないことに注意してください。したがって、同じボリューム名を持つディスクが複数登録されている場合があります。 このため<CODE>DiskFind()</CODE>は<CODE>DiskFindResults</CODE>(以下で説明する)を<EM>記号</EM>ポインタ。</P>
<P CLASS="refField"><STRONG>構造:</STRONG><CODE>DiskFind()</CODE>では<CODE>DiskFindResult</CODE>列挙型。次の値を持ちます。</P>
<DL>
<DT>DFR_UNIQUE(固有)</DT><DD>指定された名前の登録済みディスクが1つだけあります。そのハンドルが返されました。</DD>
<DT>DFR_NOT_UNIQUE(一意でない)</DT><DD>指定された名前の登録済みディスクが2つ以上あります。これらのディスクのうち任意の1つのハンドルが返されました。</DD>
<DT>DFRが見つかりません</DT><DD>指定された名前の登録済みディスクがありません。NULLのディスクハンドルが返されました。</DD>
</DL>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>指定したボリューム名を持つすべてのディスクを検索するには<CODE><A HREF="../../CRef/Routines/R_1a.htm#IX_DiskForEach()">DiskForEach()</A></CODE>コールバックルーチンに各ディスクの名前をチェックさせます。<CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeName()">DiskGetVolumeName()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_1a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_1a.htm_IX_DiskForEach()"></A>
        <H1 CLASS="refHeading">DiskForEach()</H1>
<PRE CLASS="syntax">DiskHandle DiskForEach(Boolean_pascal(*callback)(DiskHandle disk))/*callback returns<EM>真</EM>*キャンセルします*/</PRE>
<P>このルーチンを使用すると、登録されているすべてのディスクに対してアクションを実行できます。 ディスクごとにコールバックルーチンを1回呼び出し、ディスクのハンドルを渡します。 コールバックルーチンは、_pascalと宣言する必要があります。 コールバックルーチンは、次の値を返すことで、強制的に終了させることができます。<EM>真</EM>(つまり、0以外)。コールバックルーチンが<EM>真</EM><CODE>DiskForEach()</CODE>は終了し、コールバックルーチンに渡された最後のディスクのハンドルを返します。 コールバックルーチンがすべてのディスクを検査し<EM>真</EM><CODE>DiskForEach()</CODE>はNULLハンドルを返す。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG><CODE>DiskForEach()</CODE>は通常、特定のディスクを検索するために使用されます。 コールバックルーチンは、各ディスクをチェックして一致するものがあるかどうかを確認します。一致するものが見つかった場合、コールバックルーチンは単に次のように返します。<EM>真</EM>、および<CODE>DiskForEach()</CODE>はディスクのハンドルを返す。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1a.htm_IX_DiskFormat()"></A>
          <A NAME="R_1a.htm_IX_DiskFormatFlags"></A>
          <A NAME="R_1a.htm_IX_DFF_&ldots;"></A>
          <A NAME="R_1a.htm_IX_FormatError"></A>
          <A NAME="R_1a.htm_IX_FMT_&ldots;"></A>
        <H1 CLASS="refHeading">DiskFormat()関数</H1>
<PRE CLASS="syntax">FormatError DiskFormat(word driveNumber, MediaType media, /*このサイズにフォーマットする*/DiskFormatFlagsフラグ,/*下のフラグを参照する*/dword*goodClusters, /*これらは*/dword*badClustersで入力される,/*フォーマットの*/Boolean_pascal(*callback)(word percentDone));/*キャンセルするにはtrueを返す*/</PRE>
<P>このルーチンは、指定されたサイズにディスクをフォーマットします。 完了すると、渡されたポインタにディスク上の良いクラスタと悪いクラスタの数を格納します。 (各クラスタのサイズを調べるには<CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeInfo()">DiskGetVolumeInfo()</A></CODE>」を参照してください。 このルーチンは<CODE>フォーマットエラー</CODE>列挙型(メンバーは後述)。</P>
<P><CODE>DiskFormat()関数</CODE>コールバックルーチンを定期的に呼び出すように指示することができます。 これにより、アプリケーションは、フォーマットがどのように進行しているかをユーザーに知らせることができます。 コールバックルーチンには、フォーマットされたディスクの割合、または現在フォーマットされているシリンダとヘッドのいずれかが渡されます。 コールバックルーチンは、_pascalと宣言する必要があります。 コールバックルーチンは、次の値を返すことでフォーマットをキャンセルできます。<EM>真</EM>(つまり0以外)。それ以外の場合は<EM>偽の</EM>(すなわちゼロ)。</P>
<P>渡される3番目の引数は、ワード長のフラグフィールドです。 現在、次の3つのフラグのみが定義されています。</P>
<DL>
<DT>DFF_CALLBACK_PERCENT_完了</DT><DD>コールバックルーチンは定期的に呼び出す必要があります。 コールバックルーチンには、単一の引数、つまり実行されたフォーマットのパーセンテージを渡す必要があります。</DD>
<DT>DFF_CALLBACK_CYL_HEAD[DFFコールバック円柱ヘッド]</DT><DD>コールバックルーチンは定期的に呼び出す必要があります。 コールバックルーチンには、単一の引数、つまりフォーマットされるシリンダヘッドを渡す必要があります。 DFF_CALLBACK_PERCENT_DONEとDFF_CALLBACK_CYL_HEADの両方が渡された場合、結果は未定義になります。 どちらのフラグも設定されていない場合、コールバックルーチンは呼び出されません。null関数ポインタが渡される可能性があります。</DD>
<DT>DFF_FORCE_ERASE[強制消去]</DT><DD>「ハードフォーマット」を行う必要があります。つまり、セクタを書き換えてゼロに初期化する必要があります。 このフラグが設定されていない場合<CODE>DiskFormat()関数</CODE>は、可能であれば「ソフトフォーマット」を行います。セクタをチェックし、空のファイル割り当てテーブルを書き込みますが、必ずしもディスクからデータを消去するわけではありません。</DD>
</DL>
<P><CODE>DiskFormat()関数</CODE>は<CODE>フォーマットエラー</CODE>列挙型。 フォーマットが成功した場合は、定数FMT_DONE(ゼロに等しいことが保証されている)を返します。 それ以外の場合は、次のいずれかの定数が返されます。</P>
<PRE>FMT_DRIVE_NOT_READY FMT_ERROR_WRITING_BOOT FMT_ERROR_WRITING_ROOT_DIR FMT_ERROR_WRITING_FAT FMT_ABORTED FMT_SET_VOLUME_NAME_ERROR FMT_CANNOT_FORMAT_FIXED_DISKS_IN_CUR_RELEASE FMT_BAD_PARTITION_TABLE FMT_ERR_NO_PARTITION_FOUND FMT_ERR_CANNOT_ALLOC_SECTOR_BUFFER FMT_ERR_WRITE_PROTECTED FMT_ERR_DRIVE_CANNOT_SUPPORT_GIVEN_FORMAT FMT_ERR_INVALID_DRIVE_SPECIFIED FMT_ERR_DRIVE_CANNOT_BE_FORMATTED FMT_ERR_DISK_UNAVAILABLE(FMT_BAD_PARTITION_</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_1b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_1b.htm_IX_DiskGetDrive()"></A>
        <H1 CLASS="refHeading">DiskGetDrive()</H1>
<PRE CLASS="syntax">ワードDiskGetDrive(DiskHandle dh)</PRE>
<P>このルーチンは、登録されたディスクに関連付けられているドライブ番号を返します。 これは、ドライブが使用できなくなった場合(たとえば、ネットワークドライブがマッピング解除された場合)でも行われることに注意してください。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>標準のパス定数を渡すと、このルーチンはメインのパスを含むディスクに関する情報を返します。<STRONG CLASS="fileName">geos.iniファイル</STRONG>ファイルを開きます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_19.htm#IX_DiskFind()">DiskFind()</A></CODE><CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1b.htm_IX_DiskGetVolumeFreeSpace()"></A>
        <H1 CLASS="refHeading">DiskGetVolumeFreeSpace()</H1>
<PRE CLASS="syntax">dワードDiskGetVolumeFreeSpace(DiskHandle dh);</PRE>
<P>このルーチンは、指定されたディスクの空き容量(バイト単位)を返します。 ディスクが本来書き込み可能でない場合(CD-ROMディスクなど)<CODE>DiskGetVolumeFreeSpace()</CODE>は0を返し、スレッドのエラー値をクリアする。 エラー状態が存在する場合<CODE>DiskGetVolumeFreeSpace()</CODE>は0を返し、スレッドのエラー値を設定する。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>標準のパス定数を渡すと、このルーチンはメインのパスを含むディスクに関する情報を返します。<STRONG CLASS="fileName">geos.iniファイル</STRONG>ファイルを開きます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeInfo()">DiskGetVolumeInfo()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1b.htm_IX_DiskGetVolumeInfo()"></A>
        <H1 CLASS="refHeading">DiskGetVolumeInfo()</H1>
<PRE CLASS="syntax">word DiskGetVolumeInfo(/*成功した場合は0を返す*/DiskHandle dh, DiskInfoStruct*info);/*この構造体を埋めるルーチン*/</PRE>
<P>このルーチンは、ディスクに関する一般情報を返します。 次の4つの情報が返されます。</P>
<UL>
<LI>各ディスクブロックのサイズ(バイト単位)。 領域が割り当てられると、最も近い整数ブロックに切り上げられます。</LI>
<LI>ディスク上の空きバイト数。</LI>
<LI>ディスク上の合計バイト数。これは、空き領域と使用済み領域の合計です。</LI>
<LI>ディスクのボリューム名。 ボリュームに名前が付いていない場合は、現在の一時的な名前が返されます。</LI>
</UL>
<P>情報は、渡された<CODE>DiskInfoStruct</CODE>エラー状態が発生した場合<CODE>DiskGetVolumeInfo()</CODE>はエラーコードを返し、スレッドのエラー値を設定する。それ以外の場合は0を返す。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>標準のパス定数を渡すと、このルーチンはメインのパスを含むディスクに関する情報を返します。<STRONG CLASS="fileName">geos.iniファイル</STRONG>ファイルを開きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1b.htm_IX_DiskGetVolumeName()"></A>
        <H1 CLASS="refHeading">DiskGetVolumeName()</H1>
<PRE CLASS="syntax">void volume(DiskHandle dh, char*バッファ);/*DiskGetVolumeName_NAME_LENGTH_ZTバイト*long*/である必要があります</PRE>
<P>このルーチンは、渡されたバッファにディスクのボリューム名を(ヌル終了文字列として)コピーします。 エラーが発生した場合は、スレッドのエラー値を設定します。 ボリュームに名前がない場合、ルーチンは現在の一時名を返します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG><CODE>DiskGetVolumeName()</CODE>は渡されたバッファのサイズをチェックしません。 バッファの長さがVOLUME_NAME_LENGTH_ZTバイト以上でない場合、ルーチンはその境界を越えて書き込むことができます。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>標準のパス定数を渡すと、このルーチンはメインのパスを含むディスクに関する情報を返します。<STRONG CLASS="fileName">geos.iniファイル</STRONG>ファイルを開きます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeInfo()">DiskGetVolumeInfo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSetVolumeName()">DiskSetVolumeName()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_1b.htm_IX_DiskRegisterDisk()"></A>
        <H1 CLASS="refHeading">DiskRegisterDisk()</H1>
<PRE CLASS="syntax">DiskHandle DiskRegisterDisk(word driveNumber)</PRE>
<P>このルーチンは、指定されたドライブにディスクを登録し、ディスクハンドルを割り当てます。 (ディスクハンドルは、GEOSの現在のセッションが終了するまで保持されます)。 ディスクにすでにハンドルがある場合は<CODE>DiskRegisterDisk()</CODE>が返します。 ディスクに名前がない場合、GEOSは一時的な名前(「UNNAMED1」など)を割り当て、一時的な名前が何であるかをユーザーに通知する警告ボックスを表示します。 (これは、各セッションでディスクが最初に登録されたときにのみ実行されます)。 一時名はディスクに書き込まれないことに注意してください。したがって、一時名はGEOSの現在のセッションが終了するまでしか保持されません。</P>
<P>このルーチンがディスクハンドルを返す場合、ドライブにはディスクがあります。ディスクハンドルを返さない場合、ドライブにはまだディスクがあるかもしれませんが、そのディスクはフォーマットされていません。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>同じディスクを何度も登録しても問題はありません。 したがって、特定のドライブにあるディスクのディスクハンドルを取得したい場合は<CODE>DiskRegisterDisk()</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDiskSilently()">DiskRegisterDiskSilently()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1b.htm_IX_DiskRegisterDiskSilently()"></A>
        <H1 CLASS="refHeading">DiskRegisterDiskSilently()</H1>
<PRE CLASS="syntax">DiskHandle DiskRegisterDiskSilently(word driveNumber)</PRE>
<P>このルーチンは、以下とほとんど同じです。<CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>(上記参照)。 唯一の違いは、GEOSがディスクに一時的な名前を割り当てた場合、ユーザーに警告ボックスが表示されないことです。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1b.htm_IX_DiskRestore()"></A>
          <A NAME="R_1b.htm_IX_DiskRestoreError"></A>
          <A NAME="R_1b.htm_IX_DRE_&ldots;"></A>
        <H1 CLASS="refHeading">DiskRestore()を実行します。</H1>
<PRE CLASS="syntax">DiskHandle DiskRestore(void*buffer, /*DiskSave()によって書き込まれたバッファ*/DiskRestoreError_pascal(*callback)(const char*driveName, const char*diskName, void**bufferPtr</PRE>
<PRE CLASS="syntax">DiskRestoreErrorエラー)。</PRE>
<P><CODE>DiskRestore()を実行します。</CODE>によって書き込まれたバッファを検査します。<CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSave()">DiskSave()メソッド</A></CODE>そのバッファで記述されたディスクのハンドルを返します。 そのディスクがすでに登録されている場合は<CODE>DiskRestore()を実行します。</CODE>は単純にハンドルを返します。 ディスクが登録されておらず、ドライブに入っていない場合は<CODE>DiskRestore()を実行します。</CODE>は指定されたコールバックルーチンを呼び出す。 コールバックルーチンは_pascalと宣言する必要があります。 コールバックルーチンには、次の4つの引数が渡されます。</P>
<UL>
<LI>ディスクのドライブ名を含むNULL終端文字列。</LI>
<LI>ディスクのボリュームラベルを含むNULL終端文字列。</LI>
<LI>の変数へのポインタ<CODE>DiskRestore()を実行します。</CODE>ルーチン。 この変数は、それ自体が<CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSave()">DiskSave()メソッド</A></CODE>コールバックルーチンは、その構造体を移動させる何らかのアクションを実行する場合(例えば、バッファを含むグローバルヒープまたはローカルヒープをシャッフルする場合)<CODE>DiskRestore()を実行します。</CODE>ボタンをクリックし</LI>
<LI>のメンバー<CODE>DiskRestoreError</CODE>列挙型。 これは間違いです<CODE>DiskRestore()を実行します。</CODE>コールバックルーチンが存在しなかった場合に返されます。 これは通常、DRE_REMOVABLE_DRIVE_DOESNT_HOLD_DISKです。</LI>
</UL>
<P>コールバックルーチンは、ユーザーにディスクの挿入を促す必要があります。 コールバックルーチンが成功した場合は、DRE_DISK_IN_DRIVE(ゼロであることが保証されています)を返します。 それ以外の場合は<CODE>DiskRestoreError</CODE>通常はDRE_USER_CANCELLED_RESTOREを返します。 コールバックルーチンは通常、ユーザがディスクを挿入したかどうかを認識しないことに注意してください。通常は警告ボックスを表示し、ユーザが「OK」をクリックしたときに戻ります。 コールバックルーチンから戻った後<CODE>DiskRestore()を実行します。</CODE>はディスクを登録し、それが正しいものであることを確認します。正しくない場合、コールバックルーチンを再度呼び出します。</P>
<P>NULL関数ポインタを<CODE>DiskRestore()を実行します。</CODE>コールバックルーチンを提供する代わりに この場合<CODE>DiskRestore()を実行します。</CODE>ディスクが登録されておらず、現在ドライブ内にない場合、は失敗します。</P>
<P><CODE>DiskRestore()を実行します。</CODE>はディスクのハンドルを返す。 何らかの理由で失敗した場合は、ヌルハンドルを返し、スレッドのエラー値を<CODE>DiskRestorenError</CODE>列挙型。 この型には次のメンバーがあります。</P>
<DL>
<DT>DREディスク入力ドライブ</DT><DD>これはコールバックルーチンによって返されます。 これはゼロに等しいことが保証されています。</DD>
<DT>DRE_DRIVE_NO_LONGER_EXISTS(DREドライブが存在しない)</DT><DD>ディスクは、システムに接続されていないドライブに関連付けられています。</DD>
<DT>DRE_REMOVABLE_DRIVE_DOESNT_CONTAIN_DISK(DREリムーバブルドライブにディスクが含まれていません)</DT><DD>ディスクは登録解除されており、現在関連付けられているドライブにありません。 コールバックルーチンが提供されている場合は<CODE>DiskRestore()を実行します。</CODE>このような状況では、によって呼び出されます。</DD>
<DT>DRE_USER_CANCELLED_RESTORE&lt;ユーザ名></DT><DD>これは、ユーザーがリストアをキャンセルした場合にコールバックルーチンによって返されます。</DD>
<DT>DRE_COULDNT_CREATE_NEW_DISK_HANDLE&lt;ディスクハンドル></DT><DD><CODE>DiskRestore()を実行します。</CODE>新しいディスクハンドルを作成できなかったため、はディスクを適切なドライブに登録できませんでした。</DD>
<DT>DRE_REMOVABLE_DRIVE_IS_BUSY(リムーバブルドライブがビジー状態)</DT><DD>該当するドライブが時間のかかる操作(ディスクフォーマットなど)でビジー状態です。</DD>
<DT>DRE_NOT_ATTACHED_TO_SERVER(サーバに接続されていない)</DT><DD>ディスクは、ログインしていないネットワークサーバからのものでした。</DD>
<DT>DRE_PERMISSION_DENIED(パーミッション拒否)</DT><DD>ディスクはネットワーク上にあり、現在アクセスを拒否しています。</DD>
<DT>DRE_ALL_DRIVES_USED(使用中のすべてのドライブ)</DT><DD>ディスクはマウントされていないネットワークボリューム上にありましたが、マッピングできるドライブが残っていません。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSave()">DiskSave()メソッド</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_1c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_1c.htm_IX_DiskSave()"></A>
        <H1 CLASS="refHeading">DiskSave()メソッド</H1>
<PRE CLASS="syntax">Boolean DiskSave(DiskHandle disk, void*buffer, /*data will be written here*/word*bufferSize);/*バッファのサイズ(バイト単位)*/</PRE>
<P>このルーチンは、指定されたバッファにディスクに関する情報を書き込みます。<CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRestore()">DiskRestore()を実行します。</A></CODE>は、GEOSの別のセッションでも、この情報を使用してディスクハンドルを返すことができます。 の<EM>バッファサイズ</EM>引数は、バッファのサイズ(バイト単位)を含むワードを指す必要があります。 バッファが十分に大きい場合は<CODE>DiskSave()メソッド</CODE>は不透明なデータ構造体をバッファに書き込み<CODE>*バッファサイズ</CODE>余分なバッファ領域は、解放するか、使用することができます。 この場合<CODE>DiskSave()メソッド</CODE>戻ります<EM>真</EM>バッファが小さすぎる場合は<CODE>DiskSave()メソッド</CODE>戻ります<EM>偽の</EM>(つまり、ゼロ)を入力し、必要なサイズを<CODE>*バッファサイズ</CODE>を呼び出します。<CODE>DiskSave()メソッド</CODE>十分な大きさのバッファが必要です 次の場合<CODE>DiskSave()メソッド</CODE>が何らかの理由で失敗した場合は<EM>偽の</EM>を選択し<CODE>*バッファサイズ</CODE>ゼロにします</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRestore()">DiskRestore()を実行します。</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1c.htm_IX_ERROR_&ldots;"></A>
          <A NAME="R_1c.htm_IX_DiskSetVolumeName()"></A>
        <H1 CLASS="refHeading">DiskSetVolumeName()</H1>
<PRE CLASS="syntax">word DiskSetVolumeName(DiskHandle dh, const char*name);/*名前をthisに変更*/</PRE>
<P>このルーチンは、ディスクのボリュームラベルを変更します。 成功した場合は0を返し、それ以外の場合はエラー・コードを返します。 また、スレッドのエラー値を適切に設定またはクリアします。 次のエラーコードが返される場合があります。</P>
<DL>
<DT>エラー_無効なボリューム</DT><DD>無効なディスクハンドルがルーチンに渡されました。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>何らかの理由で、ボリュームの名前を変更できませんでした。 たとえば、ボリュームが書き込み可能でない場合があります。</DD>
<DT>ERROR_DISK_STALE(古いディスクエラー)</DT><DD>そのディスクを含むドライブが削除されました。 これは通常、ネットワークドライブでのみ発生します。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">disk.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1c.htm_IX_DosExec()"></A>
        <H1 CLASS="refHeading">DosExec()関数</H1>
<PRE CLASS="syntax">word DosExec(const char*prog, DiskHandle progDisk, const char*arguments, const char*execDir, DiskHandle execDisk, DosExecFlagsフラグ);</PRE>
<P>このルーチンは、GEOSをシャットダウンしてDOSプログラムを実行します。 エラーが発生した場合はエラーコードを返し、成功した場合は0を返します。 パラメータは次のとおりです。</P>
<DL>
<DT>
          <CODE>プログラム</CODE>
        </DT><DD>実行されるプログラムのパスを表すNULL終端文字列へのポインタ。 ヌル文字列(ヌルポインタではない)の場合、システムのDOSコマンドインタプリタが実行されます。 パス文字列にドライブ名を含めることはできません。</DD>
<DT>
          <CODE>progDisk</CODE>
        </DT><DD>プログラムが実行されるディスクを示すディスクハンドル。 0が渡された場合、GEOSが存在するディスクが使用されます。</DD>
<DT>
          <CODE>引き数</CODE>
        </DT><DD>実行中のプログラムに渡される引数を含む、ロックされたバッファまたは固定バッファへのポインタ。</DD>
<DT>
          <CODE>execDir</CODE>
        </DT><DD>プログラムが実行されるパスを表すNULL終端文字列へのポインタ。 文字列にドライブ名を含めることはできません。 NULLポインタが渡され<CODE>execDisk</CODE>が0の場合、プログラムはGEOSが最初に起動されたディレクトリで実行されます。</DD>
<DT>
          <CODE>execDisk</CODE>
        </DT><DD>ディレクトリが格納されているディスクのディスクハンドル<CODE>execDir</CODE>ボタンをクリックし</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>DosExecFlags</CODE>DOSプログラムがユーザにGEOSに戻るようプロンプトを表示するかどうかを示します。 使用可能なフラグは、DEF_PROMPT、DEF_FORCED_SHUTDOWN、およびDEF_INTERACTIVEです。 詳細については、のエントリを参照してください。<CODE>DosExecFlags</CODE>ボタンをクリックし</DD>
</DL>
<P>エラーがなければ<CODE>DosExec()関数</CODE>は0を返します。 それ以外の場合は、次のいずれかのエラー値が返されます。 ERROR_FILE_NOT_FOUND、ERROR_DOS_EXEC_IN_PROGRESS、ERROR_INSUFFICIENT_MEMORY、またはERROR_ARGS_TOO_LONG。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">system.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_1d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_1d.htm_IX_DriveGetDefaultMedia()"></A>
        <H1 CLASS="refHeading">DriveGetDefaultMedia()</H1>
<PRE CLASS="syntax">MediaType DriveGetDefaultMedia(wordドライブ番号);</PRE>
<P>このルーチンは、指定したドライブのデフォルトのメディアタイプを返します。 この関数は<CODE>メディアの種類</CODE>列挙型(Data Structuresリファレンスで説明されています)。 ドライブは、デフォルト以外のメディアタイプにも使用できます。 たとえば、高密度3.5インチドライブのデフォルトのメディアタイプはMEDIA_1M44ですが、サイズがMEDIA_720Kの3.5インチディスクに対して読み取り、書き込み、およびフォーマットを行うことができます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveTestMediaSupport()">DriveTestMediaSupport()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライブ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1d.htm_IX_DriveGetExtStatus()"></A>
          <A NAME="R_1d.htm_IX_DES_&ldots;"></A>
        <H1 CLASS="refHeading">DriveGetExtStatus()</H1>
<PRE CLASS="syntax">word DriveGetExtStatus(word driveNumber);</PRE>
<P>このルーチンは次のようになります。<CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>(以下に説明)。 ただし<CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>の場合、戻り値の上位バイトに追加のフラグを設定します。 次の追加フラグを返します。</P>
<DL>
<DT>DES_LOCAL_ONLY(ローカルのみ)</DT><DD>このフラグは、デバイスをネットワーク経由で表示できない場合に設定されます。</DD>
<DT>DES読み取り専用</DT><DD>このフラグは、デバイスが読み取り専用の場合、つまり、デバイスにマウントされているボリューム(CD-ROMドライブなど)にデータを書き込むことができない場合に設定されます。</DD>
<DT>DES_FORMATTABLE[DES形式テーブル]</DT><DD>このフラグは、ドライブでディスクをフォーマットできる場合に設定されます。</DD>
<DT>DES_ALIAS(エイリアス)</DT><DD>このフラグは、ドライブが実際に別のドライブ上のパスのエイリアスである場合に設定されます。</DD>
<DT>DES_ビジー</DT><DD>このフラグは、ドライブが長時間ビジー状態になる場合(たとえば、ディスクがフォーマットされている場合)に設定されます。</DD>
</DL>
<P>エラー状態が存在する場合<CODE>DriveGetExtStatus()</CODE>は0を返します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライブ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1d.htm_IX_DriveGetName()"></A>
        <H1 CLASS="refHeading">DriveGetName()</H1>
<PRE CLASS="syntax">char*DriveGetName(word driveNumber, /*このドライブの名前を取得*/char*buffer, /*このバッファに名前を書き込む*/word bufferSize);/*バッファのサイズ(バイト単位)*/</PRE>
<P>このルーチンは、指定されたドライブの名前を検索します。 このドライブに関する操作(ディスクの挿入など)をユーザーに求める場合は、この名前を使用してください。 このルーチンは、渡されたバッファに名前をNULL終端文字列として書き込みます。 末尾のヌルへのポインタを返します。 ドライブが存在しない場合、またはバッファが小さすぎる場合は<CODE>DriveGetName()</CODE>はNULLポインタを返す。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライブ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1d.htm_IX_DriveGetStatus()"></A>
          <A NAME="R_1d.htm_IX_DriveStatus"></A>
          <A NAME="R_1d.htm_IX_DS_&ldots;  (DriveStatus)"></A>
        <H1 CLASS="refHeading">DriveGetStatus()</H1>
<PRE CLASS="syntax">word DriveGetStatus(word driveNumber);</PRE>
<P>このルーチンは、ドライブの現在のステータスを返します。 ドライブは、ドライブ番号で指定します。 このルーチンは次のワードを返します。<CODE>ドライブの状態</CODE>フラグ。 これらのフラグを次に示します。</P>
<DL>
<DT>DS_現在</DT><DD>このフラグは、ドライブにディスクが含まれているかどうかにかかわらず、物理ドライブが存在する場合に設定されます。</DD>
<DT>DS_MEDIA_REMOVABLE[DSメディアリムーバブル]</DT><DD>このフラグは、ディスクをドライブから取り出せる場合に設定されます。</DD>
<DT>DSネットワーク</DT><DD>このフラグは、ドライブがネットワーク経由(またはネットワークプロトコル経由)でアクセスされる場合に設定されます。これは、ドライブをフォーマットまたはコピーできないことを意味します。</DD>
<DT>DSタイプ</DT><DD>これは、フィールドの下位4ビットのマスクです。 これらのビットには<CODE>ドライブタイプ</CODE>列挙型。</DD>
</DL>
<P>エラー状態が存在する場合<CODE>DriveGetStatus()</CODE>は0を返します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetExtStatus()">DriveGetExtStatus()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライブ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1d.htm_IX_DriveTestMediaSupport()"></A>
        <H1 CLASS="refHeading">DriveTestMediaSupport()</H1>
<PRE CLASS="syntax">Boolean DriveTestMediaSupport(word DriveNumber, MediaType media);/*必要なディスクサイズ*/</PRE>
<P>このルーチンは、指定したドライブが指定したサイズのディスクをサポートできるかどうかをチェックします。 戻ります<EM>真</EM>ドライブがそのサイズをサポートしている場合(つまり、ゼロ以外)。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetDefaultMedia()">DriveGetDefaultMedia()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライブ.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_1e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_EC() macro"></A>
        <H1 CLASS="refHeading">EC()にて</H1>
<PRE CLASS="syntax">ボイドEC(<EM>線</EM>)</PRE>
<P>このマクロは、エラー・チェック・バージョンのgeodeにのみコンパイルされるコード行を定義します。 の<CODE>線</CODE>マクロのパラメータは実際のコード行です。 ECバージョンのプログラムがコンパイルされると、その行は通常のコード行として扱われます。非ECバージョンがコンパイルされると、その行は無視されます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_74.htm#IX_NEC()">NEC()社</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_Pointers:bounds checking"></A>
          <A NAME="R_1e.htm_IX_EC_BOUNDS() macro"></A>
        <H1 CLASS="refHeading">関数EC_BOUNDS()</H1>
<PRE CLASS="syntax">voidのEC_BOUNDS(<EM>アドレス</EM>)</PRE>
<P>このマクロは、プログラムのエラーチェックバージョンにアドレスチェックを追加します。 プログラムのECバージョンがコンパイルされると、アドレスチェックは含まれますが、非ECバージョンがコンパイルされると、アドレスチェックは除外されます。 の<CODE>アドレス</CODE>パラメータは、チェックするアドレスまたはポインタです。</P>
<P>マクロは次の呼び出しに展開されます。<CODE><A HREF="../../CRef/Routines/R_1e.htm#IX_ECCheckBounds()">ECCheckBounds()</A></CODE>指定したアドレスまたはポインタに対して アドレスが範囲外の場合、プログラムは次の呼び出しで停止します。<CODE><A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()[致命的エラー]</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1e.htm#IX_ECCheckBounds()">ECCheckBounds()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_EC_ERROR() macro"></A>
        <H1 CLASS="refHeading">関数EC_ERROR()</H1>
<PRE CLASS="syntax">voidのEC_ERROR(<EM>記号</EM>)</PRE>
<P>このマクロは<CODE><A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()[致命的エラー]</A></CODE>エラー・チェック・バージョンのプログラムでは何も行われず、非ECバージョンでは何も行われません。 プログラムがこの点に到達すると、プログラムは停止し、指定されたエラーに対応するエラーメッセージを表示します。<CODE>記号</CODE>コールする前に条件をチェックする必要がある場合<CODE><A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()[致命的エラー]</A></CODE>の代わりにEC_ERROR_IF()を使用することもできます。</P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_EC_ERROR_IF() macro"></A>
        <H1 CLASS="refHeading">EC_ERROR_IF()を返します。</H1>
<PRE CLASS="syntax">void EC_ERROR_IF(&lt;値><EM>試験</EM><EM>記号</EM>)</PRE>
<P>このマクロは<CODE><A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()[致命的エラー]</A></CODE>非ECバージョンに対しては何もしません。 の<CODE>試験</CODE>パラメータはブール値で<CODE>真</CODE>を選択すると<CODE><A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()[致命的エラー]</A></CODE>呼び出しを行います。 次の場合<CODE>試験</CODE>である<CODE>偽の</CODE><CODE><A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()[致命的エラー]</A></CODE>は呼び出されません。</P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_EC_WARNING() macro"></A>
        <H1 CLASS="refHeading">関数EC_WARNING()</H1>
<PRE CLASS="syntax">警告(単語warningCode);</PRE>
<P>このマクロは、エラーチェックコードによって実行されると、デバッガに対して警告を生成します。EC以外のコードでは効果がありません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_EC_WARNING_IF() macro"></A>
        <H1 CLASS="refHeading">EC_WARNING_IF()を返します。</H1>
<PRE CLASS="syntax">EC_WARNING_IF(&lt;式>,単語warningCode)</PRE>
<P>このマクロをエラーチェックコードで実行すると、&lt;<EM>式</EM>>;&lt;の場合<EM>式</EM>>がゼロ以外の場合は、コードとともに警告を生成します。<CODE>warningCode</CODE>デバッガ用。</P>
<P>EC以外のコードでは、マクロは何の効果もありません(そして&lt;<EM>式</EM>>は評価されません)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_Pointers:bounds checking"></A>
          <A NAME="R_1e.htm_IX_ECCheckBounds()"></A>
        <H1 CLASS="refHeading">ECCheckBounds()</H1>
<PRE CLASS="syntax">void ECCheckBounds(void*住所)</PRE>
<P>このルーチンは、指定されたポインタが、それが指しているブロックの境界内にあるかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。 「LMem」ECフラグがオンで、ポインタがLMemブロック内を指している場合、このルーチンは、ポインタが有効なチャンクハンドルまたはLMemブロック内のチャンクを指しているかどうかもチェックします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_Chunk arrays:checking validity"></A>
          <A NAME="R_1e.htm_IX_ECCheckChunkArray()"></A>
        <H1 CLASS="refHeading">ECCheckChunkArray()</H1>
<PRE CLASS="syntax">無効ECCheckChunkArray(optr o)</PRE>
<P>このルーチンは、指定されたチャンク配列の有効性をチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_Chunk arrays:checking validity"></A>
          <A NAME="R_1e.htm_IX_ECCheckChunkArrayHandles()"></A>
        <H1 CLASS="refHeading">ECCheckChunkArrayHandles()</H1>
<PRE CLASS="syntax">空のECCheckChunkArrayHandles(MemHandle mh、ChunkHandle ch)</PRE>
<P>このルーチンは、指定されたチャンク配列の有効性をチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_Classes:checking class pointers"></A>
          <A NAME="R_1e.htm_IX_ECCheckClass()"></A>
        <H1 CLASS="refHeading">ECCheckClass()</H1>
<PRE CLASS="syntax">無効ECCheckClass(ClassStruct*クラス)</PRE>
<P>このルーチンは、指定されたポインタが実際にクラス定義を参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_Drivers:handle checking"></A>
          <A NAME="R_1e.htm_IX_ECCheckDriverHandle()"></A>
        <H1 CLASS="refHeading">ECCheckDriverHandle()</H1>
<PRE CLASS="syntax">空隙ECCheckDriverHandle(GeodeHandle gh)</PRE>
<P>このルーチンは、渡されたハンドルが実際にドライバを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_Events:handles, checking"></A>
          <A NAME="R_1e.htm_IX_ECCheckEventHandle()"></A>
        <H1 CLASS="refHeading">ECCheckEventHandle()</H1>
<PRE CLASS="syntax">空のECCheckEventHandle(EventHandle eh)</PRE>
<P>このルーチンは、渡されたハンドルが実際に格納されたメッセージを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_Files:handles, checking"></A>
          <A NAME="R_1e.htm_IX_ECCheckFileHandle()"></A>
        <H1 CLASS="refHeading">ECCheckFileHandle()</H1>
<PRE CLASS="syntax">void ECCheckFileHandle(FileHandleファイル);</PRE>
<P>このルーチンは、渡されたハンドルが実際にファイルハンドルであり、ファイルを参照していることを確認します。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_Geodes:handles, checking"></A>
          <A NAME="R_1e.htm_IX_ECCheckGeodeHandle()"></A>
        <H1 CLASS="refHeading">ECCheckGeodeHandle()</H1>
<PRE CLASS="syntax">空隙ECCheckGeodeHandle(GeodeHandle gh)</PRE>
<P>このルーチンは、渡されたハンドルがロードされたジオードを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1e.htm_IX_GStateHandle:checking"></A>
          <A NAME="R_1e.htm_IX_GStates:handles, checking"></A>
          <A NAME="R_1e.htm_IX_ECCheckGStateHandle()"></A>
        <H1 CLASS="refHeading">ECCheckGStateHandle()</H1>
<PRE CLASS="syntax">空隙ECCheckGStateHandle(GStateHandle gsh)</PRE>
<P>このルーチンは、渡されたハンドルがGStateを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_1f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_Huge arrays:checking"></A>
          <A NAME="R_1f.htm_IX_ECCheckHugeArray()"></A>
        <H1 CLASS="refHeading">ECCheckHugeArray()</H1>
<PRE CLASS="syntax">void ECCheckHugeArray(VMFileHandle vmFile、VMBlockHandle vmBlock);</PRE>
<P>このルーチンは、渡されたHuge配列の妥当性をチェックします。 渡されたブロックが巨大配列のディレクトリブロックでない場合、ルーチンは失敗します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_Libraries:handles, checking"></A>
          <A NAME="R_1f.htm_IX_ECCheckLibraryHandle()"></A>
        <H1 CLASS="refHeading">ECCheckLibraryHandle()</H1>
<PRE CLASS="syntax">空隙ECCheckLibraryHandle(GeodeHandle gh)</PRE>
<P>このルーチンは、渡されたハンドルがライブラリを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_Local memory:handles, checking"></A>
          <A NAME="R_1f.htm_IX_Chunks:checking"></A>
          <A NAME="R_1f.htm_IX_ECCheckLMemChunk()"></A>
        <H1 CLASS="refHeading">ECCheckLMemChunk()</H1>
<PRE CLASS="syntax">void ECCheckLMemChunk(void*chunkPtr)</PRE>
<P>このルーチンは、が指すチャンクの有効性をチェックします。<CODE>chunkPtr</CODE>アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_ECCheckLMemHandle()"></A>
        <H1 CLASS="refHeading">ECCheckLMemHandle()</H1>
<PRE CLASS="syntax">空隙ECCheckLMemHandle(MemHandle mh)</PRE>
<P>このルーチンは、渡されたハンドルがメモリハンドルであり、実際にローカルメモリブロックを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_ECCheckLMemHandleNS()"></A>
        <H1 CLASS="refHeading">ECCheckLMemHandleNS()</H1>
<PRE CLASS="syntax">空隙ECCheckLMemHandleNS(MemHandle mh)</PRE>
<P>このルーチンは、渡されたハンドルがローカルメモリハンドルであるかどうかをチェックします。<CODE><A HREF="../../CRef/Routines/R_1f.htm#IX_ECCheckLMemHandle()">ECCheckLMemHandle()</A></CODE>ただし、共有違反(スレッドが共有不可能なメモリを不正に使用している場合)はチェックされません。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_optr:checking"></A>
          <A NAME="R_1f.htm_IX_Objects:address checking"></A>
          <A NAME="R_1f.htm_IX_ECCheckLMemObject()"></A>
        <H1 CLASS="refHeading">ECCheckLMemObject()</H1>
<PRE CLASS="syntax">void ECCheckLMemObject(optr obj);/*オブジェクトをロックする必要があります。*/</PRE>
<P>このルーチンは、オブジェクトの有効性をチェックして、そのオブジェクトがオブジェクトブロックに格納されているオブジェクトであることを確認します。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_ECCheckLMemObjectHandles()"></A>
        <H1 CLASS="refHeading">ECCheckLMemObjectHandles()</H1>
<PRE CLASS="syntax">空のECCheckLMemObjectHandles(MemHandle mh、ChunkHandle ch)</PRE>
<P>このルーチンは、オブジェクトの有効性をチェックして、そのオブジェクトがオブジェクトブロックに格納されているオブジェクトであることを確認します。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_ECCheckLMemOD()"></A>
        <H1 CLASS="refHeading">ECCheckLMemOD()</H1>
<PRE CLASS="syntax">無効ECCheckLMemOD(optr o)</PRE>
<P>このルーチンは、指定されたローカルメモリベースのオブジェクトの有効性をチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_ECCheckLMemODHandles()"></A>
        <H1 CLASS="refHeading">ECCheckLMemODHandles()</H1>
<PRE CLASS="syntax">void ECCheckLMemODHandles(MemHandle objHan、ChunkHandle objCh);</PRE>
<P>このルーチンは、指定されたローカルメモリベースのオブジェクトの有効性をチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_Heap:checking memory handles"></A>
          <A NAME="R_1f.htm_IX_ECCheckMemHandle()"></A>
        <H1 CLASS="refHeading">ECCheckMemHandle()</H1>
<PRE CLASS="syntax">空隙ECCheckMemHandle(MemHandle mh)</PRE>
<P>このルーチンは、渡されたハンドルがメモリブロックを参照するメモリハンドルであることを確認します。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_ECCheckHandleNS()"></A>
        <H1 CLASS="refHeading">ECCheckMemHandleNS()</H1>
<PRE CLASS="syntax">空隙ECCheckMemHandleNS(MemHandle mh)</PRE>
<P>このルーチンは、渡されたハンドルがメモリブロックを参照しているかどうかをチェックします。<CODE><A HREF="../../CRef/Routines/R_1f.htm#IX_ECCheckMemHandle()">ECCheckMemHandle()</A></CODE>ただし、共有違反(スレッドが共有不可能なブロックに不正にアクセスした場合)のチェックは行いません。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_ECCheckObject()"></A>
        <H1 CLASS="refHeading">ECCheckObject()</H1>
<PRE CLASS="syntax">空のECCheckObject(optr obj)</PRE>
<P>このルーチンは、指定したロックされたオブジェクトの有効性をチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_ECCheckObjectHandles()"></A>
        <H1 CLASS="refHeading">ECCheckObjectHandles()</H1>
<PRE CLASS="syntax">空のECCheckObjectHandles(Memhandle mh、ChunkHandle ch)</PRE>
<P>このルーチンは、指定したロックされたオブジェクトの有効性をチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_Process object:checking"></A>
          <A NAME="R_1f.htm_IX_ECCheckOD()"></A>
        <H1 CLASS="refHeading">ECCheckOD()</H1>
<PRE CLASS="syntax">空のECCheckOD(optr obj)</PRE>
<P>このルーチンは、指定されたオブジェクトの有効性をチェックします。 とは異なり<CODE><A HREF="../../CRef/Routines/R_1f.htm#IX_ECCheckLMemObject()">ECCheckLMemObject()</A></CODE>ただし、Processオブジェクトのオプションを指定することはできます。 アサーションが失敗すると、致命的なエラーが発生します。</P>
</DIV>
<DIV>
          <A NAME="R_1f.htm_IX_ECCheckODHandles()"></A>
        <H1 CLASS="refHeading">ECCheckODHandles()</H1>
<PRE CLASS="syntax">void ECCheckODHandles(MemHandle objHan、ChunkHandle objCh);</PRE>
<P>このルーチンは、指定されたオブジェクトの有効性をチェックします。 とは異なり<CODE><A HREF="../../CRef/Routines/R_1f.htm#IX_ECCheckLMemObjectHandles()">ECCheckLMemObjectHandles()</A></CODE>ただし、プロセスを指定することはできます。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_20.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_Process object:checking"></A>
          <A NAME="R_20.htm_IX_ECCheckProcessHandle()"></A>
        <H1 CLASS="refHeading">ECCheckProcessHandle()</H1>
<PRE CLASS="syntax">空隙ECCheckProcessHandle(GeodeHandle gh)</PRE>
<P>このルーチンは、渡されたハンドルが実際にプロセスを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_Event queues:handles, checking"></A>
          <A NAME="R_20.htm_IX_ECCheckQueueHandle()"></A>
        <H1 CLASS="refHeading">ECCheckQueueHandle()</H1>
<PRE CLASS="syntax">空隙ECCheckQueueHandle(QueueHandle qh)</PRE>
<P>このルーチンは、渡されたハンドルがイベント・キューを参照していることを確認します。アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_Resources:handles, checking"></A>
          <A NAME="R_20.htm_IX_ECCheckResourceHandle()"></A>
        <H1 CLASS="refHeading">ECCheckResourceHandle()</H1>
<PRE CLASS="syntax">空隙ECCheckResourceHandle(MemHandle mh)</PRE>
<P>このルーチンは、渡されたハンドルがgeodeリソースを参照していることを確認します。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_Stack:checking"></A>
          <A NAME="R_20.htm_IX_ECCheckStack()"></A>
        <H1 CLASS="refHeading">ECCheckStack()</H1>
<PRE CLASS="syntax">void ECCheckStack x</PRE>
<P>このルーチンは、現在のスタックがオーバーフローしていない(オーバーフローしようとしていない)ことを確認します。 このルーチンはまた、スタックボトムとスタックポインタの間に100バイトのギャップを強制します。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_Threads:handles, checking"></A>
          <A NAME="R_20.htm_IX_ECCheckThreadHandles()"></A>
        <H1 CLASS="refHeading">ECCheckThreadHandle()</H1>
<PRE CLASS="syntax">空ECCheckThreadHandle(ThreadHandle th)</PRE>
<P>このルーチンは、渡されたハンドルが実際にスレッドを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_Windows:handles,checking"></A>
          <A NAME="R_20.htm_IX_ECCheckWindowHandle()"></A>
        <H1 CLASS="refHeading">ECCheckWindowHandle()</H1>
<PRE CLASS="syntax">空のECCheckWindowHandle(WindowHandle wh)</PRE>
<P>このルーチンは、渡されたハンドルが実際にウィンドウを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_Local memory:handles, checking"></A>
          <A NAME="R_20.htm_IX_Chunks:checking"></A>
          <A NAME="R_20.htm_IX_ECLMemExists()"></A>
        <H1 CLASS="refHeading">ECLMemExists()</H1>
<PRE CLASS="syntax">無効ECLMemExists(optr o)</PRE>
<P>このルーチンは、指定されたチャンクが存在するかどうかを確認します。 このルーチンは、チャンクハンドルの有効性をチェックするために、アプリケーションによって呼び出されます。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_ECLMemExistsHandles()"></A>
        <H1 CLASS="refHeading">ECLMemExistsHandles()</H1>
<PRE CLASS="syntax">空のECLMemExistsHandles(MemHandle mh、ChunkHandle ch)</PRE>
<P>このルーチンは、指定されたチャンクが存在するかどうかを確認します。 このルーチンは、チャンクハンドルの有効性をチェックするために、アプリケーションによって呼び出されます。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_ECLMemValidateHandle()"></A>
        <H1 CLASS="refHeading">ECLMemValidateHandle()</H1>
<PRE CLASS="syntax">無効ECLMemValidateHandle(optr o)</PRE>
<P>このルーチンは、渡されたoptrがローカル・メモリー・チャンクを指しているかどうかを検査します。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_ECLMemValidateHandleHandles()"></A>
        <H1 CLASS="refHeading">ECLMemValidateHandleHandles()</H1>
<PRE CLASS="syntax">空のECLMemValidateHandleHandles(MemHandle mh、ChunkHandle ch)</PRE>
<P>このルーチンは、渡されたメモリーハンドルとチャンクハンドルが実際にローカルメモリーチャンクを参照しているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_ECLMemValidateHeap()"></A>
        <H1 CLASS="refHeading">ECLMemValidateHeap()</H1>
<PRE CLASS="syntax">空隙ECLMemValidateHeap(MemHandle mh)</PRE>
<P>このルーチンは、LMemヒープの完全なエラーチェックを行います。 これは内部で使用され、アプリケーション・プログラマーには必要ありません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_ECMemVerifyHeap()"></A>
        <H1 CLASS="refHeading">ECMemVerifyHeap()</H1>
<PRE CLASS="syntax">void ECMemVerifyHeap()</PRE>
<P>このルーチンは、グローバル・ヒープが一貫した状態にあることを確認します。 アサーションが失敗すると、致命的なエラーが発生します。 このルーチンはECカーネル以外から呼び出されるべきではありません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_20.htm_IX_Virtual memory:handles, checking"></A>
          <A NAME="R_20.htm_IX_ECVMCheckMemHandle()"></A>
        <H1 CLASS="refHeading">ECVMCheckMemHandle()</H1>
<PRE CLASS="syntax">空虚なECVMCheckMemHandle(MemHandle飯)</PRE>
<P>このルーチンは、指定されたメモリーハンドルが実際にVMブロックハンドルにリンクされているかどうかをチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_21.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_21.htm_IX_Virtual memory:handles, checking"></A>
          <A NAME="R_21.htm_IX_ECVMCheckVMBlockHandle()"></A>
        <H1 CLASS="refHeading">ECVMCheckVMBlockHandle()</H1>
<PRE CLASS="syntax">空のECVMCheckVMBlockHandle(VMFileHandleファイル、VMBlockHandleブロック)</PRE>
<P>このルーチンは、指定されたVMファイルとブロックハンドルの有効性をチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_21.htm_IX_ECVMCheckVMFile()"></A>
        <H1 CLASS="refHeading">ECVMCheckVMFile()</H1>
<PRE CLASS="syntax">空のECVMCheckVMFile(VMFileHandleファイル)</PRE>
<P>このルーチンは、指定されたVMファイルハンドルの有効性をチェックします。 アサーションが失敗すると、致命的なエラーが発生します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_21.htm_IX_ElementArrayAddElement()"></A>
        <H1 CLASS="refHeading">ElementArrayAddElement()</H1>
<PRE CLASS="syntax">word ElementArrayAddElement(optr arr, /*要素配列のハンドル*/void*element, /*追加する要素(必要な場合)*/dword callBackData, /*これはコールバックルーチンに渡されます*/Boolean_pascal(*callback)(void*elementToAdd, void*elementFromArray, dword valueForCallback));</PRE>
<P>このルーチンは、配列に要素を追加するために使用されます。 可能性のある要素のアドレスが渡されます。 要素を要素配列の各メンバーと比較します。 一致するものがない場合は、要素を配列に追加し、参照カウントを1に設定します。 一致するものがある場合は、配列内の一致する要素の参照カウントを増分して返します。新しい要素は追加されません。 要素のアドレスを渡すときは、(reference-countヘッダーではなく)要素のデータ部分のアドレスを渡すようにしてください。</P>
<P>コールバックルーチンをに渡すことができます<CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>ボタンをクリックし<CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>はコールバックルーチンを呼び出し、要素を比較して一致するかどうかを確認します。 コールバックルーチンは_pascalと宣言する必要があります。<CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>は、コールバックルーチンに、渡された要素のアドレスと、配列内の要素のデータ部分(<CODE>RefElementHeader</CODE>構造)。 2つの要素が(使用する条件にかかわらず)一致した場合は<CODE>真</CODE>;それ以外の場合はreturn<CODE>偽の</CODE>NULL関数ポインタを渡すと、デフォルトの比較ルーチンが呼び出され、すべてのデータバイトが一致するかどうかがチェックされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>要素が既に配列内にあることがわかっている場合は<CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>(修正されていない限り)を呼び出す前に、グローバルヒープ上のブロックをロックします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_21.htm_IX_ElementArrayAddElementHandles()"></A>
        <H1 CLASS="refHeading">ElementArrayAddElementHandles()</H1>
<PRE CLASS="syntax">word ElementArrayAddElementHandles(MemHandle mh, /*LMemヒープのグローバルハンドル*/ChunkHandleチャンク/*要素配列のチャンクハンドル*/void*element, /*追加する要素*/dword callBackData, /*コールバックルーチンに渡される*/Boolean_pascal(*callback)(void*elementToAdd, void*elementFromArray, dword valueForCallback));</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>ただし、要素配列はグローバルハンドルとチャンクハンドル(optrではなく)で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>要素が既に配列内にあることがわかっている場合は<CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>(修正されていない限り)を呼び出す前に、グローバルヒープ上のブロックをロックします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_21.htm_IX_ElementArrayAddReference()"></A>
        <H1 CLASS="refHeading">ElementArrayAddReference()</H1>
<PRE CLASS="syntax">void ElementArrayAddReference(optr arr, /*optr to element array*/wordトークン);/*要素のインデックス番号*/</PRE>
<P>このルーチンは、要素配列のメンバの参照カウントをインクリメントします。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>(修正されていない限り)を呼び出す前に、グローバルヒープ上のブロックをロックします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_21.htm_IX_ElementArrayAddReferenceHandles()"></A>
        <H1 CLASS="refHeading">ElementArrayAddReferenceHandles()</H1>
<PRE CLASS="syntax">void ElementArrayAddReferenceHandles(MemHandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandle ch, /*要素配列のハンドル*/wordトークン);/*要素のインデックス番号*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>ただし、要素配列はグローバルハンドルとチャンクハンドル(optrではなく)で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_21.htm_IX_ElementArrayCreate()"></A>
        <H1 CLASS="refHeading">ElementArrayCreate()</H1>
<PRE CLASS="syntax">ChunkHandle ElementArrayCreate(MemHandle mh, /*LMemヒープのブロックのハンドル*/word elementSize, /*各要素のサイズ、または*可変サイズの場合はゼロ*/</PRE>
<PRE CLASS="syntax">word headerSize);/*ヘッダのサイズ(デフォルトはゼロ)*/</PRE>
<P>このルーチンは、指定されたLMemヒープに要素配列を作成します。 これにより<CODE>ElementArrayHeader</CODE>チャンクの先頭の構造。 配列の先頭の前に余分なスペースを残したい場合は、より大きなヘッダサイズを渡すことができます。標準ヘッダを使用したい場合は、ゼロのヘッダサイズを渡します。</P>
<P>各要素のサイズを指定できます。 要素配列内の各要素の最初の3バイトは、要素の<CODE>RefElementHeader</CODE>;参照カウントを含む構造;サイズを選択するときは、このためのスペースを残します。 可変サイズの要素を持つ配列の場合は、サイズ0を渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>配列要素の構造体を宣言することもできます。<CODE>RefElementHeader</CODE>この構造体のサイズを<CODE>ElementArrayCreate()</CODE>ボタンをクリックし</P>
<P>後に余分なスペースが必要な場合は<CODE>ElementArrayHeader</CODE>の場合は、独自のヘッダー構造を作成することができます。<CODE>ElementArrayHeader</CODE>このヘッダのサイズを<CODE>ElementArrayCreate()</CODE>構造体を介してヘッダー内のデータにアクセスします。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>このルーチンを呼び出す前に、グローバルヒープ上のブロックをロックします(修正されていない場合)。 ヘッダーのサイズを渡す場合は、そのサイズが<CODE>sizeof(ElementArrayHeader)</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_21.htm_IX_ElementArrayCreateAt()"></A>
        <H1 CLASS="refHeading">ElementArrayCreateAt()</H1>
<PRE CLASS="syntax">ChunkHandle ElementArrayCreateAt(optr arr, /*配列のチャンクのoptr*/word elementSize, /*各要素のサイズ,または*可変サイズの場合はゼロ*/</PRE>
<PRE CLASS="syntax">word headerSize);/*ヘッダのサイズ(デフォルトはゼロ)*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayCreate()">ElementArrayCreate()</A></CODE>ただし、要素配列は既存のチャンク内に作成されます。 そのチャンクの内容は上書きされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>チャンクのサイズが十分でない場合は、サイズが変更されます。 これにより、そのブロック内のチャンクへのすべてのポインタが無効になります。</P>
</DIV>
<DIV>
          <A NAME="R_21.htm_IX_ElementArrayCreateAtHandles()"></A>
        <H1 CLASS="refHeading">ElementArrayCreateAtHandles()</H1>
<PRE CLASS="syntax">ChunkHandle ElementArrayCreateAtHandles(MemHandle mh、/*LMemヒープのハンドル*/ChunkHandle ch/*このチャンクに配列を作成*/word elementSize、/*各要素のサイズ、またはゼロ*可変サイズの場合*/</PRE>
<PRE CLASS="syntax">word headerSize);/*ヘッダのサイズ(デフォルトはゼロ)*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayCreateAt()">ElementArrayCreateAt()</A></CODE>ただし、要素配列はグローバルハンドルとチャンクハンドル(optrではなく)で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>チャンクのサイズが十分でない場合は、サイズが変更されます。 これにより、そのブロック内のチャンクへのすべてのポインタが無効になります。</P>
</DIV>
<HR>
          <A NAME="R_22.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_22.htm_IX_ElementArrayDelete()"></A>
        <H1 CLASS="refHeading">ElementArrayDelete()</H1>
<PRE CLASS="syntax">void ElementArrayDelete(optr arr, /*optr to element array*/wordトークン);/*削除する要素のインデックス*/</PRE>
<P>このルーチンは、参照カウントに関係なく、要素配列から要素を削除します。 このルーチンには、要素配列のoptrと、削除する要素のトークンが渡されます。</P>
<P>要素が削除されると、実際にはサイズが0に縮小され、空き要素のリストに追加されることに注意してください。 これにより、後の要素のインデックス番号が保持されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>(修正されていない限り)を呼び出す前に、グローバルヒープ上のブロックをロックします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayRemoveReference()">ElementArrayRemoveReference()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_22.htm_IX_ElementArrayDeleteHandles()"></A>
        <H1 CLASS="refHeading">ElementArrayDeleteHandles()</H1>
<PRE CLASS="syntax">void ElementArrayDeleteHandles(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandle ch, /*要素配列のチャンクハンドル*/wordトークン);/*要素削除のインデックス*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_22.htm#IX_ElementArrayDelete()">ElementArrayDelete()</A></CODE>ただし、要素配列はグローバルハンドルとチャンクハンドル(optrではなく)で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>(修正されていない限り)を呼び出す前に、グローバルヒープ上のブロックをロックします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayRemoveReference()">ElementArrayRemoveReference()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_22.htm_IX_ElementArrayElementChanged()"></A>
        <H1 CLASS="refHeading">ElementArrayElementChanged()</H1>
<PRE CLASS="syntax">void ElementArrayElementChanged(optr arr, /*optr to element array*/word token, /*Index number of element*/dword callbackData, /*This is passed along to callback*/Boolean_pascal(*callback)/*Returns true if elements identical*/(void*elementChanged, void*elementToCompare, dword valueForCallback));</PRE>
<P>このルーチンは、要素が同じ要素配列内の他の要素と同一であるかどうかをチェックします。 これは、要素が変更された後に、別の要素と一致するかどうかを確認するために使用されます。 要素が別の要素と一致する場合、その要素は削除され、別の要素の参照カウントが増加します。</P>
<P>このルーチンには、要素配列へのoptr、チェック対象の要素のトークン、データのdword(コールバックルーチンに渡される)、およびコールバック比較ルーチンへのポインタが渡されます。 コールバックルーチン自体には、2つの要素へのポインタと<EM>コールバックデータ</EM>渡された引数<CODE>ElementArrayElementChanged()</CODE>コールバックルーチンは_pascalと宣言する必要があります。 2つの要素が同一の場合、コールバックは次の値を返します。<EM>真</EM>(つまり0以外)。それ以外の場合は<EM>偽の</EM>ボタンをクリックし</P>
<P>NULL関数ポインタを渡すと<CODE>ElementArrayElementChanged()</CODE>は要素をバイト単位で比較する。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_22.htm_IX_ElementArrayElementChangedHandles()"></A>
        <H1 CLASS="refHeading">ElementArrayElementChangedHandles()</H1>
<PRE CLASS="syntax">void ElementArrayElementChangedHandles(MemHandle MemHandle、/*LMemヒープのブロックのハンドル*/ChunkHandle ChunkHandle、/*要素配列のチャンクハンドル*/wordトークン、/*要素のインデックス番号*/dword callbackData、/*これは*callback*/に渡されます。</PRE>
<PRE CLASS="syntax">Boolean_pascal(*callback)/*要素が同一の場合にtrueを返す*/(void*elementChanged, void*elementToCompare, dword valueForCallback));</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_22.htm#IX_ElementArrayElementChanged()">ElementArrayElementChanged()</A></CODE>ただし、要素配列はグローバルハンドルとチャンクハンドル(optrではなく)で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_22.htm_IX_ElementArrayGetUsedCount()"></A>
        <H1 CLASS="refHeading">ElementArrayGetUsedCount()</H1>
<PRE CLASS="syntax">word ElementArrayGetUsedCount(optr arr, /*optr to element array*/dword callbackData, /*これはコールバックルーチンに渡されます*/Boolean_pascal(*callback)/*この要素をカウントするにはtrueを返します*/(void*element, dword cbData));</PRE>
<P>このルーチンは、要素配列内のアクティブな要素(参照カウントが1以上の要素)の数をカウントします。 すべての要素、または特定の基準に一致するすべての要素をカウントするように指示することができます。 このルーチンには、チャンク配列のoptr、コールバックルーチンに渡されるdword、および要素をカウントするかどうかを決定するコールバックルーチンの3つのパラメータが渡されます。 コールバックルーチン(_pascalと宣言する必要があります)には、要素へのポインタとしてdwordが渡されます。 戻るはずです<EM>真</EM>要素をカウントする必要がある場合。それ以外の場合は<EM>偽の</EM>すべての要素をカウントするには、ヌルのコールバックポインタを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayTokenToUsedIndex()">ElementArrayTokenToUsedIndex()</A></CODE><CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayUsedIndexToToken()">ElementArrayUsedIndexToToken()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_22.htm_IX_ElementArrayGetUsedCountHandles()"></A>
        <H1 CLASS="refHeading">ElementArrayGetUsedCountHandles()</H1>
<PRE CLASS="syntax">void ElementArrayGetUsedCountHandles(MemHandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandle ch, /*要素配列のチャンクハンドル*/dword callbackData, /*これはコールバックルーチンに渡されます*/Boolean_pascal(*callback)/*この要素を数えるためにtrueを返します*/(void*element, dword cbData));</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_22.htm#IX_ElementArrayGetUsedCount()">ElementArrayGetUsedCount()</A></CODE>ただし、要素配列はグローバルハンドルとチャンクハンドル(optrではなく)で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_23.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_23.htm_IX_ElementArrayRemoveReference()"></A>
        <H1 CLASS="refHeading">ElementArrayRemoveReference()</H1>
<PRE CLASS="syntax">void ElementArrayRemoveReference(optr arr, /*要素配列のoptr*/wordトークン,/*参照を解除する要素のインデックス*/</PRE>
<PRE CLASS="syntax">dword callbackData, /*コールバックルーチンに渡される*/void_pascal(*callback)(void*element, dword valueForCallback));/*要素が実際に削除された場合にルーチンが呼び出される*/</PRE>
<P>このルーチンは、指定したエレメントの参照カウントをデクリメントします。 参照カウントがゼロになると、要素は削除されます。 要素を削除する場合は<CODE>ElementArrayRemoveReference()</CODE>は、その要素のコールバックルーチンを呼び出します。 コールバックルーチンは、必要なクリーンアップを実行する必要があります。コールバックルーチンには、要素へのポインタと<CODE>コールバックデータ</CODE>引数を指定します。 ヌルの関数ポインタを渡すと、コールバックルーチンは呼び出されません。</P>
<P>要素が削除されると、実際にはサイズが0に縮小され、空き要素のリストに追加されることに注意してください。 これにより、後の要素のインデックス番号が保持されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>(修正されていない限り)を呼び出す前に、グローバルヒープ上のブロックをロックします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_22.htm#IX_ElementArrayDelete()">ElementArrayDelete()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_23.htm_IX_ElementArrayRemoveReferenceHandles()"></A>
        <H1 CLASS="refHeading">ElementArrayRemoveReferenceHandles()</H1>
<PRE CLASS="syntax">void ElementArrayRemoveReferenceHandles(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandle ch, /*要素配列のチャンクハンドル*/wordトークン,/*参照を解除する要素のインデックス*/dword callbackData, /*コールバックルーチンに渡される*/void_pascal(*callback)(void*element, dword valueForCallback));/*要素が実際に削除された場合にルーチンが呼び出される*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayRemoveReference()">ElementArrayRemoveReference()</A></CODE>ただし、要素配列はグローバルハンドルとチャンクハンドル(optrではなく)で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_23.htm_IX_ElementArrayTokenToUsedIndex()"></A>
        <H1 CLASS="refHeading">ElementArrayTokenToUsedIndex()</H1>
<PRE CLASS="syntax">word ElementArrayTokenToUsedIndex(optr arr, /*要素配列のハンドル*/wordトークン,/*参照を解除する要素のインデックス*/dword callbackData, /*コールバックルーチンに渡されるデータ*/Boolean_pascal(*callback)/*この要素をカウントするためにtrueを返す*/(void*element, dword cbData));</PRE>
<P>このルーチンには、要素配列のトークンが渡されます。 これは、トークンを何らかの非標準索引付けスキームからの索引に変換します。 インデキシング系列は、使用中の要素(すなわち、参照カウントが0より大きい要素)のみをカウントするように、要素に0から番号を付けることも、より制限的な系列を使用することもできる。 コールバックルーチンが渡された場合、そのコールバックルーチンは使用されるすべての要素に対して呼び出されます。<EM>真</EM>要素をカウントするかどうかを指定します。 ヌルのコールバックポインタが渡されると、使用されたすべての要素がカウントされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_23.htm_IX_ElementArrayTokenToUsedIndexHandles()"></A>
        <H1 CLASS="refHeading">ElementArrayTokenToUsedIndexHandles()</H1>
<PRE CLASS="syntax">word ElementArrayTokenToUsedIndexHandles(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandle ch, /*要素配列のチャンクハンドル*/wordトークン,/*参照を解除する要素のインデックス*/dword callbackData, /***コールバックルーチンに渡されるデータ*/</PRE>
<PRE CLASS="syntax">Boolean_pascal(*callback)/*この要素を数えるにはtrueを返します*/(void*element, dword cbData));</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayTokenToUsedIndex()">ElementArrayTokenToUsedIndex()</A></CODE>ただし、要素配列はグローバルハンドルとチャンクハンドル(optrではなく)で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_23.htm_IX_ElementArrayUsedIndexToToken()"></A>
        <H1 CLASS="refHeading">ElementArrayUsedIndexToToken()</H1>
<PRE CLASS="syntax">word ElementArrayUsedIndexToToken(optr arr, /*optr to element array*/word index, /*このインデックスで要素のトークンを検索*/dword callbackData, /*これはコールバックルーチンに渡されます*/Boolean_pascal(*callback)/*この要素をカウントするにはtrueを返します*/(void*element, dword cbData));</PRE>
<P>このルーチンは、何らかの非標準のインデックス付けスキームから要素配列にインデックスを取得します。 このルーチンは、指定された要素を検出し、その要素のトークンを返します。 インデキシング系列は、使用中の要素(すなわち、参照カウントが0より大きい要素)のみをカウントするように、要素に0から番号を付けることも、より制限的な系列を使用することもできる。 コールバックルーチンが渡された場合、コールバックルーチンは使用されたすべての要素に対して呼び出されます。<EM>真</EM>要素をカウントするかどうかを指定します。 ヌルのコールバックポインタが渡されると、使用されたすべての要素がカウントされます。</P>
<P>一致する要素が見つからない場合は<CODE>ElementArrayUsedIndexToToken()</CODE>は、CA_NULL_ELEMENTを返す。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_23.htm_IX_ElementArrayUsedIndexToTokenHandles()"></A>
        <H1 CLASS="refHeading">ElementArrayUsedIndexToTokenHandles()</H1>
<PRE CLASS="syntax">word ElementArrayUsedIndexToTokenHandles(MemHandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandle ch, /*要素配列のハンドル*/word index, /*このインデックスで要素のトークンを検索*/dword callbackData, /***コールバックルーチンに渡されるデータ*/</PRE>
<PRE CLASS="syntax">Boolean_pascal(*callback)/*この要素を数えるにはtrueを返します*/(void*element, dword cbData));</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayUsedIndexToToken()">ElementArrayUsedIndexToToken()</A></CODE>ただし、要素配列はグローバルハンドルとチャンクハンドル(optrではなく)で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">chunkarr.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_24.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_24.htm_IX_FatalError()"></A>
        <H1 CLASS="refHeading">FatalError()[致命的エラー]</H1>
<PRE CLASS="syntax">void FatalError(単語errorCode);</PRE>
<P>このルーチンは致命的なエラーを引き起こし<CODE>エラーコード</CODE>デバッガ用。</P>
</DIV>
<DIV>
          <A NAME="R_24.htm_IX_FileClose()"></A>
        <H1 CLASS="refHeading">FileClose()[ファイルを閉じる]</H1>
<PRE CLASS="syntax">word FileClose(/*エラーを返します*/FileHandle fh, /*閉じるファイル*/Boolean noErrorFlag);/*アプリケーションの場合に設定します。 *エラー*/を処理できません</PRE>
<P>このルーチンは、開いているバイトファイルを閉じます。 ルーチンが成功した場合は0を返します。 ルーチンが失敗し<EM>noErrorFlag</EM>である<EM>偽の</EM>(すなわち、ゼロ)<CODE>FileClose()[ファイルを閉じる]</CODE>は<CODE>ファイルエラー</CODE>列挙型。 ルーチンが失敗し<EM>noErrorFlag</EM>である<EM>真</EM>(つまり、ゼロ以外)の場合、ルーチンは致命的なエラーとなる。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>の<CODE>noErrorFlag</CODE>パラメータは<CODE>真</CODE>デバッグ中のみ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_24.htm_IX_FileCommit()"></A>
        <H1 CLASS="refHeading">FileCommit()</H1>
<PRE CLASS="syntax">word FileCommit(/*エラーを返します*/FileHandle fh, Boolean noErrorFlag);/*エラーを処理できない場合に設定します*/</PRE>
<P><CODE>FileCommit()</CODE>ファイルシステムは、キャッシュされたファイル情報をただちにディスクに書き込むように強制されます。 成功した場合は0を返します。 失敗した場合は、エラーコードを返します。 ルーチンが失敗し<EM>noErrorFlag</EM>である<EM>真</EM>(つまり、0以外)の場合、ルーチンは致命的なエラーになります。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>の<CODE>noErrorFlag</CODE>パラメータは<CODE>真</CODE>デバッグ中のみ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_24.htm_IX_FileConstructFullPath()"></A>
        <H1 CLASS="refHeading">FileConstructFullPath()</H1>
<PRE CLASS="syntax">DiskHandle FileConstructFullPath(char**buffer, /*パス文字列はここに書き込まれます*/word bufSize, /*バッファ長(バイト単位)*/DiskHandle disk, /*ディスクまたは標準パス;*current path*/の場合はnull</PRE>
<PRE CLASS="syntax">const char*tail, /*ハンドルへの相対パス*/Boolean addDriveLetter);/*パスはドライブ*nameで始まるべきか? (注)</PRE>
<P>このルーチンは、GEOSディレクトリ指定を完全なパス文字列に変換します。 渡されたバッファに文字列を書き込みます。 ディレクトリは、次の2つの引数で指定します。 1つ目は<CODE>円板</CODE>はディスクのハンドルです。これは標準のパス定数である場合もあります。 (ヌルハンドルが渡された場合は、現在の作業ディレクトリが使用されます)。 2つ目は<CODE>尾</CODE>は、パスの末尾を表す文字列へのポインタです。<CODE>FileConstructFullPath()</CODE>は、この相対パスをディスクハンドルが示す場所に追加します。 次に、そのディスクのルートディレクトリから始まるフルパス文字列を構築し、渡されたバッファに書き込みます。 次の場合<EM>addDriveName</EM>である<EM>真</EM>(つまり0以外)の場合、パス文字列はドライブ名とコロンで始まります。 が指すポインタ<EM>緩衝剤</EM>は、構築された文字列の末尾を指すように更新されます。</P>
<P CLASS="refField"><STRONG>例:</STRONG>次の呼び出しは<CODE>FileConstructFullPath()</CODE>次のような結果が得られます。</P>
<P CLASS="figTitle">FileConstructFullPathへのサンプルコール()</P>
<PRE>/*ここでは、DOCUMENTディレクトリのサブディレクトリのフルパスを調べます*/</PRE>
<PRE>DiskHandle documentDisk;char pathBuffer[256];/*ほとんどのパスに対して十分な長さ*/char*pB=&amp;pathBuffer;</PRE>
<PRE>documentDisk=FileConstructFullPath(&amp;pB, /*ポインタへのポインタ*/256, /*バッファ長*/SP_DOCUMENT, /*これはディスクまたは*標準パス*/&quot;MEMO\\JANUARY&quot;,/*C文字列では、*バックスラッシュは*2倍にする必要があります*/TRUE);/*ドライブ名を先頭に追加します*/</PRE>
<PRE>/*標準パスがデフォルト設定で設定されている場合、「documentDisk」*はメインハードドライブのハンドルになり、pathBufferには「C:\GEOWORKS\DOCUMENT\MEMOS\JANUARY」*/のような*文字列が含まれます。</PRE>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FileParseStandardPath()">FileParseStandardPath()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_24.htm_IX_FileCopy()"></A>
        <H1 CLASS="refHeading">ファイルコピー()</H1>
<PRE CLASS="syntax">word FileCopy(/*エラーを返します*/const char*source, /*ソースパスとファイル名*/const char*dest, /*デスティネーションパスとファイル名*/DiskHandle sourceDisk, /*これらのハンドルはStandard*/DiskHandle destDiskの場合があります);/*パス定数、または*現在の作業ディレクトリを決定する*/</PRE>
<P>このルーチンは、ファイルのコピーを作成します。 ソースと宛先はパス文字列で指定されます。 各文字列は、対応するディスクハンドルで指定された場所からの相対パスを指定します。 ハンドルがディスクハンドルの場合、パスはそのディスクのルートからの相対パスになります。 ディスクハンドルが標準パスの定数の場合、パス文字列はその標準パスからの相対パスになります。 ディスクハンドルがヌルの場合、パスは現在の作業ディレクトリからの相対パスになります。</P>
<P>次の場合<CODE>ファイルコピー()</CODE>が成功した場合は0を返す。 それ以外の場合は、次のいずれかのエラーコードを返します。</P>
<DL>
<DT>エラー_ファイル_見つかりません</DT><DD>そのようなソースファイルは指定されたディレクトリに存在しません。</DD>
<DT>エラー_パス_が見つかりません</DT><DD>無効なソースまたは宛先のパス文字列が渡されました。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>宛先ファイルの既存のコピーを削除する権限がないか、宛先ディスクまたはディレクトリが書き込み可能ではありません。</DD>
<DT>エラー_ファイル_使用中</DT><DD>一部のgeodeでは、既存の保存先ファイルが開いています。</DD>
<DT>ERROR_SHORT_READ_WRITE(エラー-短-読み取り-書き込み)</DT><DD>コピー先のディスクに十分な領域がありませんでした。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileMove()">FileMove()[ファイル移動]</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_25.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_25.htm_IX_FileCreate()"></A>
        <H1 CLASS="refHeading">FileCreate()関数</H1>
<PRE CLASS="syntax">FileHandle FileCreate(/*スレッドのエラー値を設定*/const char*name, /*作業ディレクトリからの相対パス*/FileCreateFlagsフラグ,/*下記参照*/FileAttrs属性);/*新しいファイルのFileAttrs*/</PRE>
<P>このルーチンは、バイトファイルを作成します。 このファイルは、DOSファイルでもGEOSバイトファイルでもかまいません。 ファイルが正常に開かれると<CODE>FileCreate()関数</CODE>はファイルのハンドルを返す。それ以外の場合はヌルハンドルを返し、スレッドのエラー値を設定する。</P>
<P>2番目のパラメータはword-lengthです。<CODE>FileCreateFlags</CODE>レコード。 3番目のパラメータ<CODE>属性#ゾク</CODE>については、を参照してください。<CODE>FileAttrs</CODE>新しいファイルに設定するレコード。</P>
<P>成功した場合<CODE>FileCreate()関数</CODE>はファイルのハンドルを返す。 失敗した場合はヌルハンドルを返し、スレッドのエラー値を設定します(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。 一般に、次のエラー値が返されます。</P>
<DL>
<DT>エラー_パス_が見つかりません</DT><DD>相対パスまたは絶対パスが渡されましたが、パスに存在しないディレクトリが含まれていました。</DD>
<DT>ERROR_TOO_MANY_OPEN_FILES(開いているファイルが多すぎます)</DT><DD>一度に開くことができるファイルの数には制限があります。 この制限に達すると<CODE>FileCreate()関数</CODE>はファイルが閉じられるまで失敗する。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>呼び出し元が許可できないアクセスを要求したか(例えば、別のgeodeがFILE_DENY_Wで既にファイルを開いているときに書き込みアクセスを要求した)、あるいは呼び出し元が別のgeodeに既にアクセスが許可されているときにアクセスを拒否しようとしたか(例えば、別のgeodeが書き込みアクセスのために既にファイルを開いているときにFILE_DENY_Wでファイルを開こうとした)のいずれかです。</DD>
<DT>ERROR_WRITE_PROTECTED(エラー書き込み保護)</DT><DD>呼び出し元が、書き込み保護されたボリューム内のファイルへの書き込みアクセスまたは読み取り/書き込みアクセスを要求しました。</DD>
<DT>エラー_ファイル_が存在します</DT><DD>次の場合に返されます。<CODE>FileCreate()関数</CODE>がFILE_CREATE_ONLYで呼び出され、指定された名前のファイルがすでに存在します。</DD>
<DT>ERROR_FILE_FORMAT_MISMATCH(エラーファイル形式の不一致)</DT><DD>次の場合に返されます。<CODE>FileCreate()関数</CODE>がFILE_CREATE_TRUNCATEまたはFILE_CREATE_NO_TRUNCATEで呼び出され、ファイルが目的とは異なる形式で存在する場合。つまり、FCF_NATIVEが渡され、ファイルがすでにGEOS形式で存在する場合、またはその逆の場合。</DD>
</DL>
<P CLASS="refField"><STRONG>例:</STRONG>以下に使用例を示します。</P>
<P CLASS="figTitle">FileCreate()の使用例</P>
<PRE>/*ここでは、現在の作業ディレクトリにDOSファイルを作成します。 ファイルがすでに*存在する場合は、既存のファイルを開いて切り詰めます。 (注)</PRE>
<PRE>FileHandle newFile;ファイルハンドルnewFile;</PRE>
<PRE>newFile=FileCreate(&quot;newFile.TXT&quot;,((FILE_CREATE_TRUNCATE FCF_NATIVE)(FILE_ACCESS_RW FILE_DENY_RW)),0);/*属性ビットを設定しない*/</PRE>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreateTempFile()">FileCreateTempFile()</A></CODE><CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FileOpen()">ファイルを開く()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_25.htm_IX_Directories (file system):creation"></A>
          <A NAME="R_25.htm_IX_FileCreateDir()"></A>
        <H1 CLASS="refHeading">FileCreateDir()</H1>
<PRE CLASS="syntax">word FileCreateDir(/*エラーを返し、スレッドのエラー値を設定する*/const char*name);/*新しいディレクトリの相対パス*/</PRE>
<P>このルーチンは、新しいディレクトリを作成します。 パラメータはパス文字列で、パスは現在のディレクトリからの相対パスです。 パス文字列の最後の要素は、作成するディレクトリである必要があります。</P>
<P>次の場合<CODE>FileCreateDir()</CODE>が成功した場合は0を返し、スレッドのエラー値をクリアする。 それ以外の場合は、エラーコードを返し、スレッドのエラー値を設定します(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。 次のエラーが返されます。</P>
<DL>
<DT>エラー_パスが長すぎます</DT><DD>パス文字列が、そのデバイスのファイルシステムで許可されている長さを超えています。</DD>
<DT>エラー_ファイル_が存在します</DT><DD>指定された名前のファイルまたはディレクトリが、指定された場所に既に存在します。</DD>
<DT>エラー_無効な名前</DT><DD>渡された名前は、そのデバイス上のディレクトリには不適切でした。</DD>
<DT>ERROR_DISK_STALE(古いディスクエラー)</DT><DD>ディスクが取り付けられていたドライブが取り外されました。</DD>
<DT>ERROR_DISK_UNAVAILABLE(エラーディスク使用不可)</DT><DD>そのドライブのディスクの検証は、ユーザーによって中止されました。</DD>
<DT>エラー_パス_が見つかりません</DT><DD>パス文字列が何らかの形で無効でした。たとえば、次のように指示された可能性があります。<CODE>FileCreateDir()</CODE>存在しないディレクトリ内にディレクトリを作成します。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>スレッドが指定された場所にディレクトリを作成できないか、指定された名前のディレクトリがすでに存在します。</DD>
<DT>ERROR_WRITE_PROTECTED(エラー書き込み保護)</DT><DD>ボリュームは書き込み保護されています。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_26.htm#IX_FileDeleteDir()">FileDeleteDir()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_25.htm_IX_FileCreateTempFile()"></A>
        <H1 CLASS="refHeading">FileCreateTempFile()</H1>
<PRE CLASS="syntax">FileHandle FileCreateTempFile(/*スレッドのエラー値を設定します*/char*dir, /*ディレクトリ、作業ディレクトリからの相対パス。;*ファイル名が返されると、末尾の14個のnull*文字を置き換えます*/</PRE>
<PRE CLASS="syntax">FileCreateFlagsフラグ、FileAttrsアトリビュート);</PRE>
<P>このルーチンは、指定したディレクトリに一時ファイルを作成して開きます。 ルーチンは、一時ファイルの名前を自動的に選択します。 ファイルは必ず新しく作成され、このgeodeによってのみ使用されるため、作成フラグは必要ありません。 ディレクトリ文字列は、14バイトのNULLで終わる必要があります(新しいファイル名に置き換えるには十分です)。</P>
<P>次の場合<CODE>FileCreateTempFile()</CODE>が成功した場合、ファイルのハンドルと渡された文字列を返す。<CODE>ディレクトリ</CODE>末尾のヌル文字はファイル名に置き換えられます。 失敗した場合はNULLハンドルを返し、スレッドのエラー値を<CODE>ファイルエラー</CODE>(このエラー値には<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>」を参照してください。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>一時ファイルは通常、SP_PRIVATE_DATAのサブディレクトリに作成されます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreate()">FileCreate()関数</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_25.htm_IX_FileDelete()"></A>
        <H1 CLASS="refHeading">FileDelete()関数</H1>
<PRE CLASS="syntax">word FileDelete(/*エラーを返します*/const char*name);/*作業ディレクトリからの相対パス*/</PRE>
<P>このルーチンは、ファイルを削除します。 成功した場合は0を返し、それ以外の場合は<CODE>ファイルエラー</CODE>一般的なエラーは次のとおりです。</P>
<DL>
<DT>エラー_ファイル_見つかりません</DT><DD>指定されたディレクトリにはそのようなファイルは存在しません。</DD>
<DT>ERROR_WRITE_PROTECTED(エラー書き込み保護)</DT><DD>ボリュームは書き込み保護されています。</DD>
<DT>エラー_パス_が見つかりません</DT><DD>無効なパス文字列が渡されました。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>そのファイルを削除する権限がありません。</DD>
<DT>エラー_ファイル_使用中</DT><DD>一部のgeodeはそのファイルを開いています。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_26.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_26.htm_IX_Directories (file system):deletion"></A>
          <A NAME="R_26.htm_IX_FileDeleteDir()"></A>
        <H1 CLASS="refHeading">FileDeleteDir()</H1>
<PRE CLASS="syntax">word FileDeleteDir(/*エラーを返し、スレッドのエラー値を設定する*/const char*name);/*削除するディレクトリの相対パス*/</PRE>
<P>この引数は、既存のディレクトリを削除します。 パラメータは、カレントワーキングディレクトリを基準にしたディレクトリの位置を指定する文字列です。 パス文字列の最後の要素は、削除するディレクトリの名前である必要があります。</P>
<P>次の場合<CODE>FileDeleteDir()</CODE>が成功した場合は0を返し、スレッドのエラー値をクリアする。 それ以外の場合は、エラーコードを返し、スレッドのエラー値を設定します(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。 次のエラーが返されます。</P>
<DL>
<DT>エラー_パス_が見つかりません</DT><DD>指定されたディレクトリが見つからないか、存在しません。</DD>
<DT>ERROR_IS_CURRENT_DIRECTORY(エラー_現在のディレクトリ)</DT><DD>このディレクトリは、あるスレッドのカレントディレクトリであるか、またはあるスレッドのディレクトリスタック上にあります。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>スレッドにはディレクトリを削除する権限がありません。</DD>
<DT>ERROR_WRITE_PROTECTED(エラー書き込み保護)</DT><DD>ボリュームは書き込み保護されています。</DD>
<DT>エラー_ディレクトリ_NOT_EMPTY</DT><DD>指定されたディレクトリは空ではありません。 ディレクトリを削除するには、そのディレクトリが空である必要があります。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreateDir()">FileCreateDir()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_26.htm_IX_FileDuplicateHandle()"></A>
        <H1 CLASS="refHeading">FileDuplicateHandle()</H1>
<PRE CLASS="syntax">FileHandle FileDuplicateHandle(/*スレッドのエラー値を設定する*/FileHandle fh);</PRE>
<P>このルーチンは、開いているファイルのハンドルを複製し、そのハンドルを返します。 複製されたハンドルの読み取り/書き込み位置は、元のハンドルと同じです。 ファイルを閉じるには、両方のハンドルを閉じる必要があります。 エラーがある場合は<CODE>FileDuplicateHandle()</CODE>はヌルハンドルを返し、スレッドのエラー値を設定する(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_27.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_27.htm_IX_FileEnum()"></A>
          <A NAME="R_27.htm_IX_FileEnumParams"></A>
          <A NAME="R_27.htm_IX_FEP_&ldots;"></A>
          <A NAME="R_27.htm_IX_FileEnumSearchFlags"></A>
          <A NAME="R_27.htm_IX_FESF_&ldots;"></A>
          <A NAME="R_27.htm_IX_FileEnumStandardReturnType"></A>
          <A NAME="R_27.htm_IX_FESRT_&ldots;"></A>
          <A NAME="R_27.htm_IX_FEDosInfo"></A>
          <A NAME="R_27.htm_IX_DPI_&ldots;"></A>
        <H1 CLASS="refHeading">FileEnum()</H1>
<PRE CLASS="syntax">word FileEnum(/*返されたファイルの数を返します*/FileEnumParams*params, /*以下で説明します*/MemHandle*bufCreated, /*FileEnumはreturn-*バッファブロックを割り当て、そのハンドルを*ここに*書き込みます*/</PRE>
<PRE CLASS="syntax">word*numNoFit);/*処理されなかったファイルの数が*ここに書き込まれます*/</PRE>
<P>このルーチンは、ディレクトリ内のすべてのファイルを調べるために使用されます。 このルーチンは、ファイルに特定の拡張属性があるかどうかによってファイルをフィルタリングできます。 バッファを作成し、このバッファにファイルに関する情報を書き込みます。 このルーチンは、さまざまな方法で呼び出すことができます。<A HREF="../../Files/FileSys/FileSys_f.htm#51873">詳細はこちら</A>ボタンをクリックし</P><P CLASS="refField"><STRONG>構造:</STRONG><CODE>FileEnum()</CODE>は、いくつかの構造体と列挙型を使用します。 それらを以下に示し、構造の詳細な説明を以下に示す。</P>
<PRE CLASS="syntax">/*FileEnum()ルーチンに渡された型、値、構造体:*/</PRE>
<PRE CLASS="syntax">typedef enum/*word*/{FESRT_COUNT_ONLY, FESRT_DOS_INFO, FESRT_NAME, FESRT_NAME_AND_ATTR</PRE>
<PRE CLASS="syntax">}FileEnumStandardReturnType;typedef enum/*word*/{FESC_WILDCARD</PRE>
<PRE CLASS="syntax">}FileEnumStandardCallback;/*FileEnum()ルーチンが*返す型、値、構造体:*/</PRE>
<PRE CLASS="syntax">typedef struct{FileAttrs DFIS_attributes;FileDateAndTime DFIS_modTimeDate;dword DFIS_fileSize;FileLongName DFIS_name;DirPathInfo DFIS_pathInfo;</PRE>
<PRE CLASS="syntax">}FEDosInfo;typedef struct_FileEnumCallbackData{FileExtAttrDesc FECD_attrs[1];</PRE>
<PRE CLASS="syntax">}FileEnumCallbackData;typedef struct_FileEnumParams{FileEnumSearchFlags FEP_searchFlags;FileExtAttrDesc*FEP_returnAttrs;word FEP_returnSize;FileExtAttrDesc*FEP_matchAttrs;word FEP_bufSize;word FEP_skipCount;word_pascal(*FEP_callback)(struct_FileEnumParams*params, FileEnumCallbackData*fecd, word frame);FileExtAttrDesc*FEP_callbackAttrs;dword FEP_cbData1;dword FEP_cbData2;word FEP_headerSize;</PRE>
<PRE CLASS="syntax">}FileEnumParams;</PRE>
<P>に渡される情報の大部分<CODE>FileEnum()</CODE>に含まれる<CODE>FileEnumParams</CODE>構造。 構造体のフィールドは次のとおりです。</P>
<DL>
<DT><CODE>FEP検索フラグ</DT><DD></CODE>これはバイト長のフラグフィールドです。 フラグのタイプ<CODE>FileEnumSearchFlags</CODE>(下記参照)。 これらのフラグは、現在の場所にあるどのファイルを<CODE>FileEnum()</CODE>また、コールバックルーチンを使用するかどうかなども指定します。</DD>
<DT><CODE>FEP_returnAttrs</DT><DD></CODE>これは以下の配列へのポインタです。<CODE>FileExtAttrDesc</CODE>構造。 最後の構造には<CODE>FEA属性</CODE>フィールドをFEA_END_OF_LISTに設定します。 配列は、返される情報を指定します。<CODE>FileEnum()</CODE>である。<CODE>FileExtAttrDesc</CODE>構造は、通常とは少し異なる方法で使用されます。 すべてのファイルはリターンバッファにエントリを持ちます。このエントリには、要求されたすべての拡張属性情報が含まれます。 各<CODE>FileExtAttrDesc</CODE>構造体は、そのエントリのどこに情報を書き込むべきかを指定する。 の<CODE>FEAD値</CODE>フィールドにはオフセット値のみを含める必要があります。拡張属性は、そのオフセットでエントリに書き込まれます。(オフセットを指定するには、整数値をタイプにキャストします。<CODE>void*(空白)</CODE>」を参照してください。 の<CODE>FEADサイズ</CODE>valueは、戻り値の長さを指定します。 特定の戻り値を要求することもできます。<CODE>FEP_returnAttrs</CODE>のメンバーに等しい<CODE>FileEnumStandardReturnType</CODE>(この場合も<CODE>FileEnumStandardReturnType</CODE>タイプする値<CODE>void*(空白)</CODE>)をクリックします。 の<CODE>FileEnumStandardReturnType</CODE>列挙型については、このセクションの後半で説明します。</DD>
<DT><CODE>FEP_returnSize</DT><DD></CODE>これは、返されるバッファ内の各エントリのサイズです。 標準の戻り値の型または配列が<CODE>FileExtAttrDesc</CODE>構造体が渡された場合、返されるバッファの各エントリには、そのファイルに対して要求されたすべての拡張属性情報が含まれます。</DD>
<DT><CODE>FEP_matchAttrs</DT><DD></CODE>これは以下の配列へのポインタです。<CODE>FileExtAttrDesc</CODE>構造。 最後の構造には<CODE>FEA属性</CODE>フィールドをFEA_END_OF_LISTに設定します。<CODE>FileEnum()</CODE>は、属性がこの配列で指定されたものと一致しないすべてのファイルを自動的に除外し、無視します。 ワードサイズのレコードである属性の場合<CODE>FEAD_value.オフセット</CODE>設定する必要のあるビットを保持し<CODE>FEAD_value.セグメント</CODE>は、クリアする必要があるビットを保持します。 バイトサイズのフラグの場合<CODE>FEAD_value.offset.low(FEAD値オフセット低)</CODE>には、設定する必要があるフラグが含まれています。<CODE>FEAD_value.offset.high(FEAD値オフセット高)</CODE>には、クリアする必要があるフラグが含まれています。 バイトサイズおよびワードサイズの非フラグ値は<CODE>FEAD_value.オフセット</CODE>その他すべての値については<CODE>FEAD値</CODE>はマッチする正確な値へのポインタを保持し<CODE>FEADサイズ</CODE>値の長さ(バイト単位)を指定します。 ワーキングディレクトリ内のファイルをフィルタリングしない場合、またはコールバックルーチンを使用してファイルをフィルタリングする場合は、このフィールドにヌルポインタを渡します。</DD>
<DT><CODE>FEPバッファ</DT><DD>イジング<BR></CODE>バッファに返されるエントリの最大数を指定します。 制限を設定しない場合は、定数FE_BUFSIZE_UNLIMITEDを渡します。 バッファは必要に応じて拡張されます。</DD>
<DT><CODE>FEP_skipCount(FEP</DT><DD></CODE>これには、最初のファイルが処理される前に無視される一致ファイルの数が含まれます。 これは、多くの場合<CODE>FEP_bufSize&lt;ファイル名></CODE>多数のファイルを一度に数個ずつ検査します。 たとえば、一度に10個のファイルのみを検査する場合は<CODE>FEP_bufSize&lt;ファイル名></CODE>10まで<CODE>FEP_skipCount(FEP</CODE>ゼロにします<CODE>FileEnum()</CODE>検索条件に一致する最初の10個のファイルのデータが返されます。 返されたデータを処理した後、ファイルが残っている場合は<CODE>FileEnum()</CODE>今度は<CODE>FEP_skipCount(FEP</CODE>10に設定します。<CODE>FileEnum()</CODE>は次の10個の一致するファイルを処理し、それらに関するデータを返します。 このようにして、ディレクトリ内のすべての一致するファイルを調べることができます。 ただし<CODE>FileEnumSearchFlags</CODE>ビットFESF_REAL_SKIPが設定されている(FEP<CODE>検索フラグ(_F)</CODE>)、ディレクトリ内の最初のファイルはスキップされます。<EM>前に</EM>一致するかどうかがテストされます。 これにより、ディレクトリ内の最初のファイルに対して一致条件をチェックする必要がなくなるため、処理が速くなります。</DD>
<DT><CODE>FEP_コールバック</DT><DD></CODE>これは、ブールコールバックルーチンへのポインタを保持します。 コールバックルーチンは、ファイルが他の任意の基準に一致するかどうかを確認できます。 コールバックルーチンは、上記のすべての条件に一致するファイルに対して呼び出されます。 _pascalと宣言する必要があります。 これには3つの引数が渡されます。<CODE>FileEnumParams</CODE>構造体へのポインタ、現在のスタックフレーム(一部のアセンブリコールバックルーチンで使用される)へのポインタ、および<CODE>FileExtAttrDesc</CODE>構造。 これらの構造体は、return、matching、またはcallbackのいずれかに必要なすべての属性です(FEP<CODE>_callbackAttrs</CODE>以下を参照)、現在のファイルの情報を入力します。必要な情報を直接検索することも<CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileEnumLocateAttr()">FileEnumLocateAttr()</A></CODE>この配列を検索します。 によってファイルが受け入れられる必要があるかどうか<CODE>FileEnum()</CODE>を指定した場合、コールバックは<EM>真</EM>;それ以外の場合は<EM>偽の</EM>次のように指示することもできます。<CODE>FileEnum()</CODE>のメンバーを渡すことで、標準コールバックルーチンの1つを使用します。<CODE>FileEnumStandardCallback</CODE>列挙型。 この場合<CODE>FEP_callbackAttrs</CODE>は無視されます。<CODE>FileEnum()</CODE>は適切な情報をコールバックルーチンに自動的に渡します。 (FESF_CALLBACKビットが<CODE>FEP検索フラグ</CODE>フィールドが設定されていない場合<CODE>FEP_コールバック</CODE>フィールドは無視されます)。</DD>
<DT><CODE>FEP_callbackAttrs</DT><DD></CODE>これは以下の配列へのポインタです。<CODE>FileExtAttrDesc</CODE>構造。 最後の構造には<CODE>FEA属性</CODE>フィールドをFEA_END_OF_LISTに設定します。 コールバックルーチンが呼び出される前に、配列に各ファイルの適切な情報が入力されます。 のFESF_CALLBACKビットが<CODE>FEP検索フラグ</CODE>が設定されていない場合<CODE>FEP_callbackAttrs</CODE>は無視されます。 コールバックルーチンに属性を渡す必要がない場合は、このフィールドをヌルポインタに設定します。</DD>
<DT><CODE>FEP_cbData1(FEP_cb</CODE><CODE>FEP_cbData2(FEP_cb</DT><DD></CODE>これらはdワード長のフィールドです。 これらの内容は<CODE>FileEnum()</CODE>;コールバックルーチンに情報を渡すために使用されます。 標準のコールバックルーチンを呼び出さない場合は、これらのフィールドを自由に使用できます。</DD>
<DT><CODE>FEPヘッダサイズ</DT><DD></CODE>フラグFESF_LEAVE_HEADERが設定されている場合<CODE>FileEnum()</CODE>はリターンバッファの先頭に空のヘッダ領域を残す。 ヘッダーのサイズはこのフィールドで指定されます。FESF_LEAVE_HEADERが消去されている場合、このフィールドは無視されます。</DD>
</DL>
<P>の最初のフィールド<CODE>FileEnumParams</CODE>構造<CODE>FEP検索フラグ</CODE>は、以下を含むワード長のレコードです。<CODE>FileEnumSearchFlags</CODE>次のフラグを使用できます。</P>
<DL>
<DT>FESFディレクトリ</DT><DD>ディレクトリは、次の方法で調べる必要があります。<CODE>FileEnum()</CODE>ボタンをクリックし</DD>
<DT>FESF_NON_GEOS[サーフェス非表示]</DT><DD>非GE OSファイルは次の方法で調べる必要があります。<CODE>FileEnum()</CODE>ボタンをクリックし</DD>
<DT>FESF_GEOS_EX ECの場合</DT><DD>GEOS実行可能ファイルは、次の方法で検査する必要があります。<CODE>FileEnum()</CODE>ボタンをクリックし</DD>
<DT>FESF_GEOS_NON_EX EC(非実行)</DT><DD>GEOSの非実行可能ファイル(VMファイルなど)は、次の方法で検査する必要があります。<CODE>FileEnum()</CODE>ボタンをクリックし</DD>
<DT>FESF_REAL_SKIP(実際のスキップ)</DT><DD>のスキップカウントが<EM>ん</EM>が指定された場合、最初の<EM>ん</EM>渡された属性と一致するかどうかにかかわらず、ファイルはスキップされます。 この場合<CODE>FileEnum()</CODE>は、バッファを満たすのに十分なファイルを取得するために通過したファイルの数を返します。したがって、戻り値は次のパスの実際のスキップ回数になります。</DD>
<DT>FESF_CALLBACK(FESF_コールバック</DT><DD><CODE>FileEnum()</CODE>はコールバックルーチンを呼び出して、ファイルを受け入れるべきかどうかを判断します。</DD>
<DT>FESF_LOCK_CB_DATA(FESF_ロック_CB_データ)</DT><DD>このフラグは<CODE>FileEnumParams</CODE>フィールド#フィールド#<CODE>FEP_コールバック1</CODE>および<CODE>FEP_コールバック2</CODE>は移動可能なメモリへの遠いポインタであり、移動可能なメモリをロックする必要がある。<CODE>FileEnum()</CODE>が呼び出されます。</DD>
<DT>FESF_LEAVE_HEADER(ヘッダを残す)</DT><DD>設定すると<CODE>FileEnum()</CODE>は、リターンバッファの先頭に空のヘッダ領域を残すべきである。 このバッファのサイズは<CODE>FEPヘッダサイズ</CODE>見出しページを開きます。</DD>
</DL>
<P>の<CODE>FileEnumStandardReturnType</CODE>列挙型には次の値があります。これらの値は<CODE>FEP_returnAttrs</CODE>の<CODE>FileEnumParams</CODE>構造。</P>
<DL>
<DT>「FESRTカウントのみ」(Snow_COUNT_ONLY)</DT><DD><CODE>FileEnum()</CODE>はメモリを割り当てず、ファイルに関するデータを返しません。代わりに、指定された条件に一致するファイルの数を返します。</DD>
<DT>FESRT情報</DT><DD><CODE>FileEnum()</CODE>は以下の配列を返す。<CODE>FEDosInfo</CODE>構造。 これらの構造体には、ファイルに関する基本的な情報(仮想名、サイズ、変更日、DOS属性、パス情報など)が含まれます。<CODE>DirPathInfo</CODE>記録)。</DD>
<DT>FESRT名</DT><DD><CODE>FileEnum()</CODE>は以下の配列を返す。<CODE>FileLongName</CODE>各文字列はFILE_LONGNAME_BUFFER_SIZE文字の長さです。各文字列には、ファイルの仮想名の後にヌル終端文字が含まれます。</DD>
<DT>FESRT名と属性</DT><DD><CODE>FileEnum()</CODE>は以下の配列を返す。<CODE>FENameAndAttr</CODE>各構造体には、ファイルのDOS属性と仮想名が含まれています。</DD>
</DL>
<P>の<CODE>FEDosInfo</CODE>構造体には、ワードサイズのレコード(<CODE>DFISパス情報</CODE>)は、標準パスを基準にしたファイルの位置を示します。 次のフィールドがあります。</P>
<DL>
<DT>DPI_EXISTS_LOCALLY[ローカルに存在する</DT><DD>このビットは、ファイルがプライマリツリーの下のディレクトリに存在する場合に設定されます。</DD>
<DT>DPIエントリ番号インパス</DT><DD>これは、オフセットがDPI_ENTRY_NUMBER_IN_PATH_OFFSETである7ビットフィールドのマスクです。</DD>
<DT>DPI標準パス</DT><DD>これは、オフセットがDPI_STD_PATH_OFFSETである8ビットフィールドのマスクです。 ファイルが標準パスにある場合、このフィールドには<CODE>StandardPath</CODE>ファイルを含む標準パスの定数。 これは、「最も近い」標準パスである必要はありません。たとえば、ファイルが「World」ディレクトリにある場合でも、この定数はSP_TOPになります。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileEnumLocateAttr()">FileEnumLocateAttr()</A></CODE><CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileEnumWildcard()">FileEnumWildcard()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">fileEnum.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_28.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_28.htm_IX_FileEnumLocateAttr()"></A>
        <H1 CLASS="refHeading">FileEnumLocateAttr()</H1>
<PRE CLASS="syntax">void*FileEnumLocateAttr(/*attrが見つからない場合はNULLを返す*/FileEnumCallbackData*fecd, /*コールバックルーチンに渡される*/FileExtendedAttribute attr, /*この属性を検索する*/const char**name);/*属性名(2番目の*引数がFEA_CUSTOMの場合)*/</PRE>
<P><CODE><A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>にコールバックルーチンを呼び出して、除外するファイルを決定するように指示することができます。 このコールバックルーチンには<CODE>FileExtAttrDesc</CODE>構造。 この配列内の特定の拡張属性を検索するには<CODE>FileEnumLocateAttr()</CODE>このルーチンは、目的の属性の値のアドレスを検索し、そのアドレスを返します。 属性が配列にない場合は<CODE>FileEnumLocateAttr()</CODE>はNULLポインタを返す。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">fileEnum.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_28.htm_IX_FileEnumWildcard()"></A>
        <H1 CLASS="refHeading">FileEnumWildcard()</H1>
<PRE CLASS="syntax">Boolean FileEnumWildcard(FileEnumCallbackData*fecd, /*コールバックルーチンに渡された*/wordフレーム);/*継承されたスタックフレーム*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>アプリケーションではほとんど使用されません。 現在のファイルの仮想名(現在評価中のファイル)が<CODE><A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>)は<CODE>FEP_cbData1(FEP_cb</CODE>の<CODE>FileEnumParams</CODE>構造。</P>
<P>の<EM>モデム</EM>パラメータは、コールバック関数の<CODE><A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>ルーチン。 frameパラメータは<CODE><A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>スタックフレーム: 最初のdワードは<CODE>FEP_cbData1(FEP_cb</CODE>フィールド、2番目は<CODE>FEP_cbData2(FEP_cb</CODE>見出しページを開きます。</P>
<P>このルーチンは<CODE>真</CODE>ファイル名とパターンが一致する場合は、(ゼロ以外)。 それ以外の場合は<CODE>偽の</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">fileEnum.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_28.htm_IX_TransferBlockID:extracting file handle from"></A>
          <A NAME="R_28.htm_IX_FileFromTransferBlockID() macro"></A>
        <H1 CLASS="refHeading">FileFromTransferBlockID()</H1>
<PRE CLASS="syntax">VMFileHandle FileFromTransferBlockID(id);TransferBlockID<EM>イド</EM>;をクリックし</PRE>
<P>このマクロは、型の値からVMFileHandleを抽出します。<CODE>TransferBlockID</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_28.htm_IX_FileGetAttributes()"></A>
        <H1 CLASS="refHeading">FileGetAttributes()</H1>
<PRE CLASS="syntax">FileAttrs FileGetAttributes(/*スレッドのエラー値を設定する*/const char*path);/*現在の*作業ディレクトリからの相対パス*/</PRE>
<P>このルーチンは、標準<CODE>FileAttrs</CODE>ファイルの属性。 ファイルは、GEOSファイルまたはプレーンDOSファイルのいずれかです。 ファイルのFEA_FILE_ATTR拡張属性を取得して、ファイルの属性を取得することもできます。 エラーが発生した場合、このルーチンはスレッドのエラーを設定します(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_13.htm#IX_FileAttrs">FileAttrs</A></CODE><CODE><A HREF="../../CRef/Routines/R_2b.htm#IX_FileSetAttributes()">FileSetAttributes()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_28.htm_IX_FileGetCurrentPath()"></A>
        <H1 CLASS="refHeading">FileGetCurrentPath()</H1>
<PRE CLASS="syntax">DiskHandle FileGetCurrentPath(char*buffer, /*パス文字列はここに書き込まれます*/word bufferSize);/*バッファのサイズ(バイト)*/</PRE>
<P>このルーチンは、現在のパス文字列(ドライブ指定なし)を指定されたバッファに書き込みます。 バッファが小さすぎる場合は、パスが収まるように切り捨てられます。 現在のパスを含むディスクのハンドルを返します。 現在のパスが標準パスからの相対パスとして宣言されている場合は、標準パスの定数が返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_28.htm_IX_FileGetDateAndTime()"></A>
        <H1 CLASS="refHeading">FileGetDateAndTime()</H1>
<PRE CLASS="syntax"><CODE>FileDateAndTime</CODE>FileGetDateAndTime(/*スレッドのエラー値を設定*/FileHandle fh);</PRE>
<P>このルーチンは、ファイルが最後に変更された時刻を検出します。 このルーチンは、GEOSファイルまたは非GEOSファイルで呼び出すことができます。 拡張属性FEA_MODIFICATIONをチェックして、ファイルの修正時間を確認することもできます。 失敗した場合は、スレッドのエラー値(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_14.htm#IX_FileDateAndTime">FileDateAndTime</A></CODE><CODE><A HREF="../../CRef/Routines/R_2b.htm#IX_FileSetDateAndTime()">FileSetDateAndTime()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_29.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_29.htm_IX_FileGetDiskHandle()"></A>
        <H1 CLASS="refHeading">FileGetDiskHandle()</H1>
<PRE CLASS="syntax">DiskHandle FileGetDiskHandle(/*スレッドのエラー値を設定する*/FileHandle fh);</PRE>
<P>このルーチンは、開いているファイルを含むディスクのハンドルを返します。 失敗した場合は、スレッドのエラー値(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_29.htm_IX_FileGetHandleExtAttributes()"></A>
        <H1 CLASS="refHeading">FileGetHandleExtAttributes()</H1>
<PRE CLASS="syntax">word length(FileHandle fh, /*ファイルのハンドルを開く*/FileExtendedAttribute属性,/*取得する属性*/void*バッファ,/*属性はここに書き込まれる*/word bufSize);/*バッファのFileGetHandleExtAttributes(バイト)*/</PRE>
<P>このルーチンは、開いているファイルの1つまたは複数の拡張属性を取得します。 (ファイルを開かずにファイルの属性を取得するには<CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileGetPathExtAttributes()">FileGetPathExtAttributes()</A></CODE>」を参照してください。 単一の属性が要求された場合、その属性は渡されたバッファに書き込まれます。 複数の属性が要求された場合<CODE>属性</CODE>FEA_MULTIPLEに設定する必要があります。<EM>緩衝剤</EM>の配列を指す必要があります。<CODE>FileExtAttrDesc</CODE>構造。 この場合<EM>bufSize/ファイルサイズ</EM>はバッファ内の構造体の数であり、バッファの長さではありません。</P>
<P>次の場合<CODE>FileGetHandleExtAttributes()</CODE>が成功した場合は0を返す。 それ以外の場合は、次のいずれかのエラーコードを返します。</P>
<DL>
<DT>エラー_ATTR_NOT_SUPPORTED</DT><DD>ファイルシステムは、渡された属性定数を認識しません。</DD>
<DT>エラー_属性_サイズ_不一致</DT><DD>渡されたバッファが、要求された属性に対して小さすぎました。</DD>
<DT>エラー_属性が見つかりません</DT><DD>ファイルにその属性の値が設定されていません。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>ファイルへの読み取りアクセス権がありません。</DD>
</DL>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>カスタム属性を復元する唯一の方法は、FEA_MULTIPLEを渡し<CODE>FileExtAttrDesc</CODE>属性を記述します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileGetPathExtAttributes()">FileGetPathExtAttributes()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_29.htm_IX_FileGetPathExtAttributes()"></A>
        <H1 CLASS="refHeading">FileGetPathExtAttributes()</H1>
<PRE CLASS="syntax">word FileGetPathExtAttributes(const char*path, /*現在の*作業ディレクトリからの相対パス*/</PRE>
<PRE CLASS="syntax">FileExtendedAttribute attr, /*取得する属性*/void*buffer, /*属性はここに書き込まれます*/word bufSize);/*バッファのバイト長*/</PRE>
<P>このルーチンは、GEOSファイルの1つまたは複数の拡張属性を取得します。 単一の属性が要求された場合、その属性は渡されたバッファに書き込まれます。 複数の属性が要求された場合<CODE>属性</CODE>FEA_MULTIPLEに設定する必要があります。<EM>緩衝剤</EM>の配列を指す必要があります。<CODE>FileExtAttrDesc</CODE>構造。 この場合<EM>bufSize/ファイルサイズ</EM>はバッファ内の構造体の数であり、バッファの長さではありません。</P>
<P>次の場合<CODE>FileGetPathExtAttributes()</CODE>が成功した場合は0を返す。 それ以外の場合は、次のいずれかのエラーコードを返します。</P>
<DL>
<DT>エラー_ATTR_NOT_SUPPORTED</DT><DD>ファイルシステムは、渡された属性定数を認識しません。</DD>
<DT>エラー_属性_サイズ_不一致</DT><DD>渡されたバッファが、要求された属性に対して小さすぎました。</DD>
<DT>エラー_属性が見つかりません</DT><DD>ファイルにその属性の値が設定されていません。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>ファイルへの読み取りアクセス権がありません。</DD>
</DL>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>カスタム属性を復元する唯一の方法は、FEA_MULTIPLEを渡し<CODE>FileExtAttrDesc</CODE>属性を記述します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileGetHandleExtAttributes()">FileGetHandleExtAttributes()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_29.htm_IX_FileLockRecord()"></A>
        <H1 CLASS="refHeading">FileLockRecord()</H1>
<PRE CLASS="syntax">word FileLockRecord(/*エラーを返します*/FileHandle fh, dword filePos, /*この位置からロックを開始します. */dword regLength);/*このバイト数をロックする*/</PRE>
<P>このルーチンは、バイトファイルの一部をロックします。 最初に、指定された領域にオーバーラップするロックが存在しないことを確認します。存在する場合は失敗し、ERROR_ALREADY_LOCKEDを返します。 ロックがない場合は、指定された領域にロックをかけ、0を返します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>領域をロックすると、スレッドは同じ領域の一部をロックできなくなりますが、領域からの読み取りや領域への書き込みはできなくなりません。 アプリケーションがこのメカニズムを使用する場合は<CODE>FileLockRecord</CODE>ファイルの一部にアクセスしようとする前。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2d.htm#IX_FileUnlockRecord()">FileUnlockRecord()</A></CODE><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_29.htm_IX_FileMove()"></A>
        <H1 CLASS="refHeading">FileMove()[ファイル移動]</H1>
<PRE CLASS="syntax">word FileMove(/*Returns error*/const char*source, /*source path and file name*/const char*dest, /*destination path and file name*/DiskHandle sourceDisk, /*これらのハンドルはStandard*/DiskHandle destDiskの場合があります);/*Path constants, or null to indi-*cate current working directory*/</PRE>
<P>このルーチンは、ファイルをある場所から別の場所に移動します。 ソースと宛先はパス文字列で指定されます。 各文字列は、対応するディスクハンドルで指定された場所からの相対パスを指定します。 ハンドルがディスクハンドルの場合、パスはそのディスクのルートからの相対パスになります。 ディスクハンドルが標準パスの定数の場合、パス文字列はその標準パスからの相対パスになります。 ディスクハンドルがヌルの場合、パスは現在の作業ディレクトリからの相対パスになります。</P>
<P>次の場合<CODE>FileMove()[ファイル移動]</CODE>が成功した場合は0を返す。 それ以外の場合は、次のいずれかのエラーコードを返し、スレッドのエラー値を設定します。</P>
<DL>
<DT>エラー_ファイル_見つかりません</DT><DD>そのようなソースファイルは指定されたディレクトリに存在しません。</DD>
<DT>エラー_パス_が見つかりません</DT><DD>無効なソースまたは宛先のパス文字列が渡されました。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>ソースファイルを削除する権限がないか、コピー先ファイルと同じ名前のファイルが既に存在する(かつ、そのファイルを削除する権限がない)か、コピー先のディスクまたはディレクトリが書き込み可能ではありません。</DD>
<DT>エラー_ファイル_使用中</DT><DD>コピー元のファイルが使用中であるか、コピー先のファイルと同じ名前のファイルが既に存在し、使用中です。</DD>
<DT>ERROR_SHORT_READ_WRITE(エラー-短-読み取り-書き込み)</DT><DD>コピー先のディスクに十分な領域がありませんでした。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_24.htm#IX_FileCopy()">ファイルコピー()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_2a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_2a.htm_IX_FileOpen()"></A>
        <H1 CLASS="refHeading">ファイルを開く()</H1>
<PRE CLASS="syntax">FileHandle FileOpen(/*スレッドのエラー値を設定*/const char*name, /*作業ディレクトリからの相対パス*/FileAccessFlagsフラグ);/*パーミッション/除外*/</PRE>
<P>このルーチンは、バイト単位のアクセス用にファイルを開きます。 このファイルは、DOSファイルでもGEOSバイトファイルでもかまいません。 ファイルが正常に開かれると<CODE>ファイルを開く()</CODE>はファイルのハンドルを返す。それ以外の場合はヌルハンドルを返し、スレッドのエラー値(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。 このルーチンによって設定される一般的なエラーを次に示します。</P>
<DL>
<DT>エラー_ファイル_見つかりません</DT><DD>指定された名前のファイルが適切なディレクトリに見つかりませんでした。</DD>
<DT>エラー_パス_が見つかりません</DT><DD>相対パスまたは絶対パスが渡されましたが、そのパスには存在しないディレクトリが含まれていました。</DD>
<DT>ERROR_TOO_MANY_OPEN_FILES(開いているファイルが多すぎます)</DT><DD>一度に開くことができるファイルの数には制限があります。 この制限に達すると<CODE>ファイルを開く()</CODE>はファイルが閉じられるまで失敗する。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>呼び出し元が許可できないアクセスを要求したか(例えば、別のgeodeがFILE_DENY_Wで既にファイルを開いているときに書き込みアクセスを要求した)、あるいは呼び出し元が別のgeodeに既にアクセスが許可されているときにアクセスを拒否しようとしたか(例えば、別のgeodeが書き込みアクセスのために既にファイルを開いているときにFILE_DENY_Wでファイルを開こうとした)のいずれかです。</DD>
<DT>ERROR_WRITE_PROTECTED(エラー書き込み保護)</DT><DD>呼び出し元が、書き込み保護されたボリューム内のファイルへの書き込みアクセスまたは読み取り/書き込みアクセスを要求しました。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreate()">FileCreate()関数</A></CODE><CODE><A HREF="../../CRef/Structs/S_12.htm#IX_FileAccessFlags">FileAccessFlags</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2a.htm_IX_FileParseStandardPath()"></A>
        <H1 CLASS="refHeading">FileParseStandardPath()</H1>
<PRE CLASS="syntax">StandardPath FileParseStandardPath(DiskHandle disk, const char**path);</PRE>
<P>このルーチンには、フルパス(渡されたディスクからの相対パス、またはディスクハンドルがヌルの場合は標準パス)が渡され、そのパスに最も近い標準パスが検索されます。 アドレスが渡されたポインタを更新して、パス文字列の末尾部分を指すようにします。 例えば、パス文字列&quot;\GEOWORKS\DOCUMENT\MEMOS\APRIL&quot;を渡すと、ポインタは&quot;\MEMOS\APRIL&quot;部分を指すように更新され<CODE>StandardPath</CODE>SP_DOCUMENTが返されます。 渡されたパスが標準パスに属していない場合、定数SP_NOT_STANDARD_PATHが返され、ポインタは変更されません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2a.htm_IX_FilePopDir()"></A>
        <H1 CLASS="refHeading">FilePopDir()</H1>
<PRE CLASS="syntax">void FilePopDir x</PRE>
<P><CODE>FilePopDir()</CODE>は、スレッドのディレクトリスタックから最上位ディレクトリを取り出し、それを現在の作業ディレクトリにする。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FilePushDir()">FilePushDir()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2a.htm_IX_FilePos()"></A>
        <H1 CLASS="refHeading">ファイル位置()</H1>
<PRE CLASS="syntax">dword FilePos(/*スレッドのエラー値を設定*/FileHandle fh, dword posOrOffset, FilePosModeモード);</PRE>
<P>このルーチンは、現在のファイル位置を変更します。 位置を指定するには<EM>モード(mode)</EM>引数:</P>
<DL>
<DT>ファイル位置開始</DT><DD>ファイル位置は、ファイルの先頭から指定されたバイト数後に設定されます。 このモードをオフセット0で渡すと、ファイルの位置はファイルの先頭に設定されます。</DD>
<DT>ファイル位置相対</DT><DD>ファイル位置は、指定されたバイト数だけ増分されます。この数は負の場合もあります。</DD>
<DT>ファイル位置終了</DT><DD>ファイル位置は、ファイルの末尾から指定されたバイト数だけ後ろに設定されます。通常は、負のバイト数で渡されます。 オフセットをゼロにしてこのモードを渡すと、ファイルの位置はファイルの末尾に設定されます。</DD>
</DL>
<P><CODE>ファイル位置()</CODE>は32ビットの整数を返す。 この整数は、移動後のファイルの絶対位置(ファイルの先頭からの相対位置)を指定します。 エラーが発生した場合には、スレッドのエラー値(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>現在のファイル位置を変更せずに確認するには<CODE>ファイル位置()</CODE>モードはFILE_POS_RELATIVEで、オフセットはゼロです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2a.htm_IX_FilePushDir()"></A>
        <H1 CLASS="refHeading">FilePushDir()</H1>
<PRE CLASS="syntax">void FilePushDir x</PRE>
<P><CODE>FilePushDir()</CODE>現在の作業ディレクトリをスレッドのディレクトリスタックにプッシュします。 現在の作業ディレクトリは変更されません。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FilePopDir()">FilePopDir()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2a.htm_IX_FileRead()"></A>
        <H1 CLASS="refHeading">FileRead()関数</H1>
<PRE CLASS="syntax">word FileRead(FileHandle fh, /*開いているファイルのハンドル*/void*buf, /*このバッファにデータをコピー*/word count, /*バッファ長(バイト単位)*/Boolean noErrorFlag);/*アプリケーションが*エラーを処理できない場合に設定*/</PRE>
<P>このルーチンは、ファイルからメモリにデータをコピーします。 ファイル内の現在の位置からコピーを開始します。 可能であれば、バッファを満たすのに十分なデータがコピーされます。 次の場合<CODE>FileRead()関数</CODE>が成功した場合、コピーされたバイト数を返す。 エラーが発生した場合は<CODE>FileRead()関数</CODE>は-1を返し、スレッドのエラー値を(通常はERROR_ACCESS_DENIEDに)設定する。 現在のファイル位置は、読み込まれたバイトの後の最初のバイトに変更されます。</P>
<P>Cでは、ERROR_SHORT_READ_WRITEエラーが発生したかどうかを判断する方法はありません。 すべてのデータが実際にメモリにコピーされたかどうかを確認するには、実際に読み取られたバイト数と、読み取られるように要求されたバイト数を比較する必要があります。 読み取り操作で複数の<CODE>FileRead()関数</CODE>操作では、0バイトが返されるまで読み込む必要があります。</P>
<P>スレッドのエラー値を取得するには<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>ボタンをクリックし</P>
<P>引数が<EM>noErrorFlag</EM>がに設定されている<EM>真</EM>(すなわち、非ゼロ)<CODE>FileRead()関数</CODE>は、エラー(ERROR_SHORT_READ_WRITEを含む)が発生した場合に致命的なエラーになります。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>パス(Pass)<CODE>noErrorFlag</CODE><CODE>真</CODE>デバッグ中のみ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_2b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_2b.htm_IX_FileRename()"></A>
        <H1 CLASS="refHeading">FileRename()[ファイル名を変更]</H1>
<PRE CLASS="syntax">word FileRename(const char*oldName, /*作業ディレクトリからの相対パス*/const char*newName);/*名前のみ、パスなし*/</PRE>
<P>このルーチンは、ファイルの名前を変更します。 ファイルを別のディレクトリに移動することはできません。<CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileMove()">FileMove()[ファイル移動]</A></CODE>ルーチンが成功した場合は0を返し、それ以外の場合は<CODE>ファイルエラー</CODE>一般的なエラーは次のとおりです。</P>
<DL>
<DT>エラー_ファイル_見つかりません</DT><DD>指定されたディレクトリにはそのようなファイルは存在しません。</DD>
<DT>エラー_パス_が見つかりません</DT><DD>無効なパス文字列が渡されました。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>そのファイルを削除する権限がないか、読み取り専用ボリュームに存在します。</DD>
<DT>エラー_ファイル_使用中</DT><DD>一部のgeodeはそのファイルを開いています。</DD>
<DT>エラー_無効な名前</DT><DD>名前が有効なGEOS名ではなかったか、ファイルが非GEOSファイルで、名前が適切なネイティブ名ではありませんでした。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileMove()">FileMove()[ファイル移動]</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2b.htm_IX_FileResolveStandardPath()"></A>
          <A NAME="R_2b.htm_IX_FileResolveStandardPathFlags"></A>
          <A NAME="R_2b.htm_IX_FRSPF_&ldots;"></A>
        <H1 CLASS="refHeading">FileResolveStandardPath()</H1>
<PRE CLASS="syntax">DiskHandle FileResolveStandardPath(char**バッファ,/*ここにパスを書き込む;ポインタを*パスの終わりを指すように更新する*/</PRE>
<PRE CLASS="syntax">word bufSize, /*バッファのサイズ(バイト単位)*/const char*path, /*ファイルの相対パス*/FileResolveStandardPathFlagsフラグ,/*フラグは後述*/FileAttrs*attrsPtr);/*空のバッファ、もしあれば渡されたファイルの属性で埋められる*/</PRE>
<P>このルーチンは、現在の場所からの相対パスでファイルを検索し、そのファイルへのフルパスをディスクのルート(<EM>しない</EM>標準パスで)。 渡されたバッファにパスを書き込み、パス文字列の最後のヌルを指すようにポインタを更新します。また、ディスクのハンドルも返します。 ファイルが見つからない場合は、nullパスが返されます。</P>
<P CLASS="refField"><STRONG>構造:</STRONG>の記録<CODE>FileResolveStandardPathFlags</CODE>に渡される<CODE>FileResolveStandardPath()</CODE>次のフラグを使用できます。</P>
<DL>
<DT>FRSPF_ADD_DRIVE_NAME</DT><DD>バッファに書き込まれるパス文字列は、ドライブ名で始まる必要があります(例:&quot;C:\GEOWORKS\DOCUMENT\MEMO&quot;)。</DD>
<DT>「最初の方向に戻る」(FRSPF_RETURN_FIRST_DIR)</DT><DD><CODE>FileResolveStandardPath()</CODE>は、渡されたパスが実際に存在するかどうかをチェックしません。代わりに、パスが標準パスを構成する最初のディレクトリに存在すると仮定し、それに応じて返す必要があります。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2b.htm_IX_FileSetAttributes()"></A>
        <H1 CLASS="refHeading">FileSetAttributes()</H1>
<PRE CLASS="syntax"><CODE>言葉</CODE>FileSetAttributes(/*エラー値を返す*/const char*path, /*現在の*作業ディレクトリからの相対パス*/</PRE>
<PRE CLASS="syntax">FileAttrs attr);/*ファイルの新しい属性*/</PRE>
<P>このルーチンは、DOSファイルまたはGEOSファイルの標準DOS属性を変更します。 拡張属性FEA_FILE_ATTRを設定して、ファイルの属性を変更することもできます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_13.htm#IX_FileAttrs">FileAttrs</A></CODE><CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileGetAttributes()">FileGetAttributes()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2b.htm_IX_FileSetCurrentPath()"></A>
        <H1 CLASS="refHeading">FileSetCurrentPath()</H1>
<PRE CLASS="syntax">DiskHandle FileSetCurrentPath(DiskHandleディスク、/*標準パス定数の場合あり*/const char*path);/*パス文字列、NULL終端*/</PRE>
<P>このルーチンは、現在のパスを変更します。 次の2つのパラメータが渡されます。 1つ目は、新しい現在のパスを含むディスクのハンドルです(これは標準パス定数の場合もあります)。 2番目はNULL終端されたパス文字列です。 これは通常のDOS規約で指定されます。ディレクトリはバックスラッシュで区切られ、ピリオド(&quot;.&quot;)は現在のディレクトリを示し、ピリオドのペア(&quot;.&quot;)は現在のディレクトリの親を示します。 文字列にワイルドカード文字を含めることはできません。</P>
<P>次の場合<CODE>円板</CODE>がディスクハンドルの場合、パスはそのディスクのルートディレクトリからの相対パスになります。<CODE>円板</CODE>は標準パスの定数で、パスは標準パスからの相対パスです。NULLの場合、パスは現在の作業ディレクトリからの相対パスです。<CODE>FileSetCurrentPath()</CODE>新しい現在のパスに関連付けられたディスクハンドルを返します。これは標準のパス定数の場合もあります。 次の場合<CODE>FileSetCurrentPath()</CODE>が失敗した場合はNULLハンドルを返す。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2c.htm#IX_FileSetStandardPath()">FileSetStandardPath()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2b.htm_IX_FileSetDateAndTime()"></A>
        <H1 CLASS="refHeading">FileSetDateAndTime()</H1>
<PRE CLASS="syntax"><CODE>言葉</CODE>FileSetDateAndTime(/*エラーを返す*/FileHandle fh, /*開いているファイルのハンドル*/FileDateAndTime dateAndTime);/*新しい変更時刻*/</PRE>
<P>このルーチンは、ファイルの最終変更のタイムスタンプを変更します。 このルーチンは、GEOSファイルまたは非GEOSファイルで呼び出すことができます。 拡張属性FEA_MODIFICATIONを変更して、ファイルの修正時間を変更することもできます。 失敗した場合、このルーチンはエラーを返し、スレッドのエラー値を設定します(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をクリックします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_14.htm#IX_FileDateAndTime">FileDateAndTime</A></CODE><CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileGetDateAndTime()">FileGetDateAndTime()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_2c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_2c.htm_IX_FileSetHandleExtAttributes()"></A>
        <H1 CLASS="refHeading">FileSetHandleExtAttributes()</H1>
<PRE CLASS="syntax">word length(/*エラーを返す*/FileHandle fh, /*開いているファイルのハンドル*/FileExtendedAttribute attr, /*取得する属性*/const void*buffer, /*ここから属性を読み込む*/word bufSize);/*バッファのFileGetPathExtAttributes(バイト)*/</PRE>
<P>このルーチンは、開いているGEOSファイルの1つまたは複数の拡張属性を設定します。 (ファイルを開かずにファイルの属性を設定するには<CODE><A HREF="../../CRef/Routines/R_2c.htm#IX_FileSetPathExtAttributes()">FileSetPathExtAttributes()</A></CODE>」を参照してください。 単一のアトリビュートが指定されている場合、渡されたバッファからアトリビュートの新しい値が読み込まれます。 複数の属性を変更する場合は<CODE>属性</CODE>FEA_MULTIPLEに設定する必要があります。<EM>緩衝剤</EM>の配列を指す必要があります。<CODE>FileExtAttrDesc</CODE>構造。 この場合<EM>bufSize/ファイルサイズ</EM>はバッファ内の構造体の数であり、バッファの長さではありません。</P>
<P>次の場合<CODE>FileSetHandleExtAttributes()</CODE>が成功した場合は0を返す。 それ以外の場合は、スレッドのエラー値(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)、次のいずれかのエラーコードを返します。</P>
<DL>
<DT>エラー_ATTR_NOT_SUPPORTED</DT><DD>ファイルシステムは、渡された属性定数を認識しません。</DD>
<DT>エラー_属性_サイズ_不一致</DT><DD>渡されたバッファーは、指定された属性に対して誤ったサイズでした。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD>呼び出し元にはファイルへの書き込みアクセス権がありません。</DD>
<DT>エラー_CAN_BE_SET</DT><DD>拡張属性は変更できません。 FEA_SIZEやFEA_NAMEなどの属性は<CODE>ファイルセット.()</CODE>ルーチン。</DD>
</DL>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>カスタム属性を作成または変更するには、FEA_MULTIPLEを渡し<CODE>FileExtAttrDesc</CODE>属性を記述します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2c.htm#IX_FileSetPathExtAttributes()">FileSetPathExtAttributes()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2c.htm_IX_FileSetPathExtAttributes()"></A>
        <H1 CLASS="refHeading">FileSetPathExtAttributes()</H1>
<PRE CLASS="syntax">word FileSetPathExtAttributes(const char*path, /*現在の*作業ディレクトリからの相対パス*/</PRE>
<PRE CLASS="syntax">FileExtendedAttribute attr, /*取得する属性*/const void*buffer, /*属性はここから読み込まれます*/word bufSize);/*バッファのバイト長*/</PRE>
<P>このルーチンは、ファイルの1つ以上の拡張属性を設定します。 単一の属性が指定された場合、その属性は渡されたバッファに書き込まれます。 複数の属性を変更する場合は<CODE>属性</CODE>FEA_MULTIPLEに設定し<EM>緩衝剤</EM>の配列を指す必要があります。<CODE>FileExtAttrDesc</CODE>構造。 この場合<EM>bufSize/ファイルサイズ</EM>はバッファ内の構造体の数であり、バッファの長さではありません。</P>
<P>次の場合<CODE>FileSetPathExtAttributes()</CODE>が成功した場合は0を返す。 それ以外の場合は、スレッドのエラー値(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)、次のいずれかのエラーコードを返します。</P>
<DL>
<DT>エラー_ATTR_NOT_SUPPORTED</DT><DD>ファイルシステムは、渡された属性定数を認識しません。</DD>
<DT>エラー_属性_サイズ_不一致</DT><DD>渡されたバッファーは、指定された属性に対して誤ったサイズでした。</DD>
<DT>エラー_アクセスが拒否されました</DT><DD><CODE>FileSetPathExtAttributes()</CODE>は、geode(呼び出し元を含む)が&quot;deny-write&quot;排他アクセスでファイルを開いている場合や、ファイルが書き込み不可の場合にこれを返す。</DD>
<DT>エラー_CAN_BE_SET</DT><DD>拡張属性は変更できません。 FEA_SIZEやFEA_NAMEなどの属性は<CODE>ファイルセット.ExtAttributes()</CODE>ルーチン。</DD>
</DL>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>カスタム属性を作成または変更するには、FEA_MULTIPLEを渡し<CODE>FileExtAttrDesc</CODE>属性を記述します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2c.htm#IX_FileSetHandleExtAttributes()">FileSetHandleExtAttributes()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2c.htm_IX_FileSetStandardPath()"></A>
        <H1 CLASS="refHeading">FileSetStandardPath()</H1>
<PRE CLASS="syntax">void FileSetStandardPath(StandardPathパス);/*設定するStandardPath*/</PRE>
<P>このルーチンは、現在の作業ディレクトリをシステムのStandardPathディレクトリの1つに変更します。 標準パスを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2c.htm_IX_FileSize()"></A>
        <H1 CLASS="refHeading">ファイルサイズ()</H1>
<PRE CLASS="syntax">dword FileSize(FileHandle fh);/*開いているファイルのハンドル*/</PRE>
<P>このルーチンは、指定されたオープンファイルのサイズを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_2d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_2d.htm_IX_FileTruncate()"></A>
        <H1 CLASS="refHeading">FileTruncate()</H1>
<PRE CLASS="syntax">word FileTruncate(FileHandle fh, /*開いているファイルのハンドル*/dword offset, /*切り捨てるオフセット*/Boolean noErrorFlag);</PRE>
<P>このルーチンは、渡されたオフセットで指定されたファイルを切り捨てます。 の<CODE>オフセット(offset)</CODE>パラメータは、必要なファイルサイズと考えることもできます。 高ビットの<EM>noErrorFlag</EM>が1の場合、エラーは返されません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2d.htm_IX_FileUnlockRecord()"></A>
        <H1 CLASS="refHeading">FileUnlockRecord()</H1>
<PRE CLASS="syntax">word FileUnlockRecord(/*エラーを返します*/FileHandle fh、/*開いているファイルのハンドルdword filePos、/*ここから始まるロックを解除します*/dword regLength);/*この長さです*/</PRE>
<P>このルーチンは、バイトファイルの一部のロックを解除します。 ロックは、以前に<CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileLockRecord()">FileLockRecord()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileLockRecord()">FileLockRecord()</A></CODE><CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2d.htm_IX_FileWrite()"></A>
        <H1 CLASS="refHeading">FileWrite()関数</H1>
<PRE CLASS="syntax">word FileWrite(/*スレッドのエラー値を設定する*/FileHandle fh, /*開いているファイルのハンドル*/const void*buf, /*ここからファイルにコピーする*/word count, /*コピーするバイト数*/Boolean noErrorFlag);/*エラーを処理できない場合に設定する*/</PRE>
<P>このルーチンは、指定されたバイト数をバッファからファイルにコピーします。 バイトは、ファイル内の現在の位置から書き込まれます。すでにその位置にあるデータは上書きされます。<CODE>FileWrite()関数</CODE>は書き込んだバイト数を返す。 次の場合<CODE>FileWrite()関数</CODE>すべてのデータを書き込むことができなかった場合(ディスクの容量が不足した場合など)、スレッドのエラー値を設定します(<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>)をERROR_SHORT_READ_WRITEに設定し、書き込まれたバイト数を返します。 ファイルにデータをまったく書き込むことができなかった場合(たとえば、ファイルへの書き込みアクセス権がない場合)、-1を返し、スレッドのエラー値をERROR_ACCESS_DENIEDに設定します。 いずれにしても、ファイルの位置は書き込まれたバイトの後の最初のバイトに変更されます。</P>
<P>引数が<EM>noErrorFlag</EM>がに設定されている<EM>真</EM>(すなわち、非ゼロ)<CODE>FileWrite()関数</CODE>エラーが発生した場合はfatal-errorを返します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>パス(Pass)<CODE>noErrorFlag</CODE><CODE>真</CODE>デバッグ中のみ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_2d.htm_IX_FloatAsciiToFloat()"></A>
          <A NAME="R_2d.htm_IX_FloatAsciiToFloatFlags"></A>
          <A NAME="R_2d.htm_IX_FAF_&ldots;"></A>
        <H1 CLASS="refHeading">FloatAsciiToFloat()</H1>
<PRE CLASS="syntax">Boolean FloatAsciiToFloat(/*成功時にFALSEを返す*/word floatAtoFflags, word stringLength, void*string, void*resultLocation);</PRE>
<P>このルーチンは、ASCII文字列を浮動小数点数に変換するために使用されます。 次の引数を取ります。</P>
<DL>
<DT><STRONG>floatAtoFflags</DT><DD></STRONG>この<CODE>FloatAsciiToFloatFlags</CODE>フィールドは、生成された浮動小数点数の処理方法を決定します。 最大1つのフラグを設定できます。FAF_PUSH_RESULTが設定されている場合、数値は浮動小数点スタックにプッシュされます。 FAF_STORE_NUMBERフラグが設定されている場合、番号はresultLocationのアドレスに返されます。</DD>
<DT><STRONG>文字列の長さ</DT><DD></STRONG>stringで渡されるバッファの長さです。</DD>
<DT>
          <STRONG>ストリング</STRONG>
        </DT><DD>このバッファには、変換するASCII文字列が含まれています。 文字列は&quot;[+-]dddd.dddd[E e][+-]dddd&quot;の形式でなければなりません。 文字列は正しいと見なされます。 小数点は多くても1つです。 スペースや桁区切り記号は無視されます。</DD>
<DT><STRONG>resultLocation</DT><DD></STRONG>FAF_STORE_NUMBERフラグを渡すと、resultLocationが指すバッファは浮動小数点数で埋められます。 このバッファは、少なくとも5ワードの長さが必要です。</DD>
</DIV>
</DL>
<HR>
          <A NAME="R_2e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_2e.htm_IX_FloatFloatToAscii()"></A>
          <A NAME="R_2e.htm_IX_FFA_dateTime"></A>
          <A NAME="R_2e.htm_IX_FFA_&ldots;  (FloatFloatToAsciiData structure)"></A>
          <A NAME="R_2e.htm_IX_FloatFloatToAsciiData"></A>
          <A NAME="R_2e.htm_IX_FloatFloatToAsciiParams"></A>
          <A NAME="R_2e.htm_IX_FloatFloatToAsciiFormatFlags"></A>
          <A NAME="R_2e.htm_IX_FFAF_&ldots;"></A>
          <A NAME="R_2e.htm_IX_FFA_dateTimeParams"></A>
          <A NAME="R_2e.htm_IX_FloatFloatToDateTime"></A>
          <A NAME="R_2e.htm_IX_FFA_&ldots;  (FloatFloatToDateTime structure)"></A>
          <A NAME="R_2e.htm_IX_FloatFormatToDateTimeFlags"></A>
          <A NAME="R_2e.htm_IX_FFDTT_&ldots;"></A>
        <H1 CLASS="refHeading">FloatFloatToAscii()</H1>
<PRE CLASS="syntax">word FloatFloatToAscii(/*ASCII文字列の文字数を返します*/FFA_stackFrame*stackFrame, char*resultString, FloatNum*number);</PRE>
<P>このルーチンは、浮動小数点数をASCII文字列に変換します。 複雑なデータ構造を使います<CODE>FFAスタックフレーム(FFA_stack</CODE>この構造体を指定せずに浮動小数点数をASCIIに変換するには<CODE>FloatFloatToAscii_StdFormat()</CODE>というメッセージを返します。 特別なフラグが渡されない限り、このルーチンは浮動小数点スタックのトップ番号を変換してポップします。<CODE>FloatFloatToAscii()</CODE>は、次の引数を取ります。</P>
<DL>
<DT>
          <STRONG>スタックフレーム(stackFrame)</STRONG>
        </DT><DD>これは<CODE>FFAスタックフレーム(FFA_stack</CODE>構造。 この構造体には<CODE>FloatFloatToAscii()</CODE>また、ルーチンはこの構造体に情報を返します。 この構造については、以下で詳しく説明します。</DD>
<DT>
          <STRONG>結果文字列</STRONG>
        </DT><DD>生成されたASCII文字列を保持するバッファへのポインタ。 このバッファは、FLOAT_TO_ASCII_NORMAL_BUF_LENまたはFLOAT_TO_ASCII_HUGE_BUF_LENバイトのいずれかでなければなりません。<STRONG>数</STRONG>(下記参照)。</DD>
<DT>
          <STRONG>数</STRONG>
        </DT><DD>浮動小数点数の形式を指定します。 FFAF_DONT_USE_SCIENTIFICの場合、バッファは<STRONG>結果文字列はFLOAT_TO_ASCII_HUGE_BUF_LENバイトの長さでなければならず、そうでなければFLOAT_TO_ASCII_NORMAL_BUF_LENバイトでなければならない。<P>FFAF_FROM_ADDRフラグを渡すと、浮動小数点スタックの先頭の数値が変換されるのではなく、この数値が変換されます。</DD>
</DL>
<P>このルーチンは、生成された文字列の文字数を明示的に返します。ヌル終端文字はカウントしません。 エラーが発生した場合は0を返します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef union{FloatFloatToAsciiData<A NAME="R_2e.htm_IX_FFA_float"></A>FFA_float;FloatFloatToDateTimeData FFA_dateTime;}FFA_stackFrame;<A NAME="R_2e.htm_IX_FFA_stackFrame"></A>typedef struct{FloatFloatToAsciiParams FFA_params;word FFA_startNumber;word FFA_decimalPoint;word FFA_endNumber;word FFA_numChars;word FFA_startExponent;word FFA_bufSize;word FFA_saveDI;word FFA_numSign;byte FFA_startSigCount;byte FFA_sigCount;byte FFA_noMoreSigInfo;byte FFA_startDecCount;byte FFA_decCount;word FFA_decExponent;word FFA_curExponent;byte FFA_useCommas;byte FFA_charsToComma;char FFA_commaChar;char FFA_decimalChar;}FloatFloatToAsciiData;</PRE>
<P>もしあなたが<CODE>FloatFloatToAsciiData</CODE>構造の場合は<CODE>FFAパラメータ</CODE>見出しページを開きます。 次の場合<CODE>FloatFloatToAscii()</CODE>その他のフィールドの一部には、潜在的に有用な情報が入力されています。</P>
<DL>
<DT><STRONG>FFA開始番号</DT><DD></STRONG>これは返された文字列へのオフセットで、数字の先頭を指します。</DD>
<DT><STRONG>FFA小数点</DT><DD></STRONG>これは、返された文字列へのオフセットで、小数点を指します。 文字列に小数点がない場合、このフィールドはゼロになります。</DD>
<DT><STRONG>FFA終了番号</DT><DD></STRONG>これは、返された文字列へのオフセットで、数字の末尾を指します。</DD>
<DT><STRONG>FFA文字数</DT><DD></STRONG>返される文字列の文字数です。エラーが発生した場合はゼロになります。 これはFloatFloatToAscii()の戻り値と同じです。</DD>
<DT><STRONG>FFA_startExponent</DT><DD></STRONG>これは、返される文字列へのオフセットで、「E」文字を指します。 文字列にそのような文字がない場合、このフィールドはゼロになります。</DD>
<DT>もう一方の<CODE>FloatFloatToAsciiData</CODE>フィールドは内部です。</DT>
</DL>
<PRE CLASS="syntax">typedef struct{FloatFloatToAsciiFormatFlags formatFlags;byte decimalOffset;byte totalDigits;byte decimalLimit;char preNegative[SIGN_STR_LEN+1];char postNegative[SIGN_STR_LEN+1];char prePositive[SIGN_STR_LEN+1];char postPositive[SIGN_STR_LEN+1];charヘッダー[PAD_STR_LEN+1];charトレーラ[PAD_STR_LEN+1];byte FFTAP_unused;}FloatFloatToAsciiParams;</PRE>
<P>の<CODE>FloatFloatToAsciiParams</CODE>構造がどのように<CODE>FloatFloatToAscii()</CODE>は、生成された文字列をフォーマットする必要があります 次のフィールドがあります。</P>
<DL>
<DT>
          <STRONG>書式フラグ</STRONG>
        </DT><DD>ア<CODE>FloatFloatToAsciiFormatFlags</CODE>フォーマットの微調整に使用されるフラグを含む構造体。</DD>
<DT><STRONG>decimalOffset</DT><DD></STRONG>小数点をオフセットする小数点以下の桁数を指定します。 たとえば、オフセットが-6の場合、数値は百万単位で表示されます。</DD>
<DT>
          <STRONG>合計桁数</STRONG>
        </DT><DD>最大桁数。 これは通常、MAX_DIGITS_FOR_NORMAL_NUMBERSです。 科学的記数法を使っているなら、これはおそらくMAX_DIGITS_FOR_HUGE_NUMBERSでしょう。</DD>
<DT><STRONG>decimalLimit</DT><DD></STRONG>10進数の最大桁数。この制限を満たすように数値が丸められます。</DD>
<DT><STRONG>preNegative</DT><DD></STRONG>負の数の前の文字。 文字列はNULLで終了する必要があります。 典型的な値は、「-」と「(」です。</DD>
<DT><STRONG>postNegative</DT><DD></STRONG>負の数の終了に使用される文字。 文字列はNULLで終了する必要があります。 一般的な値には、空の文字列と「)」があります。</DD>
<DT>
          <STRONG>プリポジティブ</STRONG>
        </DT><DD>正の数の前に付ける文字。 文字列はNULLで終了する必要があります。 一般的な値には、ヌルストリングと「+」があります。</DD>
<DT>
          <STRONG>postPositive(正の値</STRONG>
        </DT><DD>正の数の終了に使用する文字。 文字列はNULLで終了する必要があります。 通常、これは空の文字列です。</DD>
<DT>
          <STRONG>ヘッダー#ヘッダー#</STRONG>
        </DT><DD>番号の前の文字。 この文字列はNULLで終了する必要があります。 この文字列は、FFAF_SIGN_CHAR_TO_FOLLOW_HEADERフラグが設定されているかどうかに応じて、符号文字の前または後に表示されます。 通常、この文字列は空です。空でない場合は、FFAF_HEADER_PRESENTフラグを設定します。</DD>
<DT>
          <STRONG>トレーラー</STRONG>
        </DT><DD>番号の後に続く文字。 この文字列はNULLで終了する必要があります。 この文字列が符号の前後にあるかどうかは、FFAF_SIGN_CHAR_TO_PRECEDE_TRAILERフラグによって決定されます。 通常、この文字列は空です。空でない場合は、FFAF_TRAILER_PRESENTフラグを設定します。</DD>
</DL>
<PRE CLASS="syntax">typedef WordFlags FloatFloatToAsciiFormatFlags;#define FFAF_FLOAT_RESERVED 0x8000#define FFAF_FROM_ADDR 0x4000#define FFAF_DONT_USE_SCIENTIFIC 0x0200#define FFAF_SCIENTIFIC 0x0100#define FFAF_PERCENT 0x0080#define FFAF_USE_COMMAS 0x0040#define FFAF_NO_TRAIL_ZEROS 0x0020#define FFAF_NO_LEAD_ZERO 0x0010#define FFAF_HEADER_PRESENT 0x0008#define FFAF_TRAILER_PRESENT 0x0004#define FFAF_SIGN_CHAR_TO_FOLLOW_HEADER 0x0002#define FFAF_SIGN_CHAR_TO_PRECEDE_TRAILER 0x0001</PRE>
<P>の<CODE>FloatFloatToAsciiFormatFlags</CODE>フィールドには、次のフラグが含まれます。</P>
<DL>
<DT>FFAF_FLOAT_RESERVED(浮動小数点予約)</DT><DD>このフラグはゼロでなければなりません。</DD>
<DT>FFAF_FROM_ADDR(アドレスからのFFAF)</DT><DD>通常<CODE>FloatFloatToAscii()</CODE>は浮動小数点スタックの先頭にある数値を変換する。 このフラグを渡すことで、ルーチンは代わりに<EM>数</EM>引数を指定します。</DD>
<DT>FFAF_DONT_USE_SCIENTIFIC[###DONT_USE_</DT><DD>このフラグを設定すると、指数表記の使用が抑制されます。 可能であれば、ゼロパディングが使用されます。</DD>
<DT>FFAF_指数関数</DT><DD>指数表記を強制するには、このフラグを設定します。</DD>
<DT>「FFAFパーセント」(FFAF_PERCENT)</DT><DD>数値をパーセンテージで表示するには、このフラグを設定します。</DD>
<DT>カンマの使用(FFAF_USE_COMMAS)</DT><DD>カンマ区切りを使用するには、このフラグを設定します。</DD>
<DT>「FFAF基準線なしゼロ」(FFAF_NO_TRAIL_ZEROS)</DT><DD>このフラグを設定すると、数字の末尾にゼロが追加されます。</DD>
<DT>「FFAFリードなしゼロ」(FFAF_NO_LEAD_ZERO)</DT><DD>このフラグを設定すると、整数値の前にゼロが表示されます。 たとえば、「.53」は「0.53」と表示されます。</DD>
<DT>FFAF_HEADER_PRESENT(ヘッダーあり)</DT><DD>ヘッダー文字列がない場合は、このフラグをクリアしたままにします。これにより、速度が最適化されます。</DD>
<DT>FFAF_TRAILER_PRESENT(FFAFトレーラーあり)</DT><DD>トレーラーストリングがない場合は、このフラグをクリアしたままにします。これにより、速度が最適化されます。</DD>
<DT>FFAF_SIGN_CHAR_TO_FOLLOW_HEADER■サービス名の場合■</DT><DD>このフラグは、符号文字列とヘッダー文字列の相対位置を決定します。</DD>
<DT>FFAF_SIGN_CHAR_TO_PRECEDE_TRAILER■サービス名の場合■</DT><DD>このフラグは、標識文字列とトレーラー文字列の相対位置を決定します。</DD>
</DL>
<PRE CLASS="syntax">typedef struct{FloatFloatToDateTimeParams FFA_dateTimeParams;}FloatFloatToDateTimeData;<A NAME="R_2e.htm_IX_FloatFloatToDateTimeData"></A>typedef struct{FloatFloatToDateTimeFlags FFA_dateTimeFlags;word FFA_year;byte FFA_month;byte FFA_day;byte FFA_weekday;byte FFA_hours;byte FFA_minutes;byte FFA_seconds;}FloatFloatToDateTimeParams;</PRE>
<P>の<CODE>FloatFloatToDateTime</CODE>構造体は、日付と時刻の文字列のフォーマットに関する情報を受け渡しするために使用されます。</P>
<DL>
<DT>
          <STRONG>FFA_dateTimeFlags</STRONG>
        </DT><DD>この<CODE>FloatFloatToDateTimeFlags</CODE>fieldは、日付文字列の書式設定方法を微調整します。</DD>
<DT>
          <STRONG>FFA_年</STRONG>
        </DT>
<DT>
          <STRONG>FFA月</STRONG>
        </DT>
<DT>
          <STRONG>FFA_日</STRONG>
        </DT>
<DT>
          <STRONG>FFA_weekday(平日)</STRONG>
        </DT>
<DT>
          <STRONG>FFA時間</STRONG>
        </DT>
<DT>
          <STRONG>FFA_分</STRONG>
        </DT>
<DT>
          <STRONG>FFA秒</STRONG>
        </DT><DD>これらのフィールドは、日付/時刻のさまざまな部分を返すために使用されます。</DD>
</DL>
<PRE CLASS="syntax">typedef WordFlags FloatFloatToDateTimeFlags;#define FFDT_DATE_TIME_OP 0x8000#define FFDT_FROM_ADDR 0x4000#define FFDT_FORMAT 0x3fff</PRE>
<P>の<CODE>FloatFloatToDateTimeFlags</CODE>フィールドは、日付/時刻の形式を決定します。</P>
<DL>
<DT>FFDTT_DATE_TIME_OP</DT><DD>このフラグを設定します。</DD>
<DT>FFDTT_始点_アドレス</DT><DD>このフラグを設定すると<EM>数</EM>浮動小数点スタックの一番上の数値ではなく、引数を使用します。</DD>
<DT>FFDTT形式</DT><DD>これは<CODE>DateTimeFormat/日付の形式</CODE>値を入力します。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_FloatFloatToAscii_StdFormat()">FloatFloatToAscii_StdFormat()</A></CODE>ボタンをクリックし</P>
</DIV>

<DIV>
          <A NAME="R_2e.htm_IX_FloatFloatToAscii_StdFormat()"></A>
        <H1 CLASS="refHeading">FloatFloatToAscii_StdFormat()</H1>
<PRE CLASS="syntax">word FloatFloatToAscii_StdFormat(char*文字列,FloatNum*数値,FloatFloatToAsciiFormatFlags形式,word numDigits, word numFractionalDigits)</PRE>
<P>このルーチンは、浮動小数点数をASCII文字列として書式設定します。 目的はと似ています。<CODE><A HREF="../../CRef/Routines/R_2e.htm#IX_FloatFloatToAscii()">FloatFloatToAscii()</A></CODE>ただし、このルーチンでは<CODE>FFAスタックフレーム(FFA_stack</CODE>データ構造。 次の引数があります。</P>
<DL>
<DT>
          <STRONG>ストリング</STRONG>
        </DT><DD>変換された文字列を保持するバッファ。 このバッファは、少なくともFLOAT_TO_ASCII_NORMAL_BUF_LENまたはFLOAT_TO_ASCII_HUGE_BUF_LENでなければなりません。</DD>
<DT>
          <STRONG>数</STRONG>
        </DT><DD>FFAF_FROM_ADDRを渡す場合、これは変換する数値へのポインタである必要があります。そうでない場合は、浮動小数点スタックの先頭の数値がポップされ、変換されます。</DD>
<DT>
          <STRONG>書式</STRONG>
        </DT><DD>これはタイプのフラグフィールドです<CODE>FloatFloatToAsciiFormatFlags</CODE>このデータ型については<CODE><A HREF="../../CRef/Routines/R_2e.htm#IX_FloatFloatToAscii()">FloatFloatToAscii()</A></CODE>次のフラグを使用できます:FFAF_FROM_ADDR、FFAF_SCIENTIFIC、FFAFF_PERCENT、FFAF_USE_COMMAS、FFAF_NO_TRAIL_ZEROS。</DD>
<DT>
          <STRONG>桁数</STRONG>
        </DT><DD>必要な有効桁数。</DD>
<DT><STRONG>numFranctionalDigits</DT><DD></STRONG>小数点記号の後に続く桁数。</DD>
</DL>
<P>このルーチンは、結果の文字列の文字数を返します。エラーが発生した場合は0を返します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2e.htm#IX_FloatFloatToAscii()">FloatFloatToAscii()</A></CODE>ボタンをクリックし</P>
</DIV>

<HR>
          <A NAME="R_FoamDBAdd.htm"></A>
        <DIV>
</DIV>

<DIV>
          <A NAME="R_FoamDBAdd.htm_IX_FoamDBAddFieldToRecord()"></A>
        <H1 CLASS="refHeading">FoamDBAddFieldToRecord()</H1>
<PRE CLASS="syntax">FieldID FoamDBAddFieldToRecord(VMFileHandleファイル、MemHandleレコード、バイト*fieldName、ワードfieldType);</PRE>
<P>レコードにフィールドを追加します。<EM>記録</EM>名前を付けて<EM>フィールド名</EM>独自の<CODE>フィールドID</CODE>が新しいフィールドに割り当てられ、返されます。 フォームデータベースでは<EM>フィールドタイプ</EM>レコードのソート順を決定します(つまり、タイプ「3」のフィールドは、タイプ「3」の既存のすべてのフィールドの後、タイプ「4」のフィールドの前に挿入されます)。 このルーチンを<CODE>ContDB</CODE>の順にクリックし<EM>フィールドタイプ</EM>は<CODE>ContdbFieldType</CODE>(以下を参照)。 それ以外の場合は、独自のフィールドタイプを設定できます。<P><PRE CLASS="syntax">/**連絡先データベースの標準フィールドタイプ*/typedef ByteEnum ContdbFieldType;#define CFT_NAME 0#define CFT_COMPANY 1#define CFT_TITLE 2#define CFT_ADDRESS 3#define CFT_PHONE 4#define CFT_FAX 5#define CFT_EMAIL 6#define CFT_DTMF 7#define CFT_NOTES 8/*1997年2月以降のCommunicator製品でのみ使用可能:*/#define CFT_URL 9#define CFT_PASSWORD 10#define CFT_TEL_FAX 11#define CFT_TEL_DATA 12</PRE>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_FoamDBAdd.htm_IX_FoamDBBinarySearch()"></A>
        <H1 CLASS="refHeading">FoamDBBinarySearch()</H1>
<PRE CLASS="syntax">RecordID FoamDBBinarySearch(VMFileHandleファイル、MemHandleレコード、PCB(int、コールバック、(void*passedRecord、/*コールバックルーチン*/void*curRecord)));</PRE>
<P>このルーチンは、Foamデータベースのバイナリ検索を実行します。<EM>やすり</EM>指数を決定する<EM>記録</EM>データベースは、アプリケーション定義のコールバックルーチンに従ってソートされます。<CODE>FoamDBBinarySearch()</CODE>見つけることができる<EM>記録</EM>同じソート・スキームに基づくコールバック・ルーチンを使用して、分割統治方式で実行します。 このルーチンが<EM>記録</EM>を呼び出すと<CODE>レコードID</CODE>それ以外の場合は、このレコードがデータベースのどこに属するかを返します。<P>(の<A HREF="#R_80.htm_IX_PCB()"><CODE>プリント回路板</CODE></A>は、コールバックルーチンを定義するGEOSマクロです)。 このコールバックルーチンのプロトタイプは、次の形式である必要があります。<PRE class = "syntax">int_pascal MyCallBackRoutine(void*passedRecord, void*curRecord);</PRE>コールバックルーチンは、レコードが<EM>passedRecord</EM>後に来る<EM>curRecord</EM>,-1の場合<EM>passedRecord</EM>前に来る<EM>curRecord</EM>、項目が一致する場合は0です。<P CLASS="refField">次を含む:<STRONG CLASS="fileName">foamdb.h</STRONG></P>
</DIV>




<DIV>
          <A NAME="R_FoamDBAdd.htm_IX_FoamDBClose()"></A>
        <H1 CLASS="refHeading">FoamDBClose()</H1>
<PRE CLASS="syntax">ワードFoamDBClose(VMFileHandleファイル)</PRE>
<P>ファイルを閉じます。 と同じです。<CODE><A HREF="../../CRef/Routines/R_a2.htm#IX_VMClose()">VMClose()</A></CODE>成功した場合は0以外の値を返し、エラーが発生した場合は<CODE>偽</CODE>エラー値は<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE><P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBAdd.htm_IX_FoamDBCreateEmptyRecord()"></A>
        <H1 CLASS="refHeading">FoamDBCreateEmptyRecord()</H1>
<PRE CLASS="syntax">MemHandle FoamDBCreateEmptyRecord(VMFileHandleファイル)</PRE>
<P>データベースに新しいレコードを作成し、一意のIDを指定して、レコードデータのハンドルを返します。 このレコードにはフィールドまたはデータは含まれません。 このレコードはデータベースに保存されません。<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>が呼び出されます。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>レコードに関連付けられたメモリを解放する場合は<STRONG>しない</STRONG>使用する<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemFree()">関数MemFree()</A></CODE>;代わりに<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDiscardRecord()">FoamDBDiscardRecord()</A></CODE>レコードの変更を破棄するか<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>データベースにコミットします。</P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBAdd.htm_IX_FoamDBDeleteFieldFromRecord()"></A>
        <H1 CLASS="refHeading">FoamDBDeleteFieldFromRecord()</H1>
<PRE CLASS="syntax">void field(VMFileHandleファイル、MemHandleレコード、FoamDBDeleteFieldFromRecord ID ID);/*削除するフィールド*/</PRE>
<P>フィールドIDを削除します<EM>イド</EM>から<EM>記録</EM>データベースの<EM>やすり</EM>ボタンをクリックし<EM>イド</EM>は、から返されるフィールドのIDです。<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBAddFieldToRecord()">FoamDBAddFieldToRecord()</A></CODE>これは優れたソリューションではありませんが<CODE>フィールドID</CODE>フィールドの<CODE>FH_ID型</CODE>の一部<CODE>FieldHeader</CODE>構造体<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBAdd.htm_IX_FoamDBDeleteRecord()"></A>
        <H1 CLASS="refHeading">FoamDBDeleteRecord()</H1>
<PRE CLASS="syntax">ブール値FoamDBDeleteRecord(VMFileHandleファイル、MemHandleレコード);/*終了するレコード*/</PRE>
<P>このルーチンは、以下にあるレコード・データを解放します。<EM>記録</EM>レコードがデータベースに存在する場合は、そのレコードもデータベースから削除されます。<P>レコードがデータベースに存在しなかった場合は、0以外の値を返します。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBAdd.htm_IX_FoamDBDiscardRecord()"></A>
        <H1 CLASS="refHeading">FoamDBDiscardRecord()</H1>
<PRE CLASS="syntax">無効FoamDBDiscardRecord(VMFileHandleファイル、MemHandle記録)</PRE>
<P>このルーチンは、渡されたレコードへの変更をすべて破棄します。<EM>記録</EM>渡されたハンドルに格納されているレコード・データを解放しますが、データベース・ファイルに格納されているデータに対しては何も行いません。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_FoamDBAdd.htm_IX_FoamDBDuplicateRecord()"></A>
        <H1 CLASS="refHeading">FoamDBDuplicateRecord()</H1>
<PRE CLASS="syntax">MemHandle FoamDBDuplicateRecord(VMFileHandleファイル、MemHandle記録);</PRE>
<P>既存のレコードを複製します。<EM>記録</EM>FoamDBの<EM>やすり</EM>新しいIDを割り当て、複製のハンドルを返します。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>と同様に<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBCreateEmptyRecord()">FoamDBCreateEmptyRecord()</A></CODE>を呼び出して、最終的にレコードを保存または破棄する必要があります。<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDiscardRecord()">FoamDBDiscardRecord()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBAdd.htm_IX_FoamDBFieldEnum()"></A>
        <H1 CLASS="refHeading">FoamDBFieldEnum()</H1>
<PRE CLASS="syntax">Boolean FoamDBFieldEnum(MemHandleレコード,void*enumData, PCB(Boolean, コールバック,/*ゼロ以外でenumを停止*/(FieldHeader*フィールド,void*callbackEnumData)));/*コールバックルーチン*/</PRE>
<P>このルーチンは基本的に、指定された<EM>記録</EM>各フィールドに対して指定されたコールバックルーチンを呼び出します。<EM>enumData</EM>は、コールバックルーチンで使用される場合、アプリケーション定義のバッファまたはデータ構造体の初期値を指すことができ、それ以外の場合は無視することができる。 このポインタは、コールバックルーチンに渡されます。</P>
<P>コールバックルーチンは2つのパラメータを受け入れます。<EM>畑</EM>、および一部のアプリケーション定義データ<EM>callbackEnumData</EM>ボタンをクリックし<EM>callbackEnumData</EM>は、検出された最も長い文字列を保存したり、レコードに対して複雑なフィルタリングを実行するなど、コールバックルーチンへの異なる呼び出し間で情報を保存するために使用される場合があります(この場合<EM>callbackEnumData</EM>はフィールド・ポインターから集めたフィールドIDの配列を指すことができます)。 レコードの最後のフィールドに到達する前に列挙を終了するには、次の値を返します。<CODE>真</CODE>(またはゼロ以外の任意の値)を返します。<P>コールバックルーチンを使用するには:<P><PRE CLASS="syntax">/**コールバックルーチンのプロトタイプ*/Boolean_pascal ExampleCallback(FieldHeader*フィールド,void*callbackEnumData);./**コールFoamDBFieldEnum()*/ok=FoamDBFieldEnum(recordHandle, &amp;someDataStruct, ExampleCallback);</PRE>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_FoamDBGetCurrent.htm#IX_FoamDBLockedRecordEnum()">FoamDBLockedRecordEnum()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_FoamDBGetCurrent.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetCurrentRecordID()"></A>
        <H1 CLASS="refHeading">FoamDBGetCurrentRecordID()</H1>
<PRE CLASS="syntax">RecordID FoamDBGetCurrentRecordID(VMFileHandleファイル)</PRE>
<P>を返します。<CODE>レコードID</CODE>データベース内の次のレコードに対して設定される<EM>やすり</EM>ボタンをクリックし<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetFieldData()"></A>
        <H1 CLASS="refHeading">FoamDBGetFieldData()</H1>
<PRE CLASS="syntax">word field(VMFileHandleファイル,MemHandleレコード,FieldID id, char*dest, /*データを格納するバッファ*/word FoamDBGetFieldData);/*#バイトのデータ*/maxBytesToGet</PRE>
<P>の指定したフィールドからデータをコピーします。<EM>記録</EM>バッファに<EM>宛先</EM>ボタンをクリックし<EM>maxBytesToGet</EM>バッファにコピーする最大バイト数を指定します。<P>実際にコピーされたバイト数を返します。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>文字列データを保存するための標準的で最も効率的な方法は、ヌルターミネータを使用しないことです。したがって、文字列データを操作する場合は、返されたデータサイズを使用してください。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetFieldName()"></A>
        <H1 CLASS="refHeading">FoamDBGetFieldName()</H1>
<PRE CLASS="syntax">Boolean FoamDBGetFieldName(VMFileHandleファイル、MemHandleレコード、FieldID ID、TCHAR*dest, /*名前を入れるバッファ(ヌル終端)*/word maxBytesToGet);/*取得する文字数*/</PRE>
<P>フィールドIDの名前をコピーします。<EM>イド</EM>バッファに<EM>宛先</EM>ボタンをクリックし<P>フィールドが存在する場合はゼロを返し、存在しない場合は非ゼロを返します。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>フィールド名はNULLで終了します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetFieldType()"></A>
        <H1 CLASS="refHeading">FoamDBGetFieldType()</H1>
<PRE CLASS="syntax">Boolean field(VMFileHandleファイル、MemHandleレコード、FoamDBGetFieldType ID id、バイト*型);</PRE>
<P>フィールドIDのタイプを取得します<EM>イド</EM>それを<EM>種類</EM>このタイプは<CODE>ContdbFieldType</CODE>ボタンをクリックし<P>フィールドが存在する場合は0を返し、存在しない場合は0以外の値を返します。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetNextPrevRecord()"></A>
        <H1 CLASS="refHeading">FoamDBGetNextPrevRecord()</H1>
<PRE CLASS="syntax">dワードFoamDBGetNextPrevRecord(VMFileHandleファイル、RecordIDレコード、ワードカウント)</PRE>
<P>このルーチンは、レコードの巨大な配列にインデックスを返します。<EM>数える</EM>レコードを<CODE>レコードID</CODE><EM>記録</EM>ボタンをクリックし<EM>数える</EM>には負の値と正の値があるため、このルーチンを使用してデータベース内を前後に移動できます。 要求されたレコードが無効になった場合。<CODE>レコードID</CODE><EM>記録</EM>または、要求されたインデックスがデータベースの境界を超えている場合、このルーチンは<EM>記録</EM>ボタンをクリックし<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetNumVisibleRecords()"></A>
        <H1 CLASS="refHeading">FoamDBGetNumVisibleRecords()</H1>
<PRE CLASS="syntax">dワードFoamDBGetNumVisibleRecords(VMFileHandleファイル);</PRE>
<P>このルーチンは、データベース内の可視レコードの数を返します。<EM>やすり</EM>これは、レコードのリストをユーザーに提供するときによく使用されます。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetRecordFromID()"></A>
        <H1 CLASS="refHeading">FoamDBGetRecordFromID()</H1>
<PRE CLASS="syntax">MemHandle FoamDBGetRecordFromID(VMFileHandleファイル、RecordID ID)</PRE>
<P>このルーチンは、データベース内で次のIDを持つレコードを検索します。<EM>イド</EM>を呼び出してメモリにコピーし、ハンドルを返します。 データベース内に渡されたIDを持つレコードがなかった場合、このルーチンは次を返します。<CODE>NullHandle</CODE>ボタンをクリックし<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>戻されたハンドルは<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDeleteRecord()">FoamDBDeleteRecord()</A></CODE><CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDiscardRecord()">FoamDBDiscardRecord()</A></CODE>、または<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>ボタンをクリックし<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetRecordID()"></A>
        <H1 CLASS="refHeading">FoamDBGetRecordID()</H1>
<PRE CLASS="syntax">RecordID FoamDBGetRecordID(MemHandleの記録)</PRE>
<P>レコードハンドルを指定すると<CODE>レコードID</CODE>します。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetVisibleRecord()"></A>
        <H1 CLASS="refHeading">FoamDBGetVisibleRecord()</H1>
<PRE CLASS="syntax">MemHandle FoamDBGetVisibleRecord(VMFileHandleファイル、dwordインデックス)</PRE>
<P>このルーチンは、インデックスが<EM>指数</EM>を呼び出し、データをメモリにコピーし、呼び出し元にブロックのハンドルを返します。 次の場合<EM>指数</EM>オービーです<CODE>FoamDBGetVisibleRecord()</CODE>NullHandleが戻されます。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>戻されたハンドルは<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDeleteRecord()">FoamDBDeleteRecord()</A></CODE><CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDiscardRecord()">FoamDBDiscardRecord()</A></CODE>、または<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE></P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBLockedRecordEnum()"></A>
        <H1 CLASS="refHeading">FoamDBLockedRecordEnum()</H1>
<PRE CLASS="syntax">Boolean FoamDBLockedRecordEnum(MemHandleレコード,void*enumData, PCB(Boolean, コールバック,/*ゼロ以外でenumを停止*/(FieldHeader*フィールド,void*callbackEnumData)));/*コールバックルーチン*/</PRE>
<P>このルーチンは、ロックされたレコードの各フィールドに対してコールバックルーチンを呼び出します。 コールバックルーチンは、次のように使用されます。<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBFieldEnum()">FoamDBFieldEnum()</A></CODE>プロトタイプである必要があります。<PRE CLASS="syntax">/**コールバックルーチンのプロトタイプ*/Boolean_pascal ExampleCallback(FieldHeader*フィールド,void*callbackEnumData);</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBMapNameToToken()"></A>
        <H1 CLASS="refHeading">FoamDBMapNameToToken()</H1>
<PRE CLASS="syntax">Boolean FoamDBMapNameToToken(VMFileHandleファイル,TCHAR*nameToLookFor, word*トークン);</PRE>
<P>このルーチンは、次のフィールドを検索します。<EM>nameToLookFor</EM>データベース内<EM>やすり</EM>その名前を持つフィールドがあるかどうかをチェックします。<P>返品<CODE>真</CODE>(-1)見つかった場合<CODE>偽</CODE>見つからない場合は(0)。<EM>トークン</EM>は<CODE>フィールド名</CODE>要素配列。 これは通常、アプリケーションによって使用されるものではありません。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBMapTokenToName()"></A>
        <H1 CLASS="refHeading">FoamDBMapTokenToName()</H1>
<PRE CLASS="syntax">Boolean FoamDBMapTokenToName(VMFileHandleファイル,単語nameToken, 単語maxBytesToCopy, TCHAR*dest);</PRE>
<P>このルーチンは、トークンに関連付けられたフィールド名を検索します。<EM>nameToken</EM>データベース・ファイル内<EM>やすり</EM>、最大部数<EM>maxBytesToCopy</EM>バイト分の名前をバッファに<EM>宛先</EM>トークンが範囲外の場合、ルーチンはゼロ以外の値を返します。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>フィールド名はNULLで終了します。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBOpen()"></A>
        <H1 CLASS="refHeading">FoamDBOpen()</H1>
<PRE CLASS="syntax">VMFileHandle FoamDBOpen(char*filename, word mapBlockSize, word majorProtocol, /*既存のファイルプロトコルはメジャープロトコルとマイナープロトコルに一致する必要があります*/word minorProtocol);</PRE>
<P>既存のデータベースファイルを開きます<EM>ファイル名</EM>または、現在存在しない場合は新しいものを作成します。 データベース・ファイルのハンドルを返します。ファイルを開けなかった場合は、NullHandleを返します。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>はエラータイプを返すために呼び出すことができます。<CODE><A HREF="../../CRef/Routines/R_a3.htm#IX_VMOpen()">VMを開く()</A></CODE>または、プロトコルの不一致があった場合は-1。<P><EM>mapBlockSize</EM>は、データベースのマップブロックのサイズを指定するために使用されます。 デフォルト(最小)サイズは<CODE>sizeof(FoamDBMap)</CODE>ただし、アプリケーションがマップブロックに余分なデータを格納する必要がある場合は、より多くの領域を割り当てることができます。<P>新しいファイルを作成すると、新しいファイルには渡されたプロトコル番号が割り当てられます。<EM>majorProtocol</EM>および<EM>minorProtocol</EM>既存のファイルを開くときに、ファイルのプロトコル番号が渡されたプロトコル番号と比較されます。<EM>majorProtocol</EM>および<EM>minorProtocol</EM>一致しない場合は、-1のエラーが返されます。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBResortDatabase()"></A>
        <H1 CLASS="refHeading">FoamDBResortDatabase()</H1>
<PRE CLASS="syntax">void FoamDBResortDatabase(VMFileHandleファイル、PCB(sword、コールバック、(RecordHeader*レコード1、RecordHeader*レコード2)));/*コールバックルーチン*/</PRE>
<P>このルーチンは、データベースを再ソートします。<EM>やすり</EM>アプリケーション定義のコールバック関数を使用して、レコードの順序を決定します。 ルーチンと同様に<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>の場合、コールバックルーチンは-1を返します。<EM>レコード1</EM>前に来るべきである<EM>レコード2</EM>、または+1<EM>レコード1</EM>後に来るべきである<EM>レコード2</EM>と入力します。 コールバックルーチンのプロトタイプは、次のようになります。<P><PRE class="syntax">sword_pascal MyCallBackRoutine(RecordHeader*レコード1、RecordHeader*レコード2);</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBResumeNotifications()"></A>
        <H1 CLASS="refHeading">FoamDBResumeNotifications()</H1>
<PRE CLASS="syntax">空のFoamDBResumeNotifications(VMFileHandleファイル)</PRE>
<P>このルーチンは、データベースの通知の生成を再開します。<EM>やすり</EM>これらの通知は次のとおりです。<CODE>FoamDBActionType</CODE>秒<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSuspendNotifications()">FoamDBSuspendNotifications()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_FoamDBResumeUpdates.htm"></A>
        <DIV>
</DIV>

<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBResumeUpdates()"></A>
        <H1 CLASS="refHeading">FoamDBResumeUpdates()</H1>
<PRE CLASS="syntax">空のFoamDBResumeUpdates(VMFileHandleファイル)</PRE>
<P>このルーチンは、データベースの更新の生成を再開します。<EM>やすり</EM>ボタンをクリックし<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSaveRecord()"></A>
        <H1 CLASS="refHeading">FoamDBSaveRecord()</H1>
<PRE CLASS="syntax">dワードFoamDBSaveRecord(VMFileHandleファイル、MemHandleレコード、PCB(剣、コールバック、(RecordHeader*レコード1、RecordHeader*レコード2)));/*コールバックルーチン*/</PRE>
<P>このルーチンはレコードを保存します<EM>記録</EM>データベース・ファイル内<EM>やすり</EM>を呼び出し、渡されたレコードデータを含むメモリブロックを解放する。 コールバックルーチンは、データベース内でレコードを保存する場所を決定します。 の<CODE>Contdb</CODE>ライブラリは、このルーチンのフロントエンドを提供します。<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactSaveRecord()">ContactSaveRecord()</A></CODE>これは、レコードを連絡先データベースに保存するときに使用されます。<P><CODE><A HREF="../../CRef/Routines/R_80.htm#IX_PCB()">プリント基板()</A></CODE>はGEOSマクロで<CODE>FoamDBSaveRecord()</CODE>はコールバックルーチンになり<CODE>太刀</CODE>2つ受け入れます<CODE>RecordHeader</CODE>s. このコールバックルーチンは、次のように宣言する必要があります。<PRE class = "syntax">sword_pascal MyCallBackRoutine(RecordHeader*レコード1、RecordHeader*レコード2);</PRE>
<P>次の場合は-1を返します。<EM>レコード1</EM>前に来るべきである<EM>レコード2</EM>、または+1<EM>レコード1</EM>後に来るべきである<EM>レコード2</EM>と入力します。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSetCurrentRecordID()"></A>
        <H1 CLASS="refHeading">FoamDBSetCurrentRecordID()</H1>
<PRE CLASS="syntax">void FoamDBSetCurrentRecordID(VMFileHandleファイル、RecordID ID)</PRE>
<P>次に作成するレコードに使用されるレコードIDを設定します。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSetFieldData()"></A>
        <H1 CLASS="refHeading">FoamDBSetFieldData()</H1>
<PRE CLASS="syntax">void field(VMFileHandleファイル、MemHandleレコード、FoamDBSetFieldData ID ID、char*data、/*格納するデータ*/word dataSize);/*データのバイト数*/</PRE>
<P>ストアーズ<EM>データサイズ</EM>バイト<EM>データ#データ#</EM>フィールドIDの<EM>イド</EM>の<EM>記録</EM>ボタンをクリックし<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>ASCIIデータ(文字列)を保存する場合、文字列は<STRONG>しない</STRONG>ヌルで終了します。 たとえば、文字列&quot;<CODE>ABCD[</CODE>」と入力し<EM>データ#データ#</EM>を文字列へのポインタにし<EM>データサイズ</EM>は4です。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSetFieldName()"></A>
        <H1 CLASS="refHeading">FoamDBSetFieldName()</H1>
<PRE CLASS="syntax">void field(VMFileHandleファイル、MemHandleレコード、FoamDBSetFieldName ID id、char*name);</PRE>
<P>IDを持つフィールドの名前を変更します。<EM>イド</EM>の<EM>記録</EM>と<EM>人名</EM>ボタンをクリックし<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG><EM>人名</EM>はNULL終端文字列です。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSetNameForToken()"></A>
        <H1 CLASS="refHeading">FoamDBSetNameForToken()</H1>
<PRE CLASS="syntax">void FoamDBSetNameForToken(VMFileHandleファイル、単語nameToken、TCHAR*name);</PRE>
<P>によって識別されるフィールドの名前を設定します。<EM>nameToken</EM>データベース内のトークン<CODE>フィールド名</CODE>要素配列。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>フィールド名はNULLで終了します。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSuspendNotifications()"></A>
        <H1 CLASS="refHeading">FoamDBSuspendNotifications()</H1>
<PRE CLASS="syntax">空のFoamDBSuspendNotifications(VMFileHandleファイル)</PRE>
<P>このルーチンは、データベースへの通知の生成を停止します。<EM>やすり</EM>このルーチンへの呼び出しは<CODE><A HREF="../../CRef/Routines/R_FoamDBGetCurrent.htm#IX_FoamDBResumeNotifications()">FoamDBResumeNotifications()</A></CODE><P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSuspendUpdates()"></A>
        <H1 CLASS="refHeading">FoamDBSuspendUpdates()</H1>
<PRE CLASS="syntax">空のFoamDBSuspendUpdates(VMFileHandleファイル)</PRE>
<P>このルーチンは、データベースの更新の生成を停止します。<EM>やすり</EM>このルーチンへの呼び出しは<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBResumeUpdates()">FoamDBResumeUpdates()</A></CODE>ボタンをクリックし<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>更新を禁止するのは危険です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBVisibleRecordEnum()"></A>
        <H1 CLASS="refHeading">FoamDBVisibleRecordEnum()</H1>
<PRE CLASS="syntax">Boolean FoamDBVisibleRecordEnum(VMFileHandleファイル,void*enumData, PCB(Boolean, コールバック,/*ゼロ以外でenumを停止*/(RecordHeader*レコード,void*callbackEnumData)));/*コールバックルーチン*/</PRE>このルーチンは、データベース内の可視レコードごとに、アプリケーション指定のコールバックルーチンを呼び出します。 コールバックルーチンは、列挙を停止するためにゼロ以外の値を返すことができます。<EM>enumData</EM>は、アプリケーションがコールバックルーチンに渡す必要があり、コールバックルーチンが変更できるあらゆる種類のデータへのポインタです。 コールバックルーチンは、列挙を停止するためにゼロ以外の値を返すことができます。<P>FoamDBでコールバックルーチンを使用する方法の詳細については、同様のルーチンの説明を参照してください。<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBFieldEnum()">FoamDBFieldEnum()</A></CODE>コールバックルーチンは、次のように宣言する必要があります。<PRE CLASS="syntax">/**コールバックルーチンのプロトタイプ*/Boolean_pascal myCallBackRoutine(RecordHeader*record, void*callbackEnumData);</PRE> 
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBVisibleRecordEnumWithRange()"></A>
        <H1 CLASS="refHeading">FoamDBVisibleRecordEnumWithRange()</H1>
<PRE CLASS="syntax">Boolean FoamDBVisibleRecordEnumWithRange(VMFileHandleファイル,void*enumData, dword startElement, dword numOfRecords, PCB(Boolean, コールバック,/*ゼロ以外でenumを停止*/(RecordHeader*レコード,void*callbackEnumData)));/*コールバックルーチン*/</PRE>
<P>このルーチンは、データベース内の一部の可視レコードに対して、アプリケーションで指定されたコールバック・ルーチンを、レコード番号から呼び出します。<EM>開始エレメント</EM>をクリックし<EM>レコード数</EM>レコード。<EM>enumData</EM>は、アプリケーションがコールバックルーチンに渡す必要があり、コールバックルーチンが変更できるあらゆる種類のデータへのポインタです。 コールバックルーチンは、列挙を停止するためにゼロ以外の値を返すことができます。<P>FoamDBでコールバックルーチンを使用する方法の詳細については、同様のルーチンの説明を参照してください。<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBFieldEnum()">FoamDBFieldEnum()</A></CODE>コールバックルーチンは、次のように宣言する必要があります。<PRE CLASS="syntax">/**コールバックルーチンのプロトタイプ*/Boolean_pascal myCallBackRoutine(RecordHeader*record, void*callbackEnumData);</PRE> 
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">foamdb.h</STRONG>
        </P>
</DIV>

<HR>
          <A NAME="R_2f.htm"></A>
        <DIV>
</DIV>

<DIV>
          <A NAME="R_2f.htm_IX_FormatIDFromManufacturerAndType()"></A>
        <H1 CLASS="refHeading">FormatIDFromManufacturerAndType</H1>
<PRE CLASS="syntax">dワードFormatIDFromManufacturerAndType(製造元、タイプ);ManufacturerIDs製造元;ClipboardItemFormatタイプ;</PRE>
<P>このマクロは製造者IDとフォーマットタイプ(例えばCIF_TEXT)を取り、それらをタイプのdword引数に結合します。<CODE>ClipboardItemFormatID</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_2f.htm_IX_free()"></A>
        <H1 CLASS="refHeading">関数free()</H1>
<PRE CLASS="syntax">void free(void*blockPtr);/*解放するメモリのアドレス*/</PRE>
<P>の<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>ファミリーのルーチンが標準Cとの互換性のために提供されている。 カーネルはgeodeの値を満足する固定ブロックを割り当てます。<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>はこのブロックからメモリを割り当てる。 ブロックがいっぱいになると、別の固定malloc-blockが割り当てられます。 ブロック内のすべてのメモリが解放されると、メモリマネージャは自動的にブロックを解放します。</P>
<P>geodeが要求されたメモリで終了したとき<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>すると、メモリが解放されます。 これにより<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>メモリ要求を満たします。 メモリを解放するには<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>(または<CODE><A HREF="../../CRef/Routines/R_3.htm#IX_calloc()">関数calloc()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">参照):realloc()</A></CODE>)を参照してください。 すべてのメモリが解放されます。</P>
<P>メモリは、geode呼び出しに割り当てられたmalloc-blockにある必要があります。<CODE>関数free()</CODE>別のgeodeのmalloc-blockのメモリを解放したい場合は<CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoFree()">GeoFree関数()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">stdlib.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>メモリを割り当てたときに返されたアドレスとまったく同じアドレスを渡します。 別のアドレスを渡すと<CODE>関数free()</CODE>は、他のメモリを消去したり、システムをクラッシュさせたりするなど、予測できない動作を行います。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3.htm#IX_calloc()">関数calloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoFree()">GeoFree関数()</A></CODE><CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">参照):realloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_2f.htm_IX_FractionOf() macro"></A>
        <H1 CLASS="refHeading">FractionOf()[分数(F)]</H1>
<PRE CLASS="syntax">単語FractionOf(WWFixedAsDWord wwf)</PRE>
<P>このマクロは、整数部の小数部を返します。<CODE>WWFixedAsDWord</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geos.hを入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_30.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListAdd()"></A>
        <H1 CLASS="refHeading">GCNListAdd()</H1>
<PRE CLASS="syntax">Boolean GCNListAdd(optr OD, /*リストに追加するoptr*/ManufacturerID manufID, /*リストの製造者ID*/word listType);/*リストタイプ*/</PRE>
<P>このルーチンは、特変に関係するGCNリストにオブジェクト・ポインター(optr)を追加します。 このルーチンには、追加するoptrと<CODE>manufID</CODE>追加するリストの種類を指定します。 指定した製造元とタイプのリストが現在存在しない場合は、新しいリストが作成されます。</P>
<P>このルーチンは<CODE>真</CODE>optrがGCNリストに正常に追加された場合<CODE>偽の</CODE>optrを追加できなかった場合。 optrは、現在GCNリストに存在する場合、そのリストに追加できません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListAddHandles()"></A>
        <H1 CLASS="refHeading">GCNListAddHandles()</H1>
<PRE CLASS="syntax">Boolean GCNListAddHandles(MemHandle mh, /*追加するオブジェクトのハンドル*/ChunkHandle ch, /*追加するオブジェクトのチャンク*/ManufacturerIDs manufID, /*リストの製造元ID*/word listType);/*リストの種類*/</PRE>
<P>このルーチンは、とまったく同じです。<CODE><A HREF="../../CRef/Routines/R_30.htm#IX_GCNListAdd()">GCNListAdd()</A></CODE>ただし、完全なoptrではなく、オブジェクトのメモリーとチャンク・ハンドルを使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListAddToBlock()"></A>
        <H1 CLASS="refHeading">GCNListAddToBlock()</H1>
<PRE CLASS="syntax">Boolean GCNListAddToBlock(optr OD, /*追加するリストのoptr*/ManufacturerID manufID, /*リストの製造者ID*/word listType, /*リストタイプ*/MemHandle mh, /*ブロック保持リストのハンドル*/ChunkHandle listOfLists);/*ブロック内のリストのリストのチャンク*/</PRE>
<P>このルーチンは、GCNリストを含むブロックに新しいGCNリストを追加します。 新しいGCNリストを含むチャンクのoptr、およびリストのタイプと製造元IDを渡します。 新しいリストを管理するGCN「リストのリスト」を含むチャンクのメモリー・ハンドルとチャンク・ハンドルも渡します。</P>
<P>このルーチンは、新しいoptrがGCNメカニズムに追加された場合はtrueを返し、追加できなかった場合(すでに追加されていた場合)はfalseを返します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンはブロック内のチャンクのサイズを変更する可能性があるため、このルーチンを呼び出した後にポインタの参照を解除する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListCreateBlock()"></A>
        <H1 CLASS="refHeading">GCNListCreateBlock()</H1>
<PRE CLASS="syntax">ChunkHandle GCNListCreateBlock(MemHandle mh);/*ロックされたLMemブロックのハンドル*/</PRE>
<P>このルーチンは、GCNメカニズムのリストのリストを作成します。 アプリケーションから呼び出されることはほとんどありません。 リストが作成されるロックされたLMemブロックのハンドルを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListDestroyBlock()"></A>
        <H1 CLASS="refHeading">GCNListDestroyBlock()</H1>
<PRE CLASS="syntax">void GCNListDestroyBlock(MemHandle mh, /*ロックされたブロックのハンドルを*破棄*/</PRE>
<PRE CLASS="syntax">ChunkHandle listOfLists);/*リストのリストのチャンク*/</PRE>
<P>このルーチンは、リストのGCNリストと、それに関連付けられているすべてのGCNリストを破棄します。 リストを含むロックされたLMemブロックのハンドルと、リストのリストを含むチャンクのチャンクハンドルを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListDestroyList()"></A>
        <H1 CLASS="refHeading">GCNListDestroyList()</H1>
<PRE CLASS="syntax">void GCNListDestroyList(optr list);/*破棄するGCNリストのoptr*/</PRE>
<P>このルーチンは、指定されたGCNリストを破棄します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListRelocateBlock()"></A>
        <H1 CLASS="refHeading">GCNListRelocateBlock()</H1>
<PRE CLASS="syntax">void GCNListRelocateBlock(MemHandle mh, /*ロックされたLMemブロックのハンドル*GCNリストを含む*/</PRE>
<PRE CLASS="syntax">ChunkHandle listOfLists、/*リストのリストのチャンク*/MemHandle relocBlock);/**再配置情報を含むブロックのハンドル*/</PRE>
<P>このルーチンは、特定街区内のリストのGCNリストを再配置し、そこに格納されているすべてのオプションを更新します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンはLMemブロックのサイズ変更や移動を行うことができるので、呼び出した後にポインタの参照を解除する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListRemove()"></A>
        <H1 CLASS="refHeading">GCNListRemove()</H1>
<PRE CLASS="syntax">Boolean GCNListRemove(optr OD, /*削除するoptr*/ManufacturerID manufID, /*リストの製造者ID*/word listType);/*リストタイプ*/</PRE>
<P>このルーチンは、渡されたoptrを指定されたGCNリストから除去します。 このルーチンには、除去するリストのメーカーIDおよびリスト・タイプとともに、除去するoptrを渡す必要があります。</P>
<P>このルーチンは<CODE>真</CODE>optrがGCNリストから正常に除去された場合<CODE>偽の</CODE>optrがGCNリストに見つからなかったために除去できなかった場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListRemoveFromBlock()"></A>
        <H1 CLASS="refHeading">GCNListRemoveFromBlock()</H1>
<PRE CLASS="syntax">Boolean GCNListRemoveFromBlock(optr OD, /*削除するGCNリストのoptr*/ManufacturerID manufID, /*削除するリストの製造元*/word listType, /*削除するリストのタイプ*/MemHandle mh, /*ロックされたLMemブロックのハンドル**リストのリストを含む*/</PRE>
<PRE CLASS="syntax">ChunkHandle listOfLists);/*リストのリストのチャンク*/</PRE>
<P>このルーチンは、GCNリストブロックおよびその中のリストのリストからGCNリストを削除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_30.htm_IX_GCNListRemoveHandles()"></A>
        <H1 CLASS="refHeading">GCNListRemoveHandles()</H1>
<PRE CLASS="syntax">Boolean GCNListRemoveHandles(MemHandle mh, ChunkHandle ch, ManufacturerID manufID, word listType);</PRE>
<P>このルーチンは、とまったく同じです。<CODE><A HREF="../../CRef/Routines/R_30.htm#IX_GCNListRemove()">GCNListRemove()</A></CODE>ただし、optrではなくハンドルを使用して削除するオブジェクトを指定する点が異なります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_30.htm#IX_GCNListRemove()">GCNListRemove()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_31.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_31.htm_IX_GCNListSend()"></A>
          <A NAME="R_31.htm_IX_GCNListSendFlags:with GCNListSend()"></A>
        <H1 CLASS="refHeading">GCNListSend()</H1>
<PRE CLASS="syntax">word GCNListSend(ManufacturerID manufID、/*リストの製造元*/word listType、/*通知タイプ*/EventHandleイベント、/*リストに送信されるイベント*/MemHandle dataBlock、/*データブロック、もしあれば*/word gcnListSendFlags);/*gcnListSendFlags*/</PRE>
<P>このルーチンは、指定されたGCNリスト内のすべてのオブジェクトにメッセージを送信します。 このメッセージは<CODE>事件</CODE>リストは<CODE>manufID</CODE>および<CODE>リストの種類</CODE>メッセージは、メッセージキューによって非同期に(変更が発生してからしばらくして)送信されます。</P>
<P>の<CODE>dataBlock(データブロック)</CODE>パラメータには、通知とともに送信される余分なデータブロックのメモリハンドルが含まれます(存在する場合)。このブロックは、分類されたイベントでも指定する必要があります。 データブロックが必要ない場合は、NullHandleを通過します。 参照カウンタを持つデータブロックを使用する場合、このルーチンを呼び出す前に参照カウンタを1つインクリメントします。このルーチンは、カウントがゼロになった場合にカウントをデクリメントし、ブロックを解放します。</P>
<P>の<CODE>gcnListSendFlags</CODE>パラメータのタイプ<CODE>GCNListSendFlags</CODE>このルーチンには、意味のあるフラグが1つしかありません。</P>
<DL>
<DT>GCNLSFセットステータス</DT><DD>GCNリストに送信されるメッセージを、リストの「ステータス」として設定します。 リストのステータスメッセージは、後でリストに自身を追加するオブジェクトに送信されます。 このフラグが設定されている場合<CODE>事件</CODE>が返される。 このフラグが設定されていない場合、戻り値は送信されたメッセージの数になります。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_31.htm_IX_GCNListSendToBlock()"></A>
        <H1 CLASS="refHeading">GCNListSendToBlock()</H1>
<PRE CLASS="syntax">word GCNListSendToBlock(ManufacturerID manufID、/*リストのメーカーID*/word listType、/*通知タイプ*/EventHandleイベント、/*リストに送信されるイベント*/MemHandle dataBlock、/*データブロック、もしあれば*/MemHandle mh、/*ロックされたLMemブロックのハンドル*リストのGCNリストを含む*/</PRE>
<PRE CLASS="syntax">ChunkHandle listOfLists、/*リストのチャンク*/GCNListSendFlagsフラグ);/*GCNListSendFlags*/</PRE>
<P>このルーチンは、指定された<CODE>事件</CODE>を指定したリストに追加します。<CODE><A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSend()">GCNListSend()</A></CODE>ボタンをクリックし<CODE>GCNListSendToBlock()</CODE>ただし、GCNリストの特定のインスタンスを指定するには<CODE>モデム</CODE>および<CODE>listOfLists</CODE>その他のパラメータと戻り値は<CODE><A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSend()">GCNListSend()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSend()">GCNListSend()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_31.htm_IX_GCNListSendToList()"></A>
        <H1 CLASS="refHeading">GCNListSendToList()</H1>
<PRE CLASS="syntax">void GCNListSendToList(optr list, /*GCNリストのoptr*/EventHandleイベント,/*リストに送るイベント*/MemHandle dataBlock, /*データブロックのハンドル,もしあれば*/GCNListSendFlagsフラグ);/*GCNListSendFlags*/</PRE>
<P>このルーチンは、指定された<CODE>事件</CODE>指定されたGCNに<CODE>一覧</CODE>リストは、メーカーIDとタイプではなく、optrによって明示的に指定されます。 イベントは、適切なキューを経由して、リストに登録されているすべてのオブジェクトに送信されます。 通知されたすべてのオブジェクトによって通知が処理されると、イベントは解放され、渡されたデータ・ブロックも解放されます。 (データブロックがない場合は、NullHandleを<CODE>dataBlock(データブロック)</CODE>)をクリックし</P>
<P>の<CODE>フラグふらぐ</CODE>パラメータは1つのフラグGCNLSF_SET_STATUSを持つことができます。 このフラグを設定すると、渡されたイベントがリストのステータスメッセージとして設定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSend()">GCNListSend()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_31.htm_IX_GCNListSendToListHandles()"></A>
        <H1 CLASS="refHeading">GCNListSendToListHandles()</H1>
<PRE CLASS="syntax">void GCNListSendToListHandles(MemHandle mh, /*リストのブロックのハンドル*/ChunkHandle ch, /*リストのチャンク*/EventHandleイベント,/*リストに送るイベント*/MemHandle dataBlock, /*もしあればデータブロックのハンドル*/GCNListSendFlagsフラグ);/*GCNListSendFlags*/</PRE>
<P>このルーチンは、とまったく同じです。<CODE><A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSendToList()">GCNListSendToList()</A></CODE>リストはoptrではなく、そのグローバルハンドルとチャンクハンドルの組み合わせで指定されます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSendToList()">GCNListSendToList()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_31.htm_IX_GCNListUnRelocateBlock()"></A>
        <H1 CLASS="refHeading">GCNListUnRelocateBlock()</H1>
<PRE CLASS="syntax">Boolean GCNListUnRelocateBlock(MemHandle mh, /*ロックされたlmemブロックのハンドル*リストのリストを含む*/</PRE>
<PRE CLASS="syntax">ChunkHandle listOfLists、/*リストのリストのチャンク*/MemHandle relocBlock);/**再配置/再配置解除情報を含むブロックのハンドル*/</PRE>
<P>このルーチンは、指定されたリストのリストをunrelocatesし<EM>relocBlock</EM>このルーチンは、アプリケーションによって使用されることはほとんどありません。主に、状態ファイルをシャットダウンするときにUIによって使用されます。</P>
<P>戻ります<CODE>真</CODE>指定したリストのリストにはstateに保存されたリストがないため、単純に破棄されます。 戻り値は次のとおりです。<CODE>偽の</CODE>リストのリストが状態ファイルに正常に保存された場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">gcnlist・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_32.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenCopyChunk()"></A>
        <H1 CLASS="refHeading">GenCopyChunk()</H1>
<PRE CLASS="syntax">word GenCopyChunk(MemHandle destBlock, /*ロックされたLMemブロックのハンドルを*どのチャンクがコピーされるか*/</PRE>
<PRE CLASS="syntax">MemHandle blk, /*ロックされたソースLMemブロックのハンドル*/ChunkHandle chnk, /*コピーされるチャンクのチャンクハンドル*/word flags);/*CompChildFlags*/</PRE>
<P>これは、1つのLMemチャンクを新しく作成されたチャンクにコピーするユーティリティルーチンです。 ルーチンは、渡されたブロックに新しいチャンクを割り当てます。<CODE>destBlock</CODE>新しいチャンクのチャンクハンドルを返します。 これは主に、汎用オブジェクトチャンクを複製するためにUIによって使用されます。</P>
<P>ソースチャンクは、グローバルハンドルによって指定されます。<CODE>ブロック</CODE>とチャンクハンドル<CODE>チェック</CODE>である。<CODE>フラグふらぐ</CODE>パラメータに次のレコードが含まれています<CODE>CompChildFlags</CODE>このうち、CCF_MARK_DIRTYフラグだけが意味を持ちます。 このフラグが設定されている場合、新しいチャンクはダーティとマークされます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、チャンクやブロックのサイズ変更や移動を行う場合があるため、呼び出した後にポインタの参照を解除する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">goh世代</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenFindObjectInTree()"></A>
        <H1 CLASS="refHeading">GenFindObjectInTree()</H1>
<PRE CLASS="syntax">optr GenFindObjectInTree(optr startObject, /*検索を開始するオブジェクトのoptr*/dword childTable);/*それぞれが*指定されたレベルでの子の位置*を示すバイトのテーブルへのポインタ;-1はテーブルの終わり*/</PRE>
<P>このユーティリティー・ルーチンは、optrを持つオブジェクトを検出します。<CODE>startObject</CODE>をクリックします。 アプリケーションがこのルーチンを必要とすることはあまりありません。</P>
<P>childTableパラメータはバイトのテーブルを指し、各バイトは各レベルで検出される子の番号を表します。 最初のバイトは取得するstartObjectの子を示し、2番目のバイトは次のレベルで取得する子を示し、3番目のバイトは次のレベルで取得する子を示し、以下同様です。 -1のバイトはテーブルの終わりを示します。 検出されたオブジェクトが返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">goh世代</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenInsertChild()"></A>
        <H1 CLASS="refHeading">GenInsertChild()</H1>
<PRE CLASS="syntax">void GenInsertChild(MemHandle mh, /*親のハンドル*/ChunkHandle chnk, /*親のチャンク*/optr childToAdd, /*新しい子のoptr*/optr referenceChild, /*参照子のoptr*/wordフラグ);/*CompChildFlags*/</PRE>
<P>このユーティリティー・ルーチンは、子オブジェクトを複合オブジェクトに追加します。 これは、汎用オブジェクトのUIによってほぼ独占的に使用されます。<CODE>MSG_GEN_ADD_CHILD(子を追加)</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_GEN_ADD_CHILD(子を追加)</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、チャンクやオブジェクトブロックを移動したり、サイズを変更したりする場合があります。したがって、呼び出した後にポインタの参照を解除する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">goh世代</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenProcessAction()"></A>
        <H1 CLASS="refHeading">GenProcessAction()</H1>
<P>これはESPのみのルーチンです。 ほとんどの場合、Gocプログラマは以下を使います。<CODE>MSG_GEN_OUTPUT_ACTION[メッセージ生成-出力アクション]</CODE>見出しページを開きます。</P>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenProcessGenAttrsAfterAction()"></A>
        <H1 CLASS="refHeading">GenProcessGenAttrsAfterAction()</H1>
<PRE CLASS="syntax">void GenProcessGenAttrsAfterAction(MemHandle mh, /*ルーチンを呼び出しているオブジェクトのハンドル*/ChunkHandle chnk);/*ルーチンを呼び出しているオブジェクトのチャンク*/</PRE>
<P>このユーティリティー・ルーチンは、オブジェクトのアクション・メッセージが送信された後で、汎用オブジェクトの各種属性を処理します。 これは、ほとんどの場合<CODE>MSG_GEN_OUTPUT_ACTION[メッセージ生成-出力アクション]</CODE>または<CODE><A HREF="../../CRef/Routines/R_32.htm#IX_GenProcessAction()">GenProcessAction()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、チャンクやオブジェクトブロックを移動したり、サイズを変更したりする場合があります。したがって、呼び出した後にポインタの参照を解除する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">goh世代</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenProcessGenAttrsBeforeAction()"></A>
        <H1 CLASS="refHeading">GenProcessGenAttrsBeforeAction()</H1>
<PRE CLASS="syntax">void GenProcessGenAttrsBeforeAction(MemHandle mh, /*ルーチンを呼び出しているオブジェクトのハンドル*/ChunkHandle chnk);/*ルーチンを呼び出しているオブジェクトのチャンク*/</PRE>
<P>このユーティリティー・ルーチンは、オブジェクトのアクション・メッセージが送信される前に、汎用オブジェクトの各種属性を処理します。 これは、以前は汎用UIによってほぼ独占的に使用されていました。<CODE>MSG_GEN_OUTPUT_ACTION[メッセージ生成-出力アクション]</CODE>または<CODE><A HREF="../../CRef/Routines/R_32.htm#IX_GenProcessAction()">GenProcessAction()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、チャンクやオブジェクトブロックを移動したり、サイズを変更したりする場合があります。したがって、呼び出した後にポインタの参照を解除する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">goh世代</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenProcessUndoGetFile()"></A>
        <H1 CLASS="refHeading">GenProcessUndoGetFile()</H1>
<PRE CLASS="syntax">VMFileHandle GenProcessUndoGetFile x</PRE>
<P>このルーチンは、プロセスの元に戻す情報を保持するファイルのハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">オブジェクト/gProcC.goh</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenProcessUndoCheckIfIgnoring()"></A>
        <H1 CLASS="refHeading">GenProcessUndoCheckIfIgnoring()</H1>
<PRE CLASS="syntax">ブール値GenProcessUndoCheckIfIgnoring();</PRE>
<P>このルーチンは<EM>真</EM>プロセスが現在アクションを無視している場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">オブジェクト/gProcC.goh</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenRemoveDownwardLink()"></A>
        <H1 CLASS="refHeading">GenRemoveDownwardLink()</H1>
<PRE CLASS="syntax">void GenRemoveDownwardLink(MemHandle mh, /*呼び出しオブジェクトのハンドル*/ChunkHandle chnk, /*呼び出しオブジェクトのチャンク*/wordフラグ);/*CompChildFlags*/</PRE>
<P>このユーティリティー・ルーチンは、汎用ツリーから子を除去し、子の上方リンクおよび使用可能性フラグを保持します。 これは主に汎用UIによって呼び出され、アプリケーションではほとんど使用されません。 flagsパラメーターは、CCF_MARK_DIRTYフラグを渡すことによってオブジェクト・リンケージをダーティとマークするかどうかを指定します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、チャンクやオブジェクトブロックを移動したり、サイズを変更したりする場合があります。したがって、呼び出した後にポインタの参照を解除する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">goh世代</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_32.htm_IX_GenSetUpwardLink()"></A>
        <H1 CLASS="refHeading">GenSetUpwardLink()</H1>
<PRE CLASS="syntax">void GenSetUpwardLink(MemHandle mh, /*呼び出し元オブジェクトのハンドル*/ChunkHandle chnk, /*呼び出し元オブジェクトのチャンク*/optr親);/*呼び出し元オブジェクトの親のoptr*/</PRE>
<P>このユーティリティルーチンは、子/親リンクを上位リンクに変換します。 ロックされた子オブジェクトのハンドルとチャンク、および親コンポジットのoptrを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">goh世代</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_33.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_33.htm_IX_GeodeAllocQueue()"></A>
        <H1 CLASS="refHeading">GeodeAllocQueue()</H1>
<PRE CLASS="syntax">QueueHandle GeodeAllocQueue x</PRE>
<P>このルーチンは、イベントキューを割り当てます。割り当てたイベントキューは<CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadAttachToQueue()">ThreadAttachToQueue()</A></CODE>割り当てられている場合はキューのハンドルを返し、割り当てられていない場合は0を返します。 このルーチンは、例外的な状況でのみカーネルの外部で使用されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>キューの使用が終了したら、キューを解放する必要があります。<CODE><A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeQueue()">GeodeFreeQueue()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_33.htm_IX_GeodeDuplicateResource()"></A>
        <H1 CLASS="refHeading">GeodeDuplicateResource()</H1>
<PRE CLASS="syntax">MemHandle GeodeDuplicateResource(MemHandle mh);/*複製するgeodeリソースのハンドル*/</PRE>
<P>このルーチンは、geodeから新たに割り当てられたブロック(このルーチンによって割り当てられたブロック)にリソースを読み込みます。 リソースのそれ自体への再配置は、複製されたブロックになるように調整されます。 複製されたブロックのハンドルが返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">resource.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_33.htm_IX_GeodeFind()"></A>
        <H1 CLASS="refHeading">GeodeFind()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeFind(const char*name, /*geode&#39;s permanent name*/word numChars, /*照合する文字数:*nameは8、name.extは12*/GeodeAttrs attrMatch, /*設定する必要があるGeodeAttrs*/GeodeAttrs attrNoMatch);/*オフにする必要があるGeodeAttrs*/</PRE>
<P>このルーチンは、その永続的な名前が付けられたgeodeを検索し、見つかった場合はgeodeハンドルを返します。 geodeが見つからない場合は、ヌルハンドルが返されます。 次のように渡します。</P>
<DL>
<DT>
          <CODE>人名</CODE>
        </DT><DD>geodeのNULL終端された永続的な名前へのポインタ。</DD>
<DT>
          <CODE>文字数</CODE>
        </DT><DD>取得する前に照合する文字数を指定します。 永続的な名前に一致させるにはGEODE_NAME_SIZEを渡し、名前と拡張子に一致させるには(GEODE_NAME_SIZE+GEODE_NAME_EXT_SIZE)を渡します。</DD>
<DT>
          <CODE>attrMatch</CODE>
        </DT><DD>の記録<CODE>GeodeAttrs</CODE>対象のgeodeが一致するように設定されている必要があります。</DD>
<DT><CODE>attrNoMatch</DT><DD></CODE>の記録<CODE>GeodeAttrs</CODE>被験者のgeodeが一致した場合はクリアされている必要があります。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_33.htm_IX_GeodeFindResource()"></A>
        <H1 CLASS="refHeading">GeodeFindResource()</H1>
<PRE CLASS="syntax">word GeodeFindResource(FileHandleファイル、/*geodeの実行可能ファイル*/word resNum、/*検索するリソース番号*/word resOffset、/*リソースへのオフセット*/dword*base);/*2番目の戻り値へのポインタ*/</PRE>
<P>このルーチンは、geodeの実行可能ファイル(<STRONG CLASS="fileName">geoと入力します</STRONG>)ファイルを開きます。 リソースのサイズと、ファイル内のリソースの最初のバイトのベース位置(<CODE>ベース</CODE>)をクリックします。 次のものを渡します。</P>
<DL>
<DT>
          <CODE>やすり</CODE>
        </DT><DD>geodeの実行可能ファイルのファイルハンドル。</DD>
<DT>
          <CODE>リソース数</CODE>
        </DT><DD>検索するリソースの番号。</DD>
<DT>
          <CODE>resOffset</CODE>
        </DT><DD>ファイルの読み取り/書き込み位置を配置するリソース内のオフセット。</DD>
<DT>
          <CODE>ベース</CODE>
        </DT><DD>ルーチンによって入力されるdword値へのポインタ。 この値は、ファイルの先頭からリソースの最初のバイトまでのベースオフセットになります。</DD>
</DL>
<P CLASS="refField"><STRONG>構造:</STRONG>geodeの実行可能ファイルは、次のようにレイアウトされます。</P>
<PRE>0:Geodeファイルヘッダ</PRE>
<PRE>1:インポートされたライブラリテーブル</PRE>
<PRE>2:エクスポートされたルーチンテーブル</PRE>
<PRE>3:リソースサイズテーブル</PRE>
<PRE>4:リソース位置テーブル</PRE>
<PRE>5:再配置表サイズ表</PRE>
<PRE>6:割り当てフラグテーブル</PRE>
<PRE>7+:アプリケーションリソース</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_33.htm_IX_GeodeFlushQueue()"></A>
        <H1 CLASS="refHeading">GeodeFlushQueue()</H1>
<PRE CLASS="syntax">void GeodeFlushQueue(QueueHandleソース,/*フラッシュするソースキュー*/QueueHandle dest, /*フラッシュされたイベントを保持するキュー*/optr obj/*フラッシュされたイベントを処理するオブジェクト*/MessageFlagsフラグ);/*MF_INSERT_AT_FRONTまたはゼロ*/</PRE>
<P>このルーチンは、あるイベント・キューから別のイベント・キューにすべてのイベントを同期的にフラッシュします。 次のように渡します。</P>
<DL>
<DT>
          <CODE>源泉</CODE>
        </DT><DD>ソース・キュー(空にされるキュー)のキュー・ハンドル。</DD>
<DT>
          <CODE>宛先</CODE>
        </DT><DD>フラッシュされたイベントを受け取る宛先キューのキュー・ハンドル。</DD>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>ソース・キューを所有するプロセスを宛先とする、フラッシュされたイベントを処理するオブジェクト。宛先キューを所有するプロセスを使用する必要がある場合は、optrのハンドル部分に宛先キュー・ハンドルとNULLチャンク・ハンドルを渡します。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>MessageFlags</CODE>このルーチンで意味のあるフラグはMF_INSERT_AT_FRONTのみです。これは、ソース・キューのイベントを宛先キューの先頭にフラッシュするように設定する必要があります。このフラグが渡されない場合、イベントはキューに追加されます。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_33.htm_IX_GeodeFreeDriver()"></A>
        <H1 CLASS="refHeading">GeodeFreeDriver()</H1>
<PRE CLASS="syntax">ボイドGeodeFreeDriver(GeodeHandle gh)/*運転者のハンドル*/</PRE>
<P>このルーチンは、でロードされたドライバgeodeを解放します。<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseDriver()">GeodeUseDriver()</A></CODE>ルーチンから返されたドライバのgeodeハンドルを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライバ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_33.htm_IX_GeodeFreeLibrary()"></A>
        <H1 CLASS="refHeading">GeodeFreeLibrary()</H1>
<PRE CLASS="syntax">void GeodeFreeLibrary(GeodeHandle gh);/*ライブラリのハンドル*/</PRE>
<P>このルーチンは、でロードされたライブラリgeodeを解放します。<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseLibrary()">GeodeUseLibrary()</A></CODE>ライブラリのジオードハンドルを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ライブラリ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_33.htm_IX_GeodeFreeQueue()"></A>
        <H1 CLASS="refHeading">GeodeFreeQueue()</H1>
<PRE CLASS="syntax">void GeodeFreeQueue(QueueHandle qh);/*解放されるキューのハンドル*/</PRE>
<P>このルーチンは、以下で割り当てられたイベントキューを解放します。<CODE><A HREF="../../CRef/Routines/R_33.htm#IX_GeodeAllocQueue()">GeodeAllocQueue()</A></CODE>キューに残っているイベントは<CODE><A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFlushQueue()">GeodeFlushQueue()</A></CODE>解放するキューのハンドルを渡す必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_34.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeGetAppObject()"></A>
        <H1 CLASS="refHeading">GeodeGetAppObject()</H1>
<PRE CLASS="syntax">optr GeodeGetAppObject(GeodeHandle gh);/*アプリケーションgeodeのハンドル*/</PRE>
<P>このルーチンは、指定されたgeodeのGenApplicationオブジェクトのoptrを返します。 geodeはアプリケーションである必要があります。 呼び出し側のアプリケーション・オブジェクトのoptrを取得するには、0を渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeGetCodeProcessHandle()"></A>
        <H1 CLASS="refHeading">GeodeGetCodeProcessHandle()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeGetCodeProcessHandle x</PRE>
<P>このルーチンは、このルーチンを呼び出すコードが存在するブロックを所有するgeodeのgeodeハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeGetDefaultDriver()"></A>
        <H1 CLASS="refHeading">GeodeGetDefaultDriver()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeGetDefaultDriver(GeodeDefaultDriverTypeタイプ);/*取得するデフォルトドライバのタイプ*/</PRE>
<P>このルーチンは、渡されたタイプのデフォルトドライバのgeodeハンドルを返します。 タイプは、次のいずれかの値である必要があります。<CODE>GeodeDefaultDriverType</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライバ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeGetInfo()"></A>
          <A NAME="R_34.htm_IX_GeodeGetInfoType"></A>
          <A NAME="R_34.htm_IX_GGIT_&ldots;"></A>
        <H1 CLASS="refHeading">GeodeGetInfo()</H1>
<PRE CLASS="syntax">word geode(GeodeHandle gh, /*対象GeodeGetInfoのハンドル*/GeodeGetInfoType info, /*返す情報の型*/void*buf);/*返された情報を格納するバッファ*/</PRE>
<P>このルーチンは、指定されたgeodeに関する情報を返します。 geodeはすでにロードされている必要があります。 返される単語の意味は、渡された値によって異なります。<CODE>情報(info)</CODE>;をクリックします。<CODE>GeodeGetInfoType</CODE>を以下に示します。 次のものを渡します。</P>
<DL>
<DT>
          <CODE>ぐ</CODE>
        </DT><DD>geodeのgeodeハンドル。 ghがヌルの場合、ルーチンは現在のgeodeの情報を返す。</DD>
<DT>
          <CODE>情報(info)</CODE>
        </DT><DD>要求された情報のタイプ。次に示す値のいずれかになります。</DD>
<DT>
          <CODE>バッファ</CODE>
        </DT><DD>ロックされたバッファまたは固定バッファへのポインタ。このバッファには、要求されたさまざまなタイプの情報が格納されます。</DD>
</DL>
<P><CODE>GeodeGetInfoType</CODE>には次の列挙があります(一度に要求できるのは1つだけです)。</P>
<DL>
<DT>GGITの属性</DT><DD>geodeの属性を取得します。 戻り値は以下のレコードとなります。<CODE>GeodeAttrs</CODE>ジオードに設定された属性に対応しています。 NULLバッファポインタを渡します。</DD>
<DT>GGITタイプ</DT><DD>ジオードのタイプを取得します。 戻り値は次の値になります。<CODE>GeosFileType</CODE>ジオードを保存するファイルの種類を示します。 NULLバッファポインタを渡します。</DD>
<DT>GGIT_ジオード_リリース</DT><DD>geodeのリリース番号を取得します。 返されるワードは<CODE>バッファ</CODE>バッファには<CODE>リリース番号</CODE>ジオードの構造。</DD>
<DT>GGIT_ジオード_プロトコル</DT><DD>geodeのプロトコルレベルを取得します。 返されるワードは<CODE>バッファ</CODE>バッファには<CODE>プロトコル番号(ProtocolNumber)</CODE>ジオードの構造。</DD>
<DT>GGITトークンID</DT><DD>geodeのトークン識別子を取得します。 返されるワードは<CODE>バッファ</CODE>バッファには<CODE>GeodeToken</CODE>geodeのトークンのトークン文字とトークンIDを含む構造体。</DD>
<DT>GGIT_PERM_NAME_AND_EXT</DT><DD>ジオードの永続的な名前を取得します。拡張子は文字です。 返されるワードは<CODE>バッファ</CODE>バッファには、geodeの永続的な名前(geodeパラメータファイルで設定されている)を表すヌル終端の文字列が含まれます。 バッファは少なくとも13バイトでなければならないことに注意してください。</DD>
<DT>GGIT_PERM_NAME_ONLY</DT><DD>拡張子文字を除いたgeodeの永続的な名前を取得します。 返されるワードはbufが指すバッファのサイズとなり、そのバッファにはgeodeの永続的な名前を表すNULL終端文字列が格納される。 バッファは少なくとも9バイトでなければなりません。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeGetOptrNS()"></A>
        <H1 CLASS="refHeading">GeodeGetOptrNS()</H1>
<PRE CLASS="syntax">optr GeodeGetOptrNS(optr obj)</PRE>
<P>このルーチンはoptrをunrelocatesし、仮想セグメント・ハンドルを実際のグローバル・ハンドルに変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">resource.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeGetProcessHandle()"></A>
        <H1 CLASS="refHeading">GeodeGetProcessHandle()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeGetProcessHandle x</PRE>
<P>現在実行中のプロセス(現在実行中のスレッドの所有者)のgeodeハンドルを返すルーチンです。 アプリケーションのgeodeハンドルまたはProcessオブジェクトのハンドルをルーチンまたはメッセージに渡す必要がある場合に使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeGetUIData()"></A>
        <H1 CLASS="refHeading">GeodeGetUIData()</H1>
<PRE CLASS="syntax">単語GeodeGetUIData(GeodeHandle gh)</PRE>
<P></P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeInfoDriver()"></A>
        <H1 CLASS="refHeading">GeodeInfoDriver()</H1>
<PRE CLASS="syntax">DriverInfoStruct*GeodeInfoDriver(GeodeHandle gh);/*情報を取得するドライバのハンドル*/</PRE>
<P>このルーチンは、指定されたドライバgeodeに関する情報を返します。 で返されたドライバのgeodeハンドルを渡します。<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseDriver()">GeodeUseDriver()</A></CODE>へのポインタを返す。<CODE>DriverInfoStruct</CODE>以下に示す構造</P>
<PRE>typedef struct{void(*DIS_strategy)();DriverAttrs DIS_driverAttributes;driverType DIS_driverType;}DriverInfoStruct;</PRE>
<P>この構造の詳細については、を参照してください。<CODE>DriverInfoStruct</CODE>参照エントリ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライバ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeInfoQueue()"></A>
        <H1 CLASS="refHeading">GeodeInfoQueue()</H1>
<PRE CLASS="syntax">word GeodeInfoQueue(QueueHandle qh);/*照会するキュー*/</PRE>
<P>このルーチンは、特定のイベントキューに関する情報を返します。 キューのハンドルを渡します。現在のプロセスのキューに関する情報を得るには、nullハンドルを渡します。 このルーチンは、現在キューに入っているイベント(またはメッセージ)の数を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_34.htm_IX_GeodeLoad()"></A>
        <H1 CLASS="refHeading">GeodeLoad()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeLoad(const char*name, /*geodeのファイル名*/GeodeAttrs attrMatch, /*設定が必要なGeodeAttrs*/GeodeAttrs attrNoMatch, /*クリアが必要なGeodeAttrs*/word priority, /*ロードされたgeodeの優先度*/dword appInfo, /*特別なロード情報*/GeodeLoadError*err);/*返されたエラー値*/</PRE>
<P>このルーチンは、指定されたファイルから指定されたgeodeをロードし、そのタイプに基づいてgeodeを実行します。 ロードに成功した場合は、ロードされたgeodeのgeodeハンドルを返します。ロードに失敗した場合、返される値はNullHandleと<CODE>エラー</CODE>ポインタはエラー値を指します。 このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>人名</CODE>
        </DT><DD>geodeのファイル名へのポインタ。 ファイルのフルパス(または現在の作業ディレクトリからの相対パス)を表すヌル終了文字列です。</DD>
<DT>
          <CODE>attrMatch</CODE>
        </DT><DD>の記録<CODE>GeodeAttrs</CODE>ロードを正常に行うには、指定されたgeodeに設定する必要があります。</DD>
<DT><CODE>attrNoMatch</DT><DD></CODE>の記録<CODE>GeodeAttrs</CODE>ロードを正常に行うには、指定されたgeodeでこれをクリアする必要があります。 (すなわち<CODE>attrNoMatch</CODE>ジオードの中ではっきりしていなければならない<CODE>GeodeAttrs</CODE>)を持つセルをシート内で</DD>
<DT>
          <CODE>優先権</CODE>
        </DT><DD>サブジェクトgeodeがプロセスの場合、これはそのプロセススレッドが実行されるときの優先順位です。</DD>
<DT>
          <CODE>appInfo(英語の可能性あり</CODE>
        </DT><DD>ロードされたgeodeに直接渡される2ワードのデータ。 ライブラリとドライバの場合、これはNULL終端されたパラメータ文字列へのfarポインタであるべきです。</DD>
<DT>
          <CODE>エラー</CODE>
        </DT><DD>空のへのポインタ<CODE>GeodeLoadError</CODE>これは、返されたエラー値を保持します。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>geodeを動的にロードするには<CODE>GeodeLoad()</CODE>を使用している場合は<CODE><A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeDriver()">GeodeFreeDriver()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeLibrary()">GeodeFreeLibrary()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_35.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_35.htm_IX_GeodeLoadDGroup()"></A>
          <A NAME="R_35.htm_IX_dgroup:GeodeLoadDGroup()"></A>
        <H1 CLASS="refHeading">GeodeLoadDGroup</H1>
<PRE CLASS="syntax">空隙GeodeLoadDGroup(MemHandle mh)</PRE>
<P>このルーチンは<CODE>dグループ</CODE>セグメントをデータセグメントレジスタに書き込む。 このルーチンは<CODE>MemHandle</CODE>で取得できます。<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeGetCodeProcessHandle()">GeodeGetCodeProcessHandle()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">resource.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_35.htm_IX_GeodePrivAlloc()"></A>
          <A NAME="R_35.htm_IX_Geodes:private data"></A>
          <A NAME="R_35.htm_IX_Private data:GeodePrivAlloc()"></A>
        <H1 CLASS="refHeading">GeodePrivAlloc()</H1>
<PRE CLASS="syntax">word GeodePrivAlloc(GeodeHandle gh, /*新しく割り当てられたプライベートデータ*/のオーナーのハンドル</PRE>
<PRE CLASS="syntax">word numWords);/*割り当てる単語数*/</PRE>
<P>このルーチンは、すべての測地のプライベートデータ領域に連続する単語の文字列を割り当てます。各単語のセットは<CODE>ぐ</CODE>割り当てられたデータには<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivWrite()">GeodePrivWrite()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivRead()">GeodePrivRead()</A></CODE>で解放する必要があります。<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivFree()">GeodePrivFree()</A></CODE>戻り値は、割り当てられた範囲の先頭までのオフセット、またはルーチンが領域を割り当てることができなかった場合はゼロになります。</P>
<P>各geodeにはプライベートデータのブロックがあり<CODE>GeodePriv…………………………………</CODE>ルーチン。 特定のジオードのプライベートデータブロックは、有効な<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivWrite()">GeodePrivWrite()</A></CODE>ジオードに対して実行されます。 領域は、すべての測地座標(ロードされているか、まだロードされていない測地座標)のデータブロックに<CODE>GeodePrivAlloc()</CODE>一度も書き込まれていないデータは、すべてゼロとして返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_35.htm_IX_GeodePrivFree()"></A>
        <H1 CLASS="refHeading">GeodePrivFree()</H1>
<PRE CLASS="syntax">void GeodePrivFree(word offset, /*offset returned by GeodePrivAlloc()*/word numWords);/*解放する単語数*/</PRE>
<P>このルーチンは、すべての測地のプライベートデータ領域から連続するワードのグループを解放します。 この領域は、以前に<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>によって返された単語にオフセットを渡します。<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>解放するワード数も指定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_35.htm_IX_GeodePrivRead()"></A>
        <H1 CLASS="refHeading">GeodePrivRead()</H1>
<PRE CLASS="syntax">void GeodePrivRead(GeodeHandle gh, /*プライベートデータのオーナーのハンドル*/word offset, /**GeodePrivAlloc()で返されるオフセット*/</PRE>
<PRE CLASS="syntax">word numWords, /*読み込むワード数*/word*dest);/*データ*がコピーされるバッファへのポインタ*/</PRE>
<P>このルーチンは、geodeのプライベートデータ領域からいくつかの単語を読み込みます。 次のものを渡します。</P>
<DL>
<DT>
          <CODE>ぐ</CODE>
        </DT><DD>読み込まれるプライベートデータの所有者のgeodeハンドル。</DD>
<DT>
          <CODE>オフセット(offset)</CODE>
        </DT><DD>によって返されるプライベートデータへのオフセット<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>ボタンをクリックし</DD>
<DT>
          <CODE>単語数</CODE>
        </DT><DD>読み上げる単語数を指定します。</DD>
<DT>
          <CODE>宛先</CODE>
        </DT><DD>ワードが読み込まれるロックされたバッファまたは固定バッファへのポインタ。 最低でも<CODE>単語数</CODE>単語の長さ。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_35.htm_IX_GeodePrivWrite()"></A>
        <H1 CLASS="refHeading">GeodePrivWrite()</H1>
<PRE CLASS="syntax">void GeodePrivWrite(GeodeHandle gh, /*プライベートデータのオーナーのハンドル*/word offset, /**GeodePrivAlloc()で返されるオフセット*/</PRE>
<PRE CLASS="syntax">word numWords, /*書き込むワード数*/word*src);/*データを含むバッファ*/</PRE>
<P>このルーチンは、geodeのプライベートデータ領域にいくつかの単語を書き込みます。 書き込まれる領域は、以前に<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>次のものを渡します。</P>
<DL>
<DT>
          <CODE>ぐ</CODE>
        </DT><DD>プライベート・データ・スペースの所有者のgeodeハンドル。</DD>
<DT>
          <CODE>オフセット(offset)</CODE>
        </DT><DD>によって返される、書き込みを開始するオフセット<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>ボタンをクリックし</DD>
<DT>
          <CODE>単語数</CODE>
        </DT><DD>書き込む単語数を指定します。 これは、以前に割り当てられた数を超えないようにする必要があります。</DD>
<DT>
          <CODE>ソース</CODE>
        </DT><DD>書き込まれるデータを含む、ロックされたバッファまたは固定バッファへのポインタ。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_35.htm_IX_GeodeSetDefaultDriver()"></A>
        <H1 CLASS="refHeading">GeodeSetDefaultDriver()</H1>
<PRE CLASS="syntax">void GeodeSetDefaultDriver(GeodeDefaultDriverTypeタイプ,/*設定するデフォルトドライバのタイプ*/GeodeHandle gh);/*デフォルトとして設定するドライバ*/</PRE>
<P>このルーチンは、指定されたドライバ・タイプのデフォルト・ドライバを設定します。 デフォルトドライバのタイプを<CODE>種類</CODE>ドライバのハンドルが<CODE>ぐ</CODE>タイプはの値である必要があります<CODE>GeodeDefaultDriverType</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライバ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_35.htm_IX_GeodeSetUIData()"></A>
        <H1 CLASS="refHeading">GeodeSetUIData()</H1>
<PRE CLASS="syntax">void GeodeSetUIData(GeodeHandle gh, ワードデータ)</PRE>
<P></P>
</DIV>
<DIV>
          <A NAME="R_35.htm_IX_GeodeUseDriver()"></A>
        <H1 CLASS="refHeading">GeodeUseDriver()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeUseDriver(const char*name, /*ロードするドライバのファイル名*/word protoMajor, /*予想されるメジャープロトコル*/word protoMinor, /*予想されるマイナープロトコル*/GeodeLoadError*err);/*返されたエラーへのポインタ*/</PRE>
<P>このルーチンは、ドライバのファイル名を指定して、ドライバgeodeを動的にロードします。 成功した場合は、ドライバのgeodeハンドルを返します。失敗した場合は<CODE>GeodeLoadError</CODE>によって示される<CODE>エラー</CODE>このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>人名</CODE>
        </DT><DD>ドライバのNULL終端されたフルパスとファイル名へのポインタ。</DD>
<DT>
          <CODE>protoMajor</CODE>
        </DT><DD>予想されるドライバのメジャープロトコル。 ゼロの場合、任意のプロトコルが受け入れられます。</DD>
<DT>
          <CODE>protoMinor</CODE>
        </DT><DD>予想されるドライバのマイナープロトコル。</DD>
<DT>
          <CODE>エラー</CODE>
        </DT><DD>へのポインタ<CODE>GeodeLoadError</CODE>エラー値が返されます。</DD>
</DL>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>geodeパラメータファイルにドライバを記録しておくと、必要なドライバを自動的にロードするのがずっと簡単になります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>を使用すると<CODE>GeodeUseDriver()</CODE>ドライバを動的にロードするには<CODE><A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeDriver()">GeodeFreeDriver()</A></CODE>をクリックして、使用を終了したときに解放します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ドライバ.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_35.htm_IX_GeodeUseLibrary()"></A>
        <H1 CLASS="refHeading">GeodeUseLibrary()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeUseLibrary(const char*name, /*ロードするライブラリのファイル名*/word protoMajor, /*予想されるメジャープロトコル*/word protoMinor, /*予想されるマイナープロトコル*/GeodeLoadError*err);/*返されたエラーへのポインタ*/</PRE>
<P>このルーチンは、ライブラリのファイル名を指定すると、ライブラリgeodeを動的にロードします(ライブラリはスレッドの作業ディレクトリ内にある必要があります)。 ロードに成功した場合は、ロードされたライブラリのgeodeハンドルを返します。<CODE>GeodeLoadError</CODE>)が指しているのは<CODE>エラー</CODE>このルーチンに次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>人名</CODE>
        </DT><DD>ライブラリのヌル終了ファイル名へのポインタ。</DD>
<DT>
          <CODE>protoMajor</CODE>
        </DT><DD>ライブラリの予想されるメジャープロトコル。 ゼロの場合、任意のプロトコルが受け入れられます。</DD>
<DT>
          <CODE>protoMinor</CODE>
        </DT><DD>ライブラリの予想されるマイナープロトコル。</DD>
<DT>
          <CODE>エラー</CODE>
        </DT><DD>へのポインタ<CODE>GeodeLoadError</CODE>これには、戻されたエラー値が含まれます。</DD>
</DL>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ライブラリを動的にロードする場合<CODE>GeodeUseLibrary()</CODE>を選択した場合は<CODE><A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeLibrary()">GeodeFreeLibrary()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ライブラリ.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_36.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_36.htm_IX_GeoFree()"></A>
        <H1 CLASS="refHeading">GeoFree関数()</H1>
<PRE CLASS="syntax">void*GeoFree(void*blockPtr, /*解放するメモリのアドレス*/GeodeHandle geodeHan);/*使用するブロックのオーナー*/</PRE>
<P>ルーチン<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>は、呼び出し元のgeodeに属するmallocブロック内のメモリだけを解放できる。 別のgeodeのmalloc-blockのメモリを解放したい場合は<CODE>GeoFree関数()</CODE>nullを渡す<CODE>GeodeHandle</CODE>作る<CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE>呼び出し元のgeodeのmallocブロック内のメモリに作用する。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>メモリを割り当てたときに返されたアドレスとまったく同じアドレスを渡します。 別のアドレスを渡すと<CODE>GeoFree関数()</CODE>は、他のメモリを消去したり、システムをクラッシュさせたりするなど、予測できない動作を行います。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">関数free()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_36.htm_IX_GeoMalloc()"></A>
        <H1 CLASS="refHeading">GeoMalloc()</H1>
<PRE CLASS="syntax">void*GeoMalloc(size_t blockSize, /*割り当てるバイト数*/GeodeHandle geodeHan, /*使用するブロックのオーナー*/word zeroInit);/*メモリをゼロ初期化しますか? (注)</PRE>
<P>ルーチン<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>は呼び出し元のgeodeに属するmalloc-blockにメモリを自動的に割り当てる。 メモリのゼロ初期化は行いません。 メモリをゼロ初期化する場合や、別のgeodeのmalloc-blockに割り当てたい場合は<CODE>GeoMalloc()</CODE>パス<EM>真</EM>(すなわち、非ゼロ)<CODE>zeroInit</CODE>メモリをゼロ初期化する。</P>
<P>ヌルを渡す<CODE>GeodeHandle</CODE>作る<CODE>GeoMalloc()</CODE>呼び出し元のgeodeのmalloc-blockにメモリを割り当てる。 &quot;zeroInit&quot;が真の場合、メモリはヌルバイトに初期化されます。そうでない場合、メモリは初期化されないままになります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>で割り当てられたすべてのメモリ<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>は、GEOSのシャットダウン時に解放されます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_36.htm_IX_GeoReAlloc()"></A>
        <H1 CLASS="refHeading">GeoReAlloc()</H1>
<PRE CLASS="syntax">void*GeoReAlloc(void*blockPtr, /*リサイズするメモリのアドレス*/size_t newSize, /*新しいサイズのバイト数*/GeodeHandle geodeHan);/*使用するブロックのオーナー*/</PRE>
<P>ルーチン<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">参照):realloc()</A></CODE>は、呼び出し元のgeodeに属するmallocブロック内のメモリのみをリサイズできる。 別のgeodeのmalloc-blockのメモリサイズを変更したい場合は<CODE>GeoReAlloc()</CODE>nullを渡す<CODE>GeodeHandle</CODE>作る<CODE>GeoReAlloc()</CODE>呼び出し元のgeodeのmallocブロック内のメモリに作用する。</P>
<P>ブロックのサイズが大きく変更された場合、新しいメモリはゼロ初期化されません。 ブロックのサイズを小さくしても、失敗することはありません。 次の場合<CODE>GeoReAlloc()</CODE>が失敗すると、NULLポインタ(ゼロ)を返す。 合格した場合<CODE>新しいサイズ</CODE>が0の場合、渡されたブロックポインタは解放され、戻りポインタはヌルポインタになる。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>メモリを割り当てたときに返されたアドレスとまったく同じアドレスを渡します。 別のアドレスを渡すと<CODE>GeoReAlloc()</CODE>は、他のメモリを消去したり、システムをクラッシュさせたりするなど、予測できない動作を行います。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">参照):realloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_36.htm_IX_GrApplyRotation()"></A>
        <H1 CLASS="refHeading">GrApplyRotation()</H1>
<PRE CLASS="syntax">void GrApplyRotation(GStateHandle GState,/*GState to alter*/WWFixedAsDWord angle);/*degrees counterclockwise*/</PRE>
<P>GStateの変換行列に回転を適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_36.htm_IX_GrApplyScale()"></A>
        <H1 CLASS="refHeading">GrApplyScale()</H1>
<PRE CLASS="syntax">void GrApplyScale(GStateHandle GState,/*GState to alter*/WWFixedAsDWord xScale, /*new xScale factor*/WWFixedAsDWord yScale);/*new yScale factor*/</PRE>
<P>GStateの変換行列にスケール係数を適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_36.htm_IX_GrApplyTransform()"></A>
        <H1 CLASS="refHeading">GrApplyTransform()</H1>
<PRE CLASS="syntax">void GrApplyTransform(GStateHandle GState,/*描画するGState*/const TransMatrix*tm);/*適用する変換行列*/</PRE>
<P>変換行列として表される変換をGStateの座標系に適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_37.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_GrApplyTranslation()"></A>
        <H1 CLASS="refHeading">GrApplyTranslation()</H1>
<PRE CLASS="syntax">void GrApplyTranslation(GStateHandle GState,/*GState to alter*/WWFixedAsDWord xTrans, /*translation in x*/WWFixedAsDWord yTrans);/*translation in y*/</PRE>
<P>GStateに変換を適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_GrApplyTranslationDWord()"></A>
        <H1 CLASS="refHeading">GrApplyTranslationDWord()</H1>
<PRE CLASS="syntax">void GrApplyTranslationDWord(GStateHandle GState,/*GState to alter*/sdword xTrans, /*extended translation in x*/sdword yTrans);/*extended translation in y*/</PRE>
<P>32ビット整数の拡張変換をGStateに適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_GrBeginPath()"></A>
        <H1 CLASS="refHeading">GrBeginPath()</H1>
<PRE CLASS="syntax">void GrBeginPath(GStateHandle GState,/*GState to alter*/PathCombineType params);/*パスパラメータ*/</PRE>
<P>GStateに関連付けられたパスを開始または変更します。 までに実行されるすべてのグラフィック操作<CODE><A HREF="../../CRef/Routines/R_3e.htm#IX_GrEndPath()">GrEndPath()</A></CODE>が呼び出されると、パスの一部になります。</P>
<P>の値に応じて<CODE>パラメータぱらめー</CODE>フィールドで、新しいパスが古いパスに置き換わるか、交差または結合によって古いパスと結合されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_GrBeginUpdate()"></A>
        <H1 CLASS="refHeading">GrBeginUpdate()</H1>
<PRE CLASS="syntax">void GrBeginUpdate(GStateHandle GState);/*描画するGState*/</PRE>
<P>アプリケーションによって呼び出され、公開領域の更新を開始しようとしていることを通知します。 このルーチンは通常<CODE>MSG_META_EXPOSED(メタデータの公開)</CODE>ハンドラ。 無効な領域を空白にします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_Video drivers:blitting"></A>
          <A NAME="R_37.htm_IX_GrBitBlt()"></A>
          <A NAME="R_37.htm_IX_BLTMode"></A>
          <A NAME="R_37.htm_IX_BLTM_&ldots;"></A>
        <H1 CLASS="refHeading">GrBitBlt()</H1>
<PRE CLASS="syntax">void GrBitBlt(GStateHandle GState,/*GState to draw to*/sword sourceX, /*original x origin*/sword sourceY, /*original y origin*/sword destX, /*new x origin*/sword destY, /*new y origin*/word width, /*width of area*/word height, /*height of area*/BLTMode mode);/*描画モード(下記参照)*/</PRE>
<P>ビデオメモリ内の2つの場所の間で、ピクセルのビット境界ブロックを転送します。 このルーチンは、画面内でドローイングを移動するアニメーションやその他のアプリケーションに便利です。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef enum/*word*/{region_COPY, /*Leave source region alone*/BLTM_MOVE, /*Clear&amp;invalidate source rect*/BLTM_CLEAR/*Clear source rectangle*/}BLTMode;BLTM</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_GrBrushPolyline()"></A>
        <H1 CLASS="refHeading">GrBrushPolyline()</H1>
<PRE CLASS="syntax">void GrBrushPolyline(GStateHandle GState,/*描画するGState*/const Point*points, /*描画するPoint構造体の配列*/word numPoints, /*配列内のポイントの数*/word brushH, /*ブラシの高さ*/word brushW);/*ブラシの幅*/</PRE>
<P>ブラシで接続されたポリラインを描画します。 このルーチンはGStateの線幅を無視し、代わりにピクセル単位で測定されたブラシの高さと幅を使用することに注意してください。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_GrCharMetrics()"></A>
          <A NAME="R_37.htm_IX_GCM_Info"></A>
          <A NAME="R_37.htm_IX_GCMI_&ldots;"></A>
        <H1 CLASS="refHeading">GrCharMetrics()</H1>
<PRE CLASS="syntax">dword GrCharMetrics(GStatehandle GState,/*メトリックを取得するGState*/GCM_info info, /*返される情報*/word ch);/*Chars型の文字*/</PRE>
<P>フォントの1文字のメトリック情報を返します。 この情報は、文字の描画境界を決定するために使用されます。 文字の幅(テキストの行を1文字ずつ描画する場合にどれだけのスペースを残すか)を調べるには<CODE><A HREF="../../CRef/Routines/R_37.htm#IX_GrCharWidth()">GrCharWidth()</A></CODE>見出しページを開きます。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef enum{GCMI_MIN_X, /*return=value&lt;&lt;16*/GCMI_MIN_X_ROUNDED, /*return=value*/GCMI_MIN_Y, /*return=value&lt;&lt;16*/GCMI_MIN_Y_ROUNDED, /*return=value&lt;&lt;16*/GCMI_MAX_X, /*return=value&lt;&lt;16*/GCMI_MAX_X_ROUNDED, /*return=value&lt;&lt;16*/GCMI_MAX_Y, /*return=value&lt;&lt;16*/GCMI_MAX_Y_ROUNDED/*return=value&lt;&lt;16*/}GCM_Info;</PRE>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_37.htm#IX_GrCharWidth()">GrCharWidth()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_GrCharWidth()"></A>
        <H1 CLASS="refHeading">GrCharWidth()</H1>
<PRE CLASS="syntax">dword GrCharWidth(/*Returns width&lt;&lt;16*/GStateHandle GState,/*GState to query*/word ch);/*Chars型の文字*/</PRE>
<P>1文字の幅を返します。 このルーチンは、トラックカーニング、ペアワイズカーニング、スペースパディング、または複数の文字に適用されるその他の属性を考慮しないことに注意してください。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_GrCheckFontAvailID()"></A>
        <H1 CLASS="refHeading">GrCheckFontAvailID()</H1>
<PRE CLASS="syntax">FontID GrCheckFontAvailID(FontEnumFlagsフラグ、語族、FontID ID);</PRE>
<P>フォント(IDで識別)が存在するかどうかを確認します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_37.htm_IX_GrCheckFontAvailName()"></A>
        <H1 CLASS="refHeading">GrCheckFontAvailName()</H1>
<PRE CLASS="syntax">FontID GrCheckFontAvailName(FontEnumFlagsフラグ,語族,const char*name);</PRE>
<P>フォント(名前で識別)が存在するかどうかを確認します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_38.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_38.htm_IX_GrClearBitmap()"></A>
        <H1 CLASS="refHeading">GrClearBitmap()</H1>
<PRE CLASS="syntax">void GrClearBitmap(GStateHandle GState);/*影響を与えるG状態*/</PRE>
<P>ビットマップの内容を消去します。 ビットマップの実際に消去される部分は、ビットマップモードによって異なります。 通常モードでは、ビットマップのデータ部分がクリアされます。 ビットマップがBM_EDIT_MASKモードの場合、マスクはクリアされ、データ部分はそのままになります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_38.htm_IX_GrCloseSubPath()"></A>
        <H1 CLASS="refHeading">GrCloseSubPath()</H1>
<PRE CLASS="syntax">void GrCloseSubPath(GStateHandle GState);/*影響を与えるG状態*/</PRE>
<P>現在開いているパスセグメントを幾何学的に閉じます。 この場合も<CODE><A HREF="../../CRef/Routines/R_3e.htm#IX_GrEndPath()">GrEndPath()</A></CODE>をクリックしてパス定義を終了します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_38.htm_IX_GrComment()"></A>
        <H1 CLASS="refHeading">GrComment()</H1>
<PRE CLASS="syntax">void GrComment(GStateHandle GState,/*影響するGState*/const void*data, /*コメント文字列*/word size);/*データのサイズ(バイト)*/</PRE>
<P>グラフィック文字列にコメントを書き込みます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_38.htm_IX_GrCopyGString()"></A>
        <H1 CLASS="refHeading">GrCopyGString()</H1>
<PRE CLASS="syntax">GSRetType GrCopyGString(GStateHandleソース、/*GStringを取得するGState*/GStateHandle dest、/*GStringをコピーするGState*/GSControlフラグ);/*コピーのフラグ*/</PRE>
<P>グラフィックス文字列の全部または一部をコピーします。 の<CODE>GSControl</CODE>レコードは以下のフラグを持つことができます。</P>
<PRE>GSC_ONE/*要素を1つだけ実行*/GSC_MISC/*MISCオペコードを返す*/GSC_LABEL/*GR_LABELオペコードを返す*/GSC_ESCAPE/*GR_ESCAPEオペコードを返す*/GSC_NEW_PAGE/*NEW_PAGEに到達したときに返す*/GSC_XFORM/*TRANSFORMATIONopcodeを返す*/GSC_OUTPUT:/*OUTPUTオペコードを返す*/GSC_ATTR/*ATTRIBUTEオペコードを返す*/GSC_PATH/*PATHオペコードを返す*/</PRE>
<P>戻り値は、次のいずれかです。<CODE>GSRetType</CODE>、バイトサイズフィールド:</P>
<PRE>GSRT_COMPLETE GSRT_ONE GSRT_MISC GSRT_LABEL GSRT_ESCAPE GSRT_NEW_PAGE GSRT_XFORM GSRT_OUTPUT GSRT_ATTR GSRT_PATH GSRT_FAULT</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_38.htm_IX_GrCreateBitmap()"></A>
        <H1 CLASS="refHeading">GrCreateBitmap()</H1>
<PRE CLASS="syntax">VMBlockHandle GrCreateBitmap(BMFormat initFormat、/*ビットマップのカラー形式*/ワードinitWidth、/*ビットマップの初期幅*/ワードinitHeight、/*ビットマップの初期高さ*/VMFileHandle vmFile、/*ビットマップのデータを保持するVMファイル*/optr exposureOD、/*MSG_META_EXPOSEDを取得するoptr*/GStateHandle*bmgs);/*このGStateへの描画*はビットマップへの描画を行います*/</PRE>
<P>このルーチンは、ビットマップ用のメモリを割り当て、ビットマップを保持するためのオフスクリーンウィンドウを作成します。 このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>initFormat</EM>
        </DT><DD>ビットマップのカラーの深度です。</DD>
<DT>
          <EM>initWidth</EM>
        </DT><DD>ビットマップの幅。</DD>
<DT>
          <EM>initHeight</EM>
        </DT><DD>ビットマップの高さ。</DD>
<DT>
          <EM>vmFile</EM>
        </DT><DD>ビットマップデータを保持するファイル。ルーチンはこのファイル内にブロックを割り当てます。</DD>
<DT><EM>exposureOD</EM>ビットマップのウィンドウが無効になったときに「エクスポーズされた」メッセージを受け取るオブジェクト。 この引数が0の場合、公開メッセージは送信されません。</DT><DD>ビットマップを格納するために、オフスクリーンウィンドウが作成されます。 このウィンドウは、最初に作成されたときには無効になりますが、その後の操作によって再び無効になることも考えられます。 これらの場合、この引数で指定されたオブジェクトはMSG_META_EXPOSEDを受け取ります。</DD>
<DT>
          <EM>ボタン</EM>
        </DT><DD>この引数で指定されたGStateHandleは、最初はヌルにすることができます。ルーチンはこれを使用して、ビットマップを描画するためのGStateを返します。 この返されたGStateを参照するグラフィックスルーチンは、ビットマップ上で実行されます。</DD>
</DL>
<P>このルーチンは<CODE>VMBlockHandle</CODE>ビットマップのデータを含む、渡されたVMファイル内のブロックのハンドル。 ブロックは、HugeArrayの最初のブロックとして設定されます。 ヘッダ領域には、次の内容が表示されます。</P>
<DL>
<DT>複雑なビットマップヘッダー</DT><DD>これは<CODE>Cビットマップ</CODE>ビットマップに関する基本的な情報を含む構造体。</DD>
<DT>編集モード</DT><DD>これらのフラグは、ビットマップの編集方法を変更できます。</DD>
<DT>デバイス情報ブロック</DT><DD>この内部構造には、ビデオドライバに関する情報と、ビデオドライバが使用する情報が含まれています。 (この構造体のサイズがわからなくても心配する必要はありません。CBitmap構造体には、ビットマップとパレットのデータ領域のオフセットが含まれていることに注意してください)。</DD>
<DT>パレット情報(オプション)</DT><DD>ビットマップに独自のパレットがある場合、ここにパレットデータが格納されます。これは3バイトエントリの配列で構成されます。 ビットマップがサポートするカラーの数に応じて、この配列には16個または256個のエントリがあります。</DD>
</DL>
<P>ビットマップの生データはVMブロック内にありますが、ヘッダー領域の外側にあります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_38.htm_IX_GrCreateGString()"></A>
        <H1 CLASS="refHeading">GrCreateGString()</H1>
<PRE CLASS="syntax">GStateHandle GrCreateGString(ハンドルhan、/*メモリ、ストリーム、またはVMファイルハンドル*/GStringType hanType、/*ハンドルのタイプin hanパラメータ*/word*gsBlock);/*GST_MEMORYおよび*GST_VMEMタイプに対してのみ返されます*/</PRE>
<P>グラフィックス文字列を開き、文字列へのグラフィックス順序のリダイレクトを開始します。 hanTypeパラメータは、GST_MEMORY、GST_STREAM、またはGST_VMEMである必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_38.htm_IX_GrCreatePalette()"></A>
        <H1 CLASS="refHeading">GrCreatePalette()</H1>
<PRE CLASS="syntax">word GrCreatePalette(/*カラーテーブルのエントリ数を返します。*モノクロまたは24ビットの場合は0を返します。*/</PRE>
<PRE CLASS="syntax">GStateHandleの状態)</PRE>
<P>カラーマッピングテーブルを作成し、現在のウィンドウに関連付けます。 テーブルエントリをデバイスのデフォルトパレットに初期化します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_38.htm_IX_GrCreateState()"></A>
        <H1 CLASS="refHeading">GrCreateState()</H1>
<PRE CLASS="syntax">GStateHandle GrCreateState(WindowHandle win);/*GStateがアクティブになるウィンドウ*/</PRE>
<P>デフォルトのGState情報を含むグラフィックステート(GState)ブロックを作成します。</P>
<P>0が渡された場合、作成されるGStateには関連付けられたウィンドウがありません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_38.htm_IX_GrDeleteGStringElement()"></A>
        <H1 CLASS="refHeading">GrDeleteGStringElement()</H1>
<PRE CLASS="syntax">void GrDeleteGStringElement(GStateHandle GState,/*GStringを含むGState*/word count);/*削除する要素の数*/</PRE>
<P>渡されたGStateのGStringから、GString要素の範囲を削除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_39.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDestroyBitmap()"></A>
          <A NAME="R_39.htm_IX_BMDestroy"></A>
          <A NAME="R_39.htm_IX_BMD_&ldots;"></A>
        <H1 CLASS="refHeading">GrDestroyBitmap()</H1>
<PRE CLASS="syntax">void GrDestroyBitmap(GStateHandle GState,/*ビットマップを含むGState*/BMDestroyフラグ);/*データを削除するためのフラグ*/</PRE>
<P>ビットマップを解放し、ウィンドウとの関連付けを解除します。 渡されたフラグに応じて、ビットマップのデータは解放されるか保持されます。 これにより、ビットマップを描画可能な状態に維持したまま、ビットマップの編集に使用したGStringを削除することができる。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE>typedef ByteEnum BMDestroy;/*BMD_KILL_DATA, BMD_LEAVE_DATA*/</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDestroyGString()"></A>
          <A NAME="R_39.htm_IX_GStringKillType"></A>
          <A NAME="R_39.htm_IX_GSKT_&ldots;"></A>
        <H1 CLASS="refHeading">GrDestroyGString()</H1>
<PRE CLASS="syntax">void GrDestroyGString(Handle GString,/*GStringのハンドル*/GStateHandle gstate, /*NULL, または解放する別の*gstate*/のハンドル)</PRE>
<PRE CLASS="syntax">GStringKillTypeタイプ);/*データ削除の強制終了タイプ*/</PRE>
<P>GStringを破棄します。 に応じて<CODE>GStringKillType</CODE>これは、GStringデータからGStateを削除するか、GStateとGStringの両方のデータを解放することになります。 GStringをGStateに描画している場合は、GStateのハンドルを次のように渡す必要があります。<EM>g状態</EM>このルーチンはクリーンアップを実行します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE>typedef ByteEnum GStringKillType;/*GSKT_KILL_DATA, GSKT_LEAVE_DATA*/</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDestroyPalette()"></A>
        <H1 CLASS="refHeading">GrDestroyPalette()</H1>
<PRE CLASS="syntax">void GrDestroyPalette(GStateHandle GState);/*破棄するパレットのG状態*/</PRE>
<P>現在のウィンドウに関連付けられているカスタムパレットを解放します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDestroyState()"></A>
        <H1 CLASS="refHeading">GrDestroyState()</H1>
<PRE CLASS="syntax">void GrDestroyState(GStateHandle GState);/*破棄されるG状態*/</PRE>
<P>グラフィックステートブロックを解放します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDrawArc()"></A>
        <H1 CLASS="refHeading">GrDrawArc()</H1>
<PRE CLASS="syntax">void GrDrawArc(GStateHandle GState,/*GState to draw to*/sword left, /*box outlineing arcの境界*/sword top, sword right, sword bottom, word startAngle, /*角度in degrees word endAngle, *反時計回り*/ArcCloseType arcType);/*弧がどのように閉じているか*/</PRE>
<P>境界ボックスで指定された楕円に沿って、開始角度から終了角度まで円弧を描きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDrawArc3Point()"></A>
        <H1 CLASS="refHeading">GrDrawArc 3点()</H1>
<PRE CLASS="syntax">void GrDrawArc3Point(GStateHandle GState,/*GState to draw to*/const ThreePointArcParams*params);</PRE>
<P>円弧に沿った3つの点(両方の端点と円弧上の他の点)を指定して、円弧を描きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDrawArc3PointTo()"></A>
        <H1 CLASS="refHeading">GrDrawArc3PointTo()</H1>
<PRE CLASS="syntax">void GrDrawArc3PointTo(GStateHandle GState,/*GState to draw to*/const ThreePointArcToParams*params);</PRE>
<P>[形式]<CODE>GrDrawArc 3点()</CODE>ただし、現在の位置は自動的に終点の1つとして使用されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDrawBitmap()"></A>
        <H1 CLASS="refHeading">GrDrawBitmap()</H1>
<PRE CLASS="syntax">void GrDrawBitmap(GStateHandle GState,/*GState to draw to*/sword x, /*x starting point*/sword y, /*y starting point*/const Bitmap*bm, /*ビットマップへのポインタ*/Bitmap*_pascal(*callback)(Bitmap*bm));/*コールバックがない場合はNULL*/</PRE>
<P>ビットマップを描画します。 ビットマップが大量のメモリを消費する場合は、描画時にそのメモリを管理する必要があります。 ビットマップが<CODE>HugeArray</CODE>(<CODE><A HREF="../../CRef/Routines/R_38.htm#IX_GrCreateBitmap()">GrCreateBitmap()</A></CODE>)をクリックし<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmap()">GrDrawHugeBitmap()</A></CODE>は自動的にメモリ管理を行います。 それ以外の場合は、適切なコールバックルーチンを提供する必要があります。 このルーチンは_pascalと宣言され、渡されたビットマップにポインタが渡され、次のスライスへのポインタを返すことが期待されています。 これにより、ビットマップを水平方向のバンド(帯)で描画できます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDrawBitmapAtCP()"></A>
        <H1 CLASS="refHeading">GrDrawBitmapAtCP()</H1>
<PRE CLASS="syntax">void GrDrawBitmapAtCP(GStateHandle GState,/*描画先のGState*/const Bitmap*bm, /*ビットマップへのポインタ*/Bitmap*_pascal(*callback)(Bitmap*bm));/*コールバックがない場合はNULL*/</PRE>
<P>このルーチンは、以下と同じです。<CODE>GrDrawBitmap()</CODE>ただし、ビットマップは現在の位置に描画されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDrawChar()"></A>
        <H1 CLASS="refHeading">GrDrawChar()</H1>
<PRE CLASS="syntax">void GrDrawChar(GStateHandle GState,/*GState to draw to*/sword x, /*x position at which draw*/sword y, /*y position at which draw*/word ch);/*Chars型の文字*/</PRE>
<P>現在のテキスト描画属性を使用して、指定した位置に文字を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_39.htm_IX_GrDrawCharAtCP()"></A>
        <H1 CLASS="refHeading">GrDrawCharAtCP()</H1>
<PRE CLASS="syntax">void GrDrawCharAtCP(GStateHandle GState,/*GState to draw to*/word ch);/*Chars型の文字*/</PRE>
<P>現在のテキスト描画属性を使用して、現在の位置に文字を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_3a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_GrDrawCurve()"></A>
          <A NAME="R_3a.htm_IX_Bezier curves:GrDrawCurve()"></A>
        <H1 CLASS="refHeading">GrDrawCurve()</H1>
<PRE CLASS="syntax">void GrDrawCurve(GStateHandle GState,/*GState to draw to*/const Point*points);/*4つのポイントの配列*/</PRE>
<P>ベジェ曲線を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_GrDrawCurveTo()"></A>
        <H1 CLASS="refHeading">GrDrawCurveTo()</H1>
<PRE CLASS="syntax">void GrDrawCurveTo(GStateHandle GState,/*GState to draw to*/const Point*points);/*3つのポイントの配列*/</PRE>
<P>現在の位置を最初の点として使用して、ベジェ曲線を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_Ellipses:GrDrawEllipse() macro"></A>
          <A NAME="R_3a.htm_IX_GrDrawEllipse()"></A>
        <H1 CLASS="refHeading">GrDrawEllipse()</H1>
<PRE CLASS="syntax">void sword(GStateHandleのGState,/*GState to draw to*/sword left, /*bounding box bounds*/sword top, sword right, sword bottom);void sword(のGState,/*GState to draw to*/sword left, /*bounding box bound GrDrawEllipse</PRE>
<P>境界ボックスで定義された楕円を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_GrDrawGString()"></A>
        <H1 CLASS="refHeading">GrDrawGString()</H1>
<PRE CLASS="syntax">GSRetType GrDrawGString(GStateHandle GState,/*GState to draw to*/Handle gstringToDraw, /*gstringToDraw*/sword x, /*point at which draw*/sword y, GSControl flags, /*GSControl record*/voice*lastElement);/*空の構造体へのポインタ*/GStringElement</PRE>
<P>グラフィックス文字列を描画します。 渡された制御フラグを使用すると、特定の種類の描画要素に遭遇したときに描画を停止できます。 これにより文字列の途中で描画が停止した場合、ルーチンは次の文字列へのポインタを提供します。<CODE>GStringElement</CODE>再生されます。</P>
<UL>
<LI>描画先のGStateを指定する必要があります。 電話して<CODE><A HREF="../../CRef/Routines/R_45.htm#IX_GrSaveState()">GrSaveState()</A></CODE>を呼び出し、GStringを描画する前にGState<CODE><A HREF="../../CRef/Routines/R_45.htm#IX_GrRestoreState()">GrRestoreState()</A></CODE>後で)。 GStringの後でこのGStateに何か他のものを描画する場合は<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>このGStateのハンドルをGState引数として渡すことで<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>GStateをクリーンアップできます。</LI>
<LI>描画するGStringを指定する必要があります。 GStringが適切にロードされている必要があります(おそらく<CODE><A HREF="../../CRef/Routines/R_44.htm#IX_GrLoadGString()">GrLoadGString()</A></CODE>)をクリックします。</LI>
<LI>GStringを描画する座標のペアを指定できます。 グラフィックスシステムは、GStringに格納されているグラフィックスコマンドを実行する前に、これらの座標によって座標系を変換します。</LI>
<LI>次のものを提供できます。<CODE>GSControl</CODE>この引数は、特定のタイプのGString要素が検出されたときに、システムがGStringの描画を停止するように要求します。 GStringインタープリターは、これらの要素のいずれかを検出すると、即座に描画を停止します。 GStringは、描画を停止した場所を記憶します。 電話する場合<CODE>GrDrawGString()</CODE>同じGStringを使って、中断したところから描画を続けます。</LI>
<LI>空のへのポインタを指定する必要があります<CODE>GStringElement</CODE>構造。<CODE>GrDrawGString()</CODE>は描画が終了すると、ここに値を返します。 GStringの描画が途中で停止した場合。<CODE>GSControl</CODE>、返される<CODE>GStringElement</CODE>値は、描画を停止させたコマンドの種類を示します。 例えばもしあなたが<CODE>GrDrawGString()</CODE>&#39;output&#39;要素(GrDraw.()またはGrFill.()コマンド)で停止し<CODE>GrDrawGString()</CODE>戻り値を調べて、どのような種類の出力要素が存在するかを確認します。</LI>
</UL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_GrDrawGStringAtCP()"></A>
        <H1 CLASS="refHeading">GrDrawGStringAtCP()</H1>
<PRE CLASS="syntax">GSRetType GrDrawGStringAtCP(GStateHandle GState,/*GState to draw to*/GStringeHandle gstringToDraw, /*gstringToDraw*/GSControlフラグ,/*GSControlフラグ*/GStringElement*lastElement);/*最後に描画する要素*/</PRE>
<P>グラフィックス文字列を描画する<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>ただし、描画は現在の位置で行われます。</P>
<UL>
<LI>描画先のGStateを指定する必要があります。 電話して<CODE><A HREF="../../CRef/Routines/R_45.htm#IX_GrSaveState()">GrSaveState()</A></CODE>を呼び出し、GStringを描画する前にGState<CODE><A HREF="../../CRef/Routines/R_45.htm#IX_GrRestoreState()">GrRestoreState()</A></CODE>後で)。 GStringの後でこのGStateに何か他のものを描画する場合は<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>このGStateのハンドルをGState引数として渡すことで<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>GStateをクリーンアップできます。</LI>
<LI>描画するGStringを指定する必要があります。 GStringが適切にロードされている必要があります(おそらく<CODE><A HREF="../../CRef/Routines/R_44.htm#IX_GrLoadGString()">GrLoadGString()</A></CODE>)をクリックします。</LI>
<LI>次のものを提供できます。<CODE>GSControl</CODE>この引数は、特定のタイプのGString要素が検出されたときに、システムがGStringの描画を停止するように要求します。 GStringインタープリターは、これらの要素のいずれかを検出すると、即座に描画を停止します。 GStringは、描画を停止した場所を記憶します。 電話する場合<CODE>GrDrawGString()</CODE>同じGStringを使って、中断したところから描画を続けます。</LI>
<LI>空のへのポインタを指定する必要があります<CODE>GStringElement</CODE>構造。<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>は描画が終了すると、ここに値を返します。 GStringの描画が途中で停止した場合。<CODE>GSControl</CODE>、返される<CODE>GStringElement</CODE>値は、描画を停止させたコマンドの種類を示します。 例えばもしあなたが<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>&#39;output&#39;要素(GrDraw.()またはGrFill.()コマンド)で停止し<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>戻り値を調べて、どのような種類の出力要素が存在するかを確認します。</LI>
</UL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_GrDrawHLine()"></A>
        <H1 CLASS="refHeading">GrDrawHLine()</H1>
<PRE CLASS="syntax">void GrDrawHLine(GStateHandle GState,/*GState to draw to*/sword x1, /*最初の水平座標*/sword y, /*行の垂直位置*/sword x2);/*2番目の水平座標*/</PRE>
<P>水平線を描きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_GrDrawHLineTo()"></A>
        <H1 CLASS="refHeading">GrDrawHLineTo()</H1>
<PRE CLASS="syntax">void GrDrawHLineTo(GStateHandle GState,/*GState to draw to*/sword x);/*水平座標の終了*/</PRE>
<P>現在の位置から水平な線を引きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_GrDrawHugeBitmap()"></A>
        <H1 CLASS="refHeading">GrDrawHugeBitmap()</H1>
<PRE CLASS="syntax">void GrDrawHugeBitmap(GStateHandle GState,/*GState to draw to*/sword x/*Point at which draw*/sword y, VMFileHandle vmFile, /*vmFile holding HugeArray*/VMBlockHandle vmBlk);/*HugeArrayのVMブロック*/</PRE>
<P>HugeArrayにあるビットマップを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmap()">GrDrawBitmap()</A></CODE><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmapAtCP()">GrDrawHugeBitmapAtCP()</A></CODE><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeImage()">GrDrawHugeImage()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_GrDrawHugeBitmapAtCP()"></A>
        <H1 CLASS="refHeading">GrDrawHugeBitmapAtCP()</H1>
<PRE CLASS="syntax">void GrDrawHugeBitmapAtCP(GStateHandle GState,/*GState to draw to*/VMFileHandle vmFile, /*HugeArrayを含むVMファイル*/VMBlockHandle vmBlk);/*HugeArrayを含むVMブロック*/</PRE>
<P>[形式]<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmap()">GrDrawHugeBitmap()</A></CODE>ただし、ビットマップは現在の位置に描画されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmapAtCP()">GrDrawBitmapAtCP()</A></CODE><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmap()">GrDrawHugeBitmap()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>ビットマップは次のようになります。<A NAME="R_3a.htm_IX_GrDrawHugeImage()"></A><H1 CLASS="refHeading">GrDrawHugeImage()</H1>
<PRE CLASS="syntax">void GrDrawHugeImage(GStateHandle GState,/*GState to draw to*/sword x/*point at which draw*/sword y, ImageFlags flags, VMFileHandle vmFile, /*vmFile holding HugeArray*/voice vmBlk);/*VM block holding HugeArray*/VMBlockHandle</PRE>
<P>にあるビットマップを描画します。<CODE>HugeArray</CODE>ビットマップピクセルごとに1つのデバイスピクセルを想定して描画されます。 ビットマップは、回転またはスケールされて描画されません。 flags引数の値に応じて、ビットマップが展開され、デバイスピクセルの四角形に各ビットマップピクセルが表示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawImage()">GrDrawImage()</A></CODE><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmapAtCP()">GrDrawHugeBitmapAtCP()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_3a.htm_IX_GrDrawImage()"></A>
        <H1 CLASS="refHeading">GrDrawImage()</H1>
<PRE CLASS="syntax">void GrDrawImage(GStateHandle GState,/*描画先のGState*/sword x/*描画先のポイント*/sword y, ImageFlagsフラグ,const Bitmap*bm);/*ビットマップへのポインタ*/</PRE>
<P>ビットマップを描画します。 ビットマップは、ビットマップピクセルごとに1つのデバイスピクセルを想定して描画されることに注意してください。 ビットマップは、回転またはスケールされて描画されません。 flags引数の値に応じて、ビットマップが展開され、デバイスピクセルの四角形に各ビットマップピクセルが表示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeImage()">GrDrawHugeImage()</A></CODE><CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmap()">GrDrawBitmap()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_3b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_3b.htm_IX_GrDrawLine()"></A>
        <H1 CLASS="refHeading">GrDrawLine()</H1>
<PRE CLASS="syntax">void GrDrawLine(GStateHandle GState,/*GState to draw to*/sword x1, /*First coordinate of line*/sword y1, sword x2, /*Second coordinate of line*/sword y2);</PRE>
<P>線を引きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3b.htm#IX_GrDrawLineTo()">GrDrawLineTo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHLine()">GrDrawHLine()</A></CODE><CODE><A HREF="../../CRef/Routines/R_3d.htm#IX_GrDrawVLine()">GrDrawVLine()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_3b.htm_IX_GrDrawLineTo()"></A>
        <H1 CLASS="refHeading">GrDrawLineTo()</H1>
<PRE CLASS="syntax">void GrDrawLineTo(GStateHandle GState,/*GState to draw to*/sword x, /*Second coordinate of line*/sword y);</PRE>
<P>現在の位置から線を引きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3b.htm#IX_GrDrawLine()">GrDrawLine()</A></CODE><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHLineTo()">GrDrawHLineTo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_3d.htm#IX_GrDrawVLineTo()">GrDrawVLineTo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_3b.htm_IX_GrDrawPath()"></A>
        <H1 CLASS="refHeading">GrDrawPath()</H1>
<PRE CLASS="syntax">void GrDrawPath(GStateHandle GState);/*描画するGState*/</PRE>
<P>現在のグラフィックの線属性を使用して、現在のパスのストロークバージョンを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3b.htm_IX_GrDrawPoint()"></A>
        <H1 CLASS="refHeading">GrDrawPoint()</H1>
<PRE CLASS="syntax">void GrDrawPoint(GStateHandle GState,/*GState to draw to*/sword x, /*Coordinates of point to draw*/sword y);</PRE>
<P>ピクセルを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3b.htm_IX_GrDrawPointAtCP()"></A>
        <H1 CLASS="refHeading">GrDrawPointAtCP()</H1>
<PRE CLASS="syntax">void GrDrawPointAtCP(GStateHandle GState);/*描画するGState*/</PRE>
<P>ピクセルを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3b.htm_IX_Polygons:GrDrawPolygon()"></A>
          <A NAME="R_3b.htm_IX_GrDrawPolygon()"></A>
        <H1 CLASS="refHeading">GrDrawPolygon()</H1>
<PRE CLASS="syntax">void GrDrawPolygon(GStateHandle GState,/*描画先のGState*/const Point*points, /*ポリゴン内の点の配列*/word numPoints);/*配列内の点の数*/</PRE>
<P>接続されたポリゴンを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3b.htm_IX_Polylines:GrDrawPolyline()"></A>
          <A NAME="R_3b.htm_IX_GrDrawPolyline()"></A>
        <H1 CLASS="refHeading">GrDrawPolyline()</H1>
<PRE CLASS="syntax">void GrDrawPolyline(GStateHandle GState,/*描画先のGState*/const Point*points, /*ポリライン内の点の配列*/word numPoints);/*配列内の点の数*/</PRE>
<P>単純なポリラインを作成します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_3c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_3c.htm_IX_Rectangles:GrDrawRect()"></A>
          <A NAME="R_3c.htm_IX_GrDrawRect()"></A>
        <H1 CLASS="refHeading">GrDrawRect()</H1>
<PRE CLASS="syntax">void sword(GStateHandleのGState,/*GState to draw to*/sword left, /*bounds of rectangle to draw*/sword top, sword right, sword bottom);void sword(のGState,/*GState to draw to*/sword left, /*bounds of rectangle to GrDrawRect</PRE>
<P>長方形のアウトラインを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3c.htm_IX_GrDrawRectTo()"></A>
        <H1 CLASS="refHeading">GrDrawRectTo()</H1>
<PRE CLASS="syntax">void GrDrawRectTo(GStateHandle GState,/*GState to draw to*/sword x, /*opposite corner of rectangle*/sword y);</PRE>
<P>現在の位置で定義された1つのコーナーを持つ長方形のアウトラインを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3c.htm_IX_GrDrawRegion()"></A>
        <H1 CLASS="refHeading">GrDrawRegion()</H1>
<PRE CLASS="syntax">void region(GStateHandle GState,/*GState to draw to*/sword xPos, /*Position at which draw*/sword yPos, const Region*reg, /*GrDrawRegion定義*/sword param0, /**パラメータ化された座標で使用する値*/</PRE>
<PRE CLASS="syntax">剣param1);/**パラメータ化された座標*/で使用する値</PRE>
<P>領域を描画します。 エリアは、GStateのエリア属性で埋められてレンダリングされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3c.htm_IX_GrDrawRegionAtCP()"></A>
        <H1 CLASS="refHeading">GrDrawRegionAtCP()</H1>
<PRE CLASS="syntax">void region(GStateHandle GState,/*描画先のGState*/const GrDrawRegionAtCP*reg, /*領域定義*/sword param0, /*パラメータ化された座標で使用する値*/sword param1, /*パラメータ化された座標で使用する値*/sword param2, /*パラメータ化された座標で使用する値*/sword param3);/*パラメータ化された座標で使用する値*/</PRE>
<P>現在のペン位置で領域を描画します。 エリアは、GStateのエリア属性で埋められてレンダリングされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3c.htm_IX_GrDrawRelArc3PointTo()"></A>
        <H1 CLASS="refHeading">GrDrawRelArc3PointTo()</H1>
<PRE CLASS="syntax">void GrDrawRelArc3PointTo(const ThreePointRelArcToParams*params);</PRE>
<P>相対座標で記述された2つの追加点(もう一方の端点と円弧上の他の点)を指定して、現在の点を基準にして円弧を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3c.htm_IX_GrDrawRelLineTo()"></A>
        <H1 CLASS="refHeading">GrDrawRelLineTo()</H1>
<PRE CLASS="syntax">void GrDrawRelLineTo(GStateHandleのGState,/*描画するGState*/WWFixedAsDWord x, /*2点目の水平オフセット*/WWFixedAsDWord y);/*2点目の垂直オフセット*/</PRE>
<P>描画する現在のペン位置からの変位を指定して、現在のペン位置から線を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_3d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_GrDrawRoundRect()"></A>
        <H1 CLASS="refHeading">GrDrawRoundRect()</H1>
<PRE CLASS="syntax">void sword(GStateHandle GState,/*GState to draw to*/sword left, /*bounds of rectangle*/sword top, sword right, sword bottom, word cornerRadius);/*GrDrawRoundRectの丸みの半径*/</PRE>
<P>角丸長方形のアウトラインを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_GrDrawRoundRectTo()"></A>
        <H1 CLASS="refHeading">GrDrawRoundRectTo()</H1>
<PRE CLASS="syntax">void GrDrawRoundRectTo(GStateHandle GState,/*GState to draw to*/sword x, /*opposite corner of bounds*/sword y, word cornerRadius);/*角の丸みの半径*/</PRE>
<P>丸みを帯びた長方形のアウトラインを描画します。バウンディング長方形の1つのコーナーが現在の位置になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_Splines:GrDrawSpline()"></A>
          <A NAME="R_3d.htm_IX_Bezier curves:GrDrawSpline()"></A>
          <A NAME="R_3d.htm_IX_GrDrawSpline()"></A>
        <H1 CLASS="refHeading">GrDrawSpline()</H1>
<PRE CLASS="syntax">void GrDrawSpline(GStateHandle GState,/*描画先のGState*/const Point*points, /*点の配列*/word numPoints,);/*配列内の点の数*/</PRE>
<P>ベジェスプラインを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawCurve()">GrDrawCurve()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_GrDrawSplineTo()"></A>
        <H1 CLASS="refHeading">GrDrawSplineTo()</H1>
<PRE CLASS="syntax">void GrDrawSplineTo(GStateHandle GState,/*描画先のGState*/const Point*points, /*点の配列*/word numPoints);/*配列内の点の数*/</PRE>
<P>現在の位置を1つの端点として使用して、ベジェスプラインを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawCurveTo()">GrDrawCurveTo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_GrDrawText()"></A>
        <H1 CLASS="refHeading">GrDrawText()</H1>
<PRE CLASS="syntax">void GrDrawText(GStateHandle GState,/*GState to draw to*/sword x, /*point at which draw to*/sword y, const Chars*str, /*pointer to character string*/word size);/*文字列の長さ*/</PRE>
<P>文字列を描画します。 文字列は文字の配列として表されます。 テキストはGStateのフォント描画属性を使って描画され、このルーチンはスタイルの実行引数を受け付けないことに注意してください。</P>
<P>合格した場合<CODE>寸法</CODE>引き数が0の場合、文字列はNULLで終端されていると見なされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_GrDrawTextAtCP()"></A>
        <H1 CLASS="refHeading">GrDrawTextAtCP()</H1>
<PRE CLASS="syntax">void GrDrawTextAtCP(GStateHandle GState,/*描画先のGState*/const Chars*str, /*文字列へのポインタ*/word size);/*文字列の長さ*/</PRE>
<P>[形式]<CODE><A HREF="../../CRef/Routines/R_3d.htm#IX_GrDrawText()">GrDrawText()</A></CODE>ただし、テキストは現在の位置に描画されます。</P>
<P>合格した場合<CODE>寸法</CODE>引き数が0の場合、文字列はNULLで終端されていると見なされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_GrDrawVLine()"></A>
        <H1 CLASS="refHeading">GrDrawVLine()</H1>
<PRE CLASS="syntax">void GrDrawVLine(GStateHandle GState,/*GState to draw to*/sword x, /*線分の水平位置*/sword y1, /*最初の垂直座標*/sword y2);/*2番目の垂直座標*/</PRE>
<P>垂直線を引きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_GrDrawVLineTo()"></A>
        <H1 CLASS="refHeading">GrDrawVLineTo()</H1>
<PRE CLASS="syntax">void GrDrawVLineTo(GStateHandle GState,/*GState to draw to*/sword y);/*2番目の垂直位置*/</PRE>
<P>現在の位置から始まる垂直線を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_GrEditBitmap()"></A>
        <H1 CLASS="refHeading">GrEditBitmap()</H1>
<PRE CLASS="syntax">GStateHandle GrEditBitmap(VMFileHandle vmFile、/*ビットマップのVMファイル*/VMBlockHandle vmBlock、/*ビットマップのVMブロック*/optr exposureOD);/*MSG_META_EXPOSEDを取得するoptr*/</PRE>
<P>このルーチンは、渡されたビットマップにGStateをアタッチして、新しい図面をビットマップに送信できるようにします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3d.htm_IX_GrEditGString()"></A>
        <H1 CLASS="refHeading">GrEditGString()</H1>
<PRE CLASS="syntax">GStateHandle GrEditGString(ハンドルvmFile、/*GStringを含むVMファイル*/word vmBlock);/*GStringを含むVMブロック*/</PRE>
<P>このルーチンは、VMファイルに保存されているGStringデータ・ブロックの場所を取得します。 このGStringデータにGStateを関連付け、このGStateのハンドルを返します。 このGStateHandleを使用して発行されたグラフィックスコマンドはすべて、GStringに追加されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_3e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrEndGString()"></A>
        <H1 CLASS="refHeading">GrEndGString()</H1>
<PRE CLASS="syntax">GStringErrorType GrEndGString(GStateHandle GState);/*描画するGState*/</PRE>
<P>グラフィックス文字列の定義を終了します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef enum{GSET_NO_ERROR, GSET_DISK_FULL}GStringErrorType;</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrEndPath()"></A>
        <H1 CLASS="refHeading">GrEndPath()</H1>
<PRE CLASS="syntax">void GrEndPath(GStateHandle GState);/*描画するGState*/</PRE>
<P>パスの定義を終了します。 その他のグラフィックスコマンドは、通常どおりディスプレイに描画されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrEndUpdate()"></A>
        <H1 CLASS="refHeading">GrEndUpdate()</H1>
<PRE CLASS="syntax">void GrEndUpdate(GStateHandle GState);/*描画するGState*/</PRE>
<P>ウィンドウの更新をロック解除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrEnumFonts()"></A>
          <A NAME="R_3e.htm_IX_Fonts:finding available"></A>
        <H1 CLASS="refHeading">GrEnumFonts()</H1>
<PRE CLASS="syntax">word GrEnumFonts(/*返り値=見つかったフォントの数*/FontEnumStruct*バッファ,/*返り値のバッファ*/単語サイズ,/*返す構造体の数*/FontEnumFlagsフラグ,/*FontEnumFlags語*/単語ファミリー);/*FontFamily*/</PRE>
<P>使用可能なフォントのリストを生成します。 フォント情報には、フォントのIDと文字列名の両方が含まれます。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef struct{FontID FES_ID;char FES_name[FID_NAME_LEN];}FontEnumStruct;</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrEscape()"></A>
          <A NAME="R_3e.htm_IX_Printing:escape codes"></A>
        <H1 CLASS="refHeading">GrEscape()</H1>
<PRE CLASS="syntax">void GrEscape(GStateHandle GState,/*GState to draw to*/word code, /*escape code*/const void*data, /*データへのポインタ*/word size);/*データのサイズ(バイト単位)*/</PRE>
<P>グラフィック文字列にエスケープコードを書き込みます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrFillArc()"></A>
        <H1 CLASS="refHeading">GrFillArc()</H1>
<PRE CLASS="syntax">void Pie(GStateHandle GState,/*GState to draw to*/sword left, /*bounding rectangle*/sword top, sword right, sword bottom, word startAngle, /*角度in degrees word endAngle*counterclockwise*/ArcCloseType closeType);/*OPEN, CHORD, or PIE*/(void GrFillArc(GState,/*GState to draw to*/sword left, /*bounding rectangle*/sword top, sword right, sword bottom, word start</PRE>
<P>楕円弧を塗り潰します。 円弧は、基本楕円の境界長方形と2つの角度で定義されます。 円弧がどのように閉じられているかに応じて、くさびまたは弦のフィルが作成されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrFillArc3Point()"></A>
        <H1 CLASS="refHeading">GrFillArc 3点()</H1>
<PRE CLASS="syntax">void GrFillArc3Point(GStateHandle GState,/*GState to draw to*/const ThreePointParams*params);</PRE>
<P>円弧を塗り潰します。 円弧がどのように閉じられているかに応じて、くさびまたは弦のフィルが作成されます。 円弧は、終点ともう1つの点で定義されます。これらはすべて円弧上にある必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrFillArc3PointTo()"></A>
        <H1 CLASS="refHeading">GrFillArc3PointTo()</H1>
<PRE CLASS="syntax">void GrFillArc3PointTo(GStateHandle GState,/*GState to draw to*/const ThreePointArcParams*params);</PRE>
<P>[形式]<CODE>GrFillArc 3点()</CODE>ただし、円弧の1つの端点は現在の位置によって定義されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrFillBitmap()"></A>
        <H1 CLASS="refHeading">GrFillBitmap()</H1>
<PRE CLASS="syntax">void GrFillBitmap(GStateHandle GState,/*描画先のGState*/sword x, /*描画するポイント*/sword y, const Bitmap*bm, /*ビットマップへのポインタ*/Bitmap*_pascal(*callback)(Bitmap*bm));</PRE>
<P>モノクロビットマップを現在の領域属性で塗りつぶします。 このルーチンの引数は<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmap()">GrDrawBitmap()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrFillBitmapAtCP()"></A>
        <H1 CLASS="refHeading">GrFillBitmapAtCP()</H1>
<PRE CLASS="syntax">void GrFillBitmapAtCP(GStateHandle GState,/*描画先のGState*/const Bitmap*bm, /*ビットマップへのポインタ*/Bitmap*_pascal(*callback)(Bitmap*bm));</PRE>
<P>モノクロビットマップを現在の領域属性で塗りつぶします。 ビットマップは現在の位置に描画されます。 このルーチンの引数は<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmapAtCP()">GrDrawBitmapAtCP()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrFillHugeBitmap()"></A>
        <H1 CLASS="refHeading">GrFillHugeBitmap()</H1>
<PRE CLASS="syntax">void GrFillHugeBitmap(GStateHandle gstate, sword x, sword y, VMFileHandle vmFile, VMBlockHandle vmBlk)</PRE>
<P>このルーチンは、巨大な配列データ構造体に格納されているモノクロビットマップを塗りつぶします。 ビットマップは<EM>vmFile</EM>および<EM>vmBlk</EM>巨大な配列を参照する引数。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3e.htm_IX_GrFillHugeBitmapAtCP()"></A>
        <H1 CLASS="refHeading">GrFillHugeBitmapAtCP()</H1>
<PRE CLASS="syntax">void GrFillHugeBitmapAtCP(GStateHandle州、VMFileHandle vmFile、VMBlockHandle vmBlk);</PRE>
<P>このルーチンは、巨大な配列データ構造体に格納されているモノクロビットマップを塗りつぶします。 GStateの現在の位置に描画されます。 ビットマップは<EM>vmFile</EM>および<EM>vmBlk</EM>巨大な配列を参照する引数。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_3f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_3f.htm_IX_Ellipses:GrFillEllipse()"></A>
          <A NAME="R_3f.htm_IX_GrFillEllipse()"></A>
        <H1 CLASS="refHeading">GrFillEllipse()</H1>
<PRE CLASS="syntax">void sword(sword GState,/*GState to draw to*/sword left, /*Bounding rectangleの境界*/sword top, sword right, sword bottom);void sword(sword GState,/*GState to draw to*/sword left, /*Bounding rectangleのGStateHandle GrFillEllipse</PRE>
<P>塗りつぶした楕円を描きます。 楕円の寸法は、境界ボックスによって定義されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3f.htm_IX_GrFillPath()"></A>
        <H1 CLASS="refHeading">GrFillPath()</H1>
<PRE CLASS="syntax">void GrFillPath(GStateHandle GState,/*GState to draw to*/RegionFillRule rule);/*ODD_EVENまたはWINDING*/</PRE>
<P>アウトラインがGStateのパスで定義されている領域を塗りつぶします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3f.htm_IX_GrFillPolygon()"></A>
          <A NAME="R_3f.htm_IX_Polygons:GrFillPolygon()"></A>
        <H1 CLASS="refHeading">GrFillPolygon()</H1>
<PRE CLASS="syntax">void GrFillPolygon(GStateHandle GState,/*GState to draw to*/RegionFillRule windingRule, /*ODD_EVEN or WINDING*/const Point*points, /*ポリゴン内の点の配列*/word numPoints);/*配列内の点の数*/</PRE>
<P>このルーチンは、塗りつぶされたポリゴンを描画します。 ポリゴンは、渡された点の配列によって定義されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3f.htm_IX_Rectangles:GrFillRect()"></A>
          <A NAME="R_3f.htm_IX_GrFillRect()"></A>
        <H1 CLASS="refHeading">GrFillRect()</H1>
<PRE CLASS="syntax">void sword(GStateHandleのGState,/*GState to draw to*/sword left, /*長方形の境界*/sword top, sword right, sword bottom);void sword(のGState,/*GState to draw to*/sword left, /*長方形の境界*/s GrFillRect</PRE>
<P>塗りつぶした長方形を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3f.htm_IX_GrFillRectTo()"></A>
        <H1 CLASS="refHeading">GrFillRectTo()</H1>
<PRE CLASS="syntax">void GrFillRectTo(GStateHandle GState,/*GState to draw to*/sword x, /*opposite corner of rectangle*/sword y);</PRE>
<P>塗りつぶした長方形を描画します。 現在の位置は、コーナーの1つを定義します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3f.htm_IX_GrFillRoundRect()"></A>
        <H1 CLASS="refHeading">GrFillRoundRect()</H1>
<PRE CLASS="syntax">void sword(GStateHandleのGState,/*GState to draw to*/sword left, /*bounds of rectangle*/sword top, sword right, sword bottom word cornerRadius);/*GrFillRoundRectの丸みの半径*/</PRE>
<P>塗りつぶした角丸四角形を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3f.htm_IX_GrFillRoundRectTo()"></A>
        <H1 CLASS="refHeading">GrFillRoundRectTo()</H1>
<PRE CLASS="syntax">void GrFillRoundRectTo(GStateHandle GState,/*GState to draw to*/sword x, /*opposite corner of rectangle*/sword y word cornerRadius);/*角の丸みの半径*/</PRE>
<P>現在の位置を使用して境界長方形の1つのコーナーを定義し、塗りつぶされた角丸長方形を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3f.htm_IX_GrFindNearestPointsize()"></A>
        <H1 CLASS="refHeading">GrFindNearestPointsize()</H1>
<PRE CLASS="syntax">Boolean GrFindNearestPointsize(/*falseの場合、FontIDは無効です*/FontID id, /*fond ID*/dword sizeSHL16, /*point size*/TextStyle styles, /*style*/TextStyle*styleFound, /*スタイルのバッファ*/dword*sizeFoundSHL16);/*サイズのバッファ*/</PRE>
<P>フォントに最も近い使用可能なポイントサイズを検索します。 フォントが渡された場合<CODE>イド</CODE>が存在する場合<CODE>styleFound</CODE>は使用可能なスタイルを指し<CODE>sizeFoundSHL一六</CODE>は、渡されたポイントサイズに最も近いポイントサイズをポイントします。 フォントが見つからない場合、戻り値は次のようになります。<CODE>真</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_3f.htm_IX_GrFontMetrics()"></A>
          <A NAME="R_3f.htm_IX_GFM_info"></A>
          <A NAME="R_3f.htm_IX_GFMI_&ldots;"></A>
        <H1 CLASS="refHeading">GrFontMetrics()</H1>
<PRE CLASS="syntax">dword GrFontMetrics(GStateHandle GState,/*subject GState*/GFM_info info);/*返される情報の種類*/</PRE>
<P>フォントに関するメトリック情報を取得します。 要求された情報を返します。<CODE>情報(info)</CODE>パラメータを指定します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE>typedef enum/*word*/{GFMI_HEIGHT, /*return=val&lt;&lt;16*/GFMI_MEAN, /*return=val&lt;&lt;16*/GFMI_DESCENT, /*return=val&lt;&lt;16*/GFMI_BASELINE, /*return=val&lt;&lt;16*/GFMI_LEADING, /*return=val&lt;&lt;16*/GFMI_AVERAGE_WIDTH, /*return=val&lt;&lt;16*/GFMI_ASCENT, /*return=val&lt;&lt;16*/GFMI_MAX_WIDTH, /*return=val&lt;&lt;16*/GFMI_MAX_ADJUSTED_HEIGHT, /*return=val&lt;&lt;16*/GFMI_UNDER_POS, /*return=val&lt;&lt;16*/GFMI_UNDER_THICKNESS, /*return=val&lt;&lt;16*/GFMI_ABOVE_BOX, /*return=val&lt;&lt;16*/GFMI_ACCENT, /*return=val&lt;&lt;16*/GFMI_LAST_CHAR, /*return=FontMaker*/GFMI_DEFAULT_CHAR, /*return=Char*/GFMI_STRIKE_POS, /*return=Char*/GFMI_BELOW_BOX, /*return=Char*/GFMI_HEIGHT_ROUNDED/*return=Char*/GFMI_DESCENT_ROUNDED, /*return=Char*/GFMI_BASELINE_ROUNDED, /*return=Char*/GFMI_ASCENT_ROUNDED, /*return=Char*/GFMI_MAX_ADJUSTED_HEIGHT_ROUNDED, /*ret=Char*/GFMI_UNDER_POS_ROUNDED, /*return=Char*/GFMI_UNDER_THICKNESS_ROUNDED, /*return=Char*/GFMI_ABOVE_BOX_ROUNDED, /*return=Char*/GFMI_ACCENT_ROUNDED=,/*return=Char*/GFMI_ACCENT_ROUNDED, /*return=Char*/GFMI_MAX ADJUSTED_HEIGHT_ROUNDED, /*ret=Char*/GFMI_return=Char*/GFMI_STRIKE_POS_ROUNDED, /*return=Char*/GFMI_BELOW_BOX_ROUNDED/*return=Char*/}GFM_info;を返します。</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_40.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_GrGetAreaColor()"></A>
        <H1 CLASS="refHeading">GrGetAreaColor()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrGetAreaColor(GStateHandle GState);/*カラーを取得するGステート*/</PRE>
<P>領域の塗りつぶしに使用されているカラーを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_GrGetAreaColorMap()"></A>
        <H1 CLASS="refHeading">GrGetAreaColorMap()</H1>
<PRE CLASS="syntax">ColorMapMode GrGetAreaColorMap(GStateHandle GState);/*エリアカラーマップを取得するGステート*/</PRE>
<P>使用できない色で領域を塗りつぶすために使用されるマッピングモードを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_GrGetAreaMask()"></A>
        <H1 CLASS="refHeading">GrGetAreaMask()</H1>
<PRE CLASS="syntax">SysDrawMask GrGetAreaMask(GStateHandle GState,/*マスクを取得するGステート*/DrawMask*dm);/*返されたマスクのバッファ*/</PRE>
<P>領域を塗りつぶすときに使用する描画マスクを取得します。 の<EM>dm(英語の</EM>引数は、マスクのビットパターンを取得するために、少なくとも8バイトを保持できるバッファを指す必要があります。<EM>dm(英語の</EM>はNULLでなければなりません。 返されるバッファは8x8ビットパターンです。各バイトはパターンの行を表し、バイトは上の行から下の行の順に並べられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_GrGetAreaPattern()"></A>
        <H1 CLASS="refHeading">GrGetAreaPattern()</H1>
<PRE CLASS="syntax">GraphicPattern GrGetAreaPattern(GStateHandle GState,/*エリアパターンのGState*/const MemHandle*customPattern, /**返されたカスタムパターンのブロックのハンドルへのポインタ*/</PRE>
<PRE CLASS="syntax">word*customSize);/*返される*buffer*のサイズへのポインタ/</PRE>
<P>エリアの塗り潰しに使用するエリアパターンを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_Video drivers:screen dumps"></A>
          <A NAME="R_40.htm_IX_GrGetBitmap()"></A>
        <H1 CLASS="refHeading">GrGetBitmap()</H1>
<PRE CLASS="syntax">MemHandle GrGetBitmap(GStateHandle GState,/*GState containing bitmap*/sword x, /*bitmap origin*/sword y, word width, /*bitmap width and height*/word height, XYSize*sizeCopied);/*返されたサイズのバッファ*/</PRE>
<P>ディスプレイの領域をビットマップにダンプします。 ビットマップを含むブロックのハンドルが返されます。<CODE>sizeCopied</CODE>ポインタは、正常にコピーされたビットマップの実際のサイズを指します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_GrGetBitmapMode()"></A>
        <H1 CLASS="refHeading">GrGetBitmapMode()</H1>
<PRE CLASS="syntax">BitmapMode GrGetBitmapMode(GStateHandleのGState);/*ビットマップを含むGState*/</PRE>
<P>編集可能ビットマップのモードビットを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_GrGetBitmapRes()"></A>
        <H1 CLASS="refHeading">GrGetBitmapRes()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrGetBitmapRes(const Bitmap*bm);/*ビットマップへのポインタ*/</PRE>
<P>ビットマップの解像度を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_GrGetBitmapSize()"></A>
        <H1 CLASS="refHeading">GrGetBitmapSize()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrGetBitmapSize(const Bitmap*bm);/*ビットマップへのポインタ*/</PRE>
<P>ビットマップのサイズをポイント単位で取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_GrGetClipRegion()"></A>
        <H1 CLASS="refHeading">GrGetClipRegion()</H1>
<PRE CLASS="syntax">MemHandle GrGetClipRegion(GStateHandle GState,/*subject GState*/RegionFillRuleルール);/*ODD_EVENまたはWINDING*/</PRE>
<P>現在のクリップ領域を取得します。 GStateにクリップパスがない場合は、ヌルハンドル(ゼロ)が返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_Current position (graphics):GrGetCurPos()"></A>
          <A NAME="R_40.htm_IX_GrGetCurPos()"></A>
        <H1 CLASS="refHeading">GrGetCurPos()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrGetCurPos(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>現在のペン位置を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_40.htm_IX_GrGetCurPosWWFixed()"></A>
        <H1 CLASS="refHeading">GrGetCurPosWWFixed()</H1>
<PRE CLASS="syntax">void GrGetCurPosWWFixed(GStateHandle GState,/*subject GState*/PointWWFixed*cp);/*curを返すバッファ。 位置*/</PRE>
<P>現在のペン位置を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_41.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetDefFontID()"></A>
        <H1 CLASS="refHeading">GrGetDefFontID()</H1>
<PRE CLASS="syntax">FontID GrGetDefFontID(dword*sizeSHL16);/*返されるサイズのバッファへのポインタ*/</PRE>
<P>システムのデフォルトフォント(サイズを含む)を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetExclusive()"></A>
        <H1 CLASS="refHeading">GrGetExclusive()</H1>
<PRE CLASS="syntax">GStateHandle・GrGetExclusive(GeodeHandle videoDriver)</PRE>
<P>このルーチンを使用して、どのGStateがビデオを独占的に取得したのかを調べます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetFont()"></A>
        <H1 CLASS="refHeading">GrGetFont()</H1>
<PRE CLASS="syntax">FontID GrGetFont(GStateHandle GState,/*サブジェクトGState*/WWFixedAsDWord*pointSize);/**返されたポイントサイズ*/のバッファへのポインタ</PRE>
<P>渡されたGStateの現在のフォント(ポイントサイズを含む)を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetFontName()"></A>
        <H1 CLASS="refHeading">GrGetFontName()</H1>
<PRE CLASS="syntax">FontID GrGetFontName(FontID id, /*フォントのID*/const char*name);/*返された名前文字列のバッファ*/</PRE>
<P>フォントの文字列名を取得します。 が返された場合<CODE>フォントID</CODE>がゼロの場合、フォントは見つかりませんでした。 名前文字列バッファのサイズは、FID_NAME_LEN以上でなければなりません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetFontWeight()"></A>
        <H1 CLASS="refHeading">GrGetFontWeight()</H1>
<PRE CLASS="syntax">FontWeight GrGetFontWeight(GStateHandle GState);/*フォントを含むGState*/</PRE>
<P>渡されたGStateに設定されている現在のフォントウェイトを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetFontWidth()"></A>
        <H1 CLASS="refHeading">GrGetFontWidth()</H1>
<PRE CLASS="syntax">FontWidth GrGetFontWidth(GStateHandleのGState);/*フォントを含むGState*/</PRE>
<P>渡されたGStateに設定されている現在のフォント幅を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetGStringBounds()"></A>
        <H1 CLASS="refHeading">GrGetGStringBounds()</H1>
<PRE CLASS="syntax">void state(GStringHandleソース,/*チェックするGString*/GStateHandle dest, /*使用するGStateのハンドル*/GSControlフラグ,/*GSControlフラグ*/Rectangle*bounds);/*GStateの返された境界*/GrGetGStringBounds</PRE>
<P>このルーチンは<CODE>源泉</CODE>GString内の現在の位置に描画されるGString。 の<CODE>宛先</CODE>GStateが渡された場合は、GStateが使用されます。GStateの制限を持たない場合は、nullハンドルを渡します。 含まれている最小の矩形の境界は<CODE>境界</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetGStringBoundsDWord()"></A>
        <H1 CLASS="refHeading">GrGetGStringBoundsDWord</H1>
<PRE CLASS="syntax">void GrGetGStringBoundsDWord(Handle GString,/*チェックするGString*/GStateHandle GState,/*使用するGStateのハンドル*/GSControlフラグ,/*GSControlフラグ*/RectDWord*範囲);/*GStateの返された範囲*/</PRE>
<P>このルーチンは次のように動作します。<CODE><A HREF="../../CRef/Routines/R_41.htm#IX_GrGetGStringBounds()">GrGetGStringBounds()</A></CODE>しかし、32ビットグラフィックス空間で動作するためにalterredになっています。</P>
<P>このルーチンは、GString内の現在の位置に描画されたaGStringの座標境界を返します。 の<EM>g状態</EM>GStateが渡された場合は、GStateが使用されます。GStateの制限を持たない場合は、nullハンドルを渡します。 含まれている最小の矩形の境界は<CODE>境界</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetGStringElement()"></A>
        <H1 CLASS="refHeading">GrGetGStringElement()</H1>
<PRE CLASS="syntax">GStringElement GrGetGStringElement(GStateHandle GState,/*GStringのGStateのハンドル*/void*buffer, /*リターンバッファへのポインタ*/word bufSize, /*リターンバッファのサイズ*/word*elementSize, /*GString要素のサイズ*/void**pointerAfterData);/**GString内の*次の要素へのポインタへのポインタ*/</PRE>
<P>グラフィックス文字列から次の要素を抽出します。 オペコードは明示的に返される。 ルーチンのデータはバッファに入れて返すことができます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_41.htm_IX_GrGetHugeBitmapSize()"></A>
        <H1 CLASS="refHeading">GrGetHugeBitmapSize()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrGetHugeBitmapSize(VMFileHandle vmFile、VMBlockHandle vmBlk);</PRE>
<P>渡された巨大なビットマップの寸法(水平および垂直)を、VMブロックおよびファイルによって参照されるとおりに返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_41.htm_IX_GrGetInfo()"></A>
        <H1 CLASS="refHeading">GrGetInfo()</H1>
<PRE CLASS="syntax">void GrGetInfo(GStateHandle GState,/*GStateは*/GrInfoTypesタイプに関する情報を取得し、/*type of informationは*/void*dataを取得します);/*返された情報のバッファ*/</PRE>
<P>GStateに関連付けられたプライベート・データ、ウィンドウ・ハンドル、またはペン位置を取得します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE>typedef enum{GIT_PRIVATE_DATA, GIT_WINDOW, GIT_PEN_POS}GrInfoType</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetLineColor()"></A>
        <H1 CLASS="refHeading">GrGetLineColor()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrGetLineColor(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>線を描くときに使用する色を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetLineColorMap()"></A>
        <H1 CLASS="refHeading">GrGetLineColorMap()</H1>
<PRE CLASS="syntax">ColorMapMode GrGetLineColorMap(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>使用できない色で線を描画するときに使用するモードを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetLineEnd()"></A>
        <H1 CLASS="refHeading">GrGetLineEnd()</H1>
<PRE CLASS="syntax">LineEnd GrGetLineEnd(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>線分を描画するときに使用する終点を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_41.htm_IX_GrGetLineJoin()"></A>
        <H1 CLASS="refHeading">GrGetLineJoin()</H1>
<PRE CLASS="syntax">LineJoin GrGetLineJoin(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>コーナーを描画するときに使用する結合を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_42.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetLineMask()"></A>
        <H1 CLASS="refHeading">GrGetLineMask()</H1>
<PRE CLASS="syntax">SysDrawMask GrGetLineMask(GStateHandle GState,/*subject GState*/DrawMask*dm);/*返されたカスタムマスクのバッファ*/</PRE>
<P>線の描画時に使用する描画マスクを取得します。 の<EM>dm(英語の</EM>引数は、マスクのビットパターンを取得するために、少なくとも8バイトを保持できるバッファを指す必要があります。<EM>dm(英語の</EM>はNULLでなければなりません。 返されるバッファは8x8ビットパターンです。各バイトはパターンの行を表し、バイトは上の行から下の行の順に並べられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetLineStyle()"></A>
        <H1 CLASS="refHeading">GrGetLineStyle()</H1>
<PRE CLASS="syntax">LineStyle GrGetLineStyle(GStateHandle GState);/*subject GState*/</PRE>
<P>線を描くときに使用されるスタイル、つまり「dottedness」を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetLineWidth()"></A>
        <H1 CLASS="refHeading">GrGetLineWidth()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrGetLineWidth(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>現在の線幅を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetMaskBounds()"></A>
        <H1 CLASS="refHeading">GrGetMaskBounds()</H1>
<PRE CLASS="syntax">void GrGetMaskBounds(GStateHandle GState,/*subject GState*/Rectangle*bounds);/*返された境界のバッファ*/</PRE>
<P>現在のクリップ矩形の16ビット境界を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetMaskBoundsDWord()"></A>
        <H1 CLASS="refHeading">GrGetMaskBoundsDWord()</H1>
<PRE CLASS="syntax">void GrGetMaskBoundsDWord(GStateHandle GState,/*subject GState*/RectDWord*bounds);/*返された境界のバッファ*/</PRE>
<P>現在のクリップ矩形の16ビット境界を取得します。精度はポイントの何分の1かです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetMiterLimit()"></A>
        <H1 CLASS="refHeading">GrGetMiterLimit()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrGetMiterLimit(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>マイター接続されたコーナーを描画するときに使用するマイター制限を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetMixMode()"></A>
        <H1 CLASS="refHeading">GrGetMixMode()</H1>
<PRE CLASS="syntax">MixMode GrGetMixMode(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>現在のミキシングモードを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetPalette()"></A>
        <H1 CLASS="refHeading">GrGetPalette()</H1>
<PRE CLASS="syntax">MemHandle GrGetPalette(GStateHandle GState、/*subject GState*/GetPalTypeフラグ、/*GPT_ACTIVE、GPT_CUSTOM、または*GPT_DEFAULT*/</PRE>
<PRE CLASS="syntax">word*numEntries);/*ブロック内のエントリ数*/</PRE>
<P>ウィンドウのカラールックアップテーブルのすべてまたは一部を返します。 このルーチンは、返されたすべてのパレットエントリを含むブロックのハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetPath()"></A>
        <H1 CLASS="refHeading">GrGetPath()</H1>
<PRE CLASS="syntax">MemHandle GrGetPath(GStateHandle GState,/*subject GState*/GetPathType ptype);/*取得するパス*/</PRE>
<P>パスデータを含むブロックへのハンドルを返します。 現在のパス、クリッピングパス、またはウィンドウクリッピングパスのいずれかを取得できます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetPathBounds()"></A>
        <H1 CLASS="refHeading">GrGetPathBounds()</H1>
<PRE CLASS="syntax">Boolean GrGetPathBounds(GStateHandle GState,/*subject GState*/GetPathType ptype, Rectangle*bounds);/*返された境界のバッファ*/</PRE>
<P>現在のパスが埋められるように、現在のパスを囲む矩形の境界を返します。 ア<CODE>真</CODE>戻り値は、エラーが発生したか、GStateのパスがなかったことを示します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetPathBoundsDWord()"></A>
        <H1 CLASS="refHeading">GrGetPathBoundsDWord()</H1>
<PRE CLASS="syntax">Boolean GrGetPathBoundsDWord(GStateHandle GState,/*subject GState*/GetPathType ptype, RectDWord*bounds);/*返される境界のバッファ*/</PRE>
<P>現在のパスが埋められるように、現在のパスを囲む矩形の境界を返します。 ア<CODE>真</CODE>戻り値は、エラーが発生したか、GStateのパスがなかったことを示します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetPathPoints()"></A>
        <H1 CLASS="refHeading">GrGetPathPoints()</H1>
<PRE CLASS="syntax">MemHandle GrGetPathPoints(GStateHandle GState,/*subject GState*/word resolution);/*dots per inch*/</PRE>
<P>現在のパスに沿った一連のポイントを返します。 返されるポイントは、ドキュメント座標内にあります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetPathRegion()"></A>
        <H1 CLASS="refHeading">GrGetPathRegion()</H1>
<PRE CLASS="syntax">MemHandle GrGetPathRegion(GStateHandle GState,/*subject GState*/RegionFillRuleルール);/*ODD_EVENまたはWINDING*/</PRE>
<P>パスで囲まれた領域を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_42.htm_IX_GrGetPoint()"></A>
        <H1 CLASS="refHeading">GrGetPoint()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrGetPoint(GStateHandle GState,/*サブジェクトGState*/sword x, /*ピクセルの座標*/sword y);</PRE>
<P>指定された座標に対応するピクセルのカラーを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_43.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetPtrRegBounds()"></A>
          <A NAME="R_43.htm_IX_Regions, graphics:GrGetPtrRegBounds()"></A>
        <H1 CLASS="refHeading">GrGetPtrRegBounds()</H1>
<PRE CLASS="syntax">word region(/*GrGetPtrRegBoundsデータ構造体のサイズを返します。 */const Region*reg, /*領域へのポインタ*/Rectangle*bounds);/*領域の返された境界*/</PRE>
<P>渡された領域の境界を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetSubscriptAttr()"></A>
        <H1 CLASS="refHeading">GrGetSubscriptAttr()</H1>
<PRE CLASS="syntax">ScriptAttrAsWord GrGetSubscriptAttr(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>GStateの添字描画属性を取得します。 戻り値の上位バイトは、下付き文字のフォントサイズのパーセンテージです。下位バイトは、文字が描画される上部からのフォントサイズのパーセンテージです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetSuperscriptAttr()"></A>
        <H1 CLASS="refHeading">GrGetSuperscriptAttr()</H1>
<PRE CLASS="syntax">ScriptAttrAsWord GrGetSuperscriptAttr(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>GStateの上付き描画属性を取得します。 戻り値の上位バイトは、上付き文字のフォントサイズのパーセンテージです。下位バイトは、文字が描画される下部からのフォントサイズのパーセンテージです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_Fonts:metrics, GrGetTextBounds() and"></A>
          <A NAME="R_43.htm_IX_GrGetTextBounds()"></A>
        <H1 CLASS="refHeading">GrGetTextBounds()</H1>
<PRE CLASS="syntax">Boolean GrGetTextBounds(GStateHandle GState,/*subject GState*/const char*str, /*text string*/word xpos, /*textが描画される位置*/word ypos, word count, /*チェックする最大文字数*/Rectangle*bounds);/*返された境界長方形*/</PRE>
<P>渡されたテキストを描画するために必要な境界を取得します。 合格した場合<CODE>数える</CODE>引き数が0の場合、文字列はNULLで終端されていると見なされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetTextColor()"></A>
        <H1 CLASS="refHeading">GrGetTextColor()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrGetTextColor(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>テキストの描画時に使用する色を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetTextColorMap()"></A>
        <H1 CLASS="refHeading">GrGetTextColorMap()</H1>
<PRE CLASS="syntax">ColorMapMode GrGetTextColorMap(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>使用できない色でテキストを描画するときに使用するモードを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetTextMask()"></A>
        <H1 CLASS="refHeading">GrGetTextMask()</H1>
<PRE CLASS="syntax">SystemDrawMask GrGetTextMask(GStateHandle GState,/*subject GState*/DrawMask*dm);/*もしあればカスタムマスクを返しました*/</PRE>
<P>テキストの描画時に使用される描画マスクを取得します。<EM>dm(英語の</EM>引数は、マスクのビットパターンを取得するために、少なくとも8バイトを保持できるバッファを指す必要があります。<EM>dm(英語の</EM>はNULLでなければなりません。 返されるバッファは8x8ビットパターンです。各バイトはパターンの行を表し、バイトは上の行から下の行の順に並べられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetTextMode()"></A>
        <H1 CLASS="refHeading">GrGetTextMode()</H1>
<PRE CLASS="syntax">TextMode GrGetTextMode(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>文字の描画時に使用される垂直オフセットに関する情報を含む、文字モードを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetTextPattern()"></A>
        <H1 CLASS="refHeading">GrGetTextPattern()</H1>
<PRE CLASS="syntax">GraphicPattern GrGetTextPattern(GStateHandle GState,/*subject GState*/const MemHandle*customPattern, /**返されたパターン*を含むブロックの*返されたハンドル*へのポインタ</PRE>
<PRE CLASS="syntax">word*customSize);/*返されたブロックのサイズ*/</PRE>
<P>テキストの描画時に使用するグラフィックパターンを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetTextSpacePad()"></A>
        <H1 CLASS="refHeading">GrGetTextSpacePad()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrGetTextSpacePad(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>文字列を描画するときに使用するスペースパッドを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetTextStyle()"></A>
        <H1 CLASS="refHeading">GrGetTextStyle()</H1>
<PRE CLASS="syntax">TextStyle GrGetTextStyle(GStateHandle GState);/*subject GState*/</PRE>
<P>テキストの描画時に使用するスタイルを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetTrackKern()"></A>
        <H1 CLASS="refHeading">GrGetTrackKern()</H1>
<PRE CLASS="syntax">word GrGetTrackKern(GStateHandle GState);/*subject GState*/</PRE>
<P>文字列を描画するときに使用するトラックカーニングを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetTransform()"></A>
        <H1 CLASS="refHeading">GrGetTransform()</H1>
<PRE CLASS="syntax">void GrGetTransform(GStateHandle GState,/*subject GState*/TransMatrix*tm);/*返されたTransMatrixへのポインタ*/</PRE>
<P>行列で表される現在の座標変換を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetWinBounds()"></A>
        <H1 CLASS="refHeading">GrGetWinBounds()</H1>
<PRE CLASS="syntax">void GrGetWinBounds(GStateHandle GState,/*subject GState*/Rectangle*bounds);/*返されたウィンドウ境界*/</PRE>
<P>GStateに関連付けられたウィンドウの境界を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetWinBoundsDWord()"></A>
        <H1 CLASS="refHeading">GrGetWinBoundsDWord()</H1>
<PRE CLASS="syntax">void GrGetWinBoundsDWord(GStateHandle GState,/*subject GState*/RectDWord*bounds);/*返されたウィンドウ境界*/</PRE>
<P>GStateに関連付けられたウィンドウの境界を、ポイントの何分の1かの精度で取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGetWinHandle()"></A>
        <H1 CLASS="refHeading">GrGetWinHandle()</H1>
<PRE CLASS="syntax">WindowHandle GrGetWinHandle(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>GStateに関連付けられたウィンドウのハンドルを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_43.htm_IX_GrGrabExclusive()"></A>
        <H1 CLASS="refHeading">GrGrabExclusive()</H1>
<PRE CLASS="syntax">GStateHandle GrGrabExclusive(GeodeHandle videoDriver, /*NULL for default*/GStateHandle GState);/*subject GState*/</PRE>
<P>ビデオドライバ専用に描画を開始します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_44.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrInitDefaultTransform()"></A>
        <H1 CLASS="refHeading">GrInitDefaultTransform()</H1>
<PRE CLASS="syntax">void GrInitDefaultTransform(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>GStateのデフォルト変換を初期化して、現在の変換の値を保持します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrInvalRect()"></A>
        <H1 CLASS="refHeading">GrInvalRect()</H1>
<PRE CLASS="syntax">void sword(sword GState,/*subject GState*/sword left, /*bounds to be invalidated*/sword top, sword right, sword bottom);void sword(sword GState,/*subject GState*/sword left, /*bounds to be invalid GStateHandle GrInvalRect</PRE>
<P>渡された長方形領域を無効にします。 この領域は再描画されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrInvalRectDWord()"></A>
        <H1 CLASS="refHeading">GrInvalRectDWord()</H1>
<PRE CLASS="syntax">void GrInvalRectDWord(GStateHandle GState,/*subject GState*/const RectDWord*bounds);/*無効にする境界*/</PRE>
<P>渡された長方形領域を無効にします。 この領域は再描画されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrLabel()"></A>
        <H1 CLASS="refHeading">GrLabel()</H1>
<PRE CLASS="syntax">void GrLabel(GStringHandle GState,/*subject GState*/word label);/*GStringに書き込むラベル*/</PRE>
<P>渡されたラベルを、渡されたGStringに書き込みます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrLoadGString()"></A>
        <H1 CLASS="refHeading">GrLoadGString()</H1>
<PRE CLASS="syntax">GStringHandle GrLoadGString(ハンドルhan、/*GStringソースのハンドル*/GStringType hanType、/*ハンドルタイプ*/ワードvmBlock);/*VMファイルの場合、VMブロックのハンドル*/</PRE>
<P>ファイルからグラフィックス文字列をロードします。 ストリーム、VM、およびポインター・アドレス指定されたGStringで使用されます。</P>
<P>GStringの操作が完了したら<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrMapColorIndex()"></A>
        <H1 CLASS="refHeading">GrMapColorIndex()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrMapColorIndex(GStateHandle GState,/*マッピングに使用するGState*/Color c);/*マップされるソースカラー*/</PRE>
<P>渡されたGStateのカラーマッピングスキームを使用して、カラーインデックスを対応するRGBにマップします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrMapColorRGB()"></A>
        <H1 CLASS="refHeading">GrMapColorRGB()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrMapColorRGB(GStateHandle GState,/*GState to use for mapping*/word red, /*RGB values to map*/word green, word blue);</PRE>
<P>RGBカラーをインデックスにマップします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrMoveReg()"></A>
          <A NAME="R_44.htm_IX_Regions, graphics:GrMoveReg()"></A>
        <H1 CLASS="refHeading">GrMoveReg()</H1>
<PRE CLASS="syntax">void region(GrMoveReg*reg, /*領域へのポインタ*/sword xOffset, /*水平方向のシフト量*/sword yOffset);/*垂直方向のシフト量*/</PRE>
<P>領域を指定した量だけ移動します。 この操作は、領域のデータ構造にのみ影響することに注意してください。 変更が目に見える効果を持つためには、領域を再描画するか、他の方法で使用する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_Current position (graphics):GrMoveTo()"></A>
          <A NAME="R_44.htm_IX_GrMoveTo()"></A>
        <H1 CLASS="refHeading">GrMoveTo()</H1>
<PRE CLASS="syntax">void GrMoveTo(GStateHandle GState,/*subject GState*/sword x, /*新しい絶対ペン位置*/sword y);</PRE>
<P>ペンの位置を変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrMoveToWWFixed()"></A>
        <H1 CLASS="refHeading">GrMoveToWWFixed()</H1>
<PRE CLASS="syntax">void GrMoveToWWFixed(GStateHandle州、WWFixedAsDWord x、WWFixedAsDWord y)</PRE>
<P>このルーチンは、ペンの位置を非常に正確に変更します。</P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrMulDWFixed()"></A>
        <H1 CLASS="refHeading">GrMulDWFixed()</H1>
<PRE CLASS="syntax">void GrMulDWFixed(const DWFixed*i, /*最初の数値*/const DWFixed*j, /*2番目の数値*/DWFixed*result);/*返された結果へのポインタ*/</PRE>
<P>2つの固定小数点数を乗算します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_44.htm_IX_GrMulWWFixed()"></A>
        <H1 CLASS="refHeading">GrMulWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrMulWWFixed(WWFixedAsDWord i、/*最初の番号*/WWFixedAsDWord j);/*2番目の番号*/</PRE>
<P>2つの固定小数点数を乗算します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_45.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_Printing:form feeds"></A>
          <A NAME="R_45.htm_IX_GrNewPage()"></A>
        <H1 CLASS="refHeading">GrNewPage()</H1>
<PRE CLASS="syntax">void GrNewPage(GStateHandle州、PageEndCommand PageEndCommand)</PRE>
<P>新しいページの描画を開始します。 通常、ドキュメントの印刷時に使用されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrNullOp()"></A>
        <H1 CLASS="refHeading">GrNullOp()</H1>
<PRE CLASS="syntax">void GrNullOp(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>ヌル操作要素をGStringに書き込みます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrParseGString()"></A>
        <H1 CLASS="refHeading">GrParseGString()</H1>
<PRE CLASS="syntax">void stop(GStateHandle gstate, GStateHandle gstringToDraw, GSControlフラグ,Boolean(*callback)/*TRUE to GrParseGString*/(void*element));</PRE>
<P>このルーチンはGStringをトラバースし、GStringElementが検出されるたびにコールバック関数を呼び出します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrQuickArcSine()"></A>
        <H1 CLASS="refHeading">GrQuickArcSine()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrQuickArcSine(WWFixedAsDWord deltaYDivDistance、/*delta y/distance*/word origDeltaX);/*original delta x*/</PRE>
<P>固定点のアークサインを計算します。 角度は、正のx軸に対して反時計回りの角度で示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrQuickCosine()"></A>
        <H1 CLASS="refHeading">GrQuickCosine()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrQuickCosine(WWFixedAsDWord angle);/*コサインへの角度*/</PRE>
<P>固定点余弦を計算します。 角度は、正のx軸に対して反時計回りの角度で示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrQuickSine()"></A>
        <H1 CLASS="refHeading">GrQuickSine()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrQuickSine(WWFixedAsDWord angle);/*正弦に対する角度*/</PRE>
<P>固定点正弦を計算します。 角度は、正のx軸に対して反時計回りの角度で示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrQuickTangent()"></A>
        <H1 CLASS="refHeading">GrQuickTangent()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrQuickTangent(WWFixedAsDWord angle);/*接線への角度*/</PRE>
<P>固定点接線を計算します。 角度は、正のx軸に対して反時計回りの角度で示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrReleaseExclusive()"></A>
        <H1 CLASS="refHeading">GrReleaseExclusive()</H1>
<PRE CLASS="syntax">void GrReleaseExclusive(/*システムが再描画を強制する必要がある場合はTRUE*/GeodeHandle videoDriver, /*ビデオドライバのハンドル*/GStateHandle GState,/*描画していたGState*/Rectangle*bounds);/*中止された描画の境界*/</PRE>
<P>ビデオドライバだけに描画するのを停止します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrRelMoveTo()"></A>
        <H1 CLASS="refHeading">GrRelMoveTo()</H1>
<PRE CLASS="syntax">void GrRelMoveTo(GStateHandle GState,/*subject GState*/WWFixedAsDWord x, /*新しいペン位置へのオフセット*/WWFixedAsDWord y);</PRE>
<P>現在の位置に対して相対的に表された座標にペンの位置を変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrRestoreState()"></A>
        <H1 CLASS="refHeading">GrRestoreState()</H1>
<PRE CLASS="syntax">void GrRestoreState(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>保存したGStateの値を復元します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_45.htm_IX_GrSaveState()"></A>
        <H1 CLASS="refHeading">GrSaveState()</H1>
<PRE CLASS="syntax">void GrSaveState(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>GStateの値を保存して<CODE><A HREF="../../CRef/Routines/R_45.htm#IX_GrRestoreState()">GrRestoreState()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_46.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSDivDWFByWWF()"></A>
        <H1 CLASS="refHeading">GrSDivDWFByWWF()</H1>
<PRE CLASS="syntax">void GrSDivDWFByWWF(const DWFixed*被除数,const WWFixed*除数,DWFixed*商)/*戻り値*/</PRE>
<P>2つの固定小数点数を除算します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSDivWWFixed()"></A>
        <H1 CLASS="refHeading">GrSDivWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrSDivWWFixed(WWFixedAsDWord配当金、WWFixedAsDWord除数)</PRE>
<P>2つの固定小数点数を除算します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSetAreaAttr()"></A>
        <H1 CLASS="refHeading">GrSetAreaAttr()</H1>
<PRE CLASS="syntax">void GrSetAreaAttr(GStateHandle GState,/*subject GState*/const AreaAttr*aa);/*AreaAttrの構造*/</PRE>
<P>領域を塗りつぶすときに使用するすべての属性を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSetAreaColor()"></A>
        <H1 CLASS="refHeading">GrSetAreaColor()</H1>
<PRE CLASS="syntax">void GrSetAreaColor(GStateHandle GState,/*カラーを設定するGState*/ColorFlagフラグ,/*カラーを設定する方法のフラグ*/word redOrIndex, /*カラーインデックスまたはred RGB値*/word green, /*green RGB値またはゼロ*/word blue);/*blue RGB値またはゼロ*/</PRE>
<P>領域を塗りつぶすときに使用する色を設定します。 フラグパラメータは、CF_RGB(RGB値を設定)、CF_INDEX(パレットインデックスを設定)、CF_GRAY、CF_SAMEのいずれかです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSetAreaColorMap()"></A>
        <H1 CLASS="refHeading">GrSetAreaColorMap()</H1>
<PRE CLASS="syntax">void GrSetAreaColorMap(GStateHandle GState,/*subject GState*/ColorMapMode colorMap);/*カラーマッピングモード*/</PRE>
<P>使用できない色で領域を塗りつぶすときに使用するモードを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSetAreaMaskCustom()"></A>
        <H1 CLASS="refHeading">GrSetAreaMaskCustom()</H1>
<PRE CLASS="syntax">void GrSetAreaMaskCustom(GStateHandle GState,/*subject GState*/const DrawMask*dm);/*新しいカスタムマスクへのポインタ*/</PRE>
<P>領域を塗りつぶすときに使用する描画マスクを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSetAreaMaskSys()"></A>
        <H1 CLASS="refHeading">GrSetAreaMaskSys()</H1>
<PRE CLASS="syntax">void area(GStateHandle GState,/*サブジェクトGState*/SystemDrawMask sysDM);/*新しいシステムGrSetAreaMaskSysマスク*/</PRE>
<P>領域を塗りつぶすときに使用する描画マスクを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSetAreaPattern()"></A>
        <H1 CLASS="refHeading">GrSetAreaPattern()</H1>
<PRE CLASS="syntax">void GrSetAreaPattern(GStateHandle GState,/*subject GState*/GraphicPattern pattern);/*新しいパターン*/</PRE>
<P>領域を塗りつぶすときに使用するグラフィックスパターンを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSetBitmapMode()"></A>
        <H1 CLASS="refHeading">GrSetBitmapMode()</H1>
<PRE CLASS="syntax">void GrSetBitmapMode(GStateHandle GState,/*subject GState*/word flags, /*BM_EDIT_MASK or BM_CLUSTERED_DITHER*/MemHandle colorCorr);/*ColorTransferのハンドル*/</PRE>
<P>ビットマップ編集モードを設定します。 これにより、ビットマップのマスクを編集したり、クラスタディザリングをオンにしたりすることができます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_46.htm_IX_GrSetBitmapRes()"></A>
        <H1 CLASS="refHeading">GrSetBitmapRes()</H1>
<PRE CLASS="syntax">Boolean GrSetBitmapRes(GStateHandle GState,/*subject GState*/word xRes, /*new resolutions*/word yRes);</PRE>
<P>複雑なビットマップの解像度を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_47.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetClipPath()"></A>
        <H1 CLASS="refHeading">GrSetClipPath()</H1>
<PRE CLASS="syntax">void GrSetClipPath(GStateHandle GState,/*subject GState*/PathCombineType params, /*パスの組み合わせ方*/RegionFillRuleルール);/*ODD_EVENまたはWINDING*/</PRE>
<P>渡されたパスと交差させて、クリッピング領域を制限します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetClipRect()"></A>
        <H1 CLASS="refHeading">GrSetClipRect()</H1>
<PRE CLASS="syntax">void sword(sword GState,/*subject GState*/PathCombineType flags, /*パスの結合方法*/sword left, /*クリッピングGrSetClipRectの境界*/sword top, sword right, sword bottom);GStateHandle</PRE>
<P>渡された長方形と交差させて、クリップ領域を制限します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetCustomAreaPattern()"></A>
        <H1 CLASS="refHeading">GrSetCustomAreaPattern()</H1>
<PRE CLASS="syntax">void GrSetCustomAreaPattern(GStateHandle GState,/*subject GState*/GraphicPattern pattern, /*new area pattern*/const void*patternData, /*パターンデータへのポインタ*/word patternSize);/*パターンデータバッファのサイズ*/</PRE>
<P>領域を塗りつぶすときに使用するグラフィックスパターンを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetCustomTextPattern()"></A>
        <H1 CLASS="refHeading">GrSetCustomTextPattern()</H1>
<PRE CLASS="syntax">void GrSetCustomTextPattern(GStateHandle GState,/*subject GState*/GraphicPattern pattern, /*new pattern*/const void*patternData);/*パターンデータへのポインタ*/</PRE>
<P>テキストの描画時に使用するグラフィックパターンを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetDefaultTransform()"></A>
        <H1 CLASS="refHeading">GrSetDefaultTransform()</H1>
<PRE CLASS="syntax">void GrSetDefaultTransform(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>現在の座標変換を既定の座標変換に置き換えます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetFont()"></A>
        <H1 CLASS="refHeading">GrSetFont()</H1>
<PRE CLASS="syntax">void GrSetFont(GStateHandle GState,/*subject GState*/FontID ID,/*new FontID*/WWFixedAsDWord pointSize);/*new pointSize*/</PRE>
<P>テキストの描画時に使用するフォントを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetFontWeight()"></A>
        <H1 CLASS="refHeading">GrSetFontWeight()</H1>
<PRE CLASS="syntax">void GrSetFontWeight(GStateHandle GState,/*subject GState*/FontWeight weight);/*新しいフォントの太さ*/</PRE>
<P>テキストの描画時に使用するフォントの太さを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetFontWidth()"></A>
        <H1 CLASS="refHeading">GrSetFontWidth()</H1>
<PRE CLASS="syntax">void width(GStateHandle GState,/*subject GState*/FontWidth width);/*新しいフォントのGrSetFontWidth*/</PRE>
<P>テキストの描画時に使用するフォント幅を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetGStringBounds()"></A>
          <A NAME="R_47.htm_IX_GStrings:GrSetGStringBounds() optimization"></A>
        <H1 CLASS="refHeading">GrSetGStringBounds()</H1>
<PRE CLASS="syntax">void sword(Handle GState,/*GState or GString handle*/sword left, /*new bounds of GString*/sword top, sword right, sword bottom);void sword(Handle GState,/*GState or GString handle*/sword left, /*new bounds of GString*/s GrSetGStringBounds</PRE>
<P>GStringの境界値を設定できる最適化ルーチンです。 この境界情報は<CODE>GrGetGStringBounds()</CODE>そのルーチンが、影響を受けるGStringに対して呼び出されたとき。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_47.htm_IX_GrSetGStringPos()"></A>
          <A NAME="R_47.htm_IX_GStringSetPosType"></A>
          <A NAME="R_47.htm_IX_GSSPT_&ldots;"></A>
        <H1 CLASS="refHeading">GrSetGStringPos()</H1>
<PRE CLASS="syntax">void GrSetGStringPos(GStateHandle GState,/*subject GState*/GStringSetPosType type, /*位置の設定方法*/word skip);/*スキップする要素の数*/</PRE>
<P>グラフィック文字列の「再生位置」を設定します。 このルーチンを使用すると、GStringの選択した要素だけを描画できます。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE>typedef ByteEnum GStringSetPosType;/*GSSPT_SKIP, GSSPT_RELATIVE, GSSPT_BEGINNING, GSSPT_END*/</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_48.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetLineAttr()"></A>
        <H1 CLASS="refHeading">GrSetLineAttr()</H1>
<PRE CLASS="syntax">void GrSetLineAttr(GStateHandle GState,/*subject GState*/const LineAttr*la);/*新しいライン属性*/</PRE>
<P>線分とコーナーを描画するときに使用するすべての属性を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetLineColor()"></A>
        <H1 CLASS="refHeading">GrSetLineColor()</H1>
<PRE CLASS="syntax">void GrSetLineColor(GStateHandle GState,/*subject GState*/ColorFlag flag, /*ColorFlag*/word redOrIndex, /*new index or red RGB value*/word green, /*new green RGB value or zero*/word blue);/*new blue RGB value or zero*/</PRE>
<P>線を描くときに使用する色を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetLineColorMap()"></A>
        <H1 CLASS="refHeading">GrSetLineColorMap()</H1>
<PRE CLASS="syntax">void GrSetLineColorMap(GStateHandle GState,/*subject GState*/ColorMapMode colorMap);/*線の新しいカラーマップモード*/</PRE>
<P>使用できない色で線を描画するときに使用するモードを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetLineEnd()"></A>
        <H1 CLASS="refHeading">GrSetLineEnd()</H1>
<PRE CLASS="syntax">void GrSetLineEnd(GStateHandle GState,/*subject GState*/LineEnd end);/*改行位置の指定*/</PRE>
<P>線を描くときに使用する終点を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetLineJoin()"></A>
        <H1 CLASS="refHeading">GrSetLineJoin()</H1>
<PRE CLASS="syntax">void GrSetLineJoin(GStateHandle GState,/*subject GState*/LineJoin join);/*新しい行結合の指定*/</PRE>
<P>コーナーの描画時に使用する線の結合を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetLineMaskCustom()"></A>
        <H1 CLASS="refHeading">GrSetLineMaskCustom()</H1>
<PRE CLASS="syntax">void GrSetLineMaskCustom(GStateHandle GState,/*subject GState*/const DrawMask*dm);/*新しい線描画マスク*/</PRE>
<P>線を描くときに使用する描画マスクを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetLineMaskSys()"></A>
        <H1 CLASS="refHeading">GrSetLineMaskSys()</H1>
<PRE CLASS="syntax">void GrSetLineMaskSys(GStateHandle GState,/*subject GState*/SystemDrawMask sysDM);/*新しいシステムラインマスク*/</PRE>
<P>線を描くときに使用する描画マスクを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetLineStyle()"></A>
        <H1 CLASS="refHeading">GrSetLineStyle()</H1>
<PRE CLASS="syntax">void GrSetLineStyle(GStateHandle GState,/*subject GState*/LineStyle style, /*新しい線種*/word skipDistance, /*最初のペアまでのスキップ距離*/const DashPairArray*dpa, /*ダッシュ定義*/word numPairs);/*ペアの数*/</PRE>
<P>線を描くときに使用するスタイル、つまり「dottedness」を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetLineWidth()"></A>
        <H1 CLASS="refHeading">GrSetLineWidth()</H1>
<PRE CLASS="syntax">void GrSetLineWidth(GStateHandle GState,/*subject GState*/WWFixedAsDWord width);/*新しい行の幅*/</PRE>
<P>線を描くときに使用する線幅を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetMiterLimit()"></A>
        <H1 CLASS="refHeading">GrSetMiterLimit()</H1>
<PRE CLASS="syntax">void miter(GStateHandle GState,/*subject GState*/WWFixedAsDWord limit);/*新しいGrSetMiterLimit制限*/</PRE>
<P>マイター接続されたコーナーを描画するときに使用するマイター制限を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetMixMode()"></A>
        <H1 CLASS="refHeading">GrSetMixMode()</H1>
<PRE CLASS="syntax">void GrSetMixMode(GStateHandle GState,/*subject GState*/MixMode mode);/*新しいミックスモード*/</PRE>
<P>GStateのミックスモードを設定します。これは、既存の描画の上に何かが描画されたときの動作を決定するために使用されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_48.htm_IX_GrSetNullTransform()"></A>
        <H1 CLASS="refHeading">GrSetNullTransform()</H1>
<PRE CLASS="syntax">void GrSetNullTransform(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>座標変換をクリアします。 ほとんどのアプリケーションでは、座標変換を既定の変換に置き換える必要があります。<CODE><A HREF="../../CRef/Routines/R_47.htm#IX_GrSetDefaultTransform()">GrSetDefaultTransform()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_49.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetPalette()"></A>
        <H1 CLASS="refHeading">GrSetPalette()</H1>
<PRE CLASS="syntax">void GrSetPalette(GStateHandle GState,/*subject GState*/SetPalType type, /*SPT_DEFAULT or SPT_CUSTOM*/const RGBValue*buffer, /*パレットエントリの配列*/word index, /*変更する最初の要素*/word numEntries);/*配列内のエントリ数*/</PRE>
<P>パレット(ウィンドウのカラールックアップテーブル)に1つまたは複数のエントリを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetPaletteEntry()"></A>
        <H1 CLASS="refHeading">GrSetPaletteEntry()</H1>
<PRE CLASS="syntax">void GrSetPaletteEntry(GStateHandle GState,/*subject GState*/word index, /*index in palette to set*/word red, /*new RGB color values for entry*/word green, word blue);</PRE>
<P>パレットにGStateのカラールックアップテーブルを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetPrivateData()"></A>
        <H1 CLASS="refHeading">GrSetPrivateData()</H1>
<PRE CLASS="syntax">void GrSetPrivateData(GStateHandle GState,/*subject GState*/word dataAX, /*設定するデータ*/word dataBX, word dataCX, word dataDX);</PRE>
<P>GStateのプライベートデータを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetStrokePath()"></A>
        <H1 CLASS="refHeading">GrSetStrokePath()</H1>
<PRE CLASS="syntax">void GrSetStrokePath(GStateHandle GState);/*サブジェクトGState*/</PRE>
<P>GStateのパスを、元のパスをストロークした結果のパスに置き換えます。 このストロークパスは描画できますが、クリッピングには使用できないことに注意してください。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetSubscriptAttr()"></A>
        <H1 CLASS="refHeading">GrSetSubscriptAttr()</H1>
<PRE CLASS="syntax">void GrSetSubscriptAttr(GStateHandle GState,/*subject GState*/ScriptAttrAsWord attrs);/*新しい添字の割合*/</PRE>
<P>下付き文字を描画するときに使用する属性を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetSuperscriptAttr()"></A>
        <H1 CLASS="refHeading">GrSetSuperscriptAttr()</H1>
<PRE CLASS="syntax">void GrSetSuperscriptAttr(GStateHandle GState,/*subject GState*/ScriptAttrAsWord attrs);/*新しい上付きパーセンテージ*/</PRE>
<P>上付き文字を描画するときに使用する属性を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetTextAttr()"></A>
        <H1 CLASS="refHeading">GrSetTextAttr()</H1>
<PRE CLASS="syntax">void GrSetTextAttr(GStateHandle GState,/*subject GState*/const TextAttr*ta);/*テキスト属性へのポインタ*/</PRE>
<P>文字およびテキスト文字列の描画に使用するすべての属性を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetTextColor()"></A>
        <H1 CLASS="refHeading">GrSetTextColor()</H1>
<PRE CLASS="syntax">void GrSetTextColor(GStateHandle GState,/*subject GState*/ColorFlag flag, /*ColorFlag*/word redOrIndex, /*palette index or red RGB value*/word green, /*green RGB value or zero*/word blue);/*blue RGB value or zero*/</PRE>
<P>テキストの描画時に使用する色を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetTextColorMap()"></A>
        <H1 CLASS="refHeading">GrSetTextColorMap()</H1>
<PRE CLASS="syntax">void GrSetTextColorMap(GStateHandle GState,/*subject GState*/ColorMapMode colorMap);/*新しいカラーマッピングモード*/</PRE>
<P>使用できない色でテキストを描画するときに使用するモードを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetTextMaskCustom()"></A>
        <H1 CLASS="refHeading">GrSetTextMaskCustom()</H1>
<PRE CLASS="syntax">void GrSetTextMaskCustom(GStateHandle GState,/*subject GState*/const DrawMask*dm);/*カスタムマスクへのポインタ*/</PRE>
<P>テキストの描画時に使用する描画マスクを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_49.htm_IX_GrSetTextMaskSys()"></A>
        <H1 CLASS="refHeading">GrSetTextMaskSys()</H1>
<PRE CLASS="syntax">void GrSetTextMaskSys(GStateHandle GState,/*subject GState*/SystemDrawMask sysDM);/*新しいシステム描画マスク*/</PRE>
<P>テキストの描画時に使用する描画マスクを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_4a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrSetTextMode()"></A>
        <H1 CLASS="refHeading">GrSetTextMode()</H1>
<PRE CLASS="syntax">void GrSetTextMode(GStateHandle GState,/*subject GState*/TextMode bitsToSet, /*設定するTextModeフラグ*/TextMode bitsToClear);/*クリアするTextModeフラグ*/</PRE>
<P>GStateに関連付けられたテキストモードを設定します。 このルーチンを使用すると、テキストの描画時に使用される垂直オフセットを変更できます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrSetTextPattern()"></A>
        <H1 CLASS="refHeading">GrSetTextPattern()</H1>
<PRE CLASS="syntax">void GrSetTextPattern(GStateHandle GState,/*subject GState*/GraphicPattern pattern);/*テキスト用の新しいグラフィックパターン*/</PRE>
<P>テキストの描画時に使用するグラフィックパターンを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrSetTextSpacePad()"></A>
        <H1 CLASS="refHeading">GrSetTextSpacePad()</H1>
<PRE CLASS="syntax">void GrSetTextSpacePad(GStateHandle GState,/*subject GState*/WWFixedAsDWord padding);/*新しいスペースパディング*/</PRE>
<P>文字列を描画するときに使用するスペースパッドを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrSetTextStyle()"></A>
        <H1 CLASS="refHeading">GrSetTextStyle()</H1>
<PRE CLASS="syntax">void GrSetTextStyle(GStateHandle GState,/*subject GState*/TextStyle bitsToSet, /*設定するTextStyleフラグ*/TextStyle bitsToClear);/*クリアするTextStyleフラグ*/</PRE>
<P>テキストの描画時に使用するスタイルを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrSetTrackKern()"></A>
        <H1 CLASS="refHeading">GrSetTrackKern()</H1>
<PRE CLASS="syntax">void GrSetTrackKern(GStateHandle GState,/*subject GState*/word tk);/*トラックカーニングの程度*/</PRE>
<P>テキスト文字列の描画時に使用するトラックカーニングを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrSetTransform()"></A>
        <H1 CLASS="refHeading">GrSetTransform()</H1>
<PRE CLASS="syntax">void GrSetTransform(GStateHandle GState,/*subject GState*/const TransMatrix*tm);/*新しい変換行列*/</PRE>
<P>GStateの座標変換を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>GStateに関連付けられたVMファイルを更新します(これは<A NAME="R_4a.htm_IX_GrSetVMFile()"></A><H1 CLASS="refHeading">GrSetVMFile()</H1>
<PRE CLASS="syntax">void GrSetVMFile(GStateHandle GState,/*subject GState*/VMFileHandle vmFile);/*新しい変換行列*/</PRE>
<P>ある種のビットマップやGStringを使って)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrSetWinClipPath()"></A>
        <H1 CLASS="refHeading">GrSetWinClipPath()</H1>
<PRE CLASS="syntax">void GrSetWinClipPath(GStateHandle GState,/*subject GState*/PathCombineType params, /*パスの結合方法*/RegionFillRuleルール);/*ODD_EVEN or WINDING*/</PRE>
<P>ウィンドウのクリッピング領域を、渡されたパスと交差させて制限します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrSetWinClipRect()"></A>
        <H1 CLASS="refHeading">GrSetWinClipRect()</H1>
<PRE CLASS="syntax">void sword(sword GState,/*subject GState*/PathCombineType flags, /*パスの結合方法*/sword left, /*新しいクリッピングGrSetWinClipRect境界*/sword top, sword right, sword bottom);GStateHandle</PRE>
<P>ウィンドウのクリッピング領域を、渡された長方形と交差させて制限します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrSqrRootWWFixed()"></A>
        <H1 CLASS="refHeading">GrSqrRootWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrSqrRootWWFixed(WWFixedAsDWord i);/*の平方根を求める数*/</PRE>
<P>固定小数点数の平方根を計算します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4a.htm_IX_GrTestPath()"></A>
        <H1 CLASS="refHeading">GrTestPath()</H1>
<PRE CLASS="syntax">Boolean GrTestPath(GStateHandle GState,/*subject GState*/GetPathType ptype);/*チェックするパスの種類*/</PRE>
<P>GStateに指定されたタイプのパスがあるかどうかを判別します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_4b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTestPointInPath()"></A>
        <H1 CLASS="refHeading">GrTestPointInPath()</H1>
<PRE CLASS="syntax">Boolean GrTestPointInPath(GStateHandle GState,/*subject GState*/word xPos, /*point to test*/word yPos, RegionFillRule rule);/*ODD_EVENまたはWINDING*/</PRE>
<P>渡されたポイントがGStateのパスの内部にあるかどうかを判別します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTestPointInPolygon()"></A>
        <H1 CLASS="refHeading">GrTestPointInPolygon()</H1>
<PRE CLASS="syntax">ブーリアンGrTestPointInPolygon(GStateHandle GState,/*subject GState*/RegionFillRule rule, /*ODD_EVEN or WINDING*/Point*list, /*ポリゴン内の点の配列*/word numPoints, /*配列内の点の数*/sword xCoord, /*テストする点の座標*/sword yCoord);</PRE>
<P>渡されたポイントが、渡されたポリゴンの内部にあるかどうかを決定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTestPointInReg()"></A>
        <H1 CLASS="refHeading">GrTestPointInReg()</H1>
<PRE CLASS="syntax">Boolean region(const Region*reg, /*領域へのポインタ*/sword x, /*テストする点の座標*/sword y, Rectangle*boundingRect);/*返された境界長方形,*GrTestPointInReg内の点の場合*/</PRE>
<P>点が渡された領域内にあるかどうかを判別します。 ポイントが領域内にない場合、戻り値は次のようになります。<CODE>真</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTestRectInMask()"></A>
        <H1 CLASS="refHeading">GrTestRectInMask()</H1>
<PRE CLASS="syntax">TestRectReturnType GrTestRectInMask(GStateHandle gstate・剣左・剣上・剣右・剣下);</PRE>
<P>このルーチンは、渡された矩形領域がクリップ領域内にあるかどうかを判断します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef ByteEnum TestRectReturnType;TRRT_OUT, /*矩形が領域から完全に外れている*/TRRT_PARTIAL, /*矩形が部分的に領域にある*/TRRT_IN/*矩形が完全に領域にある*/</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTestRectInReg()"></A>
          <A NAME="R_4b.htm_IX_TestRectReturnType"></A>
          <A NAME="R_4b.htm_IX_TRRT_&ldots;"></A>
        <H1 CLASS="refHeading">GrTestRectInReg()</H1>
<PRE CLASS="syntax">TestRectReturnType GrTestRectInReg(const Region*reg/*領域へのポインタ*/sword left, /*テストする長方形の境界*/sword top, sword right, sword bottom);</PRE>
<P>長方形が渡された領域内にあるかどうかを判別します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef ByteEnum TestRectReturnType;TRRT_OUT, /*矩形が領域から完全に外れている*/TRRT_PARTIAL, /*矩形が部分的に領域にある*/TRRT_IN/*矩形が完全に領域にある*/</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTextWidth()"></A>
        <H1 CLASS="refHeading">GrTextWidth()</H1>
<PRE CLASS="syntax">word GrTextWidth(GStateHandle GState,/*subject GState*/const Chars*str, /*チェックするテキスト文字列*/word size);/*チェックする最大文字数*/</PRE>
<P>渡されたテキスト文字列がテキストの行で必要とするスペースを計算します。 使用(Use)<CODE><A HREF="../../CRef/Routines/R_43.htm#IX_GrGetTextBounds()">GrGetTextBounds()</A></CODE>テキストのレンダリングに必要な領域を決定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTextWidthWWFixed()"></A>
        <H1 CLASS="refHeading">GrTextWidthWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrTextWidthWWFixed(/*returns width&lt;&lt;16*/GStateHandle GState,/*subject GState*/const Chars*str, /*チェックするテキスト文字列*/word size)/*チェックする最大文字数*/</PRE>
<P>渡されたテキスト文字列がテキスト行で必要とする間隔を、1ポイントの何分の1かの精度で計算します。 使用(Use)<CODE><A HREF="../../CRef/Routines/R_43.htm#IX_GrGetTextBounds()">GrGetTextBounds()</A></CODE>テキストのレンダリングに必要な領域を決定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTransform()"></A>
        <H1 CLASS="refHeading">GrTransform()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrTransform(GStateHandle GState,/*subject GState*/sword xCoord, /*coordinates to transform*/sword yCoord);</PRE>
<P>渡された点にデバイスの変換を適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTransformDWFixed()"></A>
        <H1 CLASS="refHeading">GrTransformDWFixed()</H1>
<PRE CLASS="syntax">void GrTransformDWFixed(GStateHandle GState,/*subject GState*/PointDWFixed*coord);/*変換する座標*/</PRE>
<P>渡された点にデバイスの変換を適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTransformDWord()"></A>
        <H1 CLASS="refHeading">GrTransformDWord()</H1>
<PRE CLASS="syntax">void GrTransformDWord(GStateHandle GState,/*subject GState*/sdword xCoord, /*座標変換*/sdword yCoord, PointDWord*deviceCoordinates);/*返されたデバイス座標へのポインタ*/</PRE>
<P>デバイスの変換を通過点に適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4b.htm_IX_GrTransformWWFixed()"></A>
        <H1 CLASS="refHeading">GrTransformWWFixed()</H1>
<PRE CLASS="syntax">void GrTransformWWFixed(GStateHandle GState,/*サブジェクトGState*/WWFixedAsDWord xPos, /*変換する座標*/WWFixedAsDWord yPos, PointWWFixed*deviceCoordinates);/*返されたデバイス座標へのポインタ*/</PRE>
<P>デバイスの変換を通過点に適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_4c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GrUDivWWFixed()"></A>
        <H1 CLASS="refHeading">GrUDivWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrUDivWWFixed(WWFixedAsDWord被除数、WWFixedAsDWord除数)</PRE>
<P>2つの固定小数点数の符号なし除算を計算します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GrUncompactBitmap()"></A>
        <H1 CLASS="refHeading">GrUncompactBitmap()</H1>
<PRE CLASS="syntax">VMBlockHandle GrUncompactBitmap(VMFileHandle srcFile、VMBlockHandle srcBlock、VMFileHandle destFile);</PRE>
<P>このルーチンは、巨大なビットマップのデータをuncompactsします。</P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GrUntransform()"></A>
        <H1 CLASS="refHeading">GrUntransform()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrUnTransformCoord(GStateHandle GState、/*subject GState*/sword xCoord、/*untransformへの座標*/sword yCoord);</PRE>
<P>渡された点に、デバイスの変換の反転を適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GrUntransformDWFixed()"></A>
        <H1 CLASS="refHeading">GrUntransformDWFixed()</H1>
<PRE CLASS="syntax">void GrUnTransCoordDWFixed(GStateHandle GState,/*subject GState*/PointDWFixed*coord);/*変換を解除する座標*/</PRE>
<P>渡された点に、デバイスの変換の反転を適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GrUntransformDWord()"></A>
        <H1 CLASS="refHeading">GrUntransformDWord()</H1>
<PRE CLASS="syntax">void GrUnTransformExtCoord(GStateHandle GState,/*subject GState*/sdword xCoord, /*untransformへの座標*/sdword yCoord, PointDWord*documentCoordinates);/*返されたデバイス座標へのポインタ*</PRE>
<P>渡された点に、デバイスの変換の反転を適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GrUntransformWWFixed()"></A>
        <H1 CLASS="refHeading">GrUntransformWWFixed()</H1>
<PRE CLASS="syntax">void GrUnTransCoordWWFixed(GStateHandle GState,/*subject GState*/WWFixedAsDWord xPos, /*untransformする座標*/WWFixedAsDWord yPos, PointWWFixed*documentCoordinates);/*返されたデバイス座標へのポインタ*</PRE>
<P>渡された点に、デバイスの変換の反転を適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">グラフィックス.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GSApplyRotation() macro"></A>
        <H1 CLASS="refHeading">GSApplyRotation()</H1>
<PRE CLASS="syntax">#define GSApplyRotation(angle_f)\GR_APPLY_ROTATION,GOC_WWF(angle_f)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、渡された<CODE>WWFixed</CODE>座標変換に対する角度の値です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GSApplyScale() macro"></A>
        <H1 CLASS="refHeading">GSApplyScale()</H1>
<PRE CLASS="syntax">#define GSApplyScale(x_f,y_f)\GR_APPLY_SCALE,GOC_WWF(x_f),GOC_WWF(y_f)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、渡されたスケール(2で定義される)を適用します。<CODE>WWFixed</CODE>番号を1つずつ<EM>エックス</EM>および<EM>イ</EM>スケール係数)を座標変換に変換します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GSApplyTransform() macro"></A>
        <H1 CLASS="refHeading">GSApplyTransform()</H1>
<PRE CLASS="syntax">#define GSApplyTransform(e11_f,e12_f,e21_f,e22_f,e31_df,e32_df)\GR_APPLY_TRANSFORM,GOC_WWF(e11_f),GOC_WWF(e12_f),\GOC_WWF(e21_f),GOC_WWF(e22_f),\GOC_DWF(e31_df),GOC_DWF(e32_df)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、渡された変換行列を座標変換に適用します。 変換行列は6つの要素で決定され、4つの要素は次のように定義されます。<CODE>WWFixed</CODE>値と2 by<CODE>DWFixed</CODE>値を指定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GSApplyTranslation() macro"></A>
        <H1 CLASS="refHeading">GSApplyTranslation()</H1>
<PRE CLASS="syntax">#define GOH(x_f,y_f)\GR_APPLY_TRANSLATION,GOC_WWF(x_f),GOC_WWF(y_f)(#define GOH(x_f,y_f)\GR_APPLY_TRANSLATION,GOC_WWF(x_f),GSApplyTranslation</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、渡された変換(2つの<CODE>WWFixed</CODE>番号を1つずつ<EM>エックス</EM>および<EM>イ</EM>座標変換に変換します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GSApplyTranslationDWord() macro"></A>
        <H1 CLASS="refHeading">GSApplyTranslationDWord()</H1>
<PRE CLASS="syntax">#define GSApplyTranslationDWord(x_sdw,y_sdw)\GR_APPLY_TRANSLATION_DWORD,GOC_SDW(x_sdw),GOC_SDW(y_sdw)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、大きな変換(2つのdwordサイズの値で定義され<EM>エックス</EM>および<EM>イ</EM>変換)を変換に変換します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GSBeginPath() macro"></A>
        <H1 CLASS="refHeading">GSBeginPath()</H1>
<PRE CLASS="syntax">#define GSBeginPath(フラグ) GR_BEGIN_PATH、(フラグ)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、その後に続く描画コマンドが、次の描画コマンドまで<CODE><A HREF="../../CRef/Routines/R_4f.htm#IX_GSEndPath() macro">GSEndPath()</A></CODE>、パスを記述します。 引数を1つ取ります。<CODE>PathCombineType</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4c.htm_IX_GSBrushPolyline() macro"></A>
        <H1 CLASS="refHeading">GSBrushPolyline()</H1>
<PRE CLASS="syntax">#define GSBrushPolyline(width_b,height_b,pts_b)\GR_BRUSH_POLYLINE, GOC_WORD(pts_b),(width_b),(height_b)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロはポリラインにブラシをかけます。 このメソッドは3つの引数を取ります。1つはポリラインの点の数を含む単語で、もう1つはブラシの長方形の幅と高さをバイト単位で指定します。 このマクロの後に、ポリラインの点が表示されます。各点はGOC_POINTマクロを介して渡されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_4d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSCloseSubPath() macro"></A>
        <H1 CLASS="refHeading">GSCloseSubPath()</H1>
<PRE CLASS="syntax">#define GSCloseSubPath() GR_CLOSE_SUB_PATH(サブパスを閉じる)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在開いているパスを幾何学的に閉じます。 この場合も<CODE><A HREF="../../CRef/Routines/R_4f.htm#IX_GSEndPath() macro">GSEndPath()</A></CODE>パスの定義が完了したことを示します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSComment() macro"></A>
        <H1 CLASS="refHeading">GSComment()</H1>
<PRE CLASS="syntax">#define GSComment(size_b)\GR_COMMENT, GOC_WORD(size_b)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、GString内のコメントの開始を通知します。 引数は1つで、バイト単位のコメントの長さです。 このマクロの後に、コメントデータを配置します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSCreatePalette() macro"></A>
        <H1 CLASS="refHeading">GSCreatePalette()</H1>
<PRE CLASS="syntax">#define GSCreatePalette() GR_CREATE_PALETTE[パレット作成]</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、カスタムパレットを作成します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDestroyPalette() macro"></A>
        <H1 CLASS="refHeading">GSDestroyPalette()</H1>
<PRE CLASS="syntax">#define GSDestroyPalette() GR_DESTROY_PALETTE[パレット破棄]</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、カスタムパレットがあればそれを破棄します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawArc() macro"></A>
        <H1 CLASS="refHeading">GSDrawArc()</H1>
<PRE CLASS="syntax">#define arc(close_enum,x1_w,y1_w,x2_w,y2_w,ang1_w,ang2_w)\GR_DRAW_GSDrawArc,GOC_WORD(close_enum),\GOC_SW(x1_w),GOC_SW(y1_w),\GOC_SW(x2_w),GOC_SW(y2_w),\GOC_SW(ang1_w),GOC_SW(ang2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは円弧を描きます。 いくつかの引数を取ります。 最初に<CODE>ArcCloseType</CODE>値を入力します。 次に、円弧の基本楕円の境界を取得します。 最後に、円弧の開始角度と終了角度を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawArc3Point() macro"></A>
        <H1 CLASS="refHeading">GSDrawArc 3点()</H1>
<PRE CLASS="syntax">#define GSDrawArc3Point(close, x1, y1, x2, y2, x3, y3)\GR_DRAW_ARC_3 POINT,GOC_WORD(close),GOC_WWF(x1),\GOC_WWF(y1),GOC_WWF(x2),GOC_WWF(y2),\GOC_WWF(x3),GOC_WWF(y3)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは3点の円弧を描きます。 いくつかの引数を取ります。<CODE>ArcCloseType</CODE>および円弧を定義する3点の座標(それぞれ<CODE>WWFixed</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawArc3PointTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawArc3PointTo()</H1>
<PRE CLASS="syntax">#define GSDrawArc3Point(close, x1, y1, x2, y2, x3, y3)\GR_DRAW_ARC_3 POINT,GOC_WORD(close),GOC_WWF(x1),\GOC_WWF(y1),GOC_WWF(x2),GOC_WWF(y2),\GOC_WWF(x3),GOC_WWF(y3)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置を端点の1つとして3点の円弧を描きます。 いくつかの引数を取ります。<CODE>ArcCloseType</CODE>および円弧の残りの定義点の座標(それぞれ<CODE>WWFixed</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawBitmap() macro"></A>
        <H1 CLASS="refHeading">GSDrawBitmap()</H1>
<PRE CLASS="syntax">#define GSDrawBitmap(x_w,y_w,w_w)\GR_DRAW_BITMAP, GOC_SW(x_w),\GOC_SW(y_w),GOC_WORD(w_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロはビットマップを描画します。 ビットマップを描画する座標とビットマップのデータのサイズの3つの引数を取ります。 このマクロの後には、ビットマップのデータが続きます。<CODE>ビットマップ(Bitmap)</CODE>構造、およびビットマップのマスクとカラーデータです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawBitmapAtCP() macro"></A>
        <H1 CLASS="refHeading">GSDrawBitmapAtCP()</H1>
<PRE CLASS="syntax">#define GSDrawBitmapAtCP(bsize_w)\GR_DRAW_BITMAP_CP, GOC_WORD(bsize_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは現在の位置にビットマップを描画します。 引数として、ビットマップデータのサイズをバイト単位で指定します。 このマクロの後には、ビットマップのデータが続きます。<CODE>ビットマップ(Bitmap)</CODE>構造、およびビットマップのマスクとカラーデータです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawBitmapOptr() macro"></A>
        <H1 CLASS="refHeading">GSDrawBitmapOptr()</H1>
<PRE CLASS="syntax">#define GSDrawBitmapOptr(x_w,y_w,o_ptr)\GR_DRAW_BITMAP_OPTR,GOC_SW(x_w),\GOC_SW(y_w),GOC_OPTR(o_ptr)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、渡された座標にビットマップを描画します。このビットマップのデータは、渡されたoptrによって参照されるチャンクに格納されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawCBitmap() macro"></A>
        <H1 CLASS="refHeading">GSDrawCBitmap()</H1>
<PRE CLASS="syntax">#define GSDrawCBitmap(x_w,y_w,slice1size_w,totalSize)\GR_DRAW_BITMAP,GOC_SW(x_w),GOC_SW(y_w),\GOC_WORD(slice1size_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは複雑なビットマップを描画します。 これには4つの引数があります。<EM>エックス</EM>および<EM>イ</EM>ビットマップを描画する座標、ビットマップのマスクとカラーデータの1スライスのサイズ、およびビットマップのデータの合計サイズ。 このマクロの後には、ビットマップのデータが続きます。<CODE>Cビットマップ</CODE>構造の後に、マスク、カラー、およびその他の関連データが続きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawChar() macro"></A>
        <H1 CLASS="refHeading">GSDrawChar()</H1>
<PRE CLASS="syntax">#define GSDrawChar(c,x1_w,y1_w)\GR_DRAW_CHAR,(c),GOC_SW(x1_w),GOC_SW(y1_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、テキスト文字を描画します。 これには3つの引数があります。<CODE>文字</CODE>文字の値と<EM>エックス</EM>および<EM>イ</EM>文字を描く座標。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawCharAtCP() macro"></A>
        <H1 CLASS="refHeading">GSDrawCharAtCP()</H1>
<PRE CLASS="syntax">#define GSDrawCharAtCP(c)\GR_DRAW_CHAR_CP,(c)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは現在の位置に1文字を描画します。 引数を1つ取ります。<CODE>文字</CODE>描画する文字の値。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawCurve() macro"></A>
        <H1 CLASS="refHeading">GSDrawCurve()</H1>
<PRE CLASS="syntax">#define GSDrawCurve(x1_sw,y1_sw,x2_sw,y2_sw,x3_sw,y3_sw,x4_sw,y4_sw)\GR_DRAW_CURVE,GOC_SW(x1_sw),GOC_SW(y1_sw),\GOC_SW(x2_sw),GOC_SW(y2_sw),\GOC_SW(x3_sw),GOC_SW(y3_sw),GOC_SW(x4_sw),GOC_SW(y4_sw)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロはベジェ曲線を描きます。 カーブのアンカーポイントとコントロールポイントの座標で構成される8つの引数を取ります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4d.htm_IX_GSDrawCurveTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawCurveTo()</H1>
<PRE CLASS="syntax">#define GSDrawCurveTo(x2_sw,y2_sw,x3_sw,y3_sw,x4_sw,y4_sw)\GR_DRAW_CURVE_TO,GOC_SW(x2_sw),GOC_SW(y2_sw),\GOC_SW(x3_sw),GOC_SW(y3_sw),\GOC_SW(x4_sw),GOC_SW(y4_sw)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置を1つの端点として使用して、ベジェ曲線を描画します。 これには6つの引数、残りのアンカーの座標、および制御点が必要です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_4e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawEllipse() macro"></A>
        <H1 CLASS="refHeading">GSDrawEllipse()</H1>
<PRE CLASS="syntax">#define GSDrawEllipse(x1_w,y1_w,x2_w,y2_w)\GR_DRAW_ELLIPSE,GOC_SW(x1_w),GOC_SW(y1_w),\GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、渡された座標で定義された境界で楕円を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawHLine() macro"></A>
        <H1 CLASS="refHeading">GSDrawHLine()</H1>
<PRE CLASS="syntax">#define GSDrawHLine(x1_w,y1_w,x2_w)\GR_DRAW_HLINE,GOC_SW(x1_w),\GOC_SW(y1_w),GOC_SW(x2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは水平線を描画します。 3つの単語長の引数を取ります。最初の端点の座標と<EM>エックス</EM>2番目の端点の座標</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawHLineTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawHLineTo()</H1>
<PRE CLASS="syntax">#define GSDrawHLineTo(x2_w)\GR_DRAW_HLINE_TO,GOC_SW(x2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置から渡された位置まで水平線を引きます。<EM>エックス</EM>座標。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawLine() macro"></A>
        <H1 CLASS="refHeading">GSDrawLine()</H1>
<PRE CLASS="syntax">#define GSDrawLine(x1_w,y1_w,x2_w,y2_w)\GR_DRAW_LINE,GOC_SW(x1_w),GOC_SW(y1_w),\GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、渡された2つの点の間に線を引きます。 これらの点は<EM>エックス</EM>および<EM>イ</EM>座標、ワード値として渡されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawLineTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawLineTo()</H1>
<PRE CLASS="syntax">#define GSDrawLineTo(x2_w,y2_w)\GR_DRAW_LINE_TO,GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは現在の位置から渡された点まで線を引きます。 線分の終点は、その線分を説明する2つの単語を介して渡されます。<EM>エックス</EM>および<EM>イ</EM>座標。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawPath() macro"></A>
        <H1 CLASS="refHeading">GSDrawPath()</H1>
<PRE CLASS="syntax">#define GSDrawPath() 「GR作成パス」(GR_DRAW_PATH)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは現在のパスを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawPoint() macro"></A>
        <H1 CLASS="refHeading">GSDrawPoint()</H1>
<PRE CLASS="syntax">#define GSDrawPoint(x1_w,y1_w)\GR_DRAW_POINT,GOC_SW(x1_w),GOC_SW(y1_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは渡された座標にドットを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawPointAtCP() macro"></A>
        <H1 CLASS="refHeading">GSDrawPointAtCP()</H1>
<PRE CLASS="syntax">#define GSDrawPointAtCP()\GR_DRAW_POINT_CP</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の描画位置にドットを描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawPolygon() macro"></A>
        <H1 CLASS="refHeading">GSDrawPolygon()</H1>
<PRE CLASS="syntax">#define GSDrawPolygon(count_w)\GR_DRAW_POLYGON,GOC_WORD(count_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、ポリゴンのアウトラインを描画します。 引数は1つで、ポリゴン内のポイントの数です。 それぞれがGOC_POINTマクロを介して渡されるポリゴンの点を使用して、マクロに従います。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawPolyline() macro"></A>
        <H1 CLASS="refHeading">GSDrawPolyline()</H1>
<PRE CLASS="syntax">#define GSDrawPolyline(count_w)\GR_DRAW_POLYLINE,GOC_WORD(count_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、ポリライン(角のあるスプライン)を描きます。 このマクロは、ポリラインの点の数を引数として取ります。 点データはマクロの後に続き、各点はGOC_POINTマクロを介して渡されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawRect() macro"></A>
        <H1 CLASS="refHeading">GSDrawRect()</H1>
<PRE CLASS="syntax">#define GSDrawRect(x1_w,y1_w,x2_w,y2_w)\GR_DRAW_RECT,GOC_SW(x1_w),GOC_SW(y1_w),\GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、渡された座標で定義された境界を持つ長方形を描画します。各座標はワード長の値です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawRectTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawRectTo()</H1>
<PRE CLASS="syntax">#define GSDrawRectTo(x2_w,y2_w)\GR_DRAW_RECT_TO,GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、一方の角が現在の位置にあり、もう一方の角が渡された座標で定義された点にある長方形を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawRelArc3PointTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawRelArc3PointTo()</H1>
<PRE CLASS="syntax">#define GSDrawRelArc3PointTo(close, x2, y2, x3, y3)\GR_DRAW_REL_ARC_3 POINT_TO,GOC_WORD(close),\GOC_WWF(x2),GOC_WWF(y2),GOC_WWF(x3),GOC_WWF(y3)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置を1つの端点とし、他の点の座標を現在の位置の座標からのオフセットとして指定して、3点円弧を描きます。 これらのオフセットに加えて、このマクロにはもう1つの引数があります。<CODE>ArcCloseType</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawRelCurveTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawRelCurveTo()</H1>
<PRE CLASS="syntax">#define GSDrawRelCurveTo(x2_sw,y2_sw,x3_sw,y3_sw,x4_sw,y4_sw)\GR_DRAW_REL_CURVE_TO,GOC_SW(x2_sw),GOC_SW(y2_sw),\GOC_SW(x3_sw),GOC_SW(y3_sw),\GOC_SW(x4_sw),GOC_SW(y4_sw)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロはベジェ曲線を描きます。 現在の位置をカーブの終点の1つとして使用します。6つの引数(現在の位置の座標からのオフセットとして表されるカーブの他のポイントの座標)を取ります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawRoundRect() macro"></A>
        <H1 CLASS="refHeading">GSDrawRoundRect()</H1>
<PRE CLASS="syntax">#define GSDrawRoundRect(x1_w,y1_w,x2_w,y2_w,r_w)\GR_DRAW_ROUND_RECT,GOC_WORD(r_w),\GOC_SW(x1_w),GOC_SW(y1_w),\GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、最初の4つの引数で境界を指定し、最後の引数でコーナー半径を指定して、丸みを帯びた長方形を描画します。 半径(単語)以外のすべての引数は、単語の長さの値です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4e.htm_IX_GSDrawRoundRectTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawRoundRectTo()</H1>
<PRE CLASS="syntax">#define GSDrawRoundRectTo(x2_w,y2_w,r_w)\GR_DRAW_ROUND_RECT_TO,GOC_WORD(r_w),\GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在位置の座標と渡された点の座標で定義された境界を持つ、丸みを帯びた四角形を描画します。コーナー半径は、マクロの最後の引数で指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_4f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSDrawSpline() macro"></A>
        <H1 CLASS="refHeading">GSDrawSpline()</H1>
<PRE CLASS="syntax">#define GSDrawSpline(count_w)\GR_DRAW_SPLINE,GOC_WORD(count_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロはスプラインを描画します。 引数は1つで、スプライン内の点の数です。 このマクロに従ってスプラインの点数一覧表を指定します。各点はGOC_POINTマクロを使用して定義する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSDrawSplineTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawSplineTo()</H1>
<PRE CLASS="syntax">#define GSDrawSplineTo(count_w)\GR_DRAW_SPLINE_TO,GOC_WORD(count_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置を1つの端点として使用してスプラインを描画します。 引数は1つで、スプライン内の点の数です。 このマクロに従ってスプラインの点数一覧表を指定します。各点はGOC_POINTマクロを使用して定義する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSDrawText() macro"></A>
        <H1 CLASS="refHeading">GSDrawText()</H1>
<PRE CLASS="syntax">#define GSDrawText(x1_w,y1_w)\GR_DRAW_TEXT,GOC_SW(x1_w),GOC_SW(y1_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、文字列を描画します。 次のようなテキスト文字列を使用して、マクロに従います。</P>
<PRE>GSDrawText(1010),&quot;foo&quot;</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSDrawTextAtCP() macro"></A>
        <H1 CLASS="refHeading">GSDrawTextAtCP()</H1>
<PRE CLASS="syntax">#define GSDrawTextAtCP() GR_DRAW_テキスト_CP</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置に文字列を描画します。 次のように、マクロの後にテキストを続けて描画します。</P>
<PRE>GSDrawTextAtCP(),&quot;bar&quot;</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSDrawTextOptr() macro"></A>
        <H1 CLASS="refHeading">GSDrawTextOptr()</H1>
<PRE CLASS="syntax">#define GSDrawTextOptr(x_w,y_w,o_ptr)\GR_DRAW_TEXT_OPTR, GOC_SW(x_w),\GOC_SW(y_w),GOC_OPTR(o_ptr)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、文字列を描画します。 これには3つの引数があります。<EM>エックス</EM>および<EM>イ</EM>テキストの描画を開始する座標と、テキストが格納されているチャンクへのoptr。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSDrawVLine() macro"></A>
        <H1 CLASS="refHeading">GSDrawVLine()</H1>
<PRE CLASS="syntax">#define GSDrawVLine(x1_w,y1_w,y2_w)\GR_DRAW_VLINE,GOC_SW(x1_w),\GOC_SW(y1_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは縦線を引きます。 このメソッドは3つの引数を取ります。最初の端点の座標と<EM>イ</EM>2番目の端点の座標</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSDrawVLineTo() macro"></A>
        <H1 CLASS="refHeading">GSDrawVLineTo()</H1>
<PRE CLASS="syntax">#define GSDrawVLineTo(y2_w)\GR_DRAW_VLINE_TO,GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置から渡された位置まで垂直線を引きます。<EM>イ</EM>座標。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSEndPath() macro"></A>
        <H1 CLASS="refHeading">GSEndPath()</H1>
<PRE CLASS="syntax">#define GSEndPath()GR_END_PATH</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、パス定義コマンドの終了を通知します。これ以降、描画コマンドはパスストロークを指定する代わりに描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSEndString() macro"></A>
        <H1 CLASS="refHeading">GSEndString()</H1>
<PRE CLASS="syntax">#define GSEndString()\GR_END_GSTRING</PRE>
<P>この<CODE>G文字列</CODE>定義マクロは、グラフィックス文字列の終わりをマークします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSEscape() macro"></A>
        <H1 CLASS="refHeading">GSEscape()</H1>
<PRE CLASS="syntax">#define GSEscape(esc_w,size_w)\GR_ESCAPE,GOC_WORD(esc_w),GOC_WORD(size_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、GStringにエスケープコードを挿入します。 マクロの最初の引数は、単語長のエスケープコードです。 2番目の引数は、後続する追加のエスケープコードデータのサイズ(バイト単位)です。 このマクロの後には、エスケープコードに関連付けるデータを任意の量だけ追加できます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSFillArc() macro"></A>
        <H1 CLASS="refHeading">GSFillArc()</H1>
<PRE CLASS="syntax">#define arc(close_enum,x1_w,y1_w,x2_w,y2_w,ang1_w,ang2_w)\GR_FILL_GSFillArc,GOC_WORD(close_enum),\GOC_SW(x1_w),GOC_SW(y1_w),\GOC_SW(x2_w),GOC_SW(y2_w),GOC_SW(ang1_w),\GOC_SW(ang2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは塗りつぶされた円弧を描きます。 いくつかの引数を取ります。<CODE>ArcCloseType</CODE>値、円弧のベース楕円の境界座標、および円弧の開始角度と終了角度です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSFillArc3Point() macro"></A>
        <H1 CLASS="refHeading">GSFillArc 3点()</H1>
<PRE CLASS="syntax">#define GSFillArc3Point(close, x1, y1, x2, y2, x3, y3)\GR_FILL_ARC_3 POINT,GOC_WORD(close),GOC_WWF(x1),GOC_WWF(y1),\GOC_WWF(x2),GOC_WWF(y2),GOC_WWF(x3),GOC_WWF(y3)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、3点円弧を塗りつぶします。 いくつかの引数を取ります。<CODE>ArcCloseType</CODE>円弧を定義する点の座標です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_4f.htm_IX_GSFillArc3PointTo() macro"></A>
        <H1 CLASS="refHeading">GSFillArc3PointTo()</H1>
<PRE CLASS="syntax">#define GSFillArc3PointTo(close, x2, y2, x3, y3)\GR_FILL_ARC_3 POINT_TO,GOC_WORD(close),\GOC_WWF(x2),GOC_WWF(y2),GOC_WWF(x3),GOC_WWF(y3)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、3点円弧を塗りつぶします。 現在の位置は円弧の端点の1つとして機能し、マクロの引数は他の点の座標を指定します。 このマクロにはもう1つの引数があります。<CODE>ArcCloseType</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_50.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillBitmap() macro"></A>
        <H1 CLASS="refHeading">GSFillBitmap()</H1>
<PRE CLASS="syntax">#define GSFillBitmap(x_w,y_w,bsize_w)\GR_FILL_BITMAP,GOC_SW(x_w),\GOC_SW(y_w),GOC_WORD(bsize_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、領域塗りつぶしカラーを使用してビットマップを描画します。 渡された座標にビットマップを描画します。マクロの最後の引数はビットマップのデータのサイズです。 マクロの後に、ビットマップのデータを配置する必要があります。最初にビットマップ構造体を配置し、次にビットマップのマスクとカラーの値を含むバイト数を配置します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillBitmapAtCP() macro"></A>
        <H1 CLASS="refHeading">GSFillBitmapAtCP()</H1>
<PRE CLASS="syntax">#define GSFillBitmapAtCP(bsize_w)\GR_FILL_BITMAP_CP, GOC_WORD(bsize_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置で領域塗りつぶしカラーを使用してビットマップを描画します。 引数は1つで、ビットマップのデータサイズです。 マクロの後に、ビットマップのデータを配置する必要があります。最初にビットマップ構造体を配置し、次にビットマップのマスクとカラーの値を含むバイト数を配置します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillBitmapOptr() macro"></A>
        <H1 CLASS="refHeading">GSFillBitmapOptr()</H1>
<PRE CLASS="syntax">#define GSFillBitmapOptr(x_w,y_w,o_ptr)\GR_FILL_BITMAP_OPTR,GOC_SW(x_w),GOC_SW(y_w),GOC_OPTR(o_ptr)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、領域塗りつぶしカラーを使用してビットマップを描画します。 これは渡された座標で実行されます。ビットマップのデータは、渡されたoptrによって参照されるチャンクに格納されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillEllipse() macro"></A>
        <H1 CLASS="refHeading">GSFillEllipse()</H1>
<PRE CLASS="syntax">#define GSFillEllipse(x1_w,y1_w,x2_w,y2_w)\GR_FILL_ELLIPSE,GOC_SW(x1_w),GOC_SW(y1_w),\GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは塗りつぶされた楕円を描きます。 楕円の境界座標である4つの引数を取ります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillPath() macro"></A>
        <H1 CLASS="refHeading">GSFillPath()</H1>
<PRE CLASS="syntax">#GSFillPathを定義(region_fill_rule)\GR_FILL_PATH,(region_fill_rule)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、渡された<CODE>RegionFillRule</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillPolygon() macro"></A>
        <H1 CLASS="refHeading">GSFillPolygon()</H1>
<PRE CLASS="syntax">#define GSFillPolygon(count_w,fillrule_enum)\GR_FILL_POLYGON,GOC_WORD(count_w),(fillrule_enum)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは塗りつぶされたポリゴンを描画します。 このメソッドは、2つの引数(ポリゴン内のポイント数と<CODE>RegionFillRule</CODE>値を入力します。 このマクロの後にはポリゴンの点が続き、それぞれGOC_POINTマクロを介して渡されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillRect() macro"></A>
        <H1 CLASS="refHeading">GSFillRect()</H1>
<PRE CLASS="syntax">#define GSFillRect(x1_w,y1_w,x2_w,y2_w)\GR_FILL_RECT,GOC_SW(x1_w),GOC_SW(y1_w),\GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは塗りつぶされた長方形を描きます。 このマクロは、長方形の境界を表す4つの引数を取ります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillRectTo() macro"></A>
        <H1 CLASS="refHeading">GSFillRectTo()</H1>
<PRE CLASS="syntax">#define GSFillRectTo(x2_w,y2_w)\GR_FILL_RECT_TO,GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置が1つのコーナーを定義し、反対側のコーナーが渡された座標によって定義される、塗りつぶされた長方形を描画します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillRoundRect() macro"></A>
        <H1 CLASS="refHeading">GSFillRoundRect()</H1>
<PRE CLASS="syntax">#define GSFillRoundRect(x1_w,y1_w,x2_w,y2_w,r_w)\GR_FILL_ROUND_RECT,GOC_WORD(r_w),GOC_SW(x1_w),\GOC_SW(y1_w),GOC_SW(x2_w),\GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、塗りつぶされた角丸の長方形を描画します。 5つの引数を取ります。最初の4つは長方形の境界座標を示し、最後の引数はコーナー半径です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSFillRoundRectTo() macro"></A>
        <H1 CLASS="refHeading">GSFillRoundRectTo()</H1>
<PRE CLASS="syntax">#define GSFillRoundRectTo(x2_w,y2_w,r_w)\GR_FILL_ROUND_RECT_TO,GOC_WORD(r_w),GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、塗りつぶされた角丸の長方形を描画します。 矩形の境界座標は、現在の位置と渡された2つの座標で定義されます。矩形のコーナー半径は、マクロの最後の引数で定義されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSInitDefaultTransform() macro"></A>
        <H1 CLASS="refHeading">GSInitDefaultTransform()</H1>
<PRE CLASS="syntax">#define GSInitDefaultTransform()\GR_INIT_DEFAULT_TRANSFORM</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、GStateのデフォルト変換を初期化して、現在の座標変換の値を保持します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_50.htm_IX_GSLabel() macro"></A>
        <H1 CLASS="refHeading">GSLabel()</H1>
<PRE CLASS="syntax">#define GSLabel(w)\GR_LABEL, GOC_WORD(w)</PRE>
<P>この<CODE>G文字列</CODE>定義マクロは、GStringにラベルを作成します。 このマクロは1つの引数(ラベルのトークンとして機能する単語)を取ります。 GSC_LABELをに渡して<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>または他のGStringトラバースコマンドを使用する場合は、このラベルをgotoコマンドで使用されるラベルに類似したものとして使用できます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_51.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSMoveTo() macro"></A>
        <H1 CLASS="refHeading">GSMoveTo()</H1>
<PRE CLASS="syntax">#define GSMoveTo(x1_w,y1_w)\GR_MOVE_TO, GOC_SW(x1_w),GOC_SW(y1_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置を渡された座標に更新します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSNewPage() macro"></A>
        <H1 CLASS="refHeading">GSNewPage()</H1>
<PRE CLASS="syntax">#define GSNewPage(pageEndCommand)\GR_NEW_PAGE,(pageEndCommand)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロはページの終わりを通知します。 の<EM>pageEndCommand</EM>引き数は<CODE>PageEndCommand</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSNullOp() macro"></A>
        <H1 CLASS="refHeading">GSNullOp()</H1>
<PRE CLASS="syntax">#define GSNullOp()GR_NULL_OP</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、ヌル操作要素をGStringに挿入します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSRelMoveTo() macro"></A>
        <H1 CLASS="refHeading">GSRelMoveTo()</H1>
<PRE CLASS="syntax">#define goal(x1_wwf,y1_wwf)\GR_REL_MOVE_TO, GOC_WWF(x1_wwf),GOC_WWF(y1_wwf)(#define GSRelMoveTo(x1_wwf,y1_wwf)\GR_REL_MOVE_TO, GOC_WWF(x1_wwf)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の位置を、古い現在の位置からのオフセットとして指定された座標のセットに更新します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSRestoreState() macro"></A>
        <H1 CLASS="refHeading">GSRestoreState()</H1>
<PRE CLASS="syntax">#define GSRestoreState()\GR_RESTORE_STATE</PRE>
<P>この<CODE>G文字列</CODE>作成マクロによってGStateが保存されます。<CODE><A HREF="../../CRef/Routines/R_51.htm#IX_GSSaveState() macro">GSSaveState()</A></CODE>復元されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSRestoreTransform() macro"></A>
        <H1 CLASS="refHeading">GSRestoreTransform()</H1>
<PRE CLASS="syntax">#define GSRestoreTransform()\GR_RESTORE_TRANSFORM</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは以前に保存した変換マトリックスを<CODE><A HREF="../../CRef/Routines/R_51.htm#IX_GSSaveTransform() macro">GSSaveTransform()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSaveState() macro"></A>
        <H1 CLASS="refHeading">GSSaveState()</H1>
<PRE CLASS="syntax">#define GSSaveState()\GR_SAVE_STATE</PRE>
<P>この<CODE>G文字列</CODE>作成マクロによってGStateが保存され、後続のマクロによって復元されます。<CODE><A HREF="../../CRef/Routines/R_51.htm#IX_GSRestoreState() macro">GSRestoreState()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSaveTransform() macro"></A>
        <H1 CLASS="refHeading">GSSaveTransform()</H1>
<PRE CLASS="syntax">#define GSSaveTransform()\GR_SAVE_TRANSFORM</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の変換マトリックスを保存します。このマトリックスは<CODE><A HREF="../../CRef/Routines/R_51.htm#IX_GSRestoreTransform() macro">GSRestoreTransform()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetAreaAttr() macro"></A>
        <H1 CLASS="refHeading">GSSetAreaAttr()</H1>
<PRE CLASS="syntax">#define area(r,g,b,mode,mask)\GR_SET_GSSetAreaAttr_ATTR,(CF_RGB),(r),(g),(b),(mask),(mode)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>AreaAttr</CODE>値を指定します。 このメソッドには、カラーの赤、緑、青のコンポーネント<CODE>ColorMapMode</CODE>使用できない色で描画しようとしたときに使用するマスク。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetAreaColor() macro"></A>
        <H1 CLASS="refHeading">GSSetAreaColor()</H1>
<PRE CLASS="syntax">#define area(r,g,b)GR_SET_GSSetAreaColor_COLOR,(r),(g),(b)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、赤、緑、および青のコンポーネントに関して新しいエリアフィルカラーを指定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetAreaColorIndex() macro"></A>
        <H1 CLASS="refHeading">GSSetAreaColorIndex()</H1>
<PRE CLASS="syntax">#define GSSetAreaColorIndex(インデックス) GR_SET_AREA_COLOR_INDEX,(インデックス)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、パレット内のインデックスを使用して、新しいエリアフィルカラーを指定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetAreaColorMap() macro"></A>
        <H1 CLASS="refHeading">GSSetAreaColorMap()</H1>
<PRE CLASS="syntax">#define GSSetAreaColorMap(モード) GR_SET_AREA_COLOR_MAP,(モード)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>ColorMapMode</CODE>使用できない色を使用して領域を塗りつぶすときに使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetAreaMask() macro"></A>
        <H1 CLASS="refHeading">GSSetAreaMask()</H1>
<PRE CLASS="syntax">#define GSSetAreaMask(インデックス) GR_SET_AREA_MASK, (インデックス)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、領域を塗りつぶすときに使用するマスクを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetAreaPattern() macro"></A>
        <H1 CLASS="refHeading">GSSetAreaPattern()</H1>
<PRE CLASS="syntax">#define area(pattern)\GR_SET_GSSetAreaPattern_PATTERN,GOC_PATTERN(pattern)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>GraphicPattern</CODE>領域を塗り潰すときに使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetClipPath() macro"></A>
        <H1 CLASS="refHeading">GSSetClipPath()</H1>
<PRE CLASS="syntax">#define GSSetClipPath(フラグ) GR_SET_CLIP_PATH、(フラグ)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは現在のパスとクリッピングパスを結合します。<CODE>PathCombineType</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetClipRect() macro"></A>
        <H1 CLASS="refHeading">GSSetClipRect()</H1>
<PRE CLASS="syntax">#define GSSetClipRect(path,rl_sw,rt_sw,rr_sw,rb_sw)\GR_SET_CLIP_RECT,GOC_SW(rl_sw),\GOC_SW(rt_sw),GOC_SW(rr_sw),GOC_SW(rb_sw)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、クリッピング長方形を設定します。 引数は5つあります。<CODE>PathCombineType</CODE>長方形の境界座標です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetCustomAreaMask() macro"></A>
        <H1 CLASS="refHeading">GSSetCustomAreaMask()</H1>
<PRE CLASS="syntax">#define area(m1,m2,m3,m4,m5,m6,m7,m8)\GR_SET_CUSTOM_AREA_MASK, (m1),(m2),(m3),(m4),(m5),(m6),(m7),(m8)GSSetCustomAreaMaskの定義</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、領域を塗りつぶすときに使用するカスタムビットマスクを指定します。 これには8つの引数があり、各バイトは1行のピクセルを表します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_51.htm_IX_GSSetCustomAreaPattern() macro"></A>
        <H1 CLASS="refHeading">GSSetCustomAreaPattern()</H1>
<PRE CLASS="syntax">#define area(pattern,size)\GR_SET_CUSTOM_AREA_PATTERN, GOC_PATTERN(pattern),GOC_WORD(size)(GSSetCustomAreaPattern(パターン、サイズ)を定義)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、領域を塗りつぶすときに使用するカスタムパターンを設定します。 2つの引数を取ります。<CODE>GraphicPattern</CODE>値とパターンのデータのサイズです。 このマクロの後に、パターンのデータが表示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_52.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetCustomLineMask() macro"></A>
        <H1 CLASS="refHeading">GSSetCustomLineMask()</H1>
<PRE CLASS="syntax">#define GSSetCustomLineMask(m1,m2,m3,m4,m5,m6,m7,m8)\GR_SET_CUSTOM_LINE_MASK, (m1),(m2),(m3),(m4),(m5),(m6),(m7),\(m8)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、線を描くときにマスクとして使用する新しいビットマップを指定します。 これには8つの引数があり、それぞれ1バイトが1行のピクセルを表します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetCustomLineStyle() macro"></A>
        <H1 CLASS="refHeading">GSSetCustomLineStyle()</H1>
<PRE CLASS="syntax">#define GSSetCustomLineStyle(index,count)\GR_SET_CUSTOM_LINE_STYLE,(index),(count)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、線を描くときに使用するカスタムスタイル(「dottedness」)を設定します。 2つの引数を取ります。1つ目は使用するパターンのインデックスで、2つ目は線種のダッシュペアの数です。 このマクロの後には<CODE>DashPairArray</CODE>線種のデータを含んでいます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetCustomTextMask() macro"></A>
        <H1 CLASS="refHeading">GSSetCustomTextMask()</H1>
<PRE CLASS="syntax">#define GSSetCustomTextMask(m1,m2,m3,m4,m5,m6,m7,m8)\GR_SET_CUSTOM_TEXT_MASK, (m1),(m2),(m3),(m4),(m5),(m6),(m7),(m8)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、テキストのレンダリング時に使用するカスタムビットマスクを指定します。 これは8つの引数を取り、各バイトはピクセルデータの1行を表します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetCustomTextPattern() macro"></A>
        <H1 CLASS="refHeading">GSSetCustomTextPattern()</H1>
<PRE CLASS="syntax">#define GSSetCustomTextPattern(pattern,size)\GR_SET_CUSTOM_TEXT_PATTERN,GOC_PATTERN(pattern),GOC_WORD(size)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、テキストのレンダリング時に使用するカスタムパターンを設定します。 2つの引数を取ります。<CODE>GraphicPattern</CODE>値とパターンのデータのサイズです。 このマクロの後に、パターンのデータが表示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetDefaultTransformation() macro"></A>
        <H1 CLASS="refHeading">GSSetDefaultTransformation()</H1>
<PRE CLASS="syntax">#define GSSetDefaultTransform()\GR_SET_DEFAULT_TRANSFORM</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在の座標変換を既定の座標変換に置き換えます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetFont() macro"></A>
        <H1 CLASS="refHeading">GSSetFont()</H1>
<PRE CLASS="syntax">#define GSSetFont(id,size_wbf)\GR_SET_FONT,GOC_WBF(size_wbf),GOC_WORD(id)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、テキストのレンダリング時に使用するフォントを設定します。 2つの引数を取ります。<CODE>フォントID</CODE>ポイントサイズは<CODE>WBFixed</CODE>番号を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetFontWeight() macro"></A>
        <H1 CLASS="refHeading">GSSetFontWeight()</H1>
<PRE CLASS="syntax">#define GSSetFontWeight(weight) GR_SET_FONT_WEIGHT、GOC_WORD(重み)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>フォントの太さ</CODE>テキストのレンダリング時に使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetFontWidth() macro"></A>
        <H1 CLASS="refHeading">GSSetFontWidth()</H1>
<PRE CLASS="syntax">#define width(GSSetFontWidth) GR_SET_FONT_WIDTH、GOC_WORD(幅)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>フォントの幅</CODE>テキストのレンダリング時に使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetGStringBounds() macro"></A>
        <H1 CLASS="refHeading">GSSetGStringBounds()</H1>
<PRE CLASS="syntax">#define GSSetGStringBounds(x1_w,y1_w,x2_w,y2_w)\GR_SET_GSTRING_BOUNDS,GOC_SW(x1_w),GOC_SW(y1_w),\GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは最適化に役立ちます。 図面を作成するとき<CODE>G文字列</CODE>、グラフィックシステムが<CODE>G文字列</CODE>図面範囲を決定します。 これらの境界を事前に計算しておけば、それらを引数としてこのマクロに渡すことができます。<CODE>G文字列</CODE>要素の残りの部分をトラバースする必要はありません。<CODE>G文字列</CODE>をクリックしますが、事前に計算された値が使用されます。 したがって、この<CODE>G文字列</CODE>エレメントの先頭に配置する必要があります。<CODE>G文字列</CODE>このマクロは4つの単語長の引数を取ります。<CODE>G文字列</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetLineAttr() macro"></A>
        <H1 CLASS="refHeading">GSSetLineAttr()</H1>
<PRE CLASS="syntax">#define GSSetLineAttr(r,g,b,mode,mask,width,end,join,style)\GR_SET_LINE_ATTR,(CF_RGB),(r),(g),(b),(mask),(mode),(end),(join),\(style),GOC_WWF(width)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>線属性</CODE>線を描くときに使用します。 使用するカラーの赤、緑、青のコンポーネント、使用できないカラーを描画するときに使用するColorMapMode、使用する描画マスク<CODE>線の終点</CODE><CODE>ライン結合</CODE>、および<CODE>線スタイル</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetLineColor() macro"></A>
        <H1 CLASS="refHeading">GSSetLineColor()</H1>
<PRE CLASS="syntax">#define GSSetLineColor(r,g,b)GR_SET_LINE_COLOR,(r),(g),(b)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、赤、緑、青のコンポーネントに関して線画の色を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetLineColorIndex() macro"></A>
        <H1 CLASS="refHeading">GSSetLineColorIndex()</H1>
<PRE CLASS="syntax">#define GSSetLineColorIndex(色) GR_SET_LINE_COLOR_INDEX, (色)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、パレット内のどのエントリを使用するかを指定して、線画の色を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_52.htm_IX_GSSetLineColorMap() macro"></A>
        <H1 CLASS="refHeading">GSSetLineColorMap()</H1>
<PRE CLASS="syntax">#define GSSetLineColorMap(モード) GR_SET_LINE_COLOR_MAP,(モード)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>ColorMapMode</CODE>使用できない色の線を描画するときに使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_53.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetLineEnd() macro"></A>
        <H1 CLASS="refHeading">GSSetLineEnd()</H1>
<PRE CLASS="syntax">#define GSSetLineEnd(end)\GR_SET_LINE_END,(end)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>線の終点</CODE>線分の終点を描画するときに使用する値。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetLineJoin() macro"></A>
        <H1 CLASS="refHeading">GSSetLineJoin()</H1>
<PRE CLASS="syntax">#define GSSetLineJoin(結合)\GR_SET_LINE_JOIN,(結合)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>ライン結合</CODE>ポリライン、ポリゴン、および長方形のコーナーを描画するときに使用する値。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetLineMask() macro"></A>
        <H1 CLASS="refHeading">GSSetLineMask()</H1>
<PRE CLASS="syntax">#define GSSetLineMask(インデックス) GR_SET_LINE_MASK, (インデックス)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、線を描くときに使用するマスクを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetLineStyle() macro"></A>
        <H1 CLASS="refHeading">GSSetLineStyle()</H1>
<PRE CLASS="syntax">#define GSSetLineStyle(style,index)\GR_SET_LINE_STYLE,(style),(index)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、線を描くときに使用するスタイル、つまり「dottedness」を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetLineWidth() macro"></A>
        <H1 CLASS="refHeading">GSSetLineWidth()</H1>
<PRE CLASS="syntax">#define GSSetLineWidth(width_wwf)\GR_SET_LINE_WIDTH, GOC_WWF(width_wwf)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、線を描くときに使用する幅を設定します。 引数は1つで、幅は<CODE>WWFixed</CODE>番号を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetMiterLimit() macro"></A>
        <H1 CLASS="refHeading">GSSetMiterLimit()</H1>
<PRE CLASS="syntax">#define miter(limit_wwf)\GR_SET_GSSetMiterLimit_LIMIT, GOC_WWF(limit_wwf)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、長方形、ポリライン、ポリゴンのマイター接続されたコーナーを描画するときに使用するマイターリミットを設定します。 このマイタ制限は<CODE>WWFixed</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetMixMode() macro"></A>
        <H1 CLASS="refHeading">GSSetMixMode()</H1>
<PRE CLASS="syntax">#define GSSetMixMode(モード) GR_SET_MIX_MODE, (モード)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、既存の図面の上に描画するときに使用するミックスモードを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetNullPath() macro"></A>
        <H1 CLASS="refHeading">GSSetNullPath()</H1>
<PRE CLASS="syntax">#define GSSetNullPath() GR_SET_NULL_PATH(GR_SET_NULLパス)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは現在のパスをクリアします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetNullTransform() macro"></A>
        <H1 CLASS="refHeading">GSSetNullTransform()</H1>
<PRE CLASS="syntax">#define GSSetNullTransform()\GR_SET_NULL_TRANSFORM</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは座標変換を無効にします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetPalette() macro"></A>
        <H1 CLASS="refHeading">GSSetPalette()</H1>
<PRE CLASS="syntax">#define GSSetPalette(entry_count) GR_SET_PALETTE,(エントリ),(カウント)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロを使用すると、一度に複数のパレットカラーを変更できます。 変更する最初のカラーエントリのインデックスと、変更するエントリの数の2つの引数を取ります。 このマクロに続いて、バイトのトリオがあります。各トリプレットは、色の赤、緑、青のコンポーネントを指定します。</P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetPaletteEntry() macro"></A>
        <H1 CLASS="refHeading">GSSetPaletteEntry()</H1>
<PRE CLASS="syntax">#define GSSetPaletteEntry(entry,r,g,b)\GR_SET_PALETTE_ENTRY GOC_WORD(entry),(r),(g),(b)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、カスタムパレット内の1つのエントリを変更します。 エントリのインデックス番号と、このエントリの新しいカラーの赤、緑、青のコンポーネントの4つの引数を取ります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_53.htm_IX_GSSetStrokePath() macro"></A>
        <H1 CLASS="refHeading">GSSetStrokePath()</H1>
<PRE CLASS="syntax">#define GSSetStrokePath() 「GRストロークパス設定」(GR_SET_STROKE_PATH)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在のパスを、現在の行属性で現在のパスをストロークした結果のパスに置き換えます。 この新しいパスは描画できますが、クリッピングには使用できません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_54.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetSubscriptAttr() macro"></A>
        <H1 CLASS="refHeading">GSSetSubscriptAttr()</H1>
<PRE CLASS="syntax">#define GSSetSubscriptAttr(pos,size)\GR_SET_SUBSCRIPT_ATTR,(pos),(size)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、下付きテキストのレンダリング時に使用する垂直オフセットとサイズを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetSuperScriptAttr() macro"></A>
        <H1 CLASS="refHeading">GSSetSuperscriptAttr()</H1>
<PRE CLASS="syntax">#define GSSetSuperscriptAttr(pos,size)\GR_SET_SUPERSCRIPT_ATTR,(pos),(size)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、上付き文字のレンダリング時に使用する垂直オフセットとサイズを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTextAttr() macro"></A>
        <H1 CLASS="refHeading">GSSetTextAttr()</H1>
<PRE CLASS="syntax">#define GSSetTextAttr(cflag,r,g,b,mask,sSet,sReset,mSet,mReset, sPad,id,pSize,trk Krn,fWeight,fWidth)\</PRE>
<PRE CLASS="syntax">GR_SET_TEXT_ATTR、(cflag)、(r)、(g)、(b)、(mask)、(sSet)、\(sReset)、(mSet)、(mReset)、GOC_WWF(sPad)、\GOC_WORD(id)、GOC_WWF(pSize)、GOC_SW(trkKrn)、(fWeight)、(fWidth)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>TextAttr</CODE>テキストのレンダリングに使用する構造。 これにはいくつかの引数があります。<CODE>カラークアッド</CODE>、描画マスク<CODE>文字スタイル</CODE>設定およびクリアするフラグ<CODE>テキストモード</CODE>設定およびクリアするフラグ、スペースパッド<CODE>フォントID</CODE>として表されるポイントサイズ<CODE>WWFixed</CODE>番号、トラックカーニング値<CODE>フォントの太さ</CODE>、および<CODE>フォントの幅</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTextColor() macro"></A>
        <H1 CLASS="refHeading">GSSetTextColor()</H1>
<PRE CLASS="syntax">#define GSSetTextColor(r,g,b)GR_SET_TEXT_COLOR,(r),(g),(b)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、赤、緑、青のコンポーネント値を使用してテキストレンダリングカラーを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTextColorIndex() macro"></A>
        <H1 CLASS="refHeading">GSSetTextColorIndex()</H1>
<PRE CLASS="syntax">#define GSSetTextColorIndex(インデックス) GR_SET_TEXT_COLOR_INDEX,(インデックス)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、パレットのインデックスとしてテキストレンダリングカラーを指定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTextColorMap() macro"></A>
        <H1 CLASS="refHeading">GSSetTextColorMap()</H1>
<PRE CLASS="syntax">#define GSSetTextColorMap(モード) GR_SET_TEXT_COLOR_MAP,(モード)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>ColorMapMode</CODE>使用できない色でテキストをレンダリングする場合に使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTextMask() macro"></A>
        <H1 CLASS="refHeading">GSSetTextMask()</H1>
<PRE CLASS="syntax">#define GSSetTextMask(インデックス) GR_SET_TEXT_MASK, (インデックス)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、テキストのレンダリング時に使用するマスクを指定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTextMode() macro"></A>
        <H1 CLASS="refHeading">GSSetTextMode()</H1>
<PRE CLASS="syntax">#define GSSetTextMode(set,reset)\GR_SET_TEXT_MODE,(set),(reset)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロセットとクリア<CODE>テキストモード</CODE>フラグ。 設定するフラグとクリアするフラグの2つの引数を取ります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTextPattern() macro"></A>
        <H1 CLASS="refHeading">GSSetTextPattern()</H1>
<PRE CLASS="syntax">#define GSSetTextPattern(pattern)\GR_SET_TEXT_PATTERN,GOC_PATTERN(pattern)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>GraphicPattern</CODE>テキストのレンダリング時に使用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTextSpacePad() macro"></A>
        <H1 CLASS="refHeading">GSSetTextSpacePad()</H1>
<PRE CLASS="syntax">#define GSSetTextSpacePad(pad_wbf)\GR_SET_TEXT_SPACE_PAD, GOC_WBF(pad_wbf)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、テキストのレンダリング時に使用するスペースパッドを指定します。 引数は1つだけです。<CODE>WBFixed</CODE>番号を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTextStyle() macro"></A>
        <H1 CLASS="refHeading">GSSetTextStyle()</H1>
<PRE CLASS="syntax">#define GSSetTextStyle(set,reset)\GR_SET_TEXT_STYLE,(set),(reset)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは<CODE>文字スタイル</CODE>テキストの描画時に使用するフラグ。 設定するフラグとクリアするフラグの2つの引数を取ります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTrackKern() macro"></A>
        <H1 CLASS="refHeading">GSSetTrackKern()</H1>
<PRE CLASS="syntax">#define GSSetTrackKern(度)GR_SET_TRACK_KERN, GOC_SW(度)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、テキスト文字列をレンダリングするときに使用するトラックカーニング値を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetTransform() macro"></A>
        <H1 CLASS="refHeading">GSSetTransform()</H1>
<PRE CLASS="syntax">#define GSSetTransform(e11_f,e12_f,e21_f,e22_f,e31_df,e32_df)\GR_SET_TRANSFORM,GOC_WWF(e11_f),\GOC_WWF(e12_f),GOC_WWF(e21_f),\GOC_WWF(e22_f),GOC_DWF(e31_df),GOC_DWF(e32_df)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは座標変換を設定します。 新しい変換は、変換マトリックスの4つの要素で定義されます。<CODE>WWFixed</CODE>値と2<CODE>DWFixed</CODE>値を指定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetWinClipPath() macro"></A>
        <H1 CLASS="refHeading">GSSetWinClipPath()</H1>
<PRE CLASS="syntax">#define GSSetWinClipPath(フラグ) GR_SET_WIN_CLIP_PATH、(フラグ)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、現在のパスとウィンドウクリッピングパスを結合します。<CODE>PathCombineType</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_54.htm_IX_GSSetWinClipRect() macro"></A>
        <H1 CLASS="refHeading">GSSetWinClipRect()</H1>
<PRE CLASS="syntax">#define GSSetWinClipRect(path,rl_sw,rt_sw,rr_sw,rb_sw)\GR_SET_WIN_CLIP_RECT,GOC_SW(rl_sw),\GOC_SW(rt_sw),GOC_SW(rr_sw),GOC_SW(rb_sw)</PRE>
<P>この<CODE>G文字列</CODE>作成マクロは、長方形を既存の窓クリッピングパスと結合します。 引数は5つあります。<CODE>PathCombineType</CODE>長方形の境界座標です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">「文字列」</STRONG>
        </P>
<P> </P>
</DIV>
<HR>
          <A NAME="R_55.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_55.htm_IX_HAL_COUNT() macro"></A>
        <H1 CLASS="refHeading">関数HAL_COUNT()</H1>
<PRE CLASS="syntax">word HAL_COUNT(dword値);</PRE>
<P>このマクロは、以下で使用するために提供されています。<CODE><A HREF="../../CRef/Routines/R_57.htm#IX_HugeArrayLock()">HugeArrayLock()</A></CODE>の下位の単語を抽出します。<CODE><A HREF="../../CRef/Routines/R_57.htm#IX_HugeArrayLock()">HugeArrayLock()</A></CODE>戻り値 これは、ロックされた配列の後の巨大配列ブロック内の要素の数です(ロックされた配列をカウントします)。</P>
</DIV>
<DIV>
          <A NAME="R_55.htm_IX_HAL_PREV() macro"></A>
        <H1 CLASS="refHeading">HAL_前</H1>
<PRE CLASS="syntax">word HAL_PREV(dword val);</PRE>
<P>このマクロは、以下で使用するために提供されています。<CODE><A HREF="../../CRef/Routines/R_57.htm#IX_HugeArrayLock()">HugeArrayLock()</A></CODE>の上位ワードを抽出します。<CODE><A HREF="../../CRef/Routines/R_57.htm#IX_HugeArrayLock()">HugeArrayLock()</A></CODE>戻り値 これは、ロックされた要素の前の巨大配列ブロック内の要素の数です(ロックされた要素をカウントします)。</P>
</DIV>
<DIV>
          <A NAME="R_55.htm_IX_HandleModifyOwner()"></A>
        <H1 CLASS="refHeading">HandleModifyOwner()</H1>
<PRE CLASS="syntax">void owner(MemHandle mh, /*変更するブロックのハンドル*/GeodeHandle HandleModifyOwner);/*ブロックの新しいオーナーのハンドル*/</PRE>
<P>このルーチンは、指定されたグローバル・メモリ・ブロックの所有者を変更します。 このルーチンは、ブロックの元の所有者に属するスレッドによってのみ呼び出すことができることに注意してください。つまり、このルーチンは、ブロックの所有権を転送するためにのみ使用できます。<EM>から</EM>自分自身<EM>と</EM>他のジオードです</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">heap.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG><BR>ブロックが既に自分のものであり、所有権を放棄するのでない限り、これを使用しないでください。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyOtherInfo()">MemModifyOtherInfo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_55.htm_IX_HandleP()"></A>
          <A NAME="R_55.htm_IX_Semaphores:HandleP()"></A>
        <H1 CLASS="refHeading">HandleP()</H1>
<PRE CLASS="syntax">void HandleP(MemHandle mh);/*グラブするブロックのハンドル*/</PRE>
<P>複数の異なるスレッドが同じグローバルメモリブロックにアクセスする場合は、それらのスレッドのアクティビティが競合しないことを確認する必要があります。 その方法は、同期ルーチンを使用してブロックの制御を取得することです。<CODE>HandleP()</CODE>は、一連の同期ルーチンの一部です。</P>
<P>スレッドがこのファミリーのルーチンを使用している場合、スレッドが問題のブロックへのアクセスを必要とするときはいつでも<CODE>HandleP()</CODE>このルーチンは、ブロックをグラブしたスレッドがあるかどうかをチェックします。<CODE>HandleP()</CODE>(または<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>)をクリックします。 ブロックを持つスレッドがない場合は、呼び出しスレッドのブロックを取得して戻ります(ブロックをグローバルヒープにロックしません)。 スレッドにブロックがある場合は<CODE>HandleP()</CODE>スレッドをプライオリティキューに入れて、スリープ状態にします。 ブロックが空になって取得できるようになると、スレッドは目を覚まし、ブロックをつかみ、戻ります。スレッドはブロックの処理が完了したら、次のようにブロックを解放する必要があります。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">heap.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ブロックを掴んだ後にロックする場合は、ルーチンを使用します。<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>(これは<CODE>HandleP()</CODE>ブロックをロックします。<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLock()">MemLock()関数</A></CODE>)をクリックします。 ブロックがアクセスされているかどうかは<CODE>HM_その他の情報</CODE>単語(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>)をクリックします。 次の場合<CODE>HM_その他の情報</CODE>が1の場合、ブロックはグラブされません。が0の場合、ブロックはグラブされますが、キューに入れられるスレッドはありません。それ以外の場合は、キューに入れられた最初のスレッドのハンドルと等しくなります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックにアクセスするすべてのスレッドが<CODE>HandleP()</CODE>および/または<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>をクリックしてブロックにアクセスします。 ルーチンでは<CODE>HM_その他の情報</CODE>このフィールドは変更しないでください。 次のコマンドでブロックを解除します。<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>あなたがそれを終えたとき。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>スレッドが<CODE>HandleP()</CODE>すでにブロックを制御している場合は、デッドロックします。<CODE>HandleP()</CODE>は、スレッドがブロックを解放するまでスレッドをスリープ状態にしますが、スレッドはスリープ状態であるため、ブロックを解放できません。<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>はこの競合を回避します。 別のスレッドが所有する共有不可能なブロックを取得しようとすると<CODE>HandleP()</CODE>致命的なエラーになります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE><CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_55.htm_IX_HandleToOptr() macro"></A>
          <A NAME="R_55.htm_IX_optr:HandleToOptr() macro"></A>
        <H1 CLASS="refHeading">HandleToOptr()</H1>
<PRE CLASS="syntax">optr HandleToOptr(ハンドルhan;</PRE>
<P>このマクロは任意のハンドルをoptrにキャストし、結果のoptrのチャンクハンドル部分を0のままにします。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ConstructOptr() macro">ConstructOptr()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToHandle()">OptrToHandle()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToChunk()">OptrToChunk()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_56.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_56.htm_IX_HandleV()"></A>
          <A NAME="R_56.htm_IX_Semaphores:HandleV()"></A>
        <H1 CLASS="refHeading">HandleV()</H1>
<PRE CLASS="syntax">void HandleV(MemHandle mh);/*グラブするブロックのハンドル*/</PRE>
<P><CODE>HandleV()</CODE>は、一連の同期ルーチンの一部です。 複数の異なるスレッドが同じグローバルメモリブロックにアクセスする場合は、それらのスレッドのアクティビティが競合しないことを確認する必要があります。 その方法は、同期ルーチンを使用してブロックの制御を取得することです。<CODE>HandleV()</CODE>は、一連の同期ルーチンの一部です。</P>
<P>ブロックがこれらの同期ルーチンを介してアクセスされている場合、スレッドは<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>スレッドがブロックを完了すると、次の呼び出しによって、他のスレッドが使用できるようにブロックを解放できます。<CODE>HandleV()</CODE>次の点に注意してください。<CODE>HandleV()</CODE>はブロックのロックを解除しません。単にブロックのセマフォを変更して、他のスレッドがそれをつかめるようにします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">heap.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>スレッドを解放する直前にロックを解除する必要がある場合は、次のルーチンを使用します。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>この関数は、まずスレッドのロックを解除してから<CODE>HandleV()</CODE>解除します。 ブロックがアクセスされているかどうかは<CODE>HM_その他の情報</CODE>単語(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>)をクリックします。 次の場合<CODE>HM_その他の情報</CODE>が1の場合、ブロックはグラブされません。が0の場合、ブロックはグラブされますが、キューに入れられるスレッドはありません。それ以外の場合は、キューに入れられた最初のスレッドのハンドルと等しくなります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックにアクセスするすべてのスレッドが<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>の順にクリックして、スレッドにアクセスします ルーチンでは<CODE>HM_その他の情報</CODE>このフィールドは変更しないでください。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>掴んでいないブロックには使用しないでください。 このルーチンは、ユーザーがスレッドをグラブしたかどうかをチェックするのではなく、単にセマフォーをクリアして戻ります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE><CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_56.htm_IX_HelpSendHelpNotification()"></A>
        <H1 CLASS="refHeading">HelpSendHelpNotification()</H1>
<PRE CLASS="syntax">void HelpSendHelpNotification(word HelpType, const char*コンテキスト名,const char*ファイル名);</PRE>
<P>このルーチンを使用して、オンラインヘルプをその場で起動したり、オンラインヘルプに現在表示されているコンテキストを動的に変更したりします。</P>
</DIV>
<DIV>
          <A NAME="R_56.htm_IX_HugeArrayAppend()"></A>
        <H1 CLASS="refHeading">HugeArrayAppend()</H1>
<PRE CLASS="syntax">dワードHugeArrayAppend(VMFileHandleファイル、VMBlockhandle vmBlock、/*ディレクトリブロックのハンドル*/ワードnumElem、/**配列*/の最後に追加する要素の数</PRE>
<PRE CLASS="syntax">const void*initData);/*新しい要素にコピーする*/</PRE>
<P>このルーチンは、1つ以上の要素を巨大配列に追加します。 次の場合<CODE>initData(英語の可能性あり)</CODE>がヌルポインタの場合、要素は初期化されません。</P>
<P>巨大配列に可変サイズの要素が含まれている場合、このルーチンは1つの要素を追加します。この要素は<CODE>numElem</CODE>バイトの長さ。 単一のエレメントは<EM>initData(英語の可能性あり)</EM>ボタンをクリックし</P>
<P>巨大配列に一定サイズの要素が含まれている場合<EM>initData(英語の可能性あり)</EM>は要素サイズの構造体の配列として扱われます。<EM>initData(英語の可能性あり)</EM>[0]は最初のエレメントの初期値になります。<EM>initData(英語の可能性あり)</EM>[1]は2番目の初期値になり、以下同様です。</P>
<P>戻り値は、追加された要素の要素番号です。 複数の要素が追加された場合、これは最初に追加された要素の番号になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_56.htm_IX_HugeArrayCompressBlocks()"></A>
        <H1 CLASS="refHeading">HugeArrayCompressBlocks()</H1>
<PRE CLASS="syntax">void HugeArrayCompressBlocks(VMFileHandle vmFile, /*巨大配列を含むファイル*/VMBlockHandle vmBlock);/*ディレクトリブロックのハンドル*/</PRE>
<P>このルーチンは、巨大配列を圧縮し、各ブロックのサイズをその要素を収容するのに必要な大きさに変更します。 巨大配列内のデータは変更されません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_56.htm_IX_HugeArrayContract()"></A>
        <H1 CLASS="refHeading">HugeArrayContract()</H1>
<PRE CLASS="syntax">word HugeArrayContract(void**elemPtr, /***elemPtrは*削除*する最初の要素です/</PRE>
<PRE CLASS="syntax">word numElem);/*削除する要素の数*/</PRE>
<P>巨大配列内のアドレスで始まる複数の要素を削除します。 このルーチンは、削除された要素の後の最初の要素を指すようにポインタを修正します。 このルーチンは、必要に応じてHuge Arrayブロックを自動的にロックおよびロック解除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_56.htm_IX_HugeArrayCreate()"></A>
        <H1 CLASS="refHeading">HugeArrayCreate()</H1>
<PRE CLASS="syntax">VMBlockhandle HugeArrayCreate(VMFileHandle vmFile/*このVMファイルに作成する*/word elemSize/*可変サイズの*要素にゼロを渡す*/</PRE>
<PRE CLASS="syntax">word headerSize);/*デフォルトのヘッダにゼロを渡す*/</PRE>
<P>このルーチンは、指定されたファイルに巨大配列を作成し、初期化します。 巨大配列のディレクトリブロックのハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_56.htm_IX_HugeArrayDelete()"></A>
        <H1 CLASS="refHeading">HugeArrayDelete()</H1>
<PRE CLASS="syntax">void HugeArrayDelete(VMFileHandle vmFile、VMBlockHandle vmBlock),/*ディレクトリブロックのハンドル*/ワードnumElem, /*削除する要素の数*/ワードelemNum);/*削除する最初の要素のインデックス*/</PRE>
<P>このルーチンは、巨大配列から1つまたは複数の要素を削除します。 必要に応じてブロックを縮小し、解放します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_56.htm_IX_HugeArrayDirty()"></A>
        <H1 CLASS="refHeading">HugeArrayDirty()</H1>
<PRE CLASS="syntax">void HugeArrayDirty(const void*elemPtr);/*dirtyブロック内の要素*/</PRE>
<P>このルーチンは、巨大配列内のブロックをダーティとしてマークします。 このルーチンには、ダーティ要素内の任意の場所へのポインタが渡されます。その要素のブロックはダーティになります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>要素のロックを解除する前に、必ずこのルーチンを呼び出してください。そうしないと、ダーティにする前にブロックが破棄される可能性があります。</P>
</DIV>
<HR>
          <A NAME="R_57.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_57.htm_IX_HugeArrayDestroy()"></A>
        <H1 CLASS="refHeading">HugeArrayDestroy()</H1>
<PRE CLASS="syntax">void HugeArrayDestroy(VMFileHandle vmFile、VMBlockHandle vmBlock);/*ディレクトリブロックのハンドル*/</PRE>
<P>このルーチンは、すべてのブロックを解放してHugeArrayを破壊します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_57.htm_IX_HugeArrayEnum()"></A>
        <H1 CLASS="refHeading">HugeArrayEnum()</H1>
<PRE CLASS="syntax">ブール値HugeArrayEnum(VMFileHandle vmFile、/*上書きの対象*/VMBlockHandle vmBlock、/*巨大配列のディレクトリ*ブロック*/のハンドル</PRE>
<PRE CLASS="syntax">Boolean_pascal(*コールバック)(/*return<EM>真</EM>to stop*/void*element, /*element to examine*/void*enumData),dword startElement, /*first element to examine*/dword count, /*examine this many elements*/void*enumData;/*このポインタはcallback*routine*/に渡される</PRE>
<P>このルーチンを使用すると、巨大配列内の一連の要素を調べることができます。<CODE>HugeArrayEnum()</CODE>には6つの引数が渡されます。 最初の2つはファイルハンドルとブロックハンドルで、これらは検査する巨大配列を指定します。 3番目は、Booleanコールバックルーチンへのポインタです。 4番目の引数は、検査する最初の要素のインデックスです(巨大配列の最初の要素のインデックスは0であることに注意してください)。 5番目の引数は、検査する要素の数、または最後の要素まで検査する場合は-1です。 6番目の引数は、変更されずにコールバックルーチンに渡されるポインタです。これを使用して、コールバックルーチンにデータを渡したり、スクラッチスペースを追跡したりできます。</P>
<P>コールバックルーチン(_pascalと宣言する必要があります)自体は2つの引数を取ります。 1つ目は、巨大配列内の要素へのポインタです。 コールバックルーチンは、指定された範囲内の各要素に対して1回呼び出されます。そのたびに、最初の引数が検査対象の要素を指します。 2番目の引数は、最後の引数として渡されたポインタです。<CODE>HugeArrayEnum()</CODE>コールバックルーチンは<CODE>HugeArrayEnum()</CODE>復帰による中止<EM>真</EM>これは、特定のエレメントを検索する必要がある場合に便利です。 それ以外の場合、コールバックルーチンは次の値を返します。<EM>偽の</EM>コールバックルーチンが列挙を中止した場合<CODE>HugeArrayEnum()</CODE>戻る<EM>真</EM>;それ以外の場合は<EM>偽の</EM>ボタンをクリックし</P>
<P><CODE>HugeArrayEnum()</CODE>は、要素を番号順に調べることが保証されています。<EM>開始エレメント</EM>次の場合でも、ルーチンは最後の要素で自動的に停止します<EM>数える</EM>要素が列挙されていません。 ただし、開始要素は配列内の要素のインデックスである必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>コールバックルーチンは、巨大配列内の要素の割り当て、解放、またはサイズ変更を行うことはできません。 実行する必要があるのは<EM>なしで</EM>サイズ変更)を単一の要素に適用します。</P>
<P>開始要素は配列内の要素である必要があります。 範囲外の開始インデックスを渡すと、結果は未定義になります。</P>
</DIV>
<DIV>
          <A NAME="R_57.htm_IX_HugeArrayExpand()"></A>
        <H1 CLASS="refHeading">HugeArrayExpand()</H1>
<PRE CLASS="syntax">word HugeArrayExpand(void**elemPtr, /***elemPtrは新しい要素が*作成される*場所*の要素です*/</PRE>
<PRE CLASS="syntax">word numElem, /*挿入する要素の数*/const void*initData);/*これをそれぞれの新しい*element*/にコピーします</PRE>
<P>このルーチンは、HugeArray内の指定した位置に複数の要素を挿入します。 ポイントされたエレメントは、新しく作成されたエレメントの後に来るようにシフトされます。 ポインタは最初の新しい要素を指すように固定されます。 が指すデータ<EM>initData(英語の可能性あり)</EM>各新規エレメントにコピーされます。 次の場合<EM>initData(英語の可能性あり)</EM>がヌルの場合、新しい要素は初期化されません。</P>
<P>エレメントのサイズが可変の場合、このルーチンはエレメントを1つ挿入します。<CODE>numElem</CODE>バイトの長さ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_57.htm_IX_HugeArrayGetCount()"></A>
        <H1 CLASS="refHeading">HugeArrayGetCount()</H1>
<PRE CLASS="syntax">dワードHugeArrayGetCount(VMFileHandle vmFile、VMBlockHandle vmBlock);/*ディレクトリブロックのハンドル*/</PRE>
<P>巨大配列内の要素の数を返すルーチンです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_57.htm_IX_HugeArrayInsert()"></A>
        <H1 CLASS="refHeading">HugeArrayInsert()</H1>
<PRE CLASS="syntax">void HugeArrayInsert(VMFileHandle vmFile、VMBlockHandle vmBlock、/*ディレクトリブロックのハンドル*/ワードnumElem、/*挿入する要素の数*/dワードelemNum、/*最初の新しい要素のインデックス*/const void*initData);/*これを各新しい要素にコピーします*/</PRE>
<P>このルーチンは、巨大配列の中央に1つ以上の要素を挿入します。 最初の新しい要素にはインデックスが付きます<EM>elemNum</EM>したがって、以前にそのインデックスを持っていた要素は、新しい要素の後に来ることになります。 が指すデータ<CODE>initData(英語の可能性あり)</CODE>各新規エレメントにコピーされます。 次の場合<CODE>initData(英語の可能性あり)</CODE>がヌルの場合、新しい要素は初期化されません。</P>
<P>エレメントのサイズが可変の場合、このルーチンはエレメントを1つ挿入します。<CODE>numElem</CODE>バイトの長さ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">heap.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_57.htm_IX_HugeArrayLock()"></A>
        <H1 CLASS="refHeading">HugeArrayLock()</H1>
<PRE CLASS="syntax">dワードHugeArrayLock(VMFileHandle vmFile、VMBlockhandle vmBlock、/*ディレクトリブロックのハンドル*/dワードelemNum、/*ロックする要素*/void**elemPtr、/*要素へのポインタがここに書き込まれます*/word*elemSize);</PRE>
<P>このルーチンは、巨大配列内の要素をロックします。 要素のアドレスを<CODE>*elemPtr</CODE>返されるdワードは、そのブロック内の要素の前後にある要素の数を示します。上のワードは、ロックされた要素の前にある要素の数を示し、ロックされた要素をカウントします。下のワードは、ロックされた要素の後にある要素の数を示し、ロックされた要素をカウントします。 エラーが発生した場合、戻り値の下位ワードはゼロになります。</P>
<P>このルーチンは、ロックされた要素のサイズ(バイト単位)も<CODE>*要素サイズ</CODE>ブロック内の他のすべての要素を確認または変更することができます。<CODE>HugeArrayLock()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">heap.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HAL_COUNT() macro">関数HAL_COUNT()</A></CODE><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HAL_PREV() macro">関数HAL_PREV()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_57.htm_IX_HugeArrayNext()"></A>
        <H1 CLASS="refHeading">HugeArrayNext()</H1>
<PRE CLASS="syntax">word HugeArrayNext(void**elemPtr, word*size);</PRE>
<P>このルーチンは、HugeArray内のエレメントへのポインタをインクリメントして、次のエレメントをポイントします。 要素がブロック内の最後の要素である場合<CODE>HugeArrayNext()</CODE>そのブロックのロックを解除し、次のブロックをロックします。 ルーチンはポインタを<EM>*elemPtr</EM>;ブロック内で新しくロックされた要素の後に来る要素の数を返し、新しくロックされた要素をカウントします。 このルーチンにHugeArrayの最後の要素へのポインタが渡されると、0が返され<EM>elemPtr</EM>は最後の要素を指します。</P>
<P>要素のサイズが可変の場合<EM>寸法</EM>は、新しくロックされた要素のサイズを反映するように更新されます。それ以外の場合、値は未定義になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">heap.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、渡された要素を含むブロックのロックを解除します。 したがって、ブロックをダーティとしてマークする必要がある場合は、この呼び出しを行う前にマークしてください。</P>
</DIV>
<HR>
          <A NAME="R_58.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_58.htm_IX_HugeArrayPrev()"></A>
        <H1 CLASS="refHeading">HugeArrayPrev()</H1>
<PRE CLASS="syntax">word HugeArrayPrev(void**elemPtr1, /*は現在の要素を示す*/void**elemPtr2, word*size);</PRE>
<P>このルーチンは、HugeArray内のエレメントへのポインタをデクリメントして、前のエレメントをポイントします。 要素がブロック内の最初の要素である場合<CODE>HugeArrayPrev()</CODE>はそのブロックのロックを解除し、前のブロックをロックします。 ルーチンはポインタを<EM>*elemPtr1</EM>のブロックの最初の要素へのポインタを書き込む。<CODE>*elemPtr2</CODE>新しくロックされた要素をカウントして、ブロック内で新しくロックされた要素の前にある要素の数を返します。 このルーチンにHugeArrayの最初の要素へのポインタが渡されると、0が返され<EM>*elemPtr1</EM>は最初の要素を指します。</P>
<P>要素のサイズが可変の場合<EM>寸法</EM>は、新しくロックされた要素のサイズを反映するように更新されます。それ以外の場合、値は未定義になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、渡された要素を含むブロックのロックを解除します。 したがって、ブロックをダーティとしてマークする必要がある場合は、この呼び出しを行う前にマークしてください。</P>
</DIV>
<DIV>
          <A NAME="R_58.htm_IX_HugeArrayReplace()"></A>
        <H1 CLASS="refHeading">HugeArrayReplace()</H1>
<PRE CLASS="syntax">void HugeArrayReplace(VMFileHandleファイル、VMBlockHandle vmblock、/*ディレクトリブロックのハンドル*/word numElem、/*置換する要素の数*/dword elemNum、/*置換する最初の要素*/const void*initData);/*これを各要素にコピーします</PRE>
<P>このルーチンは、1つ以上の要素を、渡されたデータのコピーで置き換えます。 次の場合<EM>initData(英語の可能性あり)</EM>がNULLの場合、要素はNULLバイトで埋められる。</P>
<P>エレメントのサイズが可変の場合、1つのエレメントのサイズが変更されます。新しいサイズは次のようになります。<CODE>numElem</CODE>バイトの長さ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_58.htm#IX_HugeArrayResize()">HugeArrayResize()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_58.htm_IX_HugeArrayResize()"></A>
        <H1 CLASS="refHeading">HugeArrayResize()</H1>
<PRE CLASS="syntax">void HugeArrayResize(VMFileHandle vmFile、VMBlockHandle vmBlock、/*ディレクトリブロックのハンドル*/dword elemNum、/*この要素のサイズを変更*/word newSize);/*新しいサイズ(バイト)*/</PRE>
<P>このルーチンは、巨大配列内の要素のサイズを変更します。 配列には、可変サイズの要素が含まれている必要があります。 新しいサイズが古いサイズより大きい場合、余分なスペースは0で初期化されます。 これよりも小さい場合、要素は切り捨てられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_58.htm_IX_HugeArrayUnlock()"></A>
        <H1 CLASS="refHeading">HugeArrayUnlock()</H1>
<PRE CLASS="syntax">void HugeArrayUnlock(void*elemPtr)</PRE>
<P>このルーチンは、渡されたエレメントを含むHugeArrayのブロックのロックを解除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">hugearr.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>ブロック内の要素のいずれかを変更した場合は<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HugeArrayDirty()">HugeArrayDirty()</A></CODE><EM>前に</EM>ブロックのロックを解除します。ロックを解除しないと、ブロックが破棄される可能性があります。</P>
</DIV>
<DIV>
          <A NAME="R_58.htm_IX_IACPConnect()"></A>
        <H1 CLASS="refHeading">IACPConnect()</H1>
<PRE CLASS="syntax">IACPConnection IACPConnect(GeodeToken*リスト、IACPConnectFlags旗、MemHandle appLaunchBlock、optrクライアント、word*numServers);</PRE>
<P>このルーチンは、クライアント・オブジェクト(デフォルトでは呼び出しスレッドのアプリケーション・オブジェクト)と、指定されたリストに登録されている1つ以上のサーバーとの間に接続を確立します。</P>
<P>の<EM>顧客</EM>引数は次のようにする必要<CODE>NullOptr</CODE>ただし、flagsパラメータにIACPCF_CLIENT_OD_SPECIFIEDフラグが設定されている場合は除きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">イアーク・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_58.htm_IX_IACPCreateDefaultLaunchBlock()"></A>
        <H1 CLASS="refHeading">IACPCreateDefaultLaunchBlock()</H1>
<PRE CLASS="syntax">MemHandle IACPCreateDefaultLaunchBlock(ワードappMode)</PRE>
<P>このルーチンは<CODE>AppLaunchBlock</CODE>通過に適した構造<CODE><A HREF="../../CRef/Routines/R_58.htm#IX_IACPConnect()">IACPConnect()</A></CODE>渡される2つの有効な値<EM>appMode</EM>である<CODE>MSG_GEN_PROCESS_OPEN_APPLICATION(プロセスを開くアプリケーション)</CODE>および<CODE>MSG_GEN_PROCESS_OPEN_ENGINEメッセージ</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">イアーク・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_58.htm_IX_IACPFinishConnect()"></A>
        <H1 CLASS="refHeading">IACPFinishConnect()</H1>
<PRE CLASS="syntax">void IACPFinishConnect(IACPConnection接続、optrサーバー)</PRE>
<P>非interactibleからinteractibleに変更する必要があったサーバーへの接続を終了します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">イアーク・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_58.htm_IX_IACPGetServerNumber()"></A>
        <H1 CLASS="refHeading">IACPGetServerNumber()</H1>
<PRE CLASS="syntax">word IACPGetServerNumber(IACPConnection接続、optrサーバ)</PRE>
<P>このルーチンは、特定の接続にある特定のサーバーのサーバー番号を取得します。 サーバー番号を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">イアーク・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_58.htm_IX_IACPLostConnection()"></A>
        <H1 CLASS="refHeading">IACPLostConnection()</H1>
<PRE CLASS="syntax">void IACPLostConnection(optr oself、IACPConnection接続)</PRE>
<P>このルーチンは、クライアントが接続を閉じるときに処理するために、IACPサーバー・オブジェクトによって呼び出されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">イアーク・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_59.htm"></A>
        <P><!-- $Id: R_59.htm,v 1.5 97/07/28 14:17:38 lawrence Exp $ --><!-- <META NAME="description" CONTENT=""> --><!-- <META NAME="keywords" CONTENT=""> --><A HREF="#index.htm"><IMG SRC="../../docImages/up.gif" ALT="上へ" BORDER="0"></A><!-- down to first child --><!-- to previous --><A HREF="#R_58.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="前へ:">HugeArrayPrev() ……………………</A><!-- to next --><A HREF="#R_5a.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="次へ:">ImpexExportToMetafile() ……………………</A><HR>
<P><H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPProcessMessage()">IACPProcessMessage()</A>
        </H1>
<PRE>void IACPProcessMessage(optr oself、EventHandle msgToSend、TravelOption topt、EventHandle completionMsg);</PRE>
<P>これは、IACP接続によってオブジェクトに渡されるカプセル化されたメッセージをディスパッチするためのユーティリティー・ルーチンです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPRegisterDocument()">IACPRegisterDocument()</A>
        </H1>
<PRE>void IACPRegisterDocument(optr server, word disk, dword fileID);</PRE>
<P>このルーチンは、開いているドキュメントとそのサーバーオブジェクトを登録します。</P>
<P>このルーチンは、クライアントではなくサーバーによってのみ使用され、文書の作成者によってのみ使用されます。 IACPを使用して、問題の文書の作成者ではないサーバーに接続するための規定はありません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPRegisterServer()">IACPRegisterServer()</A>
        </H1>
<PRE>void IACPRegisterServer(GeodeToken*リスト、optrサーバー、IACPServerModeモード、IACPServerFlagsフラグ)</PRE>
<P>このルーチンは、渡されたトークンで指定されたIACPサーバー・リストのサーバーとしてオブジェクトを登録します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>

 <H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPSendMessage()">IACPSendMessage()</A>
        </H1>
<PRE class="syntax">ワード・IACPSendMessage(IACPConnection・コネクション、EventHandle・msgToSend、TravelOption・トップ、EventHandle completionMsg、IACPSide側);</PRE>
<P>このルーチンは、メッセージ・イベントをIACP経由でIACP接続の反対側にあるすべてのオブジェクトに送信します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>


<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPSendMessageAndWait()">IACPSendMessageAndWait()</A>
        </H1>
<PRE>ワードIACPSendMessageAndWait(IACPConnectionコネクション、EventHandle msgToSend、TravelOptionトポト、IACPSideサイド);</PRE>
<P>このルーチンは、IACP接続の反対側にあるすべてのオブジェクトに録音されたメッセージを送信し、もう一方のアプリケーションがIACP経由でメッセージを受信したと応答するまで待機します。 これは、メッセージが他のアプリケーションによって処理されたことを意味するのではなく、他のアプリケーションが<CODE>EventHandle</CODE>それに対処しようとします これは、揮発性データを渡す場合に便利です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPSendMessageToServer()">IACPSendMessageToServer()</A>
        </H1>
<PRE>word IACPSendMessageToServer(IACPConnectionコネクション、EventHandle msgToSend、TravelOption topt、EventHandle completionMsg、word serverNum);</PRE>
<P>このルーチンは、IACP接続の反対側にある特定のサーバーにメッセージを送信します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPShutdown()">IACPShutdown()</A>
        </H1>
<PRE>ボイドIACPShutdown(IACPConnection接続、optr serverOD)</PRE>
<P>このルーチンは、IACP接続からサーバーまたはクライアントを削除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPShutdownAll()">IACPShutdownAll()</A>
        </H1>
<PRE>空のIACPShutdownAll(optr obj)</PRE>
<P>これは<A HREF="../../CRef/Routines/R_59.htm#IX_IACPShutdown()">IACPShutdown()</A>渡されたオブジェクトがパーティであるすべての接続に対して。 これは主に<CODE>GenApplicationClass</CODE>アプリケーションが終了するとき。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPUnregisterDocument()">IACPUnregisterDocument()</A>
        </H1>
<PRE>void IACPUnregisterDocument(optr server, word disk, dword fileID);</PRE>
<P>このルーチンは、開いているドキュメントとそのサーバーオブジェクトの登録を解除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_IACPUnregisterServer()">IACPUnregisterServer()</A>
        </H1>
<PRE>void IACPUnregisterServer(GeodeToken*トークン,optrオブジェクト);</PRE>
<P>これにより、指定されたサーバー・オブジェクトが、示されたIACPサーバー・リストから除去されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>イアーク・ゴー</STRONG>
        </P></DIV><DIV>
<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_ImpexCreateTempFile()">ImpexCreateTempFile()</A>
        </H1>
<PRE>TransError ImpexCreateTempFile(char*buffer, word fileType, FileHandle*file, MemHandle*errorString);</PRE>
<P>このルーチンは、ファイルのインポートとエクスポートのために変換ライブラリで使用される一意の一時ファイルを作成して開きます。 このルーチンは、翻訳ライブラリからのみ呼び出されます。</P>
<P>このルーチンには、次の引数が渡されます。</P>
<DL>
<DT>
          <CODE>緩衝剤</CODE>
        <DD>ファイル名は、この引数が指すバッファに書き込まれます。 バッファの長さは、少なくともFILE_LONGNAME_BUFFER_SIZEバイトである必要があります。<DT>
          <CODE>ファイルの種類</CODE>
        <DD>これは、作成する一時ファイルの種類を指定します。 IMPEX_TEMP_VM_FILEが渡されると、GEOS VMファイルが作成されます。 IMPEX_TEMP_NATIVE_FILEが渡された場合、ネイティブ形式の一時ファイルが作成されます。<DT>
          <CODE>やすり</CODE>
        <DD>これは、FileHandle変数へのポインタです。 一時ファイルのハンドルは<CODE>*ファイル</CODE>ボタンをクリックし<DT>
          <CODE>エラー文字列</CODE>
        <DD>次の場合<CODE>ImpexCreateTempFile</CODE>がエラー条件TE_CUSTOMで失敗すると、エラー文字列を含むブロックが割り当てられる。 ブロックのハンドルを<CODE>*エラー文字列</CODE>このブロックの処理が完了したら、それを解放するのは呼び出し側の責任です。</DL>
<P>次の場合<CODE>ImpexCreateTempFile</CODE>が成功した場合、TE_NO_ERROR(0に等しい)を返す。 失敗した場合は<CODE>TransferErrors</CODE>列挙型(通常はTE_METAFILE_CREATION_ERROR)。 一時ファイルの処理が完了したら<A HREF="../../CRef/Routines/R_24.htm#IX_FileClose()">FileClose()[ファイルを閉じる]</A>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>インペックスゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>このファイルを閉じると、いつでも削除される可能性があります。 通常は次のようにして閉じます。<A HREF="../../CRef/Routines/R_59.htm#IX_ImpexDeleteTempFile()">ImpexDeleteTempFile()</A>これにより、ファイルがただちに削除されます。</P>
<P>ルーチンが条件TE_CUSTOMで失敗しない場合<CODE>*エラー文字列</CODE>には、ランダム値を含めることができます。 使用しない<CODE>*エラー文字列</CODE>ルーチンがTE_CUSTOMを返さなかった場合。</P></DIV><DIV> 
<H1 CLASS="refHeading">
          <A NAME="R_59.htm_IX_ImpexDeleteTempFile()">ImpexDeleteTempFile()</A>
        </H1>
<PRE>TransError ImpexDeleteTempFile(const char*buffer, FileHandle tempFile, word fileType);</PRE>
<P>このルーチンは、によって作成された一時ファイルを閉じてから削除します。<A HREF="../../CRef/Routines/R_59.htm#IX_ImpexCreateTempFile()">ImpexCreateTempFile()</A>次の引数が渡されます。</P>
<DL>
<DT>
          <CODE>緩衝剤</CODE>
        <DD>一時ファイルの名前を含む文字バッファへのポインタです。 で埋められたバッファのアドレスを渡すだけでよい。<A HREF="../../CRef/Routines/R_59.htm#IX_ImpexCreateTempFile()">ImpexCreateTempFile()</A>ボタンをクリックし<DT>
          <CODE>tempFile(英語の可能性あり</CODE>
        <DD>これは一時ファイルのハンドルです。<DT>
          <CODE>ファイルの種類</CODE>
        <DD>削除するファイルの種類を指定します。 一時ファイルがGEOS VMファイルの場合、これはIMPEX_TEMP_VM_FILEになります。 ネイティブ形式のファイルの場合は、IMPEX_TEMP_NATIVE_FILEになります。<DT>
          <CODE>エラー文字列</CODE>
        <DD>次の場合<CODE>ImpexDeleteTempFile</CODE>がエラー条件TE_CUSTOMで失敗すると、エラー文字列を含むブロックが割り当てられる。 ブロックのハンドルを<CODE>*エラー文字列</CODE>このブロックの処理が完了したら、それを解放するのは呼び出し側の責任です。</DL>
<P><CODE>ImpexDeleteTempFile()</CODE>指定されたファイルを閉じてから削除します。 成功した場合はTE_NO_ERROR(つまり0)を返し、それ以外の場合は<CODE>TransError</CODE>列挙型。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG>インペックスゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>ルーチンが条件TE_CUSTOMで失敗しない場合<CODE>*エラー文字列</CODE>には、ランダム値を含めることができます。 使用しない<CODE>*エラー文字列</CODE>ルーチンがTE_CUSTOMを返さなかった場合。</P></DIV>
<HR>
<P><P>
          <A NAME="R_5a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_5a.htm_IX_ImpexExportToMetafile()"></A>
        <H1 CLASS="refHeading">ImpexExportToMetafile()</H1>
<PRE CLASS="syntax">TransError ImpexExportToMetafile(Handle xlatLib, VMFileHandle xferFile, FileHandleメタファイル,dword xferFormat, word arg1, word arg2, MemHandle*errString);</PRE>
<P>このルーチンは、翻訳ライブラリで使用されます。 このルーチンは、中間変換ライブラリを呼び出して、指定されたファイルのGEOSメタファイル形式への変換を完了します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">インペックスゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>ルーチンが条件TE_CUSTOMで失敗しない場合<CODE>*エラー文字列</CODE>には、ランダム値を含めることができます。 使用しない<CODE>*エラー文字列</CODE>ルーチンがTE_CUSTOMを返さなかった場合。</P>
</DIV>
<DIV>
          <A NAME="R_5a.htm_IX_ImpexImportExportCompleted()"></A>
        <H1 CLASS="refHeading">ImpexImportExportCompleted()</H1>
<PRE CLASS="syntax">void ImpexImportExportCompleted(ImpexTranslationParams*itParams)</PRE>
<P>アプリケーションは、データのインポートまたはエクスポートが完了したときに、このメッセージを送信する必要があります。 このルーチンは、ImportControlオブジェクトまたはExportControlオブジェクトの設定に応じて、適切な確認メッセージを送信します。<CODE>ITP_impexOD</CODE>およびITP<CODE>_returnMsg</CODE>ボタンをクリックし</P>
<P>アプリケーションがインポートを完了したばかりの場合は<CODE>ImpexTranslationParams</CODE>構造。 エクスポート用のデータの準備が完了したばかりの場合は、ITP<CODE>_transferVMChain</CODE>フィールドには、VMチェーンの先頭のハンドルが入ります。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは基本的に、ImportControlオブジェクトまたはExportControlオブジェクトに対して、アプリケーションによる転送ファイルの処理が完了したことを通知します。 ImportControlは転送ファイルを破棄することで応答し、ExportControlは適切な変換ライブラリを呼び出して出力ファイルを生成します。 したがって、アプリケーションは転送ファイルの処理が完全に終了するまで、このルーチンを呼び出すべきではありません。</P>
</DIV>
<DIV>
          <A NAME="R_5a.htm_IX_ImpexImportFromMetafile()"></A>
        <H1 CLASS="refHeading">ImpexImportFromMetafile()</H1>
<PRE CLASS="syntax">TransError ImpexExportToMetafile(Handle xlatLib, VMFileHandle xferFile, FileHandleメタファイル,dword*xferFormat, word arg1, word arg2, MemHandle*errString);</PRE>
<P>このルーチンは、翻訳ライブラリで使用されます。 このルーチンは、中間変換ライブラリを呼び出して、指定されたファイルをGEOSメタファイル形式から中間形式に変換します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">インペックスゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>ルーチンが条件TE_CUSTOMで失敗しない場合<CODE>*エラー文字列</CODE>には、ランダム値を含めることができます。 使用しない<CODE>*エラー文字列</CODE>ルーチンがTE_CUSTOMを返さなかった場合。</P>
</DIV>
<DIV>
          <A NAME="R_5a.htm_IX_InitFileCommit()"></A>
        <H1 CLASS="refHeading">InitFileCommit()</H1>
<PRE CLASS="syntax">void InitFileCommit(void)</PRE>
<P>このルーチンは、GEOS.INIファイルに対するすべての変更をコミットし、保存されているバックアップを削除して置き換えます。 これにより、コミット操作中に他のスレッドがファイルで作業していないことが保証されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5a.htm_IX_InitFileDeleteCategory()"></A>
        <H1 CLASS="refHeading">InitFileDeleteCategory()</H1>
<PRE CLASS="syntax">void InitFileDeleteCategory(const char*category);</PRE>
<P>このルーチンは、指定されたカテゴリとそのすべてのエントリをGEOS.INIファイルから削除します。 次のように渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>削除するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5a.htm_IX_InitFileDeleteEntry()"></A>
        <H1 CLASS="refHeading">InitFileDeleteEntry()</H1>
<PRE CLASS="syntax">void InitFileDeleteEntry(const char*category, const char*key);</PRE>
<P>このルーチンは、GEOS.INIファイル内のエントリを削除します。 次のように渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>削除するキーを表すNULL終端文字列へのポインタ。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5a.htm_IX_InitFileDeleteStringSection()"></A>
        <H1 CLASS="refHeading">InitFileDeleteStringSection()</H1>
<PRE CLASS="syntax">void InitFileDeleteStringSection(const char*category, const char*key, word stringNum);</PRE>
<P>このルーチンは、GEOS.INIファイル内の指定されたブロブから、指定された文字列セクションを削除します。 次のように渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>編集するキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>stringNum</CODE>
        </DT><DD>ゼロから始まる文字列のセクション番号。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_5b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_5b.htm_IX_InitFileEnumStringSection()"></A>
        <H1 CLASS="refHeading">InitFileEnumStringSection()</H1>
<PRE CLASS="syntax">Boolean InitFileEnumStringSection(const char*category, const char*key, InitFileReadFlagsフラグ,Boolean_pascal(*callback)(const char*stringSection, word sectionNum, void*enumData),void*enumData);</PRE>
<P>このルーチンは、特定のブロブを列挙し、コールバックルーチンがその中の各文字列セクションを処理できるようにします。 ルーチンは、最後の文字列セクションの後、またはコールバックルーチンが戻ったときに処理を停止します。<CODE>真</CODE>ボタンをクリックし</P>
<P>このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>列挙されるキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>InitFileReadFlags</CODE>読み込み時の文字変換の方法(すべて大文字、すべて小文字、変更しない)を示します。</DD>
<DT>
          <CODE>コールバック</CODE>
        </DT><DD>Booleanコールバックルーチンへのポインタ。 コールバックルーチンについては、以下で説明します。</DD>
<DT>
          <EM>enumData</EM>
        </DT><DD>このポインタは、変更されずにコールバックルーチンに渡されます。<CODE>InitFileEnumStringSection()</CODE>では使用されません。</DD>
</DL>
<P>このルーチンはブール値を返します。 戻ります<CODE>真</CODE>コールバックルーチンが次の値を返して列挙を停止した場合<EM>真</EM>;それ以外の場合は<EM>偽の</EM>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>コールバックルーチン:</STRONG>
          </STRONG>
        </P>
<P>コールバックルーチンは、受け取った文字列セクションに対して、必要な処理を実行できます。 _pascalと宣言する必要があります。 ブール値を返す必要があります。 戻る場合<CODE>真</CODE><CODE>InitFileEnumStringSection()</CODE>はブロブの処理を停止します。 戻る場合<CODE>偽の</CODE>の場合、処理は次の文字列セクション(存在する場合)に進みます。 コールバックは、次のパラメータを受け取ります。</P>
<DL>
<DT><CODE>stringSection</DT><DD></CODE>処理するNULL終端文字列セクションへのポインタ。</DD>
<DT>
          <CODE>sectionNum</CODE>
        </DT><DD>現在処理中の文字列セクションのゼロベースの番号。</DD>
<DT>
          <CODE>enumData</CODE>
        </DT><DD>の呼び出し元から渡されたポインタ<CODE>InitFileEnumStringSection()</CODE>ボタンをクリックし</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5b.htm_IX_InitFileGetTimeLastModified()"></A>
        <H1 CLASS="refHeading">InitFileGetTimeLastModified()</H1>
<PRE CLASS="syntax">dワードInitFileGetTimeLastModified(無効)</PRE>
<P>このルーチンは、GEOS.INIファイルが最後に修正された時刻を返します。 返される時間は、ファイルが最後に書き込まれたときのシステムカウンタの値です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_5b.htm_IX_InitFileMakeCanonicKeyCategory()"></A>
        <H1 CLASS="refHeading">InitFileMakeCanonicKeyCategory()</H1>
<PRE CLASS="syntax">void InitFileMakeCanonicKeyCategory(char*keyCat, const TCHAR*src);</PRE>
<P>SBCS/DBCS(GEOSバージョンに依存)文字列を、特殊なINI文字を含まないASCIIX文字列に変換します。 これは、任意のタイプの文字列を、INIファイルキーまたはカテゴリとして使用するのに適したものに変換するために使用されます。</P>

<P CLASS="refField">
          <STRONG>パス:</STRONG>
        </P>
<DL>
<DT>
          <STRONG>keyCat</STRONG>
        </DT><DD>変換されていないSBCS/DBCS文字列</DD>
<DT>
          <STRONG>ソース</STRONG>
        </DT><DD>変換されたSBCS ASCII 16進文字列のバッファ。<EM>keyCat</EM>はSBCS<EM>ソース</EM>と同じ長さにする必要があります<EM>keyCat</EM>(NULLターミネータを含む)。<EM>keyCat</EM>がDBCSの場合<EM>ソース</EM>の2倍の長さのバッファを指す必要があります。<EM>keyCat</EM>(NULLターミネータを含む)。</DD>
</DL>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>

<P CLASS="refField"><STRONG>バージョン:</STRONG>このルーチンは、Nokia 9000i Communicatorのビルド4以降で使用できます(を参照)。<A HREF = "../../Nokia9000/Versions/index.htm">「バージョン」の章</A>」を参照してください)。</P>

</DIV>




<DIV>
          <A NAME="R_5b.htm_IX_InitFileReadBoolean()"></A>
        <H1 CLASS="refHeading">InitFileReadBoolean()</H1>
<PRE CLASS="syntax">Boolean InitFileReadBoolean(const char*category, const char*key, Boolean*bool);</PRE>
<P>このルーチンは、GEOS.INIファイル内のブール値エントリを読み取り、渡されたバッファにコピーします。 最初に検出したカテゴリ/キーの組み合わせの最初のインスタンスを返し、最初にローカルINIファイルを検索します。 したがって、ローカル設定は常にシステムまたはネットワーク設定よりも優先されます。</P>
<P>このルーチンは、書き込みデータの読み込みに使用されます。<CODE><A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteBoolean()">InitFileWriteBoolean()</A></CODE>次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>取得するキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>ブール</CODE>
        </DT><DD>ブール値が返されるブール変数へのポインタ。</DD>
</DL>
<P>この関数の戻り値は次のようになります。<CODE>真</CODE>エラーが発生した場合、またはエントリが見つからなかった場合は、次のようになります。<CODE>偽の</CODE>そうでなければ。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>この関数の戻り値は次のとおりです。<EM>しない</EM>GEOS.INIファイルに格納されているブール値。 この値は<CODE>ブール</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5b.htm_IX_InitFileReadDataBlock()"></A>
        <H1 CLASS="refHeading">InitFileReadDataBlock()</H1>
<PRE CLASS="syntax">Boolean InitFileReadDataBlock(const char*category, const char*key, MemHandle*block, word*dataSize);</PRE>
<P>このルーチンは、GEOS.INIファイル内のエントリを読み取り、新しいブロックを割り当て、その中にデータをコピーします。 このルーチンは、最初に検出したカテゴリ/キーの組み合わせの最初のインスタンスを返し、最初にローカルINIファイルを検索します。 したがって、ローカル設定は常にシステムまたはネットワーク設定よりも優先されます。</P>
<P>このルーチンは、書き込みデータの読み込みに使用されます。<CODE><A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteData()">InitFileWriteData()</A></CODE>次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>取得するキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>ブロック(block)</CODE>
        </DT><DD>NULLメモリー・ハンドルへのポインタ。 このポインタは、戻り時に新しく割り当てられたブロックハンドルを指します。 読み込まれたデータは新しいブロックに格納されます。 このブロックを使い終わったら解放するのがあなたのrespojnsibilityです。</DD>
<DT>
          <CODE>データサイズ</CODE>
        </DT><DD>読み取りデータのサイズ。 すべてのデータが読み込まれます。ブロックは必要な大きさになります。</DD>
</DL>
<P>この関数の戻り値は次のようになります。<CODE>真</CODE>エラーが発生した場合、またはエントリが見つからなかった場合は、次のようになります。<CODE>偽の</CODE>そうでなければ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5b.htm_IX_InitFileReadDataBuffer()"></A>
        <H1 CLASS="refHeading">InitFileReadDataBuffer()</H1>
<PRE CLASS="syntax">Boolean InitFileReadDataBuffer(const char*category, const char*key, void*buffer, word bufSize, word*dataSize);</PRE>
<P>このルーチンは、GEOS.INIファイル内のエントリを読み取り、渡されたバッファにコピーします。 最初に検出したカテゴリ/キーの組み合わせの最初のインスタンスを返し、最初にローカルINIファイルを検索します。 したがって、ローカル設定は常にシステムまたはネットワーク設定よりも優先されます。</P>
<P>このルーチンは、書き込みデータの読み込みに使用されます。<CODE><A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteData()">InitFileWriteData()</A></CODE>次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>取得するキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>データが返されるバッファへのポインタ。 このバッファは、ロックされたメモリまたは固定メモリにある必要があります。</DD>
<DT>
          <CODE>bufSize/ファイルサイズ</CODE>
        </DT><DD>渡されたバッファのサイズ(バイト単位)。 データのサイズがわからない場合は、を使用することをお勧めします(効率は若干低くなります)。<CODE><A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadDataBlock()">InitFileReadDataBlock()</A></CODE>ボタンをクリックし</DD>
<DT>
          <CODE>データサイズ</CODE>
        </DT><DD>単語へのポインタ。返されるとき、ポイントされた単語には、返されたデータのサイズ(バイト単位)が含まれます。</DD>
</DL>
<P>この関数の戻り値は次のようになります。<CODE>真</CODE>エラーが発生した場合、またはエントリが見つからなかった場合は、次のようになります。<CODE>偽の</CODE>そうでなければ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5b.htm_IX_InitFileReadInteger()"></A>
        <H1 CLASS="refHeading">InitFileReadInteger()</H1>
<PRE CLASS="syntax">Boolean InitFileReadInteger(const char*category, const char*key, word*i);</PRE>
<P>このルーチンは、GEOS.INIファイル内の整数エントリを読み取り、渡された変数にコピーします。 最初に検出したカテゴリ/キーの組み合わせの最初のインスタンスを返し、最初にローカルINIファイルを検索します。 したがって、ローカル設定は常にシステムまたはネットワーク設定よりも優先されます。</P>
<P>このルーチンは、書き込みデータの読み込みに使用されます。<CODE><A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteInteger()">InitFileWriteInteger()</A></CODE>次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>取得するキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>アイ</CODE>
        </DT><DD>整数が返される単語へのポインタ。</DD>
</DL>
<P>この関数の戻り値は次のようになります。<CODE>真</CODE>エラーが発生した場合、またはエントリが見つからなかった場合は、次のようになります。<CODE>偽の</CODE>そうでなければ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_5c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_5c.htm_IX_InitFileReadStringBlock()"></A>
        <H1 CLASS="refHeading">InitFileReadStringBlock()</H1>
<PRE CLASS="syntax">Boolean InitFileReadStringBlock(const char*category, const char*key, MemHandle*block, InitFileReadFlags flags, word*dataSize);</PRE>
<P>このルーチンは、GEOS.INIファイルの文字列エントリを読み込み、グローバルヒープに新しいブロックを割り当て、読み込んだ文字列を新しいブロックにコピーします。 最初に検出したカテゴリ/キーの組み合わせの最初のインスタンスを返し、最初にローカルINIファイルを検索します。 したがって、ローカル設定は常にシステムまたはネットワーク設定よりも優先されます。</P>
<P>このルーチンは、書き込みデータの読み込みに使用されます。<CODE><A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteString()">InitFileWriteString()</A></CODE>次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>取得するキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>ブロック(block)</CODE>
        </DT><DD>メモリブロックハンドル変数へのポインタ。 返されると、この変数には新しく割り当てられたブロックのハンドルが含まれ、ブロックにはファイルから読み込まれた文字列が含まれます。 このブロックを使用し終わったら、それを解放するのはあなたの責任です。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>InitFileReadFlags</CODE>読み込み時の文字変換の方法(すべて大文字、すべて小文字、変更しない)を示します。</DD>
<DT>
          <CODE>データサイズ</CODE>
        </DT><DD>返されたときに、ファイルから実際に読み込まれた文字列のサイズ(バイト単位)を格納するワードへのポインタ。</DD>
</DL>
<P>この関数の戻り値は次のようになります。<CODE>真</CODE>エラーが発生した場合、またはエントリが見つからなかった場合は、次のようになります。<CODE>偽の</CODE>そうでなければ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5c.htm_IX_InitFileReadStringBuffer()"></A>
        <H1 CLASS="refHeading">InitFileReadStringBuffer()</H1>
<PRE CLASS="syntax">Boolean InitFileReadStringBuffer(const char*category, const char*key, char*buffer, InitFileReadFlagsフラグ,word*dataSize);</PRE>
<P>このルーチンは、GEOS.INIファイル内の文字列エントリを読み取り、渡されたロックされたバッファにコピーします。 最初に検出したカテゴリ/キーの組み合わせの最初のインスタンスを返し、最初にローカルINIファイルを検索します。 したがって、ローカル設定は常にシステムまたはネットワーク設定よりも優先されます。</P>
<P>このルーチンは、書き込みデータの読み込みに使用されます。<CODE><A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteString()">InitFileWriteString()</A></CODE>次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>取得するキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>返された文字列が書き込まれるバッファへのポインタ。 このバッファは、ロックされたメモリまたは固定メモリにある必要があります。 データのおおよそのサイズがわからない場合は、を使用することができます(効率はやや低下します)。<CODE><A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringBlock()">InitFileReadStringBlock()</A></CODE>ボタンをクリックし</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>InitFileReadFlags</CODE>渡されたバッファのサイズと読み込み時の文字変換方法(すべて大文字、すべて小文字、変更しない)を示します。</DD>
<DT>
          <CODE>データサイズ</CODE>
        </DT><DD>返されたときに、ファイルから実際に読み込まれた文字列のサイズ(バイト単位)を格納するワードへのポインタ。</DD>
</DL>
<P>この関数の戻り値は次のようになります。<CODE>真</CODE>エラーが発生した場合、またはエントリが見つからなかった場合は、次のようになります。<CODE>偽の</CODE>そうでなければ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5c.htm_IX_InitFileReadStringSectionBlock()"></A>
        <H1 CLASS="refHeading">InitFileReadStringSectionBlock()</H1>
<PRE CLASS="syntax">Boolean InitFileReadStringSectionBlock(const char*category, const char*key, word section, MemHandle*block, InitFileReadFlags flags, word*dataSize);</PRE>
<P>このルーチンは、GEOS.INIファイル内の指定されたエントリから文字列セクションを読み取り、グローバルヒープに新しいブロックを割り当て、読み取った文字列セクションを新しいブロックにコピーします。 最初に検出したカテゴリ/キーの組み合わせの最初のインスタンスを返し、最初にローカルINIファイルを検索します。 したがって、ローカル設定は常にシステムまたはネットワーク設定よりも優先されます。</P>
<P>このルーチンは、書き込みデータの読み込みに使用されます。<CODE><A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteString()">InitFileWriteString()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteStringSection()">InitFileWriteStringSection()</A></CODE>次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>取得するキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>断面</CODE>
        </DT><DD>取得する文字列セクションの0から始まる番号。</DD>
<DT>
          <CODE>ブロック(block)</CODE>
        </DT><DD>メモリブロックハンドルへのポインタ。 返されると、このポインタは新しく割り当てられたブロックのハンドルを指します。ブロックには、ファイルから読み込まれた文字列セクションが含まれます。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>InitFileReadFlags</CODE>読み込み時の文字変換の方法(すべて大文字、すべて小文字、変更しない)を示します。</DD>
<DT>
          <CODE>データサイズ</CODE>
        </DT><DD>返されたときに、ファイルから実際に読み込まれた文字列セクションのサイズ(バイト単位)を格納するワードへのポインタ。</DD>
</DL>
<P>この関数の戻り値は次のようになります。<CODE>真</CODE>エラーが発生した場合、またはエントリが見つからなかった場合は、次のようになります。<CODE>偽の</CODE>そうでなければ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5c.htm_IX_InitFileReadStringSectionBuffer()"></A>
        <H1 CLASS="refHeading">InitFileReadStringSectionBuffer()</H1>
<PRE CLASS="syntax">Boolean InitFileReadStringSectionBuffer(const char*category, const char*key, word section, char*buffer, InitFileReadFlags flags, word*dataSize);</PRE>
<P>このルーチンは、GEOS.INIファイル内の指定されたエントリから文字列セクションを読み取り、渡されたロックされたバッファにコピーします。 最初に検出したカテゴリ/キーの組み合わせの最初のインスタンスで指定されたセクションを返し、最初にローカルINIファイルを検索します。 したがって、ローカル設定は常にシステムまたはネットワーク設定よりも優先されます。</P>
<P>このルーチンは、書き込みデータの読み込みに使用されます。<CODE><A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteStringSection()">InitFileWriteStringSection()</A></CODE>次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>エントリが存在するカテゴリを表すNULL終端文字列へのポインタ。 この文字列は空白を無視し、大文字と小文字を区別しません。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>取得するキーを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>断面</CODE>
        </DT><DD>取得する文字列セクションの0から始まる番号。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>返された文字列セクションが書き込まれるバッファへのポインタ。 このバッファは、ロックされたメモリまたは固定メモリにある必要があります。 文字列セクションのおおよそのサイズがわからない場合は、を使用することをお勧めします(少し非効率的です)。<CODE><A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringSectionBlock()">InitFileReadStringSectionBlock()</A></CODE>ボタンをクリックし</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>InitFileReadFlags</CODE>渡されたバッファのサイズと読み込み時の文字変換方法(すべて大文字、すべて小文字、変更しない)を示します。</DD>
<DT>
          <CODE>データサイズ</CODE>
        </DT><DD>返されたときに、ファイルから実際に読み込まれた文字列セクションのサイズ(バイト単位)を格納するワードへのポインタ。</DD>
</DL>
<P>この関数の戻り値は次のようになります。<CODE>真</CODE>エラーが発生した場合、またはエントリが見つからなかった場合は、次のようになります。<CODE>偽の</CODE>そうでなければ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_5d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_5d.htm_IX_InitFileRevert()"></A>
        <H1 CLASS="refHeading">InitFileRevert()</H1>
<PRE CLASS="syntax">ブール値InitFileRevert(void);</PRE>
<P>このルーチンは、保存されているバックアップバージョンからGEOS.INIファイルを復元します。 これにより、ファイルのリストア中に他のスレッドがファイルを操作していないことが保証されます。 この関数はエラーフラグを返します。<CODE>真</CODE>ファイルの復元中にエラーが発生したことを示します。<CODE>偽の</CODE>成功を示します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5d.htm_IX_InitFileSave()"></A>
        <H1 CLASS="refHeading">InitFileSave()</H1>
<PRE CLASS="syntax">ブール値InitFileSave(void);</PRE>
<P>このルーチンは、バックアップファイルを現在のバージョンに更新することによって、GEOS.INIファイルを同期的に保存します(<CODE><A HREF="../../CRef/Routines/R_5a.htm#IX_InitFileCommit()">InitFileCommit()</A></CODE>は、実際にはGEOS.INIファイル自体を上書きします)。 これにより、ファイルが書き出されている間、他のスレッドがファイルを操作していないことが保証されます。 この関数はエラーフラグを返します。<CODE>真</CODE>は、ファイルの保存中にエラーが発生したことを示します。<CODE>偽の</CODE>成功を示します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5d.htm_IX_InitFileWriteBoolean()"></A>
        <H1 CLASS="refHeading">InitFileWriteBoolean()</H1>
<PRE CLASS="syntax">void InitFileWriteBoolean(const char*category, const char*key, Boolean bool);</PRE>
<P>この整数は、ローカルGEOS.INIファイルの指定されたカテゴリとキーにブール値を書き込みます。 ユーザがテキストエディタでGEOS.INIを参照すると、ブール値は「true」または「false」として表示されますが、GEOSにとっては実際のブール値になります。 このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>データが書き込まれるINIカテゴリを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>内部のINIキーを表すNULL終端文字列へのポインタ<CODE>種類</CODE>データの書き込み先です。</DD>
<DT>
          <CODE>ブール</CODE>
        </DT><DD>書き込まれるブール値。</DD>
</DL>
<P>書き込まれたブール値は<CODE><A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadBoolean()">InitFileReadBoolean()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5d.htm_IX_InitFileWriteData()"></A>
        <H1 CLASS="refHeading">InitFileWriteData()</H1>
<PRE CLASS="syntax">void InitFileWriteData(const char*category, const char*key, const void*buffer, word bufSize);</PRE>
<P>このルーチンは、指定されたデータをローカルGEOS.INIファイルに書き込みます。 次のように渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>データが書き込まれるINIカテゴリを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>内部のINIキーを表すNULL終端文字列へのポインタ<CODE>種類</CODE>データの書き込み先です。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>書き込まれるデータを含む、ロックされたバッファまたは固定バッファへのポインタ。</DD>
<DT>
          <CODE>bufSize/ファイルサイズ</CODE>
        </DT><DD>バッファのサイズ(バイト単位)。</DD>
</DL>
<P>データがINIファイルに書き込まれると、次のコマンドで読み取ることができます。<CODE><A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadDataBlock()">InitFileReadDataBlock()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadDataBuffer()">InitFileReadDataBuffer()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5d.htm_IX_InitFileWriteInteger()"></A>
        <H1 CLASS="refHeading">InitFileWriteInteger()</H1>
<PRE CLASS="syntax">void InitFileWriteInteger(const char*category, const char*key, word value);</PRE>
<P>このルーチンは、ローカルGEOS.INIファイルに指定されたカテゴリとキーに整数を書き込みます。 次のものを渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>データが書き込まれるINIカテゴリを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>内部のINIキーを表すNULL終端文字列へのポインタ<CODE>種類</CODE>データの書き込み先です。</DD>
<DT>
          <CODE>値(value)</CODE>
        </DT><DD>書き込む整数。</DD>
</DL>
<P>一度書き込まれた整数は<CODE><A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadInteger()">InitFileReadInteger()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5d.htm_IX_InitFileWriteString()"></A>
        <H1 CLASS="refHeading">InitFileWriteString()</H1>
<PRE CLASS="syntax">void InitFileWriteString(const char*category, const char*key, const char*str);</PRE>
<P>このルーチンは、ローカルGEOS.INIファイルに指定されたカテゴリとキーに文字列全体を書き込みます。 次のように渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>データが書き込まれるINIカテゴリを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>内部のINIキーを表すNULL終端文字列へのポインタ<CODE>種類</CODE>データの書き込み先です。</DD>
<DT>
          <CODE>文字列</CODE>
        </DT><DD>書き込まれるNULL終端文字列へのポインタ。 文字列に改行またはキャリッジリターンが含まれている場合、文字列は自動的に文字列セグメントに解析され、中カッコで囲まれます。中カッコが含まれている場合、すべての閉じカッコの前に自動的にバックスラッシュが挿入されます。</DD>
</DL>
<P>このルーチンで作成された文字列を読み取るには<CODE><A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringBlock()">InitFileReadStringBlock()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringBuffer()">InitFileReadStringBuffer()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5d.htm_IX_InitFileWriteStringSection()"></A>
        <H1 CLASS="refHeading">InitFileWriteStringSection()</H1>
<PRE CLASS="syntax">void InitFileWriteStringSection(const char*category, const char*key, const char*string);</PRE>
<P>このルーチンは、文字列セクションを<CODE>種類</CODE>および<CODE>カギ</CODE>パラメータを指定します。 文字列セクションはブロブの一部となり、その最後のセクションになります。 セクションには、キャリッジリターンや改行を含めることはできません。 このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>データが書き込まれるINIカテゴリを表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>カギ</CODE>
        </DT><DD>内部のINIキーを表すNULL終端文字列へのポインタ<CODE>種類</CODE>データの書き込み先です。</DD>
<DT>
          <CODE>ストリング</CODE>
        </DT><DD>書き込む文字列セクションへのポインタ。</DD>
</DL>
<P>書き込まれたセグメントは<CODE><A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringSectionBlock()">InitFileReadStringSectionBlock()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringSectionBuffer()">InitFileReadStringSectionBuffer()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">initfile.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_5e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkDBGetDisplayInfo()"></A>
          <A NAME="R_5e.htm_IX_InkDBDisplayInfo"></A>
          <A NAME="R_5e.htm_IX_IDBDI_&ldots;"></A>
        <H1 CLASS="refHeading">InkDBGetDisplayInfo()</H1>
<PRE CLASS="syntax">void InkDBGetDisplayInfo(InkDBDisplayInfo*retVal, VMFileHandle fh)</PRE>
<P>このルーチンは、インクデータベースによって現在表示されているノートまたはフォルダのdword IDを返します。また、親フォルダのIDと、該当する場合はページ番号も返します。</P>
<P CLASS="refField"><STRONG>構造:</STRONG>この情報を返すには<CODE>InkDBDisplayInfo</CODE>構造:</P>
<PRE>typedef struct{dword IDBDI_currentDisplay;dword IDBDI_parentFolder;word IDBDI_pageNumber;}InkDBDisplayInfo;</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkDBGetHeadFolder()"></A>
        <H1 CLASS="refHeading">InkDBGetHeadFolder()</H1>
<PRE CLASS="syntax">dワードInkDBGetHeadFolder(VMFileHandle fh)</PRE>
<P>このルーチンは、インクデータベースファイルのheadフォルダのdword IDを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkDBInit()"></A>
        <H1 CLASS="refHeading">InkDBInit()</H1>
<PRE CLASS="syntax">空隙InkDBInit(VMFileHandle fh)</PRE>
<P>このルーチンは、新しいインクデータベースファイルを取得します。 ファイルを使用できるように初期化し、必要なすべてのマップと最上位のフォルダを作成します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkDBSetDisplayInfo()"></A>
        <H1 CLASS="refHeading">InkDBSetDisplayInfo()</H1>
<PRE CLASS="syntax">void note(VMFileHandle fh, dword ofh, /*親フォルダdword InkDBSetDisplayInfo#*/dword note, /*表示するノートまたはフォルダのID番号*/word page);/*ノートを表示する場合は、表示するページ番号*/</PRE>
<P>このルーチンは、インクデータベースファイルの表示情報を設定します。 このルーチンは、データベース内のユーザーの場所を設定します。 呼び出し側は、表示するノートまたはフォルダのdword ID番号、親フォルダ(最上位レベルのフォルダを表示する場合は0)、およびノートを表示する場合に表示するページ番号を指定する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkFolderCreateSubFolder()"></A>
        <H1 CLASS="refHeading">InkFolderCreateSubFolder()</H1>
<PRE CLASS="syntax">dword InkFolderCreateSubFolder(dword tag, /*親フォルダのID番号(トップレベルの場合は0)*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、渡されたフォルダ内にサブフォルダを作成します。 新しいフォルダは、親のチャンク配列に自動的に追加されます。 戻り値は、新しいフォルダのdword ID番号です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkFolderDelete()"></A>
        <H1 CLASS="refHeading">InkFolderDelete()</H1>
<PRE CLASS="syntax">void InkFolderDelete(dwordタグ,/*フォルダのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、インクデータベースフォルダを削除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkFolderDepthFirstTraverse()"></A>
        <H1 CLASS="refHeading">InkFolderDepthFirstTraverse()</H1>
<PRE CLASS="syntax">word InkFolderDepthFirstTraverse(dword rfldr, /*検索ツリーのルートにあるフォルダのID番号*/VMFileHandle fh, /*インクDBファイルのハンドル*/Boolean_pascal(*callback)(/*コールバックルーチンへのfar ptr*/dword fldr, VMFileHandle語fh, word*info)</PRE>
<PRE CLASS="syntax">word*info);/*コールバックに渡す追加データ*/</PRE>
<P>このルーチンは、フォルダーツリーを深さ優先で走査します。 コールバックルーチン(_pascalと宣言する必要があります)は、次の値を返すことで検索を停止できます。<EM>真</EM>この場合、検索ルーチンは即座に<EM>真</EM>;それ以外の場合、検索結果は<EM>偽の</EM>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkFolderDisplayChildInList()"></A>
        <H1 CLASS="refHeading">InkFolderDisplayChildInList()</H1>
<PRE CLASS="syntax">void InkFolderDisplayChildInList(dword fldr, /*フォルダのID番号*/VMFileHandle fh, /*インクDBファイルのハンドル*/optrリスト,/*GenDynamicList*/単語エントリ,/*表示する子のエントリ番号*/ブールdisplayFolders);/*カウントにモニカを含め、*モニカを返す*/</PRE>
<P>このルーチンは、動的リストにフォルダの子の1つの名前を表示するように要求します。 通常、アプリケーションで呼び出されます。<CODE>GDLI_queryMsg</CODE>ハンドラ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkFolderGetChildInfo()"></A>
        <H1 CLASS="refHeading">InkFolderGetChildInfo()</H1>
<PRE CLASS="syntax">ブール値InkFolderDisplayChildInfo(/*フォルダの場合はtrue、それ以外の場合はnote*/dword fldr、/*フォルダのID番号*/VMFileHandle fh、/*インクDBファイルのハンドル*/wordエントリ、/*子のエントリ番号*/dword*childID);/*返された子ID番号へのポインタ*/</PRE>
<P>このルーチンは、フォルダの子の1つに関する情報を返します。 明示的な戻り値は、子がフォルダの場合はtrue、ノートの場合はfalseになります。 さらに、渡されたdwordポインタは、子のdword ID番号を指します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkFolderGetChildNumber()"></A>
        <H1 CLASS="refHeading">InkFolderGetChildNumber()</H1>
<PRE CLASS="syntax">word note(dword fldr, /*フォルダのID番号*/VMFileHandle fh, /*インクDBファイルのハンドル*/dword note);/*子InkFolderDisplayChildInListまたはフォルダのID番号*/</PRE>
<P>このルーチンは、渡された親フォルダ内の、渡されたノートまたはフォルダのエントリ番号を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5e.htm_IX_InkFolderGetContents()"></A>
        <H1 CLASS="refHeading">InkFolderGetContents()</H1>
<PRE CLASS="syntax">DBGroupAndItem InkFolderGetContents(dwordタグ、/*フォルダのID番号*/VMFileHandle fh、/*インクDBファイルのハンドル*/DBGroupAndItem*サブフォルダ);/*戻り値へのポインタ*/);</PRE>
<P>このルーチンは、フォルダの内容を返します。 この関数は2つのチャンク配列を返します。各配列には、フォルダの子のdword ID番号が入ります。 明示的に返される配列には、フォルダの子ノートの番号が保持されます。 また、サブフォルダのID番号を持つチャンク配列を保持するDB項目をポインタに設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_5f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkFolderGetNumChildren()"></A>
        <H1 CLASS="refHeading">InkFolderGetNumChildren()</H1>
<PRE CLASS="syntax">dword InkFolderGetNumChildren(/*Subfolders:Notes*/dword fldr, /*フォルダのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このメッセージは、インクデータベースフォルダにある子の数を返します。 戻り値の上位ワードにはサブフォルダの数が保持され、下位ワードにはノートの数が保持されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkFolderMove()"></A>
        <H1 CLASS="refHeading">InkFolderMove()</H1>
<PRE CLASS="syntax">void InkFolderMove(dword fldr, /*移動するフォルダのID番号*/dword pfldr);/*新しい親フォルダのID番号*/</PRE>
<P>このルーチンは、インクデータベースフォルダをフォルダツリー内の新しい場所に移動します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkFolderSetTitle()"></A>
        <H1 CLASS="refHeading">InkFolderSetTitle()</H1>
<PRE CLASS="syntax">void InkFolderSetTitle(dwordタグ,/*フォルダのID番号*/VMFileHandle fh, /*インクDBファイルのハンドル*/const char*name);/*テキストオブジェクト*/);</PRE>
<P>このルーチンは、インクデータベースフォルダの名前を変更します。 渡される名前はNULLで終了する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkFolderSetTitleFromTextObject()"></A>
        <H1 CLASS="refHeading">InkFolderSetTitleFromTextObject()</H1>
<PRE CLASS="syntax">void InkFolderSetTitleFromTextObject(dwordタグ,/*フォルダのID番号*/FileHandle fh, /*インクDBファイルのハンドル*/optr text);/*テキストオブジェクト*/);</PRE>
<P>このルーチンは、渡されたVisTextオブジェクトの内容から、渡されたインクデータベースフォルダの名前を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkGetDocPageInfo()"></A>
        <H1 CLASS="refHeading">InkGetDocPageInfo()</H1>
<PRE CLASS="syntax">void InkGetDocPageInfo(PageSizeReport*psr, /*戻り値を設定する構造体*/VMFileHandle fh);</PRE>
<P>このルーチンは、インクデータベースファイルのheadフォルダのdword IDを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkGetDocCustomGString()"></A>
        <H1 CLASS="refHeading">InkGetDocCustomGString()</H1>
<PRE CLASS="syntax">GStateHandle InkGetDocCustomGString(VMFileHandle dbfh)</PRE>
<P>このルーチンは、渡されたインクデータベースファイルに関連付けられているカスタムGStringを返します。 このカスタム背景が使用されるのは、ドキュメントの基本<CODE>InkBackgroundType</CODE>はIBT_CUSTOMです。 (これは<CODE><A HREF="../../CRef/Routines/R_61.htm#IX_InkSetDocGString()">InkSetDocGString()</A></CODE>ルーチン。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkGetDocGString()"></A>
        <H1 CLASS="refHeading">InkGetDocGString()</H1>
<PRE CLASS="syntax">InkBackgroundType InkGetDocGString(VMFileHandle dbfh)</PRE>
<P>このルーチンは、渡されたインクデータベースファイルの背景ピクチャとして使用する標準GStringを返します。 返される背景の種類がカスタムの場合は<CODE><A HREF="../../CRef/Routines/R_5f.htm#IX_InkGetDocCustomGString()">InkGetDocCustomGString()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkGetParentFolder()"></A>
        <H1 CLASS="refHeading">InkGetParentFolder()</H1>
<PRE CLASS="syntax">dword InkGetParentFolder(dword tag, /*フォルダまたはメモのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このメッセージは、渡されたインクデータベースノートまたはフォルダのdword IDを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkGetTitle()"></A>
        <H1 CLASS="refHeading">InkGetTitle()</H1>
<PRE CLASS="syntax">word InkGetTitle(dwordタグ、/*フォルダまたはノートのID番号*/VMFileHandle fh、/*インクDBファイルのハンドル*/char*dest);/*INK_DB_MAX_TITLE_SIZE+1である必要があります*/);</PRE>
<P>このメッセージは、渡されたテキストバッファに、フォルダまたはメモのタイトル(NULL終端文字列)を格納します。 ルーチンの明示的な戻り値は、文字列の長さ(ターミネータを含む)です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkNoteCopyMoniker()"></A>
        <H1 CLASS="refHeading">InkNoteCopyMoniker()</H1>
<PRE CLASS="syntax">dワードInkNoteCopyMoniker(dワードタイトル、/*親フォルダのID番号*/optrリスト、/*出力リスト*/ワードタイプ、/*1:テキストノート*0:インクノート*-1:フォルダ*/</PRE>
<PRE CLASS="syntax">ワード入力);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、アイコンとタイトルをVisMonikerにコピーします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkNoteCreate()"></A>
        <H1 CLASS="refHeading">InkNoteCreate()</H1>
<PRE CLASS="syntax">dword InkNoteCreate(dword tag, /*親フォルダのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、ノートを作成し、渡されたフォルダの子リストに追加します。 新しいノートのdword IDが返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkNoteCreatePage()"></A>
        <H1 CLASS="refHeading">InkNoteCreatePage()</H1>
<PRE CLASS="syntax">word InkNoteCreatePage(dwordタグ、/*ノートのID番号*/VMFileHandle fh、/*インクDBファイルのハンドル*/wordページ);/*前に挿入するページ番号、*追加するCA_NULL_ELEMENT*/</PRE>
<P>このルーチンは、ノート内に新しいページを作成します。 新しいページ番号を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkNoteDelete()"></A>
        <H1 CLASS="refHeading">InkNoteDelete()</H1>
<PRE CLASS="syntax">void note(dword tag, /*InkNoteDeleteのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このメッセージは、渡されたノートを削除します。 注記への参照がすべて削除されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkNoteFindByKeywords()"></A>
        <H1 CLASS="refHeading">InkNoteFindByKeywords()</H1>
<PRE CLASS="syntax">ChunkHandle InkNoteFindByKeywords(/*戻り値は要素を持つチャンク配列です:*FindNoteHeader*-dword tag-*-dword tag-*etc.*/</PRE>
<PRE CLASS="syntax">VMFileHandle fh、char*strings、/*一致する文字列(*空白文字またはカンマで区切る)には、*C_WILDCARDまたはC_SINGLE_WILDCARD*/を含めることができます。</PRE>
<PRE CLASS="syntax">word opt, /*すべてのキーワードに一致する場合はtrue;*少なくとも1つのキーワードに一致する場合はfalse*/</PRE>
<P>このルーチンは、渡された検索文字列にキーワードが一致するすべてのノートのdword ID番号を含むチャンク配列を返します。この番号の前には、一致するノートの数が続きます。 そのようなノートが見つからない場合、返されるハンドルはNULLになります。</P>
<P>このルーチンは約20Kの紙幣しか返さないことに注意してください。一致する紙幣がさらにある場合は、最初の20Kの紙幣だけが返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_5f.htm_IX_InkNoteFindByTitle()"></A>
        <H1 CLASS="refHeading">InkNoteFindByTitle()</H1>
<PRE CLASS="syntax">ChunkHandle InkNoteFindByTitle(/*戻り値は要素を持つチャンク配列です:*FindNoteHeader*-dword tag-*-dword tag-*etc.*/</PRE>
<PRE CLASS="syntax">const char*文字列、/*一致する文字列(C_WILDCARD*またはC_SINGLE_WILDCARD*/を含むことができます)</PRE>
<PRE CLASS="syntax">SearchOptions opt, /*検索オプション*/Boolean Body, /*テキストノートの本文を参照する場合はtrue*/</PRE>
<PRE CLASS="syntax">VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、渡された検索文字列にタイトルが一致するすべての音符のdword ID番号を含むチャンク配列を返します。この番号の前には、一致する音符の番号が続きます。 そのようなノートが見つからない場合、返されるハンドルはNULLになります。</P>
<P>このルーチンは約20Kの紙幣しか返さないことに注意してください。一致する紙幣がさらにある場合は、最初の20Kの紙幣だけが返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_60.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteGetCreationDate()"></A>
        <H1 CLASS="refHeading">InkNoteGetCreationDate()</H1>
<PRE CLASS="syntax">dword note(dword tag, /*InkNoteGetCreationDateのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、ノートの作成日を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteGetKeywords()"></A>
        <H1 CLASS="refHeading">InkNoteGetKeywords()</H1>
<PRE CLASS="syntax">void note(dwordタグ,/*InkNoteGetKeywordsのID番号*/VMFileHandle fh, /*インクDBファイルのハンドル*/char*text);/*戻り値を保持する文字列*/);</PRE>
<P>このルーチンは、渡されたバッファにノートのキーワードを入れます。 ターゲットバッファの長さは、少なくともINK_DB_MAX_NOTE_KEYWORDS_SIZE+1である必要があります。 文字列はNULLで終了します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteGetModificationDate()"></A>
        <H1 CLASS="refHeading">InkNoteGetModificationDate()</H1>
<PRE CLASS="syntax">dword note(dword tag, /*InkNoteGetModificationDateのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、ノートの修正日を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteGetNoteType()"></A>
        <H1 CLASS="refHeading">InkNoteGetNoteType()</H1>
<PRE CLASS="syntax">NoteType InkNoteGetNoteType(/*0:インク、1:テキスト*/dwordタグ、/*ノートのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、メモの<CODE>メモの種類</CODE>:NT_INKまたはNT_TEXT。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteGetNumPages()"></A>
        <H1 CLASS="refHeading">InkNoteGetNumPages()</H1>
<PRE CLASS="syntax">word note(dwordタグ);/*InkNoteGetNumPagesのID番号*/</PRE>
<P>このルーチンは、渡されたノート内のページ数を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteGetPages()"></A>
        <H1 CLASS="refHeading">InkNoteGetPages()</H1>
<PRE CLASS="syntax">DBGroupAndItem InkNoteGetPages(dwordタグ、/*メモのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、チャンク配列を含むDBグループと項目を返します。 チャンク配列には、ノートのページ情報(圧縮されたペンデータまたはテキスト)が含まれます。 各配列要素は1ページ分のデータを保持します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteLoadPage()"></A>
        <H1 CLASS="refHeading">InkNoteLoadPage()</H1>
<PRE CLASS="syntax">void note(dword tag, /*InkNoteLoadPageのID番号*/VMFileHandle fh, /*Ink DBファイルのハンドル*/word page, /*ページ番号*/optr obj, /*InkまたはVisTextオブジェクト*/word type);/*note type 0:ink, 1:text*/</PRE>
<P>このルーチンは、渡されたインクデータベースページの内容を持つビジュアルオブジェクト(インクまたはテキスト)をロードします。 必ず正しいタイプのデータのみをオブジェクトにロードしてください。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteMove()"></A>
        <H1 CLASS="refHeading">InkNoteMove()</H1>
<PRE CLASS="syntax">void InkNoteMove(dwordタグ、/*メモのID番号*/dword pfolder、/*新しい親フォルダのID番号*/VMFileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このメッセージは、渡されたノートを新しい場所に移動します。 注記へのすべての参照は適切に変更されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteSavePage()"></A>
        <H1 CLASS="refHeading">InkNoteSavePage()</H1>
<PRE CLASS="syntax">void note(dword tag, /*InkNoteSavePageのID番号*/VMFileHandle fh, /*Ink DBファイルのハンドル*/word page, /*ページ番号*/optr obj, /*InkまたはVisTextオブジェクト*/word type);/*note type 0:ink, 1:text*/</PRE>
<P>このルーチンは、渡されたインクデータベースページにビジュアルオブジェクト(インクまたはテキスト)の内容を保存します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteSendKeywordsToTextObject()"></A>
        <H1 CLASS="refHeading">InkNoteSendKeywordsToTextObject()</H1>
<PRE CLASS="syntax">void InkNoteSendKeywordsToTextObject(dwordタグ、/*ノートのID番号*/VMFileHandle fh、/*インクDBファイルのハンドル*/optrテキスト);/*設定するテキストオブジェクト*/);</PRE>
<P>このメッセージは、渡されたVisTextオブジェクトのテキストを、渡されたフォルダまたはインクデータベースファイルのノートからのキーワードで置き換えます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteSetKeywords()"></A>
        <H1 CLASS="refHeading">InkNoteSetKeywords()</H1>
<PRE CLASS="syntax">void note(dwordタグ,/*InkNoteSetKeywordsのID番号*/VMFileHandle fh, /*インクDBファイルのハンドル*/const char*text);/*キーワード文字列*/);</PRE>
<P>このメッセージは、インクデータベースノートのキーワードを設定します。 渡された文字列はNULLで終了する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_60.htm_IX_InkNoteSetKeywordsFromTextObject()"></A>
        <H1 CLASS="refHeading">InkNoteSetKeywordsFromTextObject()</H1>
<PRE CLASS="syntax">void InkNoteSetKeywordsFromTextObject(dwordタグ、/*ノートのID番号*/VMFileHandle fh、/*インクDBファイルのハンドル*/optr*テキスト);/*テキストオブジェクト*/);</PRE>
<P>このメッセージは、渡されたテキストオブジェクトからコピーすることによって、インクデータベースノートのキーワードを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_61.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_61.htm_IX_InkNoteSetModificationDate()"></A>
        <H1 CLASS="refHeading">InkNoteSetModificationDate()</H1>
<PRE CLASS="syntax">void note(word tdft1, /*最初の2語*/word tdft2, /*TimerDateAndTime構造*/dword note, /*InkNoteSetModificationDateのID番号*/FileHandle fh);/*インクDBファイルのハンドル*/</PRE>
<P>このルーチンは、ノートの修正日を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_61.htm_IX_InkNoteSetNoteType()"></A>
        <H1 CLASS="refHeading">InkNoteSetNoteType()</H1>
<PRE CLASS="syntax">void note(dwordタグ,/*InkNoteSetNoteTypeのID番号*/VMFileHandle fh, /*インクDBファイルのハンドル*/NoteType nt);/*NT_INKまたはNT_TEXT*/</PRE>
<P>このルーチンは、ノートのタイプ(テキストまたはインク)を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_61.htm_IX_InkNoteSetTitle()"></A>
        <H1 CLASS="refHeading">InkNoteSetTitle()</H1>
<PRE CLASS="syntax">void note(dwordタグ,/*InkNoteSetTitleのID番号*/VMFileHandle fh, /*インクDBファイルのハンドル*/const char*name);/*テキストオブジェクト*/);</PRE>
<P>このメッセージは、インクデータベースノートの名前を変更します。 渡される名前はNULLで終了する必要があります。 文字列の長さは、INK_DB_MAX_NOTE_KEYWORDS_SIZE+1までです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_61.htm_IX_InkNoteSetTitleFromTextObject()"></A>
        <H1 CLASS="refHeading">InkNoteSetTitleFromTextObject()</H1>
<PRE CLASS="syntax">void note(dwordタグ,/*InkNoteSetTitleFromTextObjectのID番号*/FileHandle fh, /*インクDBファイルのハンドル*/optr text);/*テキストオブジェクト*/);</PRE>
<P>このメッセージは、渡されたVisTextオブジェクトの内容から、渡されたインクデータベースノートの名前を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_61.htm_IX_InkSendTitleToTextObject()"></A>
        <H1 CLASS="refHeading">InkSendTitleToTextObject()</H1>
<PRE CLASS="syntax">void InkSendTitleToTextObject(dwordタグ、/*フォルダまたはノートのID番号*/VMFileHandle fh、/*インクDBファイルのハンドル*/optr to);/*設定するテキストオブジェクト*/);</PRE>
<P>このメッセージは、渡されたVisTextオブジェクトのテキストを、渡されたフォルダの名前またはインクデータベースファイルのノートに置き換えます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_61.htm_IX_InkSetDocCustomGString()"></A>
        <H1 CLASS="refHeading">InkSetDocCustomGString()</H1>
<PRE CLASS="syntax">void InkSetDocCustomGString(VMFileHandle dbfh、Handle gstring)</PRE>
<P>このルーチンは、渡されたインクデータベースファイルの背景として使用するカスタムGStringを設定します。 このカスタム背景が使用されるのは、ドキュメントの基本<CODE>InkBackgroundType</CODE>はIBT_CUSTOMです。 (これを設定するには<CODE><A HREF="../../CRef/Routines/R_61.htm#IX_InkSetDocGString()">InkSetDocGString()</A></CODE>ルーチン)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_61.htm_IX_InkSetDocGString()"></A>
        <H1 CLASS="refHeading">InkSetDocGString()</H1>
<PRE CLASS="syntax">ボイドInkSetDocGString(VMFileHandle dbfh、InkBackgroundType型)</PRE>
<P>このルーチンは、渡されたインクデータベースファイルの背景ピクチャとして使用する標準GStringを設定します。 渡された背景の種類がカスタムの場合は<CODE><A HREF="../../CRef/Routines/R_61.htm#IX_InkSetDocCustomGString()">InkSetDocCustomGString()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_61.htm_IX_InkSetDocPageInfo()"></A>
        <H1 CLASS="refHeading">InkSetDocPageInfo()</H1>
<PRE CLASS="syntax">void InkSetDocPageInfo(PageSizeReport*psr、VMFileHandle fh)</PRE>
<P>インクデータベースファイルのページ情報を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ペン・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_61.htm_IX_IntegerOf()"></A>
        <H1 CLASS="refHeading">IntegerOf()</H1>
<PRE CLASS="syntax">ワードIntegerOf(WWFixedAsDWord WWF)</PRE>
<P>このマクロは<CODE>WWFixedAsDWord</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geos.hを入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_62.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_isalnum()"></A>
        <H1 CLASS="refHeading">isalnum()も参照下さい。</H1>
<PRE CLASS="syntax">int LocalIsAlphaNumeric(int__C);</PRE>
<P>このルーチンは<EM>真</EM>(渡された文字が英数字の場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_isalpha()"></A>
        <H1 CLASS="refHeading">isalpha()も参照下さい。</H1>
<PRE CLASS="syntax">int isalpha(int__C);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>渡された文字がアルファベットの場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_iscntrl()"></A>
        <H1 CLASS="refHeading">参照):iscntrl()</H1>
<PRE CLASS="syntax">int iscntrl(int__C);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が制御文字である場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_isdigit()"></A>
        <H1 CLASS="refHeading">isdigit()も参照下さい。</H1>
<PRE CLASS="syntax">int isdigit(int__c);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が10進数の場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_isgraphic()"></A>
        <H1 CLASS="refHeading">isgraph()も参照下さい。</H1>
<PRE CLASS="syntax">int isgraph(wint__C);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が表示可能な場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_islower()"></A>
        <H1 CLASS="refHeading">islower()も参照下さい。</H1>
<PRE CLASS="syntax">int islower(int__C);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>これは、渡された文字が小文字のアルファベット文字である場合です。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_isprint()"></A>
        <H1 CLASS="refHeading">関数isprint()</H1>
<PRE CLASS="syntax">int isprint(int__C);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が印刷可能な場合(つまり、印刷時にスペースを消費する場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_ispunct()"></A>
        <H1 CLASS="refHeading">と同じです。</H1>
<PRE CLASS="syntax">int ispunct(int__c);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が約物の場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_isspace()"></A>
        <H1 CLASS="refHeading">isspace()も参照下さい。</H1>
<PRE CLASS="syntax">int isspace(int__c);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が空白の場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_isupper()"></A>
        <H1 CLASS="refHeading">参照):isupper()</H1>
<PRE CLASS="syntax">int isupper(int__c);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が大文字のアルファベット文字の場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_62.htm_IX_isxdigit()"></A>
        <H1 CLASS="refHeading">isxdigit()も参照下さい。</H1>
<PRE CLASS="syntax">int isxdigit(int__C);と入力します。</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が16進数の場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンにcharを渡す場合は注意が必要です。このルーチンは整数を受け取り、渡された値が符号拡張されると、期待した結果が得られない可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_63.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_63.htm_IX_LMemAlloc()"></A>
        <H1 CLASS="refHeading">LMemAlloc()</H1>
<PRE CLASS="syntax">ChunkHandle LMemAlloc(MemHandle mh, /*ヒープを含むブロックのハンドル*/word chunkSize);/*新しいチャンクのサイズ(バイト単位)*/</PRE>
<P>このルーチンは、LMemヒープに新しいチャンクを割り当てます。 ヒープをロックまたは修正する必要があります。 これはチャンクを割り当て、enccessaryの場合はチャンク・テーブルを拡張し、チャンクのハンドルを返します。 チャンクがゼロ初期化されていません。 チャンクを割り当てることができなかった場合は、nullハンドルを返します。 チャンクはdwordで整列されるため、チャンクの実際のサイズは要求したサイズよりも若干大きくなる場合があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(ブロックが固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>ヒープは圧縮される可能性があるため、チャンクへのすべてのポインタが無効になります。 LMF_NO_EXPANDが設定されていない場合、ヒープのサイズが変更され(したがって移動され)、そのブロックへのすべてのポインタが無効になります。 固定ブロックであっても、サイズを変更したり移動することができます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE><CODE><A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAlloc()">LMemReAlloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_63.htm_IX_LMemContract()"></A>
        <H1 CLASS="refHeading">LMemContract()</H1>
<PRE CLASS="syntax">void LMemContract(MemHandle mh);/*LMemヒープのハンドル*/</PRE>
<P>このルーチンはLMemヒープを縮小します。つまり、すべての空きチャンクを削除し、すべての使用済みチャンクをヒープの先頭(チャンク・ハンドル・テーブルの直後)に移動し、最後に未使用の領域を解放するようにブロックのサイズを変更します。 大量のチャンクを解放したばかりの場合は、グローバル・ヒープの一部が解放されるため、このルーチンを呼び出すことをお勧めします。 LMemヒープは移動しないことが保証されていますが、チャンクへのすべてのポインタは無効になります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(修正されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_63.htm_IX_LMemDeleteAt()"></A>
        <H1 CLASS="refHeading">LMemDeleteAt()</H1>
<PRE CLASS="syntax">void LMemDeleteAt(optrチャンク,/*サイズを変更するチャンク*/word deleteOffset, /*削除する最初の*バイトのチャンク内のオフセット*/</PRE>
<PRE CLASS="syntax">ワードdeleteCount);/*削除するバイト数*/</PRE>
<P>このルーチンは、チャンク内から指定されたバイト数を削除します。 ヒープのサイズ変更や圧縮が行われないことが保証されているため、他のチャンクへのポインタは有効なままです。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>削除するバイトは、すべてチャンク内にある必要があります。 次の場合<CODE>deleteOffset</CODE>および<CODE>deleteCount</CODE>チャンク内に存在しないバイトを示します。結果は未定義です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAlloc()">LMemReAlloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInsertAt()">LMemInsertAt()</A></CODE><CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeleteAtHandles()">LMemDeleteAtHandles()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_63.htm_IX_LMemDeleteAtHandles()"></A>
        <H1 CLASS="refHeading">LMemDeleteAtHandles()</H1>
<PRE CLASS="syntax">void LMemDeleteAtHandles(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandle ch, /*サイズを変更するチャンクのハンドル*/word deleteOffset, /*削除する最初の*バイトのチャンク内のオフセット*/</PRE>
<PRE CLASS="syntax">ワードdeleteCount);/*削除するバイト数*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeleteAt()">LMemDeleteAt()</A></CODE>ただし、チャンクはグローバルハンドルとチャンクハンドルによって指定されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>削除するバイトは、すべてチャンク内にある必要があります。 次の場合<CODE>deleteOffset</CODE>および<CODE>deleteCount</CODE>チャンク内に存在しないバイトを示します。結果は未定義です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_63.htm_IX_LMemDeref()"></A>
        <H1 CLASS="refHeading">LMemDeref()</H1>
<PRE CLASS="syntax">void*LMemDeref(optr chunk);/*参照解除するチャンクへのoptr*/</PRE>
<P>このルーチンはoptrをチャンクのアドレスに変換します。 LMemヒープは、グローバルヒープ上でロックまたは修正する必要があります。 チャンク・アドレスは多くのLMemルーチンによって無効にされる可能性があるため、optrを再度参照解除する必要があります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDerefHandles()">LMemDerefHandles()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_63.htm_IX_LMemDerefHandles()"></A>
        <H1 CLASS="refHeading">LMemDerefHandles()</H1>
<PRE CLASS="syntax">void*LMemDerefHandles(MemHandle mh, /*LMemヒープのブロックのハンドル*/ChunkHandleチャンク);/*参照解除するチャンクのハンドル*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE>ただし、チャンクはグローバルハンドルとチャンクハンドルによって指定されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_63.htm_IX_LMemFree()"></A>
        <H1 CLASS="refHeading">LMemFree()</H1>
<PRE CLASS="syntax">void LMemFree(optr chunk);/*解放するチャンクのoptr*/</PRE>
<P>このルーチンは、LMemヒープからチャンクを解放します。 チャンクがヒープの空きリストに追加されます。 このルーチンは、ヒープを圧縮したりサイズ変更したりしないことが保証されています。したがって、ブロック内のすべてのポインタは有効なままです(もちろん、解放されたチャンク内のデータへのポインタを除きます)。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemFreeHandles()">LMemFreeHandles()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_63.htm_IX_LMemFreeHandles()"></A>
        <H1 CLASS="refHeading">LMemFreeHandles()</H1>
<PRE CLASS="syntax">void LMemFreeHandles(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandleチャンク);/*解放するチャンクのハンドル*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemFree()">LMemFree()</A></CODE>ただし、チャンクは(optrではなく)グローバルハンドルとチャンクハンドルによって指定されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_64.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_64.htm_IX_LMemGetChunkSize()"></A>
        <H1 CLASS="refHeading">LMemGetChunkSize()</H1>
<PRE CLASS="syntax">word LMemGetChunkSize(optr chunk);/*対象チャンクのoptr*/</PRE>
<P>このルーチンは、LMemヒープ内のチャンクのサイズ(バイト単位)を返します。 LMemチャンクはdwordで整列されているため、チャンクのサイズは、割り当てられたときに指定されたサイズよりもわずかに大きくなる場合があります。 このルーチンは、ヒープの圧縮やサイズ変更を行わないことが保証されています。したがって、ブロック内のすべてのポインタは有効なままです。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemGetChunkSizeHandles()">LMemGetChunkSizeHandles()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_64.htm_IX_LMemGetChunkSizeHandles()"></A>
        <H1 CLASS="refHeading">LMemGetChunkSizeHandles()</H1>
<PRE CLASS="syntax">word Routine(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandleチャンク);/*問題のチャンクのハンドル*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemGetChunkSize()">LMemGetChunkSize()</A></CODE>ただし、チャンクは(optrではなく)グローバルハンドルとチャンクハンドルによって指定されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemGetChunkSize()">LMemGetChunkSize()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_64.htm_IX_LMemInitHeap()"></A>
          <A NAME="R_64.htm_IX_LMemType:with LMemInitHeap()"></A>
          <A NAME="R_64.htm_IX_LocalMemoryFlags"></A>
          <A NAME="R_64.htm_IX_LMF_&ldots;"></A>
        <H1 CLASS="refHeading">LMemInitHeap()</H1>
<PRE CLASS="syntax">void LMemInitHeap(MemHandle mh, /*ヒープを含む(ロックまたは固定された)*ブロックのハンドル*/</PRE>
<PRE CLASS="syntax">LMemTypeタイプ、/*作成するヒープのタイプ*/LocalMemoryFlagsフラグ、/*LocalMemoryFlagsの記録*/ワードlmemOffset、/*ヒープ内の最初のチャンクのオフセット*/ワードnumHandles、/*スターターハンドルテーブルのサイズ*/ワードfreeSpace);/*最初の空きチャンクのサイズ*作成された*/</PRE>
<P>このルーチンは、グローバルメモリブロックにLMemヒープを作成します。 ブロックはロックされているか、メモリに固定されている必要があります。 ルーチンは<CODE>LMemBlockHeader</CODE>、ハンドルテーブルを作成し、1つの空きチャンクを割り当て、ブロックのHF_LMEMフラグをオンにします。 ヒープ用の領域を確保する必要がある場合は、ブロックが再割り当てされます。 このルーチンは6つの引数を取ります。</P>
<DL>
<DT>
          <CODE>モデム</CODE>
        </DT><DD>メモリブロックのハンドル</DD>
<DT>
          <CODE>種類</CODE>
        </DT><DD>のメンバー<CODE>LMemType</CODE>作成するブロックの種類を指定する列挙型。 ほとんどのアプリケーションでは、これはLMEM_TYPE_GENERALになります。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>LocalMemoryFlags</CODE>ヒープの特定のプロパティを指定します。 ほとんどのアプリケーションは、nullレコードを渡します。</DD>
<DT>
          <CODE>lmemOffset</CODE>
        </DT><DD>ヒープを開始するブロック内のオフセット。 これは<CODE>LMemBlockHeader</CODE>すべてのヒープブロックを開始する構造体。 間の任意のスペース<CODE>LMemBlockHeader</CODE>ヒープはすべてのLMemルーチンの影響を受けません。 通常は、sizeof(<CODE>LMemBlockHeader</CODE>)をこの引数として、またはsizeof(<CODE>ObjLMemBlockHeader</CODE>)をクリックします。</DD>
<DT>
          <CODE>numHandles</CODE>
        </DT><DD>ブロックのチャンクハンドルテーブルに作成するエントリの数。 すべてのエントリが使用されると、チャンクハンドルテーブルは自動的に大きくなります。 アプリケーションは通常、定数STD_INIT_HANDLESを渡す必要がありますが、必ず正の数を渡す必要があります。</DD>
<DT>
          <CODE>フリースペース</CODE>
        </DT><DD>最初の空きチャンクに割り当てる領域の量。 アプリケーションは通常、定数STD_INIT_HEAPを渡す必要がありますが、必ず正の数を渡す必要があります。</DD>
</DL>
<P>LMemヒープを破棄するには、次の関数を呼び出します。<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemFree()">関数MemFree()</A></CODE>を呼び出して、ヒープを含むブロックを解放します。</P>
<P CLASS="refField"><STRONG>構造:</STRONG>このルーチンでは、次の2つの特殊なデータ型が使用されます。<CODE>LMemType</CODE>および<CODE>LocalMemoryFlags</CODE>ボタンをクリックし</P>
<P>LMemヒープは、さまざまな目的のために作成される。 これらの目的の中には、ヒープが特別な機能を持つことを必要とするものもあります。 このため<CODE>LMemType</CODE>作成するヒープの種類を指定する列挙型。 次のタイプを使用できます。他のタイプもありますが、では使用しないでください。<CODE>LMemInitHeap()</CODE>ボタンをクリックし</P>
<DL>
<DT>一般LMEM_TYPE_GENERAL</DT><DD>通常のヒープ。 ほとんどのアプリケーションのLMemヒープは、このタイプになります。</DD>
<DT>LMEM_TYPE_OBJ_BLOCK[オブジェクトタイプブロック]</DT><DD>ヒープには、オブジェクトインスタンスチャンクが含まれます。</DD>
</DL>
<P>LMemヒープが作成されたら、フラグのレコードを<CODE>LMemInitHeap()</CODE>ヒープの処理方法を指定します。 ほとんどの<CODE>LocalMemoryFlags</CODE>このルーチンで使用可能なフラグは、LMF_HAS_FLAGS、LMF_DETACHABLE、LMF_NO_ENLARGE、LMF_RETURN_ERRORSです。 フラグを読み取るには<CODE>LMemBlockHeader</CODE>構造をブロックの先頭に配置します。 通常、一般的なLMemヒープでは、すべてのフラグがクリアされます。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ヘッダーの後に固定データ領域が必要な場合は、最初の要素が<CODE>LMemBlockHeader</CODE>その他のフィールドは、固定データ・スペースに保管するデータ用です。 この構造体のサイズを<EM>LMemOffset</EM>引数を指定します。 これで、構造体のフィールドを使用して固定データ領域にアクセスできます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>少なくとも以下の大きさのオフセットを渡します。<CODE>sizeof(LMemBlockHeader)</CODE>小さすぎるオフセットを渡すと、結果は未定義になります。 このルーチンを呼び出す前に、グローバルヒープ上のブロックをロックします(ブロックが固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>ブロックの初期サイズが小さすぎてヒープを収容できない場合は、ブロックを再配置できます。 これは、固定ブロックにも当てはまります。 フラグLMF_NO_ENLARGEが設定されている場合、ブロックは再配置されません。ただし、ヒープ全体を収容するのに十分な大きさで開始する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_25.htm#IX_LMemBlockHeader">LMemBlockHeader</A></CODE><CODE><A HREF="../../CRef/Structs/S_26.htm#IX_LMemType">LMemType</A></CODE><CODE><A HREF="../../CRef/Structs/S_26.htm#IX_LocalMemoryFlags">LocalMemoryFlags</A></CODE><CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">関数MemAlloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAllocLMem()">MemAllocLMem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemFree()">関数MemFree()</A></CODE><CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAllocLMem()">VMAllocLMem()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_64.htm_IX_LMemInsertAt()"></A>
        <H1 CLASS="refHeading">LMemInsertAt()</H1>
<PRE CLASS="syntax">void LMemInsertAt(optrチャンク,/*サイズを変更するチャンクのoptr*/word insertOffset, /*最初のバイトのチャンク内のオフセット*追加される*/</PRE>
<PRE CLASS="syntax">word insertCount);/*追加するバイト数*/</PRE>
<P>このルーチンは、チャンクの中央にスペースを挿入し、新しいスペースをゼロから初期化します。 最初の新しいバイトは、チャンク内の指定されたオフセットに配置されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。 オフセットが指定したチャンク内にあることを確認します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、ヒープのサイズを変更したり、ヒープを圧縮したりします。したがって、ブロック内のデータへのすべてのポインタが無効になります。</P>
<P>合格する必要があります<CODE>insertOffset</CODE>オフセットが範囲外の場合、結果は定義されません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAlloc()">LMemReAlloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeleteAt()">LMemDeleteAt()</A></CODE><CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInsertAtHandles()">LMemInsertAtHandles()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_64.htm_IX_LMemInsertAtHandles()"></A>
        <H1 CLASS="refHeading">LMemInsertAtHandles()</H1>
<PRE CLASS="syntax">void LMemInsertAtHandles(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandleチャンク,/*サイズを変更するチャンク*/word insertOffset, /*追加される*最初のバイトのチャンク内のオフセット*/</PRE>
<PRE CLASS="syntax">word insertCount);/*追加するバイト数*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInsertAt()">LMemInsertAt()</A></CODE>ただし、チャンクは(optrではなく)グローバルハンドルとチャンクハンドルによって指定されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。 オフセットが指定したチャンク内にあることを確認します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、ヒープのサイズを変更したり、ヒープを圧縮したりします。したがって、ブロック内のデータへのすべてのポインタが無効になります。</P>
<P>合格する必要があります<CODE>insertOffset</CODE>オフセットが範囲外の場合、結果は定義されません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_65.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_65.htm_IX_LMemReAlloc()"></A>
        <H1 CLASS="refHeading">LMemReAlloc()</H1>
<PRE CLASS="syntax">Boolean chunk(optr chunk, /*サイズを変更するLMemReAllocのoptr*/word chunkSize);/*チャンクの新しいサイズ(バイト単位)*/</PRE>
<P>このルーチンは、LMemヒープ内のチャンクのサイズを変更します。 ヒープはロックされた状態または固定ブロックにある必要があります。 ルーチンが成功した場合は0を返します。 失敗した場合(ヒープ領域が不足して拡張できなかったため)、0以外の値が返されます。</P>
<P>新しいサイズが元のサイズより大きい場合は、チャンクの最後に余分なバイトが追加されます。 これらのバイトはゼロ初期化されません。 要求に対応するために、ヒープを圧縮またはサイズ変更する必要がある場合があります。したがって、ブロック内のデータへのすべてのポインタが無効になります。</P>
<P>新しいサイズが古いサイズよりも小さい場合、チャンクは切り捨てられます。 リクエストは成功することが保証されており、チャンクは移動されず、ヒープは圧縮もサイズ変更もされません。 したがって、他のチャンクへのすべてのポインタは有効なままです。 チャンクを0バイトに再割り当てすることは、チャンクを解放することと同じです。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>前述したように、新しいサイズが古いサイズよりも大きい場合、ヒープは圧縮またはサイズ変更され、ポインタが無効になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAllocHandles()">LMemReAllocHandles()</A></CODE><CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInsertAt()">LMemInsertAt()</A></CODE><CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeleteAt()">LMemDeleteAt()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_65.htm_IX_LMemReAllocHandles()"></A>
        <H1 CLASS="refHeading">LMemReAllocHandles()</H1>
<PRE CLASS="syntax">Boolean LMemReAllocHandles(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandleチャンク,/*サイズを変更するチャンクのハンドル*/word chunkSize);/*チャンクの新しいサイズ(バイト単位)*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAlloc()">LMemReAlloc()</A></CODE>ただし、チャンクは(optrではなく)グローバルハンドルとチャンクハンドルによって指定されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>グローバルヒープ上のブロックをロックします(固定されていない場合)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>前述したように、新しいサイズが古いサイズよりも大きい場合、ヒープは圧縮またはサイズ変更され、ポインタが無効になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_66.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalAsciiToFixed()"></A>
        <H1 CLASS="refHeading">LocalAsciiToFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord LocalAsciiToFixed(const char*buffer, char**parseEnd);</PRE>
<P>&quot;12.345&quot;のような文字列を固定小数点数に変換するルーチンである。 が指すポインタ<EM>parseEnd</EM>は、最後に解析された文字の後のバッファを指して返される。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalCalcDaysInMonth()"></A>
        <H1 CLASS="refHeading">LocalCalcDaysInMonth()</H1>
<PRE CLASS="syntax">単語LocalCalcDaysInMonth(単語年、単語月)</PRE>
<P>このルーチンは、指定された月の日数を計算します。</P>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalCmpStrings()"></A>
        <H1 CLASS="refHeading">LocalCmpStrings()</H1>
<PRE CLASS="syntax">剣LocalCmpStrings(const char*str1, const char*)<EM>str2(文字列2)</EM>,word strSize);</PRE>
<P>このルーチンは、2つの文字列を比較して、語彙(つまりアルファベット)順でどちらが先かを判断します。 戻り値が負の場合<EM>str1(文字列1)</EM>より前<EM>str2(文字列2)</EM>戻り値が正の場合<EM>str1(文字列1)</EM>より後<EM>str2(文字列2)</EM>戻り値が0の場合、文字列はアルファベット順に同じ場所に表示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalCmpStringsDosToGeos()"></A>
          <A NAME="R_66.htm_IX_LocalCmpStringsDosToGeosFlags"></A>
          <A NAME="R_66.htm_IX_LCSDTG_NO_CONVERT_STRING_&ldots;"></A>
        <H1 CLASS="refHeading">LocalCmpStringsDosToGeos()</H1>
<PRE CLASS="syntax">ソードLocalCmpStringsDosToGeos(const char*str1, const char*str2, word strSize, word defaultChar, LocalCmpStringsDosToGeosFlags flags);</PRE>
<P>このルーチンは、2つの文字列を比較して、どちらが最初に現れるかを決定します。 これらの文字列のいずれかまたは両方をDOS文字列にすることができます。 戻り値が負の場合<EM>str1(文字列1)</EM>より前<EM>str2(文字列2)</EM>戻り値が正の場合<EM>str1(文字列1)</EM>より後<EM>str2(文字列2)</EM>戻り値が0の場合、文字列はアルファベット順に同じ場所に表示されます。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef ByteFlags LocalCmpStringsDosToGeosFlags;/*以下のフラグは&amp;を使用して組み合わせることができます:*LCSDTG_NO_CONVERT_STRING_2, *LCSDTG_NO_CONVERT_STRING_1*/</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalCmpStringsNoCase()"></A>
        <H1 CLASS="refHeading">LocalCmpStringsNoCase()</H1>
<PRE CLASS="syntax">剣LocalCmpStringsNoCase(const char*str1, const char*str2, word strSize);</PRE>
<P>このルーチンは、2つの文字列を比較して、語彙(つまりアルファベット)順でどちらが先かを判断します。 使用される比較では、大文字と小文字は区別されません。 戻り値が負の場合<EM>str1(文字列1)</EM>より前<EM>str2(文字列2)</EM>戻り値が正の場合<EM>str1(文字列1)</EM>より後<EM>str2(文字列2)</EM>戻り値が0の場合、文字列はアルファベット順に同じ場所に表示されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalCmpStringsNoSpace()"></A>
        <H1 CLASS="refHeading">LocalCmpStringsNoSpace()</H1>
<PRE CLASS="syntax">剣LocalCmpStringsNoSpace(const char*str1, const char*str2, word strSize);</PRE>
<P>このルーチンは、2つの文字列を比較して、語彙(つまりアルファベット)順でどちらが先かを判断します。 この比較では、スペースは無視されます。 戻り値が負の場合<EM>str1(文字列1)</EM>より前<EM>str2(文字列2)</EM>戻り値が正の場合<EM>str1(文字列1)</EM>より後<EM>str2(文字列2)</EM>戻り値が0の場合、文字列はアルファベット順に同じ場所に表示されます。</P>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalCmpStringsNoSpaceCase()"></A>
        <H1 CLASS="refHeading">LocalCmpStringsNoSpaceCase()</H1>
<PRE CLASS="syntax">剣LocalCmpStringsNoSpaceCase(const char*str1, const char*str2, word strSize);</PRE>
<P>このルーチンは、2つの文字列を比較して、語彙(つまりアルファベット)順でどちらが先かを判断します。 この比較ではスペースは無視され、大文字と小文字は区別されません。 戻り値が負の場合<EM>str1(文字列1)</EM>より前<EM>str2(文字列2)</EM>戻り値が正の場合<EM>str1(文字列1)</EM>より後<EM>str2(文字列2)</EM>戻り値が0の場合、文字列はアルファベット順に同じ場所に表示されます。</P>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalCodePageToGeos()"></A>
        <H1 CLASS="refHeading">LocalCodePageToGeos()</H1>
<PRE CLASS="syntax">Boolean LocalCodePageToGeos(char*str, word strSize, /*文字列のサイズ(バイト単位)*/DosCodePage codePage, word defaultChar);</PRE>
<P>このルーチンは、指定されたコードページを使用して、DOS文字列を標準GEOSテキストに変換します。 対応するGEOSがない文字は、渡されたデフォルト文字に置き換えられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalCodePageToGeosChar()"></A>
        <H1 CLASS="refHeading">LocalCodePageToGeosChar()</H1>
<PRE CLASS="syntax">word LocalCodePageToGeosChar(word ch, DosCodePage codePage, word defaultChar);</PRE>
<P>このルーチンは、指定されたコードページを使用して、DOS文字を標準GEOSテキストに変換します。 対応するGEOSがない文字は、渡されたデフォルト文字に置き換えられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_66.htm_IX_LocalCustomFormatDateTime()"></A>
        <H1 CLASS="refHeading">LocalCustomFormatDateTime()</H1>
<PRE CLASS="syntax">word LocalCustomFormatDateTime(char*str, /*書式付きテキストを保存するバッファ*/const char*書式,/*書式文字列*/const TimerDateAndTime*dateTime);</PRE>
<P>このルーチンは、日付または時刻を受け取り、カスタム・フォーマットを使用してストリングを構成します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_67.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalCustomParseDateTime()"></A>
        <H1 CLASS="refHeading">LocalCustomParseDateTime()</H1>
<PRE CLASS="syntax">word dateTime(const char*str, LocalCustomParseDateTime形式format, TimerDateAndTime*dateTime);</PRE>
<P>このルーチンは、日付と時刻の文字列を、渡された<CODE>DateTimeFormat/日付の形式</CODE>のフィールドに入力されます。<CODE>TimerDateAndTime</CODE>構造。 フォーマット文字列で指定されていないフィールドには、-1が入力されます。</P>
<P>文字列が正しく解析されれば<CODE>LocalCustomParseDateTime()</CODE>は、-1を返します。 それ以外の場合は、正しく解析されなかったテキストの先頭へのオフセットを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalDistanceFromAscii()"></A>
          <A NAME="R_67.htm_IX_Measurement:LocalDistanceFromAscii()"></A>
        <H1 CLASS="refHeading">LocalDistanceFromAscii()</H1>
<PRE CLASS="syntax">WWFixedAsDword LocalDistanceFromAscii(const char*buffer、DistanceUnit distanceUnits、MeasurementTypes measurementType);</PRE>
<P>このルーチンは&quot;72 pt&quot;のような関数を取り、距離を表す数値を返します。 返される答えは、ポイント、インチ、センチメートル、または渡された単位で指定されたその他の単位で表されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalDistanceToAscii()"></A>
          <A NAME="R_67.htm_IX_Measurement:LocalDistanceToAscii()"></A>
        <H1 CLASS="refHeading">LocalDistanceToAscii()</H1>
<PRE CLASS="syntax">word length(/*NULLを含む文字列のLocalDistanceToAscii*/char*buffer, /*書式設定されたテキストを保存するバッファ*/word value, DistanceUnit distanceUnits, MeasurementType MeasurementType);</PRE>
<P>このルーチンは、距離と単位のセットを受け取り、適切な形式の距離を含む文字列を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalDosToGeos()"></A>
        <H1 CLASS="refHeading">LocalDosToGeos()</H1>
<PRE CLASS="syntax">Boolean LocalDosToGeos(char*str, word strSize, word defaultChar);</PRE>
<P>DOS文字列をGEOSテキストに変換します。 対応するGEOSがない文字は、渡されたデフォルト文字に置き換えられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalDosToGeosChar()"></A>
        <H1 CLASS="refHeading">LocalDosToGeosChar()</H1>
<PRE CLASS="syntax">word LocalDosToGeosChar(word ch, word defaultChar);</PRE>
<P>DOS文字をGEOSテキストに変換します。 対応するGEOSがない文字は、渡されたデフォルト文字に置き換えられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalDowncaseChar()"></A>
        <H1 CLASS="refHeading">LocalDowncaseChar()</H1>
<PRE CLASS="syntax">語LocalDowncaseChar(語ch)</PRE>
<P>渡された文字に対応する小文字があれば、それを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalDowncaseString()"></A>
        <H1 CLASS="refHeading">LocalDowncaseString()</H1>
<PRE CLASS="syntax">void LocalDowncaseString(char*str, word size);/*文字列のサイズ(バイト単位)*/</PRE>
<P>渡された文字列をすべて小文字の文字列に変換します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalFixedToAscii()"></A>
        <H1 CLASS="refHeading">LocalFixedToAscii()</H1>
<PRE CLASS="syntax">void LocalFixedToAscii(char*buffer, WWFixedAsDWord値,word fracDigits);</PRE>
<P>このルーチンは、固定小数点数のASCII式を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalFormatDateTime()"></A>
        <H1 CLASS="refHeading">LocalFormatDateTime()</H1>
<PRE CLASS="syntax">word date(/*返された文字列のLocalFormatDateTime*/char*str, DateTimeFormat format, const TimerDateAndTime*dateTime);</PRE>
<P>このルーチンは、渡されたDateAndTimeに対応する文字列(&quot;9:37&quot;など)を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_67.htm_IX_LocalFormatFileDateTime()"></A>
        <H1 CLASS="refHeading">LocalFormatFileDateTime()</H1>
<PRE CLASS="syntax">word LocalFormatFileDateTime(char*str, DateTimeFormat format, const FileDateAndTime*dateTime);</PRE>
<P>このユーティリティルーチンは<CODE>FileDateAndTime</CODE>ファイル関連の操作で使用されるような構造</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef struct{byte numberFormatFlags;/*numberFormatFlags値*/byte decimalDigits;wchar thousandsSeparator;wchar decimalSeparator;wchar listSeparator;}LocalNumericFormat;</PRE>
<P>最初のバイトは<CODE>NumberFormatFlags</CODE>先行ゼロを使用するかどうかを指定するフィールド。 2番目のバイトは、小数点以下に表示する桁数です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_68.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGeosToCodePage()"></A>
        <H1 CLASS="refHeading">LocalGeosToCodePage()</H1>
<PRE CLASS="syntax">Boolean LocalGeosToCodePage(char*str, word strSize, DosCodePage codePage, word defaultChar);</PRE>
<P>指定されたコードページを使用して、GEOS文字列をDOSテキストに変換します。 DOSに対応するものがない文字は、渡されたデフォルト文字に置き換えられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGeosToCodePageChar()"></A>
        <H1 CLASS="refHeading">LocalGeosToCodePageChar()</H1>
<PRE CLASS="syntax">word LocalGeosToCodePageChar(word ch, DosCodePage codePage, word defaultChar);</PRE>
<P>指定されたコードページを使用して、GEOS文字をDOSテキストに変換します。 DOSに対応するものがない文字は、渡されたデフォルト文字に置き換えられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGeosToDos()"></A>
        <H1 CLASS="refHeading">LocalGeosToDos()</H1>
<PRE CLASS="syntax">Boolean LocalGeosToDos(char*str, word strSize, word defaultChar);</PRE>
<P>GEOS文字列をDOSテキストに変換します。 DOSに対応するものがない文字は、渡されたデフォルト文字に置き換えられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGeosToDosChar()"></A>
        <H1 CLASS="refHeading">LocalGeosToDosChar()</H1>
<PRE CLASS="syntax">word LocalGeosToDosChar(word ch, word defaultChar);</PRE>
<P>GEOS文字をDOSテキストに変換します。 DOSに対応するものがない文字は、渡されたデフォルト文字に置き換えられます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGetCodePage()"></A>
        <H1 CLASS="refHeading">LocalGetCodePage()</H1>
<PRE CLASS="syntax">DosCodePage LocalGetCodePage(ボイド)</PRE>
<P>このルーチンは、DOSが国際文字セットを処理するために使用する現在のコード・ページを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGetCurrencyFormat()"></A>
        <H1 CLASS="refHeading">LocalGetCurrencyFormat()</H1>
<PRE CLASS="syntax">void LocalGetCurrencyFormat(LocalCurrencyFormat*buf, char*symbol);</PRE>
<P>このルーチンは、現在の通貨書式と記号を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGetDateTimeFormat()"></A>
        <H1 CLASS="refHeading">LocalGetDateTimeFormat()</H1>
<PRE CLASS="syntax">void datetime(char*str, LocalGetDateTimeFormat時刻形式);</PRE>
<P>このルーチンは、ユーザーが希望する日付と時刻の書式を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGetLanguage()"></A>
        <H1 CLASS="refHeading">LocalGetLanguage()</H1>
<PRE CLASS="syntax">word LocalGetLanguage(void);/*StandardLanguage値を返します*/</PRE>
<P>このルーチンは、ユーザマシンの言語を返します。</P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGetMeasurementType()"></A>
        <H1 CLASS="refHeading">LocalGetMeasurementType()</H1>
<PRE CLASS="syntax">MeasurementTypes LocalGetMeasurementType(ボイド)</PRE>
<P>このルーチンは、US測定システムとメートル法測定システムの間のユーザー設定を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGetNumericFormat()"></A>
        <H1 CLASS="refHeading">LocalGetNumericFormat()</H1>
<PRE CLASS="syntax">void LocalGetNumericFormat(LocalNumericFormat*buf)</PRE>
<P>このルーチンは、ユーザーが使用する数値の書式を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalGetQuotes()"></A>
        <H1 CLASS="refHeading">LocalGetQuotes()</H1>
<PRE CLASS="syntax">void LocalGetQuotes(LocalQuotes*引用);</PRE>
<P>このルーチンは、ユーザーが希望する引用符を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalIsDateChar()"></A>
        <H1 CLASS="refHeading">LocalIsDateChar()</H1>
<PRE CLASS="syntax">ブーリアンLocalIsDateChar(単語ch);</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が日付または時刻の一部である可能性がある場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalIsDosChar()"></A>
        <H1 CLASS="refHeading">LocalIsDosChar()</H1>
<PRE CLASS="syntax">ブーリアンLocalIsDosChar(単語ch);</PRE>
<P>このルーチンは<EM>真</EM>渡された文字がDOS文字セットの一部である場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalIsNumChar()"></A>
        <H1 CLASS="refHeading">LocalIsNumChar()</H1>
<PRE CLASS="syntax">ブーリアンLocalIsNumChar(単語ch);</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が数値または数値書式の一部である場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalIsSymbol()"></A>
        <H1 CLASS="refHeading">LocalIsSymbol()</H1>
<PRE CLASS="syntax">ブーリアンLocalIsSymbol(単語ch);</PRE>
<P>このルーチンは<EM>真</EM>渡された文字がシンボルの場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_68.htm_IX_LocalIsTimeChar()"></A>
        <H1 CLASS="refHeading">LocalIsTimeChar()</H1>
<PRE CLASS="syntax">ブーリアンLocalIsTimeChar(単語ch);</PRE>
<P>このルーチンは<EM>真</EM>渡された文字が数値であるか、ユーザーの時間書式の一部である場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_69.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalLexicalValue()"></A>
        <H1 CLASS="refHeading">LocalLexicalValue()</H1>
<PRE CLASS="syntax">語LocalLexicalValue(語ch)</PRE>
<P>このルーチンは、渡された文字の字句値を返します。これは、文字列をアルファベット順にソートする場合に便利です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalLexicalValueNoCase()"></A>
        <H1 CLASS="refHeading">LocalLexicalValueNoCase()</H1>
<PRE CLASS="syntax">語LocalLexicalValueNoCase(語ch)</PRE>
<P>このルーチンは、渡された文字の大文字と小文字を区別しない字句値を返します。これは、文字列をアルファベット順にソートしようとする場合に便利です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalParseDateTime()"></A>
        <H1 CLASS="refHeading">LocalParseDateTime()</H1>
<PRE CLASS="syntax">Boolean LocalParseDateTime(/*失敗時にFALSEを返す*/const char*str, DateTimeFormat format, TimerDateAndTime*dateTime);</PRE>
<P>このルーチンは、日付または時刻を表す文字列(「9:37」など)を受け取り、渡されたフォーマットを使用して解析します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalSetCurrencyFormat()"></A>
        <H1 CLASS="refHeading">LocalSetCurrencyFormat()</H1>
<PRE CLASS="syntax">void LocalSetCurrencyFormat(const LocalCurrencyFormat*buf, const char*symbol);</PRE>
<P>このルーチンは、保存されている優先通貨書式を変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalSetDateTimeFormat()"></A>
        <H1 CLASS="refHeading">LocalSetDateTimeFormat()</H1>
<PRE CLASS="syntax">void datetime(const char*str, LocalSetDateTimeFormat時刻形式);</PRE>
<P>このルーチンは、保存されている優先日時形式を変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalSetMeasurementType()"></A>
        <H1 CLASS="refHeading">LocalSetMeasurementType()</H1>
<PRE CLASS="syntax">空隙LocalSetMeasurementType(MeasurementTypesの面積)</PRE>
<P>このルーチンは、保存されている優先測定タイプを変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalSetNumericFormat()"></A>
        <H1 CLASS="refHeading">LocalSetNumericFormat()</H1>
<PRE CLASS="syntax">void LocalSetNumericFormat(const LocalNumericFormat*buf);</PRE>
<P>このルーチンは、保存されている優先数値書式を変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalSetQuotes()"></A>
        <H1 CLASS="refHeading">LocalSetQuotes()</H1>
<PRE CLASS="syntax">void LocalSetQuotes(const LocalQuotes*quotes);</PRE>
<P>このルーチンは、保存されている優先引用符を変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalStringLength()"></A>
        <H1 CLASS="refHeading">LocalStringLength()</H1>
<PRE CLASS="syntax">word LocalStringLength(const char*str);という文字列を返します。</PRE>
<P>このルーチンは、マルチバイト文字セットの場合でも、NULL終端文字列の長さ(文字数)を返します(NULLはカウントされません)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalStringSize()"></A>
        <H1 CLASS="refHeading">LocalStringSize()</H1>
<PRE CLASS="syntax">word LocalStringSize(const char*str);という文字列を返します。</PRE>
<P>このルーチンは、NULL終端文字列のサイズ(バイト単位)を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalUpcaseChar()"></A>
        <H1 CLASS="refHeading">LocalUpcaseChar()</H1>
<PRE CLASS="syntax">語LocalUpcaseChar(語ch)</PRE>
<P>このルーチンは、渡された文字に対応する大文字があれば、それを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LocalUpcaseString()"></A>
        <H1 CLASS="refHeading">LocalUpcaseString()</H1>
<PRE CLASS="syntax">void LocalUpcaseString(char*str, 単語サイズ);</PRE>
<P>このルーチンは、渡された文字列をすべて大文字に変換します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">localize.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LogAddEntry()"></A>
        <H1 CLASS="refHeading">LogAddEntry()</H1>
<PRE CLASS="syntax">void LogAddEntry(logEntry*logEntry);</PRE>
<P>この関数は、コンタクトログにエントリを追加します。 (Contactログは、ユーザが各連絡先との間で送受信したコールを追跡します。これは、コールをログに記録する機能です)。 この関数は引数として<CODE>ログエントリ</CODE>構造。</P>
<PRE>typedef struct{NameOrNumber LE_number;dword LE_contactID;LogEntryType LE_type;LogEntryDirection LE_direction;dword LE_duration;DateAndTime LE_datetime;LogEntryFlags LE_flags;}LogEntry;</PRE>
<P>通常、この関数は呼び出しごとに2回呼び出されます。1回は呼び出しの開始時に呼び出され、もう1回は呼び出しが完了したときに呼び出されます。</P>
<P>コールの開始時に関数をinvlkingすると<STRONG CLASS="fileName">ログエントリ</STRONG>構造。 に入力します。<CODE>LE番号</CODE>および/または<CODE>LE連絡先ID</CODE>フィールド(連絡先の名前、番号、または<CODE>レコードID</CODE>番号を入力します。<CODE>LEタイプ</CODE>フィールドに、LET_CALL、LET_FAX、LET_SMS、LET_DATA_MAILBOX、LET_DATA_WWW、またはLET_DATA_TELNETのいずれかを指定します。 に入力します。<CODE>LE方向</CODE>フィールドにLED_SENT、LED_RECEIVED、またはLED_MISSEDのいずれかを指定します。 LE_durationはゼロでなければなりません。 に入力します。<CODE>LE_日時</CODE>フィールドに現在の日付と時刻を入力します。 (<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_TimerGetDateAndTime()">TimerGetDateAndTime()</A></CODE>関数はこの情報を返す)。 [<CODE>LEフラグ</CODE>フィールドにのみ表示されます。</P>
<P>ルーチンを呼び出した後は、構造体を保持してください。ルーチンはいくつかのフィールドを埋めます。 次に、コールが完了したら<CODE>LE期間(_D)</CODE>関数をもう一度呼び出します。 の<CODE>LE期間(_D)</CODE>フィールドには、呼び出しの継続時間(秒単位)を指定します。 この時間を計算する方法の1つは<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_TimerGetCount()">TimerGetCount()</A></CODE>コールの開始時と終了時の2回。 終了時間から開始時間を引いて60で割ることで、経過した秒数を計算できます。</P>
<P>この関数をもう一度呼び出すと、プログラムは<CODE>ログエントリ</CODE>構造。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_TimerGetDateAndTime()">TimerGetDateAndTime()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_TimerGetCount()">TimerGetCount()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LogDeleteAllEntries()"></A>
        <H1 CLASS="refHeading">LogDeleteAllEntries()</H1>
<PRE CLASS="syntax">void LogDeleteAllEntries x</PRE>
<P>この関数は、コンタクトログのすべてのエントリを削除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_69.htm_IX_LogDestroy()"></A>
        <H1 CLASS="refHeading">LogDestroy()</H1>
<PRE CLASS="syntax">void LogDestroy x</PRE>
<P>この関数は、コンタクトログのログファイルを削除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
<P> </P>
</DIV>
<HR>
          <A NAME="R_MailboxAck.htm"></A>
        <DIV>
</DIV>

<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxAcknowledgeMessageReceipt()"></A>
        <H1 CLASS="refHeading">MailboxAcknowledgeMessageReceipt()</H1>
<PRE CLASS="syntax">void MailboxAcknowledgeMessageReceipt(MailboxMessage msg)</PRE>
<P>このルーチンは、アプリケーションがメッセージの制御を取得したことをMailboxライブラリに通知します。<EM>メッセージ</EM>ボタンをクリックし<EM>メッセージ</EM>は、この関数が呼び出されたときにのみ、システムの受信トレイから視覚的に削除されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>メールボックスは、アプリケーションを対象としたメッセージを受信すると、そのアプリケーションにメッセージを送信します。<CODE>MSG_META_MAILBOX_NOTIFY_MESSAGE_AVAILABLEというメッセージ</CODE>アプリケーションが<CODE>MailboxAcknowledgeMessageReceipt()</CODE>アプリケーションが終了して再起動すると、メッセージが使用可能であることがアプリケーションに再度通知されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>




<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxBodyReformatted()"></A>
        <H1 CLASS="refHeading">MailboxBodyReformatted()</H1>
<PRE CLASS="syntax">MailboxError MailboxBodyReformatted(MailboxMessage msg、MailboxDataFormat newFormat、MailboxMessageFlags newBodyFlags);</PRE>
<P>このルーチンは、メッセージの表示形式を変更します。<EM>メッセージ</EM>と<EM>新しい書式</EM>をクリックし<CODE>MailboxMessageFlags</CODE><EM>newBodyFlags</EM>いずれかに<CODE>MMF_BODY_DATA_VOLATILE[MMFボディデータ揮発性]</CODE>または<CODE>MMF_DELETE_BODY_AFTER_TRANSMISSION(転送後にボディを削除)</CODE>このルーチンはmsgの内容を変更しません。<EM>メッセージ</EM>の場合<EM>メッセージ</EM>が無効な場合<CODE>MailboxError</CODE>が生成されます。</P>
<P>の<CODE>MailboxDataFormat</CODE>構造は次のようにフォーマットされます。<PRE CLASS = "syntax">typedef struct{word MDF_id;/*GeoworksMailboxDataFormatID*/ManufacturerID MDF_manuf;}MailboxDataFormat;</PRE></P>
<P CLASS="refField"><STRONG>警告:</STRONG><CODE>MailboxBodyReformatted()</CODE>は<EM>メッセージ</EM>インプレイス。 新しい形式でメッセージのコピーを作成するには<CODE>MailboxChangeBodyFormat()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>





<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxChangeBodyFormat()"></A>
        <H1 CLASS="refHeading">MailboxChangeBodyFormat()</H1>
<PRE CLASS="syntax">MailboxError MailboxChangeBodyFormat(MailboxMessage msg、const MailboxChangeBodyFormatArgs*mcbfArgs);</PRE>
<P>このルーチンは、メッセージの形式と本文を置き換えます。<EM>メッセージ</EM>と<EM>mcbfArgs</EM>の場合<EM>メッセージ</EM>が無効であるか、ボディが使用中である場合<CODE>MailboxError</CODE>が生成されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG><CODE>MailboxChangeBodyFormat()</CODE>は、新しいフォーマットでメッセージのコピーを作成するときに使用します。 メッセージをその場で再フォーマットするには<CODE>MailboxBodyReformatted()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_MailboxAck.htm_IX_ MailboxChangeToMailboxDir()"></A>
        <H1 CLASS="refHeading">MailboxChangeToMailboxDir()</H1>
<PRE CLASS="syntax">void MailboxChangeToMailboxDir(void)</PRE>
<P>このルーチンは、アプリケーションの現在の作業ディレクトリを、Mailboxライブラリがメッセージ本文と管理ファイルを保持しているディレクトリに変更します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>これは主に、データドライバとトランスポートドライバでの使用を目的としています。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>




<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxCheckMediumAvailable()"></A>
        <H1 CLASS="refHeading">MailboxCheckMediumAvailable()</H1>
<PRE CLASS="syntax">ブール値MailboxCheckMediumAvailable(mediumType mediumType, word unitNum, MediumUnitType unitType);</PRE>
<P>伝送媒体が<CODE>mediumタイプ</CODE>が存在する場合、このルーチンは<CODE>真</CODE>(ゼロ以外)。それ以外の場合は<CODE>偽</CODE>(ゼロ)。 Mailboxライブラリは、異なるメディアの出入りを制御することができないため、現在存在するメディアが後に存在するという保証はない。</P>
<P><STRONG>次に例を示します。</STRONG>モデムPCMCIAカードが挿入されている場合は、DATA_MODEMメディアが使用可能になります(ユニット番号は、モデムに到達できるSERIAL_COMx定数になります)。 PCMCIAカードを取り外すと、そのメディアは使用できなくなります。<CODE>MailboxCheckMediumAvailable()</CODE>戻ります<CODE>偽</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>次の場合<EM>ユニットタイプ</EM>は<CODE>MUT_MEM_BLOCK[MUTメモリブロック]</CODE>(他のデータへのハンドル)、これは、Mailboxライブラリがメモリブロックを解放する責任を負うことを意味する。 この場合、アプリケーションはユニット番号として渡されたハンドルを参照しなくなります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxCheckMediumConnected()"></A>
        <H1 CLASS="refHeading">MailboxCheckMediumConnected()</H1>
<PRE CLASS="syntax">ブール値MailboxCheckMediumConnected(mediumType mediumType, word unitNum, MediumUnitType unitType);</PRE>
<P>指定された伝送媒体上に接続が存在するかどうかをMailboxライブラリに通知したかどうかを確認します。 通常、Mailboxライブラリは接続を制御できないため、この呼び出しが戻った後もメディアが接続されたままになることは保証されません。 このルーチンは、呼び出しの進行中に、メディアが<CODE>メディアタイプ</CODE><EM>mediumタイプ</EM>、ユニット番号<EM>単位数(unitNum)</EM>(無視されるのは<EM>ユニットタイプ</EM>がに設定されている<CODE>MUT_NONE(なし)</CODE>)、および<CODE>MediumUnitType</CODE><EM>ユニットタイプ</EM>接続されていない場合は0を返します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>次の場合<EM>ユニットタイプ</EM>は<CODE>MUT_MEM_BLOCK[MUTメモリブロック]</CODE>(他のデータへのハンドル)、これは、Mailboxライブラリがメモリブロックを解放する責任を負うことを意味する。 この場合、アプリケーションはユニット番号として渡されたハンドルを参照しなくなります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>
 



<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxDeleteMessage()"></A>
        <H1 CLASS="refHeading">MailboxDeleteMessage()</H1>
<PRE CLASS="syntax">void MailboxDeleteMessage(MailboxMessage msg)</PRE>
<P>このルーチンは、メッセージを自由に削除できることをMailboxライブラリに通知します。<EM>メッセージ</EM>このルーチンは、アプリケーションが<CODE>MailboxAcknowledgeMessageReceipt()</CODE>メッセージの処理が完了したことを確認します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxDoneWithBody()"></A>
        <H1 CLASS="refHeading">MailboxDoneWithBody()</H1>
<PRE CLASS="syntax">void MailboxDoneWithBody(MailboxMessage msg, const void*appRef, word appRefSize);</PRE>
<P>このルーチンは、ボディリファレンスが<EM>appRef</EM>の以前の呼び出しで返された<CODE>MailboxGetBodyRef()</CODE>が使用されなくなるため、データドライバはファイルを自由に閉じることができます。<EM>appRef</EM>メッセージの本文を指す<EM>メッセージ</EM>、および<EM>appRefSize</EM>は、このボディのサイズをバイト単位で示します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンを呼び出した後は<EM>appRef</EM>してもよい。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>







<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxDoneWithVMFile()"></A>
        <H1 CLASS="refHeading">MailboxDoneWithVMFile()</H1>
<PRE CLASS="syntax">空のMailboxDoneWithVMFile(VMFileHandleファイル)</PRE>
<P>アプリケーションがファイルを使用して完了したことをメールボックスに通知<EM>やすり</EM>、から返されたパラメータ<CODE>MailboxGetVMFile()</CODE>Mailboxライブラリは自由に閉じることができます。<EM>やすり</EM>このルーチンが呼び出された後。<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxFreeDriver()"></A>
        <H1 CLASS="refHeading">MailboxFreeDriver()</H1>
<PRE CLASS="syntax">void MailboxFreeDriver(GeodeHandle driverHandle)</PRE>
<P>このルーチンは、ドライバをアンロードします。<EM>ドライバハンドル</EM>以前にMailboxライブラリによってロードされています。 への呼び出しが<CODE>MailboxLoad.ドライバ()</CODE>への呼び出しでバランスをとる必要があります<CODE>MailboxFreeDriver()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>MailboxLoadDataDriver()</CODE>
          <BR>
          <CODE>MailboxLoadDataDriverWithError()</CODE>
          <BR>
          <CODE>MailboxLoadTransportDriver()</CODE>
        </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>




<DIV>
          <A NAME="R_MailboxAck.htm_IX_MailboxGetAdminFile()"></A>
        <H1 CLASS="refHeading">MailboxGetAdminFile()</H1>
<PRE CLASS="syntax">VMFileHandle MailboxGetAdminFile(ボイド)</PRE>
<P>Mailboxライブラリによって維持されているメイン管理VMファイルのハンドルを返します。</P>
<P CLASS = "refField"><STRONG>警告:</STRONG>返されるファイルは<STRONG>しない</STRONG>データの一般的な保存に使用されます。 このルーチンは、アプリケーションがメッセージを登録する際に<CODE>MailboxSendControl</CODE>をクリックして<CODE>データ変換</CODE>ドライバがadminファイル内に何かが割り当てられることを期待している場合は、選択したトランスポートドライバが必要とする引数。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<HR>
<P>
          <EM>このドキュメントはベータ版です。 自分の責任で乗ってください。<A HREF="#mailto:isv-feedback@geoworks.com">メール送信</A>皆様のご意見・ご提案</EM>
        </P>
          <A NAME="R_MailboxGetBodyFormat.htm"></A>
        <DIV>




<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetBodyFormat()"></A>
        <H1 CLASS="refHeading">MailboxGetBodyFormat()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetBodyFormat(MailboxMessage msg, MailboxDataFormat*dataFormat);</PRE>
<P>このルーチンは<CODE>MailboxDataFormat</CODE>メッセージのトークン<EM>メッセージ</EM>コピーして<EM>データ形式</EM>を返します。<CODE>MailboxError</CODE>ルーチンが無効な場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_ MailboxGetBodyMboxRefBlock()"></A>
        <H1 CLASS="refHeading">MailboxGetBodyMboxRefBlock()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetBodyMboxRefBlock(MailboxMessage msg、MemHandle*mboxRefHandle);</PRE>
<P>メッセージのメッセージ本文への不透明なメールボックス参照を取得する<EM>メッセージ</EM>ブロックに保存します。<EM>mboxRefHandle</EM>この返されたブロックには、データドライバに固有のメールボックス参照構造が含まれます。 次に例を示します。<PRE>/*VMChainsを使用するメールボックスデータドライバの場合*/typedef{dword VMTMR_vmChain;TCHAR VMTMR_filename[];}VMTreeMboxRef;/*生のデータファイルを使用するメールボックスデータドライバの場合*/typedef{Boolean FMR_deleteAfterTransmit;word FMR_diskDataOffset;word FMR_diskDataLen;word FMR_filenameLen;byte FMR_filenameAndDiskData[];/*NULL終端されたファイル名の先頭、*その後にdiskData(*FMR_diskDataOffset)が続く */}FileDDMboxRef</PRE>ルーチンは以下を返します。<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>メッセージが無効な場合、または<CODE>メモリ不足</CODE>データのブロックを作成できなかった場合。</P>
<P CLASS="refField"><STRONG>注:</STRONG>このルーチンは通常、アプリケーションではなく、メールボックスドライバによって使用されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetBodyRef()"></A>
        <H1 CLASS="refHeading">MailboxGetBodyRef()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetBodyRef(MailboxMessage msg、void*appRefBuf、word*appRefBufSize);</PRE>
<P>このルーチンは、メッセージのメッセージ本文のアドレスを取得します。<EM>メッセージ</EM>Mailboxライブラリにメッセージを登録するアプリケーションによって理解され、使用されるフォーマットでは、app-reference。 アプリケーション参照構造の定義は、さまざまな通信方法のそれぞれのドキュメントで定義されています。<EM>例:</EM><A HREF="../../Nokia9000/SMS/index.htm">SMSの章</A>このボディへの参照がバッファにコピーされます。<EM>appRefBuf</EM>ボタンをクリックし<EM>appRefBufSize</EM>は、最初にこのバッファのサイズをバイト単位で示し、次にバッファにコピーされたバイト数を設定します。 エラーが発生した場合(<EM>メッセージ</EM>が無効である、ライブラリがドライバをロードできない、メモリが不足している、app-refバッファが小さすぎる、使用可能なメッセージ本文がない)a<CODE>MailboxError</CODE>が生成されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンへの各呼び出しは<CODE>MailboxDoneWithBody()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>





<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetDestApp()"></A>
        <H1 CLASS="refHeading">MailboxGetDestApp()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetDestApp(MailboxMessage msg、GeodeToken*tokenBuf);</PRE>
<P>を取得します。<CODE>GeodeToken</CODE>メッセージからの宛先アプリケーションの<EM>メッセージ</EM>コピーして<EM>tokenBuf</EM>このルーチンは<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>渡されたMailboxMessageが無効な場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetEndBound()"></A>
        <H1 CLASS="refHeading">MailboxGetEndBound()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetEndBound(MailboxMessage msg, FileDateAndTime*dateTime);</PRE>
<P>メッセージの終わりの境界を取得します<EM>メッセージ</EM>コピーして<EM>日時</EM>メッセージが無効な場合、このルーチンはを返します。<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>MailboxGetStartBound()</CODE>
        </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetFirstMediumUnit()"></A>
        <H1 CLASS="refHeading">MailboxGetFirstMediumUnit()</H1>
<PRE CLASS="syntax">word MailboxGetFirstMediumUnit(mediumType mediumType, MediumUnitType*unitType);</PRE>
<P>指定されたオブジェクトの最初に使用可能な単位を<CODE>メディアタイプ</CODE><EM>mediumタイプ</EM>に<EM>ユニットタイプ</EM>これは、トランスポートドライバが特定のメディアを使用したいだけで、どのメディアを使用しても構わない場合に使用します。 このルーチンはユニット番号を返します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>ユニット番号を使用しないメディアに対しては、これを呼び出さないでください。 エラー・チェックを行うバージョンでは致命的なエラーが発生し、エラー・チェックを行わないバージョンでは追加情報が得られません(戻り値は<CODE>MUT_NONE(なし)</CODE>利用可能なユニットがあるかどうかにかかわらず)。 使用(Use)<CODE>MailboxCheckMediumAvailable()</CODE>見出しページを開きます。 また、次の場合にも注意してください。<EM>ユニットタイプ</EM>は他のメモリへのハンドルである。<CODE>MUT_MEM_BLOCK[MUTメモリブロック]</CODE>の場合、関連するメモリブロックを解放するのはユーザーの責任となります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetMessageFlags()"></A>
        <H1 CLASS="refHeading">MailboxGetMessageFlags()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetMessageFlags(MailboxMessageメッセージ、MailboxMessageFlags*旗);</PRE>
<P>を取得します。<CODE>MailboxMessageFlags</CODE>メッセージの<EM>メッセージ</EM>コピーして<EM>フラグふらぐ</EM>メッセージが無効な場合は<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>見出しページを開きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetNumTransAddrs()"></A>
        <H1 CLASS="refHeading">MailboxGetNumTransAddrs()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetNumTransAddrs(MailboxMessageメッセージ、ワード*numAddresses);</PRE>
<P>メッセージにバインドされているトランスポートアドレスの数を取得します。<EM>メッセージ</EM>その数を<EM>numAddresses</EM>の場合<EM>メッセージ</EM>が受信トレイにある場合<EM>numAddressess</EM>はゼロに設定されます。 アドレスの数を取得できない場合、ルーチンはを返します。<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>MailboxGetTransAddr()</CODE>
        </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetStartBound()"></A>
        <H1 CLASS="refHeading">MailboxGetStartBound()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetStartBound(MailboxMessage msg, FileDateAndTime*dateTime);</PRE>
<P>メッセージの開始境界をフェッチします<EM>メッセージ</EM>コピーして<EM>日時</EM>メッセージが無効な場合、このルーチンはを返します。<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>MailboxGetEndBound()</CODE>
        </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetStorageType()"></A>
        <H1 CLASS="refHeading">MailboxGetStorageType()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetStorageType(MailboxMessageメッセージ、MailboxStorage*ストレージ)</PRE>
<P>このルーチンは<CODE>MailboxStorage</CODE>メッセージのトークン<EM>メッセージ</EM>コピーして<EM>貯蔵</EM>メッセージが無効な場合は<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>見出しページを開きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetSubjectBlock()"></A>
        <H1 CLASS="refHeading">MailboxGetSubjectBlock()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetSubjectBlock(MailboxMessage msg、MemHandle*subjHandle);</PRE>
<P>メッセージのNULL終端された件名/要約を取得します<EM>メッセージ</EM>それをグローバルメモリブロックにコピーし、関連する<CODE>MemHandle</CODE>に<EM>subjHandle</EM>戻り値<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>条件<EM>メッセージ</EM>が無効であるか<CODE>メモリ不足</CODE>ブロックを作成するのに十分なメモリがない場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetSubjectLMem()"></A>
        <H1 CLASS="refHeading">MailboxGetSubjectLMem()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetSubjectLMem(MailboxMessage msg、MemHandle lmemBlock、ChunkHandle*subjectChunk);</PRE>
<P>メッセージの件名/要約を取得します<EM>メッセージ</EM>ローカルメモリブロックにコピーします。<EM>lmemBlock</EM>をクリックし<CODE>ChunkHandle</CODE>このNULLで終了したサブジェクトの<EM>subjectChunk</EM>戻り値<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>条件<EM>メッセージ</EM>が無効であるか<CODE>メモリ不足</CODE>ブロックを作成するのに十分なメモリがない場合。</P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetTransAddr()"></A>
        <H1 CLASS="refHeading">MailboxGetTransAddr()</H1>
<PRE CLASS="syntax">Boolean MailboxGetTransAddr(MailboxMessage msg, word addrNumber, void*addressBuffer, word*bufSizePtr);</PRE>

<P>このルーチンは<EM>addrNumber</EM>-メッセージからのth番目の転送アドレス<EM>メッセージ</EM>アドレスをにコピーします。<EM>アドレスバッファ</EM>ボタンをクリックし<EM>bufSizePtr</EM>は、最初にバッファのサイズをバイト単位で指す必要があり、ルーチンが正常に動作すれば、実際にコピーされたバイト数が設定される。<EM>アドレスバッファ</EM>である。<EM>addrNumber</EM>は大きすぎるか、メッセージが存在しないため無効です。<EM>bufSizePtr</EM>はゼロに設定されます。 バッファがアドレスを格納するのに十分な大きさでない場合<EM>bufSizePtr</EM>は必要なバイト数に設定される。 このルーチンは0(<CODE>偽</CODE>)エラーが発生した場合はゼロ以外の値を返します。</P>

<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>MailboxGetNumTransAddrs()<BR>MailboxGetUserTransAddrLMem()<BR>MailboxSetTransAddr()</CODE>
        </P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetTransData()"></A>
        <H1 CLASS="refHeading">MailboxGetTransData()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetTransData(MailboxMessage msg, dword*transData);</PRE>

<P>メッセージに登録された32ビット転送データを書き込みます。<EM>メッセージ</EM>に<EM>データ変換</EM>の場合<EM>メッセージ</EM>が無効なメッセージである場合、ルーチンは<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>ボタンをクリックし</P>

<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>MailboxSetTransData()</CODE>
        </P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetUserTransAddrLMem()"></A>
        <H1 CLASS="refHeading">MailboxGetUserTransAddrLMem()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetUserTransAddrLMem(MailboxMessageメッセージ、ワードaddrNumber、MemHandle lmemBlock、ChunkHandle*addrChunk);</PRE>

<P>メッセージからユーザーが読み取り可能なトランスポートアドレスを取得します。 入力パラメータはメッセージです。<EM>メッセージ</EM>、アドレス番号<EM>addrNumber</EM>、lmemブロックのハンドル<EM>lmemBlock</EM>文字列を配置する場所。 このルーチンは、ヌル文字で終わった文字列をこのブロックにコピーし<EM>addrChunk</EM>文字列のチャックを指します。 次の3つのエラーが発生する可能性があります。<EM>addrNumber</EM>は有効ではありません。<CODE>ME_ADDRESS_INVALID(無効なMEアドレス)</CODE>が返されます。<EM>メッセージ</EM>は有効ではありません。<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>が返され、チャンクを作成するのに十分なメモリがない場合は<CODE>メモリ不足</CODE>が返されます。</P>

<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>MailboxGetTransAddr()</CODE>
        </P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<HR>
<P>
          <EM>このドキュメントはベータ版です。 自分の責任で乗ってください。<A HREF="#mailto:isv-feedback@geoworks.com">メール送信</A>皆様のご意見・ご提案</EM>
        </P>
          <A NAME="R_MailboxGetVMFile.htm"></A>
        <DIV>
</DIV>

<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxGetVMFile()"></A>
        <H1 CLASS="refHeading">MailboxGetVMFile()</H1>
<PRE CLASS="syntax">VMFileHandle MailboxGetVMFile(ワードexpectedNumBlocks、ワード*vmStatusp);</PRE>
<P>このルーチンは、データを格納できる書き込み可能なVMファイルのハンドルを取得します。 ファイルはMailboxライブラリによって管理されるため、ファイルに保存されたデータは<CODE>MMF_BODY_DATA_VOLATILE[MMFボディデータ揮発性]</CODE>ボタンをクリックし</P>
<P>
          <STRONG>パラメータ:</STRONG>
        <DL>
<DT>
          <EM>expectedNumBlocks</EM>
        <DD>このパラメータは、ファイルサイズの概算値(ブロック単位)です。 ライブラリはこの推定値を使用して、システムが従来のメモリを使い果たす危険があるほど大きな1つのファイル内のブロックサイズを取得することなく、さまざまなVMファイル間でデータを合理的に割り当てる。 ライブラリは新しいファイルを開始するかどうかを決定する際にかなり慎重であるため、見積もりが不十分でも通常は致命的な問題は発生しません。 それでも、自分のニーズに関する正確な情報を得るために最善を尽くすべきです。 保存するデータの4 Kbごとに1ブロックを要求する必要があります。 たとえば、SMSメッセージに必要なブロックは1つだけです。 次の場合<EM>expectedNumBlocks</EM>が0に設定されている場合は、システムが想定する値が使用されます。<DT>
          <EM>vmStatusp</EM>
        <DD>これは、エラーの場合にエラータイプに設定される単語へのポインタです。</DL>
<P CLASS="refField"><STRONG>戻り値:</STRONG>成功した場合、このルーチンは<CODE>VMFileHandle</CODE>書き込み可能なVMファイルにコピーします。 失敗した場合は<CODE>NullHandle</CODE>およびセット<EM>vmStatusp</EM>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxGetVMFileName()"></A>
        <H1 CLASS="refHeading">MailboxGetVMFileName()</H1>
<PRE CLASS="syntax">void MailboxGetVMFileName(VMFileHandleファイル、FileLongName*namep)</PRE>
<P>VMファイルの名前を取得する<EM>やすり</EM>これは、以前にMailboxライブラリによって開かれていました。 このファイルは、Mailboxライブラリのスプールディレクトリにあります。<EM>名前</EM>は、ファイルの<CODE>FileLongName</CODE>、NULL終端されたファイル名。</P>
<P CLASS="refField"><STRONG>警告:</STRONG><CODE>MailboxGetVMFileName()</CODE>は、主にデータストレージドライバがメッセージの本文への永続的な参照を取得するために使用されます。これは、シャットダウンやファイルのクローズが行われてもファイルハンドルは保持されないためです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxLoadDataDriver()"></A>
        <H1 CLASS="refHeading">MailboxLoadDataDriver()</H1>
<PRE CLASS="syntax">GeodeHandle MailboxLoadDataDriver(MailboxStorage貯蔵、GeodeLoadError*エラー);</PRE>
<P><CODE>MailboxLoadDataDriver()</CODE>指定されたデータストレージドライバをロードします。</P>
<P CLASS="refField">
          <STRONG>パラメータ:</STRONG>
        </P>
<DL>
<DD><EM>貯蔵</EM>は<CODE>MailboxStorage</CODE>要求されたデータ・ストレージ・ドライバーのトークン。<DD><EM>誤り</EM>は<CODE>GeodeLoadError</CODE>ドライバが適切にロードされない場合。</DL>
<P CLASS="refField"><STRONG>戻る:</STRONG>このルーチンが成功すると、ロードされたドライバのハンドルが返されます。 それ以外の場合、エラーは<EM>誤り</EM>ボタンをクリックし</P>
<P>このドライバは、次を使用してアンロードする必要があります。<CODE>MailboxFreeDriver()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxLoadDataDriverWithError()"></A>
        <H1 CLASS="refHeading">MailboxLoadDataDriverWithError()</H1>
<PRE CLASS="syntax">GeodeHandle MailboxLoadDataDriverWithError(MailboxStorage貯蔵、GeodeLoadError*エラー);</PRE>
<P><CODE>MailboxLoadDataDriverWithError()</CODE>指定されたデータストレージドライバをロードします。 ドライバをロードできない場合は、エラーメッセージ<EM>誤り</EM>は、ロードを再試行するオプションとともに、ドライバを使用可能にするようユーザに促すために使用されます。</P>

<P CLASS="refField">
          <STRONG>パラメータ:</STRONG>
        </P>
<DL>
<DD><EM>貯蔵</EM>は<CODE>MailboxStorage</CODE>要求されたデータ・ストレージ・ドライバーのトークン。<DD><EM>誤り</EM>は、ドライバが正しくロードできない場合にユーザに表示される通知文字列を指す必要があります。 次の場合<EM>誤り</EM>がNULLを指している場合、このルーチンは以下のように動作する。<CODE>MailboxLoadDataDriver()</CODE>ボタンをクリックし</DD></DL>
<P><STRONG>戻る:</STRONG>このルーチンが成功すると、ロードされたドライバのハンドルが返されます。 それ以外の場合、エラーは<EM>誤り</EM>ボタンをクリックし</P>
<P>このドライバは、次を使用してアンロードする必要があります。<CODE>MailboxFreeDriver()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxLoadTransportDriver()"></A>
        <H1 CLASS="refHeading">MailboxLoadTransportDriver()</H1>
<PRE CLASS="syntax">GeodeHandle MailboxLoadTransportDriver(MailboxTransportトランスポート、GeodeLoadError*エラー);</PRE>
<P><CODE>MailboxLoadTransportDriver()</CODE>トランスポートドライバに<CODE>MailboxTransport</CODE>トークン<EM>運搬</EM>ドライバのハンドルを返します。 ドライバをロードできない場合は<CODE>GeodeLoadError</CODE>に入れられる<EM>誤り</EM>ボタンをクリックし</P>
<P>ドライバをアンロードするには<CODE>MailboxFreeDriver()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxOpenVMFile()"></A>
        <H1 CLASS="refHeading">MailboxOpenVMFile()</H1>
<PRE CLASS="syntax">VMFileHandle MailboxOpenVMFile(FileLongName*namep, word*vmStatusp);</PRE>
<P>によって以前に返されたVMファイルを再度開きます。<CODE>MailboxGetVMFileName()</CODE>、およびその名前<EM>名前</EM>を通じて取得されました<CODE>MailboxGetVMFileName</CODE>成功した場合、ルーチンは<CODE>VMFileHandle</CODE>に<CODE>VMFile</CODE>エラーが発生した場合、このルーチンは<CODE>NullHandle</CODE>と<CODE>vmStatusp</CODE>適切な<CODE>VMStatus</CODE>値を入力します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンへのすべての呼び出しは<CODE>MailboxDoneWithVMFile()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxPushToMailboxDir()"></A>
        <H1 CLASS="refHeading">MailboxPushToMailboxDir()</H1>
<PRE CLASS="syntax">void MailboxPushToMailboxDir x</PRE>
<P>このルーチンは<CODE>FilePushDir()</CODE>の後に<CODE>MailboxChangeToMailboxDir()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxRegisterMessage()"></A>
        <H1 CLASS="refHeading">MailboxRegisterMessage()</H1>
<PRE CLASS="syntax">MailboxError MailboxRegisterMessage(MailboxRegisterMessageArgs*mrmArgs、MailboxMessage*msg);</PRE>
<P>このルーチンは、システムにメッセージを登録します。 メッセージは、システムがそのメッセージを適切に処理するために必要な情報で構成されます。<CODE>MailboxRegisterMessageArgs</CODE><EM>mrmArgs</EM>、およびメッセージ自体の本文データ<EM>メッセージ</EM>ボディデータは、必要に応じてコピーされるか、または単にシステムによって占有されます。<P>入力の例<CODE>MailboxRegisterMessageArgs</CODE>次のようなさまざまな通信方法について説明する章で<A HREF="../../Nokia9000/SMS/index.htm">SMSの章</A>ボタンをクリックし<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxSetTransAddr()"></A>
        <H1 CLASS="refHeading">MailboxSetTransAddr()</H1>
<PRE CLASS="syntax">MailboxError MailboxSetTransAddr(MailboxMessage msg, word addrNumber, const void*newAddress, word addrSize);</PRE>
<P>の不透明な転送アドレスを設定します。<EM>addrNumber</EM>メッセージの-thアドレス<EM>メッセージ</EM>と<EM>新しいアドレス</EM>をクリックし、既存のものを置き換えます。<EM>addrSzie</EM>は、新しいアドレスバッファのサイズ(バイト単位)です。 このルーチンは<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>条件<EM>メッセージ</EM>が無効であるか<CODE>メモリ不足</CODE>十分なメモリがない場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>新しいアドレスは、その有効アドレスバイトが古いアドレスと異なることはありません。 これはメッセージの任意のリダイレクションを許すことを意図したものではなく、単にトランスポートドライバがアドレスの重要でない部分に特定のアドレスの進捗を記録することを意図したものです。</P>
<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>MailboxGetTransAddr()</CODE>
        </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>



<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxSetTransData()"></A>
        <H1 CLASS="refHeading">MailboxSetTransData()</H1>
<PRE CLASS="syntax">MailboxError MailboxGetTransData(MailboxMessage msg, dword transData);</PRE>
<P>このルーチンは、メッセージに登録されている32ビットトランスポートデータを置き換えます。<EM>メッセージ</EM>と<EM>データ変換</EM>メッセージが無効な場合、ルーチンは<CODE>ME_INVALID_MESSAGE(無効なメッセージ)</CODE>;成功した場合は<CODE>ME_SUCCESS(成功)</CODE>ボタンをクリックし</P>
<P CLASS = "refField"><STRONG>警告:</STRONG>呼び出し側は、前の<CODE>dワード</CODE>これは、Mailboxライブラリが<CODE>データ変換</CODE>、したがって、何を解放する必要があるかを知ることができない。<CODE>データ変換</CODE>dwordは別のを置き換えます。</P>
<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>MailboxGetTransAddr()</CODE>
        </P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>


<DIV>
          <A NAME="R_MailboxGetVMFile.htm_IX_MailboxStealBody()"></A>
        <H1 CLASS="refHeading">MailboxStealBody()</H1>
<PRE CLASS="syntax">MailboxError MailboxStealBody(MailboxMessage msg、void*appRefBuf、word*appRefBufSize);</PRE>
<P>このルーチンは、アプリケーションにメッセージの本文を取得させます。<EM>メッセージ</EM>本文へのapp-referenceを<EM>appRefBuf</EM>各通信モードに対して定義されたアプリケーション参照構造は、その通信モードのドキュメントで定義されています。<EM>例:</EM><A HREF="../../Nokia9000/SMS/index.htm">SMSの章</A>アプリケーションは、このアプリケーション参照に関連付けられたデータを破棄する責任があります。 メッセージ本文がVMファイル内にある場合、アプリケーションは<CODE><A HREF="../../CRef/Routines/R_MailboxAck.htm#IX_MailboxDoneWithVMFile()">MailboxDoneWithVMFile()</A></CODE>体を構成するデータを解放した後です このルーチンのパラメーターは、以下のメッセージです。<EM>メッセージ</EM>、ポインタ<EM>appRefBuf</EM>一つの単語を<EM>appRefBufSize</EM>大きさを示す<EM>appRefBuf</EM>(バイト単位)。<EM>appRefBufSize</EM>に入力されたバイト数が<EM>appRefBuf</EM>ボタンをクリックし<P>表示される可能性のあるエラーは次のとおりです<CODE>ME_INVALID_MESSAGE、ME_NOT_ENOUgh_MEMORY、ME_CANNOT_LOAD_DATA_DRIVER、ME_CANNOT_LOAD_TRANSPORT_DRIVER、ME_APP_REF_BUF_TOO_SMALL、ME_CANNOT_OPEN_MESSAGE_FILE</CODE>および<CODE>ME_CANNOT_READ_MESSAGE_FILE(メッセージファイルを読み取れません)</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メールボックス.h</STRONG>
        </P>
</DIV>

<HR>
          <A NAME="R_6a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_6a.htm_IX_MakeWWFixed()"></A>
        <H1 CLASS="refHeading">MakeWWFixed()</H1>
<PRE CLASS="syntax">WWFixed MakeWWFixed(番号)</PRE>
<P>このマクロは、浮動小数点数または整数を<CODE>WWFixed</CODE>値を入力します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>geos.hを入力します。</P>
</DIV>
<DIV>
          <A NAME="R_6a.htm_IX_malloc()"></A>
        <H1 CLASS="refHeading">関数malloc()</H1>
<PRE CLASS="syntax">void*malloc(size_t blockSize);/*割り当てるバイト数*/</PRE>
<P>の<CODE>関数malloc()</CODE>ファミリーのルーチンが標準Cとの互換性のために提供されている。 geodeが少量の固定メモリを必要とする場合、ルーチンの1つを呼び出すことができます。 カーネルはgeodeの値を満足する固定ブロックを割り当てます。<CODE>関数malloc()</CODE>はこのブロックからメモリを割り当てる。 ブロックがいっぱいになると、別の固定malloc-blockが割り当てられます。 ブロック内のすべてのメモリが解放されると、メモリマネージャは自動的にブロックを解放します。</P>
<P>ジオードが<CODE>関数malloc()</CODE>を呼び出すと、指定されたサイズのメモリセクションがmallocブロックから割り当てられ、メモリの先頭アドレスが返される。 メモリが<EM>しない</EM>はゼロ初期化されます。 要求を満たすことができない場合<CODE>マロック</CODE>はNULLポインタを返す。 メモリは、解放されるまで移動されないことが保証されています(<CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">関数free()</A></CODE>)またはリサイズ(<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">参照):realloc()</A></CODE>)をクリックします。 GEOSがシャットダウンすると、すべての固定ブロックが解放され<CODE>関数malloc()</CODE>が失われました。</P>
<P>固定ブロックの使用が多すぎると、メモリマネージャのパフォーマンスが低下し、システム全体の速度が低下します。 このため、アプリケーションでは<CODE>マロック</CODE>-避けられる可能性がある場合は、家族の習慣。 これらは既存のプログラムの移植を簡単にするためだけに提供されていますが、アプリケーションは代わりにGEOSメモリ管理とLMemルーチンを使用するためにあらゆる努力を払う必要があります。 を使用する必要がある場合は<CODE>マロック</CODE>-家族のルーチン、それらを控えめに使用し、できるだけ早くメモリを解放します。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>別のgeodeのmalloc-blockにメモリを割り当てるには、次の関数を呼び出す。<CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE>ただし、他のgeodeが終了すると、そのブロックは解放されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>で割り当てられたすべてのメモリ<CODE>関数malloc()</CODE>は、GEOSのシャットダウン時に解放されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>stdlib.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3.htm#IX_calloc()">関数calloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">関数free()</A></CODE><CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">参照):realloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6a.htm_IX_ManufacturerFromFormatID"></A>
        <H1 CLASS="refHeading">ManufacturerFromFormatID</H1>
<PRE CLASS="syntax">word ManufacturerFromFormatID(id);ClipboardItemFormatID<EM>イド</EM>;をクリックし</PRE>
<P>このマクロは、ワードサイズの製造者ID(タイプ<CODE>ManufacturerIDs</CODE>)から<CODE>ClipboardInfoFormatID</CODE>引数を指定します。</P>
</DIV>
<HR>
          <A NAME="R_6b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_6b.htm_IX_MemAlloc()"></A>
        <H1 CLASS="refHeading">関数MemAlloc()</H1>
<PRE CLASS="syntax">MemHandle MemAlloc(word byteSize, /*ブロックのサイズ(バイト単位)*/HeapFlags hfFlags, /*ブロックの種類*/HeapAllocFlags haFlags);/*ブロックの割り当て方法*/</PRE>
<P>このルーチンは、グローバルメモリブロックを割り当て、そのエントリをグローバルハンドルテーブルに作成します。 ブロックのプロパティは<CODE>HeapFlags</CODE>ブロックの割り当て方法は<CODE>HeapAllocFlags</CODE>レコード。 以下では、両方のフラグについて説明します。 このルーチンはブロックのハンドルを返します。 ブロックを割り当てられなかった場合は、NULLハンドルを返します。 ブロックサイズは次の偶数段落に切り上げられるため(1段落は16バイトに等しい)、割り当てられるブロックは要求されたサイズよりも大きくなる場合があります。</P>
<P><CODE>HeapFlags</CODE>はブロックのハンドルテーブルエントリに格納されます。 これらは以下のルーチンで検索できます。<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>;一部はルーチンで変更できます。<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE>次のフラグを使用できます。</P>
<DL>
<DT>HF_FIXED[固定]</DT><DD>ブロックは、解放されるまで、グローバルヒープ内のその場所から移動しません。 このフラグがオフの場合、メモリマネージャはロックが解除されている間にブロックを移動できます。 フラグがオンの場合、ブロックはロックされていない可能性があり、HF_DISCARDABLEとHF_SWAPABLEはオフである必要があります。</DD>
<DT>HF_共有可能</DT><DD>ブロックは、ブロックの所有者以外の測地に属するスレッドによってロックされる場合があります。</DD>
<DT>HF_DISCARDABLE[破棄可能]</DT><DD>ロックが解除されると、ブロックは破棄されます。</DD>
<DT>HF_SWAPABLE[スワップ可能]</DT><DD>ロックが解除されると、ブロックは拡張/拡張メモリまたはディスクスワップ領域にスワップされます。</DD>
<DT>HF_LMEM(英語の可能性あり)</DT><DD>ブロックにはローカルメモリヒープが含まれています。 このフラグは<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAllocLMem()">VMAllocLMem()</A></CODE>;アプリケーションはこのフラグを設定する必要はありません。</DD>
<DT>HF_DISCARDED(破棄され</DT><DD>メモリマネージャは、ブロックを破棄すると、このビットをオンにします。 ブロックが再割り当てされると、このビットはオフになります。</DD>
<DT>HF_スワップ</DT><DD>メモリマネージャは、ブロックを拡張メモリまたはディスクスワップ領域にスワップするときに、このビットをオンにします。 ブロックをグローバルヒープにスワップバックするときに、ビットをオフにします。</DD>
</DL>
<P><CODE>HeapAllocFlags</CODE>ブロックの割り当てと初期化の方法を示します。 これらは保存されず、取得することもできません。 フラグの中には<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>次のフラグを使用できます。</P>
<DL>
<DT>HAF_ZERO_INIT(ゼロ初期化)</DT><DD>メモリマネージャは、ブロックをヌルバイトに初期化する必要があります。 このフラグは<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>新しいメモリがゼロ初期化されます。</DD>
<DT>HAF_LOCK[ハーフロック]</DT><DD>メモリマネージャは、割り当て後にブロックをロックする必要があります。 ブロックのアドレスを取得するには<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>このフラグは<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>ボタンをクリックし</DD>
<DT>HAF_NO_ERRエラー</DT><DD>メモリマネージャはエラーを返さないはずです。 ブロックを割り当てられない場合、GEOSはクラッシュします。 このフラグの使用は強く推奨されません。 このフラグは<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>ボタンをクリックし</DD>
<DT>HAF_UI[ユーザインタフェース]</DT><DD>HAF_OBJECT_RESOURCEとHAF_UIの両方が設定されている場合、このブロックはアプリケーションのUIスレッドによって実行されます。</DD>
<DT>HAF読み込み専用</DT><DD>ブロックのデータは変更されません。 デバッガに便利です。</DD>
<DT>HAF_OBJECT_RESOURCEオブジェクトリソース</DT><DD>このブロックはオブジェクトブロックになります。</DD>
<DT>HAFコード</DT><DD>このブロックには、実行可能コードが含まれています。</DD>
<DT>HAF準拠</DT><DD>ブロックにコードが含まれている場合、そのコードは権限の低いエンティティによって実行される可能性があります。 ブロックにデータが含まれている場合、データは権限の低いエンティティによってアクセスまたは変更される可能性があります。</DD>
</DL>
<P>必要に応じて、このルーチンは自動的にヒープを圧縮し、必要なサイズのブロックを割り当てるのに十分な領域を見つけます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">heap.hと入力します</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAllocSetOwner()">MemAllocSetOwner()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6b.htm_IX_MemAllocLMem()"></A>
        <H1 CLASS="refHeading">MemAllocLMem()</H1>
<PRE CLASS="syntax">MemHandle MemAllocLMem(LMemType型,/*LMemブロックの型*/word headerSize);/*ヘッダー構造体のサイズ*/</PRE>
<P>このルーチンは、ローカルメモリブロックの割り当てと初期化を行います。このルーチンを使用すると<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">関数MemAlloc()</A></CODE>の後に<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>使用するヘッダー構造体のサイズと共に、ブロックに格納する内容を示すLMem型を渡します。 ブロックに標準ヘッダを持たせる場合は<CODE>ヘッダーサイズ</CODE>ボタンをクリックし</P>
<P>このルーチンは、ロックされていない、新しく割り当てられたブロックのハンドルを返します。 このブロックには、2つのLMemハンドルと、LMemヒープに割り当てられた64バイトが含まれます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メモリh</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6b.htm_IX_MemAllocSetOwner()"></A>
        <H1 CLASS="refHeading">MemAllocSetOwner()</H1>
<PRE CLASS="syntax">MemHandle MemAllocSetOwner(GeodeHandleオーナー、/*ブロックのオーナーのハンドル*/ワードバイトサイズ、/*ブロックのサイズ(バイト単位)*/HeapFlags hfFlags、/*ブロックのタイプ*/HeapAllocFlags haFlags);/*ブロックの割り当て方法*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">関数MemAlloc()</A></CODE>ただし、作成されたグローバル・メモリー・ブロックの所有者は指定できます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">関数MemAlloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6b.htm_IX_MemDecRefCount()"></A>
        <H1 CLASS="refHeading">MemDecRefCount()</H1>
<PRE CLASS="syntax">void MemDecRefCount(MemHandle mh);/*影響を受けるブロックのハンドル*/</PRE>
<P>このルーチンは、グローバルメモリブロックの参照カウントをデクリメントします(参照カウントはHMに格納されます)。<CODE>その他の情報(_O)</CODE>)をクリックします。 参照カウントが0に達すると<CODE>MemDecRefCount()</CODE>はブロックを解放します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、参照カウントがHMに格納されていることを前提としています。<CODE>その他の情報(_O)</CODE>このルーチンは、ブロックに参照カウントが設定されている場合にのみ使用できます。<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemInitRefCount()">MemInitRefCount()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
</DIV>
<DIV>
          <A NAME="R_6b.htm_IX_MemDeref()"></A>
        <H1 CLASS="refHeading">MemDeref()</H1>
<PRE CLASS="syntax">void*MemDeref(MemHandle mh);/*参照解除するロックされたブロックのハンドル*/</PRE>
<P>このルーチンは1つの引数(グローバルメモリブロックのハンドル)を取り、グローバルヒープ上のブロックのアドレスを返します。 ブロックが破棄された場合、またはハンドルがメモリハンドルでない場合は、ヌルポインタを返します。 この情報は、ブロックのハンドルテーブルエントリを読み取ることによって取得されます。実際にブロックにアクセスする必要はありません。</P>
<P>ハンドルがロックされていない可動ブロックのものである場合<CODE>MemDeref()</CODE>は警告なしでブロックのアドレスを返すが、メモリマネージャはいつでもブロックを移動できるので、アドレスは信頼できない。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>これは、固定されたブロックやロックされたブロックを割り当て<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLock()">MemLock()関数</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、ロックされていない移動可能なブロックを指定した場合、そのブロックがいつでも移動する可能性がある場合でも、警告なしでポインタを返します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_6c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_6c.htm_IX_MemDowngradeExclLock()"></A>
        <H1 CLASS="refHeading">MemDowngradeExclLock()</H1>
<PRE CLASS="syntax">void MemDowngradeExclLock(MemHandle mh);/*影響を受けるブロックのハンドル*/</PRE>
<P>ブロックに排他ロックを持つアプリケーションは、このルーチンを使用してブロックを共有ロックにダウングレードすることができます。 それ以外の場合は、ブロックには影響しません。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
</DIV>
<DIV>
          <A NAME="R_6c.htm_IX_MemFree()"></A>
        <H1 CLASS="refHeading">関数MemFree()</H1>
<PRE CLASS="syntax">void MemFree(MemHandle mh);/*解放するブロックのハンドル*/</PRE>
<P>このルーチンは、グローバルメモリブロックを解放します。 ブロックは、ロックまたはロック解除できます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、他のスレッドがブロックをロックしたかどうかを考慮しません。 不正なハンドルを解放しようとすると、ルーチンで致命的なエラーが発生する可能性があります。</P>
</DIV>
<DIV>
          <A NAME="R_6c.htm_IX_MemGetInfo()"></A>
        <H1 CLASS="refHeading">MemGetInfo()</H1>
<PRE CLASS="syntax">word MemGetInfo(/*返される値は渡されたフラグに依存する*/MemHandle mh, /*情報を取得するブロックのハンドル*/MemGetInfoType info);/*取得する情報のタイプ*/</PRE>
<P><CODE>MemGetInfo()</CODE>は、グローバルメモリブロックに関する情報を取得するための汎用ルーチンである。 この関数は、ブロックのハンドルテーブルエントリを調べることで情報を取得します。実際のブロックにアクセスする必要はありません。 データの1ワードを返します。そのワードの意味は<CODE>MemGetInfoType</CODE>変数が渡されました。 次のタイプを使用できます。</P>
<DL>
<DT>MGITサイズ</DT><DD>戻り値はブロックのサイズ(バイト単位)です。 ブロックは段落の境界に沿って割り当てられるため、最初に要求されたサイズよりも大きくなる場合があります。</DD>
<DT>MGIT_FLAGS_AND_LOCK_COUNT(MGITフラグとロックカウント)</DT><DD>戻り値の上位バイトは現在の<CODE>HeapFlags</CODE>ブロックのレコード 下位バイトは、現在ブロック上にあるロックの数です。</DD>
<DT>MGIT_OWNER_OR_VM_FILE_HANDLE(MGIT_OWNER_OR_VM_FILE_ハンドル)</DT><DD>ブロックがVMファイルの一部である場合、戻り値はVMファイルハンドルです。 それ以外の場合、戻り値は所有スレッドのGeodeHandleになります。</DD>
<DT>MGIT_アドレス</DT><DD>返り値はグローバルヒープ上のブロックのセグメントアドレスで、ブロックが破棄された場合は0を返します。 ブロックがロック解除され、移動可能な場合、アドレスは警告なしに変更されることがあります。 通常<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>が好ましい。</DD>
<DT>MGIT_その他_情報</DT><DD>の値を返します。<CODE>HM_その他の情報</CODE>単語。 この単語は、ハンドルの種類によって使用方法が異なります。</DD>
<DT>MGIT_EXEC_スレッド</DT><DD>このブロックを実行しているスレッドのThreadHandleを返します(存在する場合)。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>警告:</STRONG>ハンドルがグローバルメモリブロックハンドルでない場合、結果は予測できません(ルーチンはハンドルテーブルエントリから不適切なデータを読み取ります)。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyOtherInfo()">MemModifyOtherInfo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleModifyOwner()">HandleModifyOwner()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6c.htm_IX_MemIncRefCount()"></A>
        <H1 CLASS="refHeading">MemIncRefCount()</H1>
<PRE CLASS="syntax">void MemIncRefCount(MemHandle mh);/*影響を受けるブロックのハンドル*/</PRE>
<P>このルーチンは、グローバルメモリブロックの参照カウントをインクリメントします(参照カウントはHMに格納されます)。<CODE>その他の情報(_O)</CODE>)をクリックします。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、参照カウントがHMに格納されていることを前提としています。<CODE>その他の情報(_O)</CODE>このルーチンは、ブロックに参照カウントが設定されている場合にのみ使用できます。<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemInitRefCount()">MemInitRefCount()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
</DIV>
<DIV>
          <A NAME="R_6c.htm_IX_MemInitRefCount()"></A>
        <H1 CLASS="refHeading">MemInitRefCount()</H1>
<PRE CLASS="syntax">void MemInitRefCount(MemHandle mh, /*影響を受けたブロックのハンドル*/ワードカウント);/*初期参照カウント*/</PRE>
<P>このルーチンは、指定されたグローバルメモリブロックの参照カウントを設定します。 渡されたカウントはHMに保存されます。<CODE>その他の情報(_O)</CODE>ブロックのハンドルテーブルエントリのフィールド。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンはHMを上書きします。<CODE>その他の情報(_O)</CODE>見出しページを開きます。 セマフォルーチン(<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>参照カウントルーチンとセマフォルーチンの両方を同じブロックで使用することはできない。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
</DIV>
<HR>
          <A NAME="R_6d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_6d.htm_IX_MemLock()"></A>
        <H1 CLASS="refHeading">MemLock()関数</H1>
<PRE CLASS="syntax">void*MemLock(MemHandle mh);/*ロックするブロックのハンドル*/</PRE>
<P>このルーチンは、グローバルヒープ上のグローバルメモリブロックをロックします。 ブロックがスワップされると、メモリマネージャはそれをグローバルヒープに戻し、ロックカウントを(最大255まで)増加させます。 ロック・カウントがゼロになるまで、ブロックは移動、スワップ、破棄されません。 このルーチンは、ブロックの先頭へのポインタを返します。ブロックが破棄された場合は、ヌルポインタを返します。 ロックせずにブロックのアドレスを取得するには<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>警告:</STRONG>不正なハンドルをロックしようとすると、ルーチンで致命的なエラーが発生する可能性があります。 このルーチンは同期の問題をチェックしません。ブロックが複数のスレッドで使用されている場合は、同期ルーチンを使用する必要があります。</P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG><BR>固定ブロックをロックしないでください。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6d.htm_IX_MemLockExcl()"></A>
        <H1 CLASS="refHeading">MemLockExcl()</H1>
<PRE CLASS="syntax">void*MemLockExcl(MemHandle mh);/*グラブするブロックのハンドル*/</PRE>
<P>複数の異なるスレッドが同じグローバルメモリブロックにアクセスする場合は、データアクセス同期ルーチンを使用する必要があります。<CODE>MemLockExcl()</CODE>このようなルーチンのセットに属しています。 多くの場合、複数のスレッドが同じブロックにアクセスする必要がありますが、ほとんどの場合、ブロックを変更する必要はありません。 複数のスレッドが同じブロックを一度に読み込む場合、どのスレッドも(サイズ変更や書き込みなどによって)ブロックを変更しない限り、同期の問題は発生しません。 ただし、スレッドがブロックを変更する必要がある場合は、その時点で他のスレッドがアクセスできないようにする必要があります。</P>
<P>ルーチン<CODE>MemLockExcl()</CODE><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>、および<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>この状況を利用してください。 ブロックへのアクセスを要求するスレッドのキューを保持します。 ブロックが使用されていない場合、キュー上の最も優先度の高いスレッドが起動されます。そのスレッドが排他アクセスを要求した場合、他のスレッドはアクセスを放棄するまでスリープします(経由<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>)をクリックします。 共有アクセスを要求した場合、ルーチンは共有アクセスを要求した他のすべてのスレッドを呼び起こします。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>)をクリックします。</P>
<P><CODE>MemLockExcl()</CODE>は、ブロックへの排他的アクセスを要求します。 ブロックがアクセスされていない場合、ルーチンはブロックの排他的アクセスを取得し、ブロックをロックし、ブロックのアドレスを返します。 ブロックがアクセスされている場合、ルーチンはアクセスできるようになるまでキューでスリープします。その後、ルーチンはスリープを解除し、ブロックをロックして、そのアドレスを返します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ブロックがアクセスされているかどうかを確認するには、HM<CODE>その他の情報(_O)</CODE>単語(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>)をクリックします。 HMの場合<CODE>その他の情報(_O)</CODE>が1の場合、ブロックはグラブされません。が0の場合、ブロックはグラブされますが、キューに入れられるスレッドはありません。それ以外の場合は、キューに入れられた最初のスレッドのハンドルと等しくなります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックにアクセスするすべてのルーチンが<CODE>MemLockExcl()</CODE>または<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>ルーチンはブロックの<CODE>HM_その他の情報</CODE>変更してはいけません。 ブロックへのアクセスが終了したら、次のコマンドを呼び出してアクセスを中止します。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>スレッドが<CODE>MemLockExcl()</CODE>すでに共有アクセスまたは排他アクセスを持っている場合は、デッドロックします。アクセスが放棄されるまでスリープしますが、スリープ中にアクセスを放棄することはできません。 別のgeodeによって所有され、共有できないブロックを取得しようとすると、このルーチンは致命的なエラーになります。</P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG><BR>使用しない<CODE>MemLockExcl()</CODE>または<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>固定ブロックです ブロックをロックしようとしますが、固定ブロックはロックできません。 代わりに<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>ルーチン。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6d.htm_IX_MemLockFixedOrMovable()"></A>
        <H1 CLASS="refHeading">MemLockFixedOrMovable()</H1>
<PRE CLASS="syntax">void*MemLockFixedOrMovable(void*ptr);/*仮想セグメント*/</PRE>
<P>仮想セグメントが指定された場合、このルーチンはそのセグメントをロックします(移動可能な場合)。 仮想セグメントは、アプリケーションがロックまたは固定と見なすブロックへの不透明なポインタです。メモリマネージャは、実際にロックまたは固定されたブロックを交換し、それらを仮想セグメントとして指定できます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
</DIV>
<DIV>
          <A NAME="R_6d.htm_IX_MemLockShared()"></A>
        <H1 CLASS="refHeading">MemLockShared()</H1>
<PRE CLASS="syntax">void*MemLockShared(MemHandle mh);/*グラブするブロックのハンドル*/</PRE>
<P><CODE>MemLockShared()</CODE>は渡されたブロックへの共有アクセスを要求します。 ブロックがアクセスされていない場合、またはブロックが共有アクセス用に保持されていてキューが空の場合、ルーチンはアクセスを取得してブロックをロックし、ブロックのアドレスを返します。 それ以外の場合は、共有リクエストが呼び起こされるまでキュー上でスリープ状態になり、ブロックをロックしてブロックのアドレスを返します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックにアクセスするすべてのルーチンが<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>または<CODE>MemLockShared()</CODE>ルーチンはブロックのHMを使用します。<CODE>その他の情報(_O)</CODE>変更してはいけません。 ブロックへのアクセスが終了したら、次のコマンドを呼び出してアクセスを中止します。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>スレッドが<CODE>MemLockShared()</CODE>アクセスを放棄するまでスリープ状態になりますが、スリープ中にアクセスを放棄することはできません。 スレッドは、ブロックのサイズ変更や書き込みなど、ブロックを変更する可能性のあるアクションを実行しないように注意する必要があります。 ルーチンはこれを強制しません。 別のgeodeによって所有され、共有できないブロックを取得しようとすると、このルーチンは致命的なエラーになります。</P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG><BR>使用しない<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>または<CODE>MemLockShared()</CODE>固定ブロックです ブロックをロックしようとしますが、固定ブロックはロックできません。 代わりに<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>ルーチン。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_6e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_6e.htm_IX_MemModifyFlags()"></A>
        <H1 CLASS="refHeading">MemModifyFlags()</H1>
<PRE CLASS="syntax">void MemModifyFlags(MemHandle mh, /*変更するブロックのハンドル*/HeapFlags bitsToSet, /*オンにするHeapFlags*/HeapFlags bitsToClear);/*オフにするHeapFlags*/</PRE>
<P><CODE>MemModifyFlags()</CODE>は<CODE></CODE><CODE>HeapFlags</CODE>グローバルメモリのレコード<CODE></CODE>ブロックが指定されました。 ブロックの作成後にすべてのフラグを変更できるわけではありません。<CODE></CODE>HF_SHARABLE、HF_DISCARDABLE、HF_SWAPABLE、およびHF_LMEMは変更できます。</P>
<P>このルーチンは、指定されたブロックのハンドルテーブルエントリを使用します。実際のブロックを参照する必要はありません。 このルーチンは、ブロックがロックされているか、固定されているか、または破棄されているかどうかにかかわらず、正常に実行されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>警告:</STRONG>ハンドルがグローバルメモリハンドルでない場合、結果は予測できません。ルーチンはハンドルテーブルエントリの不適切なビットを変更します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleModifyOwner()">HandleModifyOwner()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyOtherInfo()">MemModifyOtherInfo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6e.htm_IX_MemModifyOtherInfo()"></A>
        <H1 CLASS="refHeading">MemModifyOtherInfo()</H1>
<PRE CLASS="syntax">void MemModifyOtherInfo(MemHandle mh, /*修正するブロックのハンドル*/word otherInfo);/*HM_otherInfo wordの新しい値*/</PRE>
<P>このルーチンを使用して、グローバル・メモリ・ブロックのHMの値を変更します。<CODE>その他の情報(_O)</CODE>単語。 一部のブロックでは、この単語をそのままにしておく必要があります。たとえば、データ・アクセス同期ルーチンではこの単語が使用されます。 オブジェクトブロックは、このスペースを使用して、間接費計算スレッドのハンドルを格納します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleModifyOwner()">HandleModifyOwner()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6e.htm_IX_MemOwner()"></A>
        <H1 CLASS="refHeading">MemOwner()</H1>
<PRE CLASS="syntax">GeodeHandle MemOwner(MemHandle mh);/*照会されたブロックのハンドル*/</PRE>
<P>このルーチンは、渡されたブロックを所有するgeodeを返します。 ブロックがVMファイルに属している場合、VMファイルの所有者が返されます(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>これはVMファイルハンドルを返します)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
</DIV>
<DIV>
          <A NAME="R_6e.htm_IX_MemPLock()"></A>
        <H1 CLASS="refHeading">MemPLock()</H1>
<PRE CLASS="syntax">void*MemPLock(MemHandle mh);/*ロックするブロックのハンドル*/</PRE>
<P>複数の異なるスレッドが同じグローバルメモリブロックにアクセスする場合は、それらのスレッドのアクティビティが競合しないことを確認する必要があります。 その方法は、同期ルーチンを使用してブロックの制御を取得することです。<CODE>MemPLock()</CODE>は、一連の同期ルーチンの一部です。</P>
<P>スレッドが<CODE>MemPLock()</CODE>その後、スレッドが問題のブロックへのアクセスを必要とするときはいつでも<CODE>MemPLock()</CODE>このルーチンは<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>次にブロックをロックし、そのアドレスを返します。 ブロックが破棄されている場合は、ブロックを取得してヌルポインタを返します。その後、ブロックを再割り当てできます。 スレッドがブロックを完了したら、次のようにしてブロックを解放する必要があります。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ブロックがアクセスされているかどうかを確認するには、HM<CODE>その他の情報(_O)</CODE>単語(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>)をクリックします。 HMの場合<CODE>その他の情報(_O)</CODE>が1の場合、ブロックはグラブされません。が0の場合、ブロックはグラブされますが、キューに入れられるスレッドはありません。それ以外の場合は、キューに入れられた最初のスレッドのハンドルと等しくなります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックにアクセスするすべてのスレッドが<CODE>MemPLock()</CODE>および/または<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>ブロックを掴むためです これらのルーチンはHM<CODE>その他の情報(_O)</CODE>このフィールドは変更しないでください。 次のコマンドでブロックを解除します。<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>あなたがそれを終えたとき。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>スレッドが<CODE>MemPLock()</CODE>すでにブロックの制御権を持っている場合は、デッドロックします。<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>はこの競合を回避します。 別のスレッドが所有する共有不可能なブロックを取得しようとすると<CODE>MemPLock()</CODE>致命的なエラーになります。</P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG><BR>使用しない<CODE>MemPLock()</CODE>固定ブロックを持っています ブロックをロックしようとしますが、固定ブロックはロックできません。 代わりに<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE><CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6e.htm_IX_MemPtrToHandle()"></A>
        <H1 CLASS="refHeading">MemPtrToHandle()</H1>
<PRE CLASS="syntax">MemHandle MemPtrToHandle(void*ptr);/*ロックされたブロックへのポインタ*/</PRE>
<P>ロックされたブロックのグローバルハンドルを返すルーチンです。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
</DIV>
<DIV>
          <A NAME="R_6e.htm_IX_MemReAlloc()"></A>
        <H1 CLASS="refHeading">MemReAlloc()</H1>
<PRE CLASS="syntax">MemHandle MemReAlloc(MemHandle mh, /*ブロックのハンドル*/ワードbyteSize, /*ブロックの新しいサイズ*/heapAllocFlags heapAllocFlags);/*ブロックを再割り当てする方法*/</PRE>
<P>このルーチンは、グローバル・メモリ・ブロックを再割り当てします。 これは、ブロックのサイズを変更するために使用できます。また、破棄されたブロックのメモリを再割り当てするためにも使用できます。 ロックされたブロックと固定されたブロックは再割り当てできますが、グローバルヒープ上を移動する可能性があるため、ブロック内のすべてのポインタを調整する必要があります。 ただし、新しいサイズが古いサイズよりも小さい場合、ブロックは移動しないことが保証されます。 ブロックサイズは次の偶数の段落に切り上げられるため(1つの段落は16バイトに等しい)、再割り当てされたブロックは要求されたサイズよりも大きくなる場合があります。 ブロックの拡張を要求したが、これが不可能な場合、ルーチンはNullHandleを返します。</P>
<P>ルーチンには次のレコードが渡されます。<CODE>HeapAllocFlags</CODE>フラグHAF_ZERO_INIT、HAF_LOCK、およびHAF_NO_ERRのみを渡すことができます。</P>
<P>必要に応じて、ルーチンは自動的にヒープを圧縮します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>警告:</STRONG>HAF_LOCKが渡されると、ブロックがこのスレッドによってすでにロックされている場合でも、ロック・カウントが増分されます。 このルーチンは、ブロックが別のスレッドによってロックされているかどうか(別のgeodeに属している可能性があるかどうか)を考慮しません。したがって、ブロックが複数のスレッドによって使用されている場合は、同期ルーチンを使用することが重要です。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">関数MemAlloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_6f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_6f.htm_IX_MemThreadGrab()"></A>
        <H1 CLASS="refHeading">MemThreadGrab()</H1>
<PRE CLASS="syntax">void*MemThreadGrab(MemHandle mh);/*グラブするブロックのハンドル*/</PRE>
<P><CODE>MemThreadGrab()</CODE>と組み合わせて使用します。<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>データ・アクセスの同期を維持します。 複数のスレッドがすべて同じグローバルメモリブロックにアクセスする場合は、データアクセス同期ルーチンを使用して、スレッドのアクティビティが競合しないようにする必要があります。 スレッドが<CODE>MemThreadGrab()</CODE>他のスレッドが問題のブロックをグラブしていない場合、ルーチンは「グラブ・カウント」を増分し、ブロックをロックして、そのアドレスを返します。 これは、呼び出しスレッドがすでにブロックをグラブしている場合でも実行できます。 別のスレッドがブロックを掴んだ場合<CODE>MemThreadGrab()</CODE>は呼び出したスレッドをブロックを取得するためのキューに入れます。<CODE>MemThreadGrab()</CODE>はブロックを取得してロックし、そのアドレスを返します。</P>
<P>ブロックが破棄されている場合は<CODE>MemThreadGrab()</CODE>はブロックを取得し、ヌルポインタを返します。その後、ブロックのメモリを再割り当てできます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックを使用するすべてのスレッドが<CODE>MemThread…………………………………</CODE>(他のデータアクセス同期ルーチンではありません)。 HMを変更しない<CODE>その他の情報(_O)</CODE>ブロックのハンドルテーブルエントリのワード(ルーチンはそのワードをセマフォとして使用する)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>別のgeodeによって所有され、共有できないブロックを取得しようとすると、このルーチンは致命的なエラーになります。</P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG><BR>使用しない<CODE>MemThreadGrab()</CODE>固定ブロックを持っています ブロックをロックしようとしますが、固定ブロックはロックできません。 固定ブロックのデータアクセスの同期が必要な場合は<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>ルーチン。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6f.htm_IX_MemThreadGrabNB()"></A>
        <H1 CLASS="refHeading">MemThreadGrabNB()</H1>
<PRE CLASS="syntax">void*MemThreadGrabNB(MemHandle mh);/*グラブするブロックのハンドル*/</PRE>
<P>これは、以下と組み合わせて使用するデータ同期ルーチンです。<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>とまったく同じです。<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>ただし、別のスレッドがグローバルメモリブロックを持っているためにそれを取得できない場合、ルーチンはブロックする代わりにエラーを返す。</P>
<P>成功した場合<CODE>MemThreadGrabNB()</CODE>はブロックへのポインタを返す。 ブロックが破棄されている場合は、そのブロックを取得してヌルポインタを返します。その後、ブロックのメモリを再割り当てできます。 ブロックが別のスレッドによってグラブされた場合<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>は定数BLOCK_GRABBEDを返す。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ブロックがアクセスされているかどうかを確認するには、HM<CODE>その他の情報(_O)</CODE>単語(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>)をクリックします。 HMの場合<CODE>その他の情報(_O)</CODE>が1の場合、ブロックはグラブされません。が0の場合、ブロックはグラブされますが、キューに入れられるスレッドはありません。それ以外の場合は、キューに入れられた最初のスレッドのハンドルと等しくなります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックを使用するすべてのスレッドが<CODE>MemThread…………………………………</CODE>(他のデータ・アクセス同期ルーチンではなく)ブロックにアクセスするルーチン。 HMを変更しない<CODE>その他の情報(_O)</CODE>ブロックのハンドルテーブルエントリのワード(ルーチンはそのワードをセマフォとして使用する)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>別のgeodeによって所有され、共有できないブロックを取得しようとすると、このルーチンは致命的なエラーになります。</P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG><BR>使用しない<CODE>MemThreadGrabNB()</CODE>固定ブロックを持っています ブロックをロックしようとしますが、固定ブロックはロックできません。 固定ブロックの同期が必要な場合は<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>ルーチン。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_6f.htm_IX_MemThreadRelease()"></A>
        <H1 CLASS="refHeading">MemThreadRelease()</H1>
<PRE CLASS="syntax">void MemThreadRelease(MemHandle mh);/*解放するロックされたブロックのハンドル*/</PRE>
<P>このルーチンを使用して、でグラブしたグローバル・メモリー・ブロックを解放します。<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE>このルーチンは、グラブカウントをデクリメントします。グラブカウントが0に達すると、ブロックのロックを解除します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ブロックがアクセスされているかどうかを確認するには、HM<CODE>その他の情報(_O)</CODE>単語(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>)をクリックします。 HMの場合<CODE>その他の情報(_O)</CODE>が1の場合、ブロックはグラブされません。が0の場合、ブロックはグラブされますが、キューに入れられるスレッドはありません。それ以外の場合は、キューに入れられた最初のスレッドのハンドルと等しくなります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックを使用するすべてのスレッドが<CODE>MemThread…………………………………</CODE>(他のデータ・アクセス同期ルーチンではなく)ブロックにアクセスするルーチン。 HMを変更しない<CODE>その他の情報(_O)</CODE>ブロックのハンドルテーブルエントリのワード(ルーチンはそのワードをセマフォとして使用する)。 ブロックをつかむたびに必ず1回解除してください。各グラブが解除されるまで、ブロックのロックは解除されません。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>正常にグラブされなかったブロックを解放しようとすると、このルーチンは致命的なエラーになります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_70.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_70.htm_IX_MemUnlock()"></A>
        <H1 CLASS="refHeading">MemUnlock()</H1>
<PRE CLASS="syntax">void MemUnlock(MemHandle mh);/*ロック解除するブロックのハンドル*/</PRE>
<P>このルーチンは、指定されたブロックのロック・カウントをデクリメントします。 ロックカウントが0に達すると、ブロックはロック解除されます(移動、スワップ、または破棄できます)。 ロックされていないブロックのロックを解除しないでください。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
</DIV>
<DIV>
          <A NAME="R_70.htm_IX_MemUnlockExcl()"></A>
        <H1 CLASS="refHeading">MemUnlockExcl()</H1>
<PRE CLASS="syntax">void MemUnlockExcl(memHandle mh);/*解放するブロックのハンドル*/</PRE>
<P>スレッドがブロックへのアクセスを取得した場合<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>できるだけ早くブロックを解放する必要があります。 それが完了するまで、他のスレッドは共有アクセスまたは排他アクセスのためにブロックにアクセスできません。 ブロックを解放するには、次のコマンドを呼び出します。<CODE>MemUnlockExcl()</CODE>このルーチンは、ブロックのロックを解除し、スレッドのブロックへのアクセスを解放します。 このブロックに対してキューがある場合、で説明されているように、待機中の最も優先度の高いスレッドが呼び起こされます。<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ブロックがアクセスされているかどうかを確認するには、HM<CODE>その他の情報(_O)</CODE>単語(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>)をクリックします。 HMの場合<CODE>その他の情報(_O)</CODE>が1の場合、ブロックはグラブされません。が0の場合、ブロックはグラブされますが、キューに入れられるスレッドはありません。それ以外の場合は、キューに入れられた最初のスレッドのハンドルと等しくなります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックにアクセスするすべてのルーチンが<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>ルーチンはブロックのHMを使用します。<CODE>その他の情報(_O)</CODE>変更してはいけません。 ブロックがロックされている間にこのルーチンを呼び出します。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>をクリックしてブロックのロックを解除します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>アクセスしていないブロックでこのルーチンを呼び出すと、致命的なエラーが発生する可能性があります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_70.htm_IX_MemUnlockFixedOrMovable()"></A>
        <H1 CLASS="refHeading">MemUnlockFixedOrMovable()</H1>
<PRE CLASS="syntax">void MemUnlockFixedOrMovable(void*ptr);/*仮想セグメント*/</PRE>
<P>このルーチンは、以前にロックされた移動可能な仮想セグメントのロックを解除します。 このルーチンは、通常のロックされたブロックや固定されたブロックでは呼び出さないでください。<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockFixedOrMovable()">MemLockFixedOrMovable()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
</DIV>
<DIV>
          <A NAME="R_70.htm_IX_MemUnlockShared()"></A>
        <H1 CLASS="refHeading">MemUnlockShared()</H1>
<PRE CLASS="syntax">void MemUnlockShared(MemHandle mh);/*解放するブロックのハンドル*/</PRE>
<P>スレッドがブロックへのアクセスを取得した場合<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>できるだけ早くブロックを解放する必要があります。 それまでは、キューからスレッドを呼び起こすことはできません。<CODE>MemUnlockShared()</CODE>このルーチンは<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>ブロックのロックカウントをデクリメントし、スレッドのアクセスを解放します。 他のスレッドがブロックにアクセスしておらず、このブロックのキューがある場合、で説明されているように、待機中の最も優先度の高いスレッドが呼び起こされます。<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ブロックがアクセスされているかどうかを確認するには、HM<CODE>その他の情報(_O)</CODE>単語(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>)をクリックします。 HMの場合<CODE>その他の情報(_O)</CODE>が1の場合、ブロックはグラブされません。が0の場合、ブロックはグラブされますが、キューに入れられるスレッドはありません。それ以外の場合は、キューに入れられた最初のスレッドのハンドルと等しくなります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックにアクセスするすべてのルーチンが<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>これらのルーチンは、ブロックのHM<CODE>その他の情報(_O)</CODE>変更してはいけません。 ブロックがロックされている間にこのルーチンを呼び出します。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>をクリックしてブロックのロックを解除します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>アクセスしていないブロックでこのルーチンを呼び出すと、致命的なエラーが発生する可能性があります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_70.htm_IX_MemUnlockV()"></A>
        <H1 CLASS="refHeading">MemUnlockV()</H1>
<PRE CLASS="syntax">void MemUnlockV(MemHandle mh);/*解放するブロックのハンドル*/</PRE>
<P>このルーチンは、ブロックのロックを解除します。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>を使ってセマフォを解放する。<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>ブロックのセマフォがつかまれてブロックがロックされない限り(通常は<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>ルーチン)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ブロックがアクセスされているかどうかを確認するには、HM<CODE>その他の情報(_O)</CODE>単語(<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>)をクリックします。 HMの場合<CODE>その他の情報(_O)</CODE>が1の場合、ブロックはグラブされません。が0の場合、ブロックはグラブされますが、キューに入れられるスレッドはありません。それ以外の場合は、キューに入れられた最初のスレッドのハンドルと等しくなります。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックにアクセスするすべてのスレッドが<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>の順にクリックして、スレッドにアクセスします これらのルーチンは<CODE></CODE>ん<CODE>その他の情報(_O)</CODE>このフィールドは変更しないでください。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>掴んでいないブロックには使用しないでください。 このルーチンは、ユーザーがスレッドをグラブしたかどうかをチェックするのではなく、単にセマフォーをクリアして戻ります。</P>
<P CLASS="refField"><STRONG>使用しない状況:</STRONG><BR>このルーチンを使用して固定ブロックを解放しないでください。 ブロックのロックを解除しようとします。固定ブロックはロックまたはロック解除できません。 代わりに<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>直接。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE><CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE><CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_70.htm_IX_MemUpgradeSharedLock()"></A>
        <H1 CLASS="refHeading">MemUpgradeSharedLock()</H1>
<PRE CLASS="syntax">void*MemUpgradeSharedLock(MemHandle mh);/*ロックされたブロックのハンドル*/</PRE>
<P>このルーチンは、呼び出し元がMemLockExcl()を使用したかのように、ブロック上の共有ロックを排他ロックにアップグレードします。 他のスレッドがそのブロックへのアクセス権を持っている場合、呼び出し側は、排他的なアクセス権を取得できるようになるまで、アクセスキューでスリープ状態になります。</P>
<P>このルーチンはロックされたブロックのポインタを返します。呼び出し元がキュー内でスリープ状態になると、メモリブロックが呼び出しとアクセスの許可の間を移動する可能性があるためです。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>heap.hと入力します</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemDowngradeExclLock()">MemDowngradeExclLock()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_70.htm_IX_MessageSetDestination()"></A>
        <H1 CLASS="refHeading">MessageSetDestination()</H1>
<PRE CLASS="syntax">void MessageSetDestination(EventHandleイベント、/*変更するイベントのハンドル*/optr dest);/*イベントの新しい宛先*/</PRE>
<P>このルーチンは、渡されたoptrにイベントの宛先を設定します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<HR>
          <A NAME="R_71.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_71.htm_IX_ModemAnswerCall()"></A>
        <H1 CLASS="refHeading">ModemAnswerCall()</H1>
<PRE CLASS="syntax">Boolean ModemAnswerCall(SerialPortNumポート,/*シリアルポート番号*/ModemResultCode*結果);</PRE>
<P>着信データコールに応答します。 接続が確立されている場合は[?]を返し(MRC_OKを<EM>結果#ケッ</EM>)、またはエラーが発生した場合は0以外の値(および[?])。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemAutoAnswer()">ModemAutoAnswer()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_71.htm_IX_ModemAutoAnswer()"></A>
        <H1 CLASS="refHeading">ModemAutoAnswer()</H1>
<PRE CLASS="syntax">Boolean ModemAutoAnswer(SerialPortNumポート,/*シリアルポート番号*/ワード番号_of_rings, ModemResultCode*result);</PRE>
<P>通話に自動的に応答するようにモデムを設定します。 コールを待たずに、モデムを自動応答に設定した後に[?]を返します(MRC_OKを<EM>結果#ケッ</EM>)、またはエラーが発生した場合は0以外の値(および[?])。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンを呼び出すときは、モデムがコマンドモードになっている必要があります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemAnswerCall()">ModemAnswerCall()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_71.htm_IX_ModemClose()"></A>
        <H1 CLASS="refHeading">ModemClose()</H1>
<PRE CLASS="syntax">void port(SerialPortNum ModemClose,/*シリアルポート番号*/StreamLingerMode close_mode);/*ストリームを閉じる方法*/</PRE>
<P>モデム接続に使用されているシリアルポートを閉じます。 使用可能な値<EM>閉じるモード(_M)</EM>STREAM_DISCARDまたはSTREAM_LINGERを含めます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>警告:</STRONG>使用(Use)<CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemHangup()">ModemHangup()</A></CODE>をクリックして既存のコールを切断します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemHangup()">ModemHangup()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_71.htm_IX_ModemDial()"></A>
        <H1 CLASS="refHeading">ModemDial()</H1>
<PRE CLASS="syntax">ModemDialのブール値(SerialPortNumポート、/*シリアルポート番号*/word dial_string_length、const char*dial_string、/*ダイヤルする電話番号*/ModemResultCode*result);</PRE>
<P>モデムのダイヤルコマンドを送信して、指定された番号にダイヤルします。 接続が確立されている場合は[?]を返し(MRC_OKを<EM>結果#ケッ</EM>)、またはエラーが発生した場合は0以外の値(および[?])。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemOpen()">ModemOpen()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_71.htm_IX_ModemFactoryReset()"></A>
        <H1 CLASS="refHeading">ModemFactoryReset()</H1>
<PRE CLASS="syntax">Boolean ModemFactoryReset(SerialPortNumポート,/*シリアルポート番号*/ModemResultCode*結果);</PRE>
<P>モデムを工場出荷時の設定に戻します。 リセットに成功した後、[?]を返します(MRC_OKを<EM>結果#ケッ</EM>)、またはエラーが発生した場合は0以外の値(および[?])。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンを呼び出すときは、モデムがコマンドモードになっている必要があります。</P>
</DIV>
<DIV>
          <A NAME="R_71.htm_IX_ModemHangup()"></A>
        <H1 CLASS="refHeading">ModemHangup()</H1>
<PRE CLASS="syntax">Boolean ModemHangup(SerialPortNumポート,/*シリアルポート番号*/ModemResultCode*結果);</PRE>
<P>既存のデータコールを切断します。 切断に成功した後、[?]を返します(そしてMRC_OKを<EM>結果#ケッ</EM>)、またはエラーが発生した場合は0以外の値(および[?])。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemClose()">ModemClose()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_71.htm_IX_ModemInitModem()"></A>
        <H1 CLASS="refHeading">ModemInitModem()</H1>
<PRE CLASS="syntax">Boolean ModemInitModem(SerialPortNumポート,/*シリアルポート番号*/word init_string_length, const char*init_string, /*初期化文字列*/ModemResultCode*result);</PRE>
<P>modemコマンド文字列でモデムを初期化します。 リード「AT」を供給する必要はない。 初期化に成功した後、[?]を返します(そしてMRC_OKを<EM>結果#ケッ</EM>)、またはエラーが発生した場合は0以外の値(および[?])。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンを呼び出すときは、モデムがコマンドモードになっている必要があります。</P>
</DIV>
<DIV>
          <A NAME="R_71.htm_IX_ModemOpen()"></A>
        <H1 CLASS="refHeading">ModemOpen()</H1>
<PRE CLASS="syntax">Boolean ModemOpen(GeodeHandle drHandle, /*シリアルドライバのハンドル*/SerialPortNumポート,/*シリアルポート番号*/StreamOpenFlagsフラグ,/*ストリームを開く方法*/word input_buffer_size, word output_buffer_size, word timeout);/*timeout if SOF_TIMEOUT*/</PRE>
<P>モデム接続に使用するシリアルポートを開き、モデムをコマンドモードにします。 使用可能な値<EM>フラグふらぐ</EM>はSOF_TIMEOUTとSOF_NOBLOCKです。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemDial()">ModemDial()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_71.htm_IX_ModemReset()"></A>
        <H1 CLASS="refHeading">ModemReset()</H1>
<PRE CLASS="syntax">Boolean ModemReset(SerialPortNumポート,/*シリアルポート番号*/ModemResultCode*結果);</PRE>
<P>コマンドモードに切り替え、モデムをリセットします。 リセットに成功した後、[?]を返します(MRC_OKを<EM>結果#ケッ</EM>)、またはエラーが発生した場合は0以外の値(および[?])。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemFactoryReset()">ModemFactoryReset()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_72.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_72.htm_IX_ModemSetMessageDataNotify()"></A>
        <H1 CLASS="refHeading">ModemSetMessageDataNotify()</H1>
<PRE CLASS="syntax">void port(SerialPortNum ModemSetMessageDataNotify,/*シリアルポート番号*/メッセージメッセージ,/*通知時に送信されるメッセージ*/optr宛先);/*メッセージを受信するオブジェクト*/</PRE>
<P>通話中にモデムからデータを受信したときに送信するメッセージを登録します。 シリアルドライバのデータ通知と同様に、シリアルポートが読み込まれるまで、それ以上の通知は送信されません。 [ストリームが読み込まれるまで?]</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>登録するメッセージのプロトタイプを使用します。</P>
<P>@prototype void MODEM_DATA_NOTIFICATION();と入力します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_72.htm#IX_ModemSetRoutineDataNotify()">ModemSetRoutineDataNotify()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_72.htm_IX_ModemSetMessageEndCallNotify()"></A>
        <H1 CLASS="refHeading">ModemSetMessageEndCallNotify()</H1>
<PRE CLASS="syntax">void port(SerialPortNum ModemSetMessageEndCallNotify,/*シリアルポート番号*/メッセージメッセージ,/*通知時に送信されるメッセージ*/optr宛先);/*メッセージを受信するオブジェクト*/</PRE>
<P>何らかの理由で通話が終了したときに送信するメッセージを登録します。 「登録を解除」するには、NullOptrを渡します。<EM>着側</EM>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>登録するメッセージのプロトタイプを使用します。</P>
<P>@prototype void MODEM_END_CALL_NOTIFICATION();と入力します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>すべてのプラットフォームがこの機能をサポートしているわけではありません。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
</DIV>
<DIV>
          <A NAME="R_72.htm_IX_ModemSetMessageResponseNotify()"></A>
        <H1 CLASS="refHeading">ModemSetMessageResponseNotify()</H1>
<PRE CLASS="syntax">void port(SerialPortNum ModemSetMessageResponseNotify,/*シリアルポート番号*/メッセージメッセージ,/*通知時に送信されるメッセージ*/optr宛先);/*メッセージを受信するオブジェクト*/</PRE>
<P>モデムから応答を受信したとき(モデムがコマンドモードのとき)に送信するメッセージを登録します。 ハンドラが解放する必要があるメモリブロックに応答が渡されます。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>登録するメッセージのプロトタイプを使用します。</P>
<P>@prototype void MODEM_RESPONSE_NOTIFICATION();と入力します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_72.htm#IX_ModemSetRoutineResponseNotify()">ModemSetRoutineResponseNotify()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_72.htm_IX_ModemSetRoutineDataNotify()"></A>
        <H1 CLASS="refHeading">ModemSetRoutineDataNotify()</H1>
<PRE CLASS="syntax">void ModemSetRoutineDataNotify(SerialPortNumポート,/*シリアルポート番号*/ワードデータ,/*コールバックに渡されるデータ*/void_pascal(*NotifyRoutine)(ワードデータ));</PRE>
<P>アクティブコール中にモデムからデータを受信したときに呼び出されるルーチンを登録します。 シリアルドライバのデータ通知と同様に、シリアルポートが読み込まれるまで、それ以上の通知は送信されません。 [ストリームが読み込まれるまで?]</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_72.htm#IX_ModemSetMessageDataNotify()">ModemSetMessageDataNotify()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_72.htm_IX_ModemSetRoutineResponseNotify()"></A>
        <H1 CLASS="refHeading">ModemSetRoutineResponseNotify()</H1>
<PRE CLASS="syntax">void port(SerialPortNum ModemSetRoutineResponseNotify,/*シリアルポート番号*/ワードデータ,/*コールバックに渡されたデータ*/void_pascal(*NotifyRoutine)(ワードデータ,ワードresponseSize, char*応答));</PRE>
<P>モデムから応答を受信したとき(モデムがコマンドモードのとき)に呼び出されるルーチンを登録します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>modemC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_72.htm#IX_ModemSetMessageResponseNotify()">ModemSetMessageResponseNotify()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_73.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_73.htm_IX_NameArrayAdd()"></A>
        <H1 CLASS="refHeading">NameArrayAdd()</H1>
<PRE CLASS="syntax">word NameArrayAdd(optr arr, /*name配列のoptr*/const char*nameToAdd, /*新しい要素の名前*/word nameLength, /*nameの長さ;*name文字列がNULL終端の場合は0を渡す*/</PRE>
<PRE CLASS="syntax">NameArrayAddFlagsフラグ、/*以下で説明*/const void*data);/*このデータを新しい要素にコピー*/</PRE>
<P>このルーチンは、name配列に新しい要素を作成し、渡された名前とデータを新しい要素にコピーします。 渡された名前を持つ要素が存在しない場合<CODE>NameArrayAdd()</CODE>は要素を作成し、そのトークンを返します。 同じ名前の要素がすでに存在する場合、既存の要素の参照カウントが増分され、そのトークンが返されます。 このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <CODE>配列複写</CODE>
        </DT><DD>name配列のoptr。</DD>
<DT><CODE>nameToAdd</DT><DD></CODE>新しい要素の名前。 この文字列にはNULLを含めることができます。</DD>
<DT><CODE>名前の長さ(nameLength</DT><DD></CODE>名前文字列の長さ(バイト単位)。 0を渡すと<CODE>NameArrayAdd()</CODE>は文字列がヌル終端されていると想定します。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>NameArrayAddFlags</CODE>」を参照してください。</DD>
<DT>
          <CODE>データ#データ#</CODE>
        </DT><DD>新しい要素にコピーするデータ。</DD>
</DL>
<P CLASS="refField"><STRONG>構造:</STRONG>引数には<CODE>NameArrayAddFlags</CODE>現在定義されているフラグは1つだけです。</P>
<DL>
<DT>NAAF_SET_DATA_ON_REPLACE(置換時のデータ設定)</DT><DD>指定した名前のエレメントが存在し、このフラグが設定されている場合、渡されたデータは既存のエレメントのデータ領域にコピーされます。 このフラグが設定されていない場合、既存のエレメントは変更されません。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンはname配列のサイズを変更する可能性があるため、LMemヒープへのすべてのポインタが無効になります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
</DIV>
<DIV>
          <A NAME="R_73.htm_IX_NameArrayAddHandles()"></A>
        <H1 CLASS="refHeading">NameArrayAddHandles()</H1>
<PRE CLASS="syntax">dword NameArrayAddHandles(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandle arr, /*名前配列のチャンクハンドル*/const char*nameToAdd, /*新しい要素の名前*/word nameLength, /*名前の長さ;*name文字列がNULL終端の場合は0を渡す*/</PRE>
<PRE CLASS="syntax">NameArrayAddFlagsフラグ、/*以下で説明*/const void*data);/*このデータを新しい要素にコピー*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayAdd()">NameArrayAdd()</A></CODE>ただし、name配列は(optrではなく)グローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンはname配列のサイズを変更する可能性があるため、LMemヒープ内へのすべてのポインタが無効になります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
</DIV>
<DIV>
          <A NAME="R_73.htm_IX_NameArrayChangeName()"></A>
        <H1 CLASS="refHeading">NameArrayChangeName()</H1>
<PRE CLASS="syntax">void length(optr配列,/*名前配列のoptr*/wordトークン,/*変更される要素のトークン*/const char*newName, /*要素の新しい名前*/word nameLength);/*名前のNameArrayChangeName(バイト単位);名前文字列が*NULL終端*の場合は*0を渡す</PRE>
<P>このルーチンは、name配列内の要素の名前を変更します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>新しい名前が古い名前よりも長い場合、チャンクはサイズ変更され、LMemヒープ内へのすべてのポインタが無効になります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
</DIV>
<DIV>
          <A NAME="R_73.htm_IX_NameArrayChangeNameHandles()"></A>
        <H1 CLASS="refHeading">NameArrayChangeNameHandles()</H1>
<PRE CLASS="syntax">dword length(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandle配列,/*名前配列のチャンクハンドル*/wordトークン,/*変更される要素のトークン*/const char*newName, /*要素の新しい名前*/word nameLength);/*名前のNameArrayChangeNameHandles(バイト単位);名前文字列が*NULL終端*の場合は*0を渡す</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayChangeName()">NameArrayChangeName()</A></CODE>ただし、name配列は(optrではなく)グローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>新しい名前が古い名前よりも長い場合、チャンクはサイズ変更され、LMemヒープ内へのすべてのポインタが無効になります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
</DIV>
<DIV>
          <A NAME="R_73.htm_IX_NameArrayCreate()"></A>
        <H1 CLASS="refHeading">NameArrayCreate()</H1>
<PRE CLASS="syntax">ChunkHandle NameArrayCreate(MemHandle mh, /*LMemヒープのグローバルハンドル*/ワードdataSize, /**各要素*/のデータセクションのサイズ</PRE>
<PRE CLASS="syntax">word headerSize);/*ヘッダーのサイズ;デフォルトのヘッダーには*0を渡す*/</PRE>
<P>このルーチンは、指定されたLMemヒープに名前配列を作成します。 これにより<CODE>NameArrayHeader</CODE>新しいチャンクの先頭にある構造。 配列の先頭の前に余分なスペースを残したい場合は、より大きなヘッダサイズを渡すことができます。標準ヘッダを使用したい場合は、ゼロのヘッダサイズを渡します。</P>
<P>配列を作成するときに、各要素のデータ部分のサイズを指定する必要があります。 名前の部分は可変サイズになります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>後に余分なスペースが必要な場合は<CODE>NameArrayHeader</CODE>の場合、独自のヘッダー構造を作成することができます。<CODE>NameArrayHeader</CODE>このヘッダのサイズを<CODE>NameArrayCreate()</CODE>構造体フィールドを介してヘッダー内のデータにアクセスします。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>このルーチンを呼び出す前に、グローバルヒープ上のブロックをロックします(修正されていない場合)。 ヘッダーのサイズを渡す場合は、そのサイズが<CODE>sizeof(NameArrayHeader)</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
</DIV>
<DIV>
          <A NAME="R_73.htm_IX_NameArrayCreateAt()"></A>
        <H1 CLASS="refHeading">NameArrayCreateAt()</H1>
<PRE CLASS="syntax">ChunkHandle NameArrayCreateAt(optr配列,/*このチャンクを名前配列に変換する*/word dataSize, /*各要素のデータセクションのサイズ*/word headerSize);/*ヘッダのサイズ;デフォルトヘッダには0を渡す*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayCreate()">NameArrayCreate()</A></CODE>ただし、要素配列は既存のチャンク内に作成されます。 そのチャンクの内容は破棄されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
<P CLASS="refField"><STRONG>警告:</STRONG>チャンクのサイズが十分でない場合は、サイズが変更されます。 これにより、そのブロック内のチャンクへのすべてのポインタが無効になります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
</DIV>
<DIV>
          <A NAME="R_73.htm_IX_NameArrayCreateAtHandles()"></A>
        <H1 CLASS="refHeading">NameArrayCreateAtHandles()</H1>
<PRE CLASS="syntax">ChunkHandle NameArrayCreateAtHandles(MemHandle mh, /*LMemヒープのグローバルハンドル*/ChunkHandleチャンク,/*配列のチャンク*/ワードdataSize, /*各要素のデータサイズ*/ワードheaderSize);/*ヘッダのサイズ;デフォルトヘッダには*0を渡す*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayCreateAt()">NameArrayCreateAt()</A></CODE>ただし、name配列は(optrではなく)グローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
<P CLASS="refField"><STRONG>警告:</STRONG>チャンクのサイズが十分でない場合は、サイズが変更されます。 これにより、そのブロック内のチャンクへのすべてのポインタが無効になります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
</DIV>
<HR>
          <A NAME="R_74.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_74.htm_IX_NameArrayFind()"></A>
        <H1 CLASS="refHeading">NameArrayFind()</H1>
<PRE CLASS="syntax">word NameArrayFind(optr配列,/*optr to name配列*/const char*nameToFind, /*この名前の要素を検索*/word nameLength, /*name文字列が*NULL終端*の場合は0を渡す</PRE>
<PRE CLASS="syntax">void*returnData);/*データセクションをこの*buffer*にコピーします/</PRE>
<P>このルーチンは、指定された名前のエレメントを検索します。 要素のトークンを返し、そのデータ・セクションを渡されたバッファーにコピーします。 指定された名前のエレメントがない場合、ルーチンはCA_NULL_ELEMENTを返します。 このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <CODE>配列複写</CODE>
        </DT><DD>name配列のoptr。</DD>
<DT><CODE>nameToAdd</DT><DD></CODE>検索する要素の名前。 この文字列にはNULLを含めることができます。</DD>
<DT><CODE>名前の長さ(nameLength</DT><DD></CODE>名前文字列の長さ(バイト単位)。 0を渡すと<CODE>NameArrayFind()</CODE>は文字列がヌル終端されていると想定します。</DD>
<DT>
          <CODE>returnData</CODE>
        </DT><DD>要素のデータセクションがこのバッファに書き込まれます。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
<P CLASS="refField"><STRONG>警告:</STRONG>次のことを確認する必要があります。<CODE>returnData</CODE>bufferは、要素のデータ部分を保持するのに十分な大きさです。そうでない場合、バッファの後のデータは上書きされます。</P>
</DIV>
<DIV>
          <A NAME="R_74.htm_IX_NameArrayFindHandles()"></A>
        <H1 CLASS="refHeading">NameArrayFindHandles()</H1>
<PRE CLASS="syntax">word NameArrayFindHandles(MemHandle mh, /*LMemヒープのハンドル*/ChunkHandle配列,/*名前配列のハンドル*/const char*nameToFind, /*この名前の要素を検索*/word nameLength, /*名前文字列が*NULL終端*の場合は0を渡す</PRE>
<PRE CLASS="syntax">void*returnData);/*データセクションをこの*buffer*にコピーします/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_74.htm#IX_NameArrayFind()">NameArrayFind()</A></CODE>ただし、name配列は(optrではなく)グローバルハンドルとチャンクハンドルで指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>chunkarr.h</P>
</DIV>
<DIV>
          <A NAME="R_74.htm_IX_NEC()"></A>
        <H1 CLASS="refHeading">NEC()社</H1>
<PRE CLASS="syntax">エヌイーシー(<EM>線</EM>)をクリックし</PRE>
<P>このマクロは<EM>ない</EM>-geodeのエラーチェックバージョン。 の<CODE>線</CODE>マクロのパラメータは実際のコード行です。 非ECバージョンのプログラムがコンパイルされると、その行は通常のコード行として扱われます。ECバージョンがコンパイルされると、その行は無視されます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_1e.htm#IX_EC() macro">EC()にて</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>例:ec.h</P>
</DIV>
<DIV>
          <A NAME="R_74.htm_IX_ObjBlockGetOutput()"></A>
        <H1 CLASS="refHeading">ObjBlockGetOutput()</H1>
<PRE CLASS="syntax">optr ObjBlockGetOutput(MemHandle mh);/*対象オブジェクトブロックのハンドル*/</PRE>
<P>このルーチンは、指定されたオブジェクトブロックの出力先オブジェクトセットのoptrを返します。 出力されたオブジェクトは<CODE>OLMBH_出力</CODE>見出しページを開きます。 ブロックに出力セットがない場合は、NullOptrが返されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_74.htm_IX_ObjBlockSetOutput()"></A>
        <H1 CLASS="refHeading">ObjBlockSetOutput()</H1>
<PRE CLASS="syntax">void ObjBlockSetOutput(MemHandle mh, /*対象オブジェクトブロックのハンドル*/optr o);/*新しい出力オブジェクトのoptr*/</PRE>
<P>このルーチンは<CODE>OLMBH_出力</CODE>フィールドに入力します。 optrが渡されました<CODE>○○○○</CODE>はブロックの出力として設定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_74.htm_IX_ObjCompAddChild()"></A>
        <H1 CLASS="refHeading">ObjCompAddChild()</H1>
<PRE CLASS="syntax">void ObjCompAddChild(optr obj, /*親コンポジットのoptr*/optr objToAdd, /*新しい子のoptr*/word flags, /*CompChildFlags*/word masterOffset, /*マスタパーツへのオフセット*/word compOffset, /*マスタパーツのコンポーネントフィールドへのオフセット*/word linkOffset);/*マスタパーツのリンクフィールドへのオフセット*/</PRE>
<P>このルーチンは、指定したオブジェクトを、別の指定したオブジェクトの子としてオブジェクトツリーに追加します。 何も返しません。 通常、このルーチンは使用しません。代わりに、以下の「関連項目」に示すメッセージを使用することになります。 このルーチンのパラメータは次のとおりです。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>親複合オブジェクトのオブジェクト。 親はコンポジットである必要があります。コンポジットでない場合は、エラーが発生します。</DD>
<DT>
          <CODE>objToAdd</CODE>
        </DT><DD>子オブジェクトのoptr。 子には、リンクインスタンスフィールド(<CODE>@リンク</CODE>)をクリックします。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>CompChildFlags</CODE>これらのフラグは、オブジェクトを最初にダーティとマークするかどうか、および親の子リストのどこに新しい子を配置するか(最初、2番目、最後など)を示します。</DD>
<DT><CODE>masterOffset</DT><DD></CODE>親のインスタンス・チャンク内の、マスター・グループのオフセットに対するオフセット。 (親クラスに表示される値は&#39;<CODE>クラス_masterOffset</CODE>の<CODE>ClassStruct</CODE>構造)</DD>
<DT>
          <CODE>compOffset</CODE>
        </DT><DD>親のインスタンス・チャンク内の複合フィールドへのオフセット。</DD>
<DT>
          <CODE>linkOffset</CODE>
        </DT><DD>親のインスタンスチャンク内のリンクフィールドへのオフセット。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、ヒープ上のLMemブロックとObjectブロックのサイズを変更して移動し、それによってすべてのセグメントアドレスとポインタを無効にします。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_VIS_ADD_CHILD(子を追加)</CODE><CODE>MSG_GEN_ADD_CHILD(子を追加)</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_74.htm_IX_ObjCompFindChildByNumber()"></A>
        <H1 CLASS="refHeading">ObjCompFindChildByNumber()</H1>
<PRE CLASS="syntax">optr ObjCompFindChildByNumber(optr obj, /*親のoptr*/単語childToFind, /*ゼロから始まる子番号*/単語masterOffset, /*マスタパーツへのオフセット*/単語compOffset, /*マスタパーツのコンポーネントフィールドへのオフセット*/単語linkOffset);/*マスタパーツのリンクフィールドへのオフセット*/</PRE>
<P>このルーチンは、渡されたオブジェクトの子のoptrを返します。子は、オブジェクトの子リスト内の位置に基づいて指定されます。 このルーチンを使用することはあまりありませんが、代わりに「関連項目」に一覧表示されているメッセージを使用することがあります。 ルーチンのパラメータを以下に示します。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>親オブジェクトのオブジェクト。</DD>
<DT><CODE>childToFind</DT><DD></CODE>検索する子のゼロベースの番号。 たとえば、最初の子のoptrを返すには、0またはCCO_FIRSTを渡します。最後の子のoptrを返すには、CCO_LASTを渡します。</DD>
<DT><CODE>masterOffset</DT><DD></CODE>親のインスタンス・チャンク内の、マスター・グループのオフセットに対するオフセット。 (親クラスに表示される値は&#39;<CODE>クラス_masterOffset</CODE>の<CODE>ClassStruct</CODE>構造)</DD>
<DT>
          <CODE>compOffset</CODE>
        </DT><DD>親のインスタンス・チャンク内の複合フィールドへのオフセット。</DD>
<DT>
          <CODE>linkOffset</CODE>
        </DT><DD>親のインスタンスチャンク内のリンクフィールドへのオフセット。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_GEN_FIND_CHILD(子を検索)</CODE><CODE>MSG_VIS_FIND_CHILD[子を検索]</CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_75.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_75.htm_IX_ObjCompFindChildByOptr()"></A>
        <H1 CLASS="refHeading">ObjCompFindChildByOptr()</H1>
<PRE CLASS="syntax">word ObjCompFindChildByOptr(optr obj, /*親のoptr*/optr childToFind, /*検索する子のoptr*/word masterOffset, /*マスタパーツへのオフセット*/word compOffset, /*マスタパーツのコンポーネントフィールドへのオフセット*/word linkOffset);/*マスタパーツのリンクフィールドへのオフセット*/</PRE>
<P>このルーチンは、optrとその親のoptrを指定して、オブジェクトのゼロベースの子番号を返します。 戻される番号は、親の子リスト内での子の位置を表します。 たとえば、戻り値0は、オブジェクトが親の最初の子であることを示します。 通常、このルーチンは使用しません。代わりに、以下の「関連項目」に示すメッセージを使用することになります。</P>
<P>このルーチンのパラメータを以下に示します。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>親オブジェクトのオブジェクト。</DD>
<DT><CODE>childToFind</DT><DD></CODE>番号が戻される子のoptr。 子が見つからない場合、ルーチンは-1を返します。</DD>
<DT><CODE>masterOffset</DT><DD></CODE>親のインスタンス・チャンク内の、マスター・グループのオフセットに対するオフセット。 (親クラスに表示される値は&#39;<CODE>クラス_masterOffset</CODE>の<CODE>ClassStruct</CODE>構造)</DD>
<DT>
          <CODE>compOffset</CODE>
        </DT><DD>親のインスタンス・チャンク内の複合フィールドへのオフセット。</DD>
<DT>
          <CODE>linkOffset</CODE>
        </DT><DD>親のインスタンスチャンク内のリンクフィールドへのオフセット。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_GEN_FIND_CHILD(子を検索)</CODE><CODE>MSG_VIS_FIND_CHILD[子を検索]</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_75.htm_IX_ObjCompMoveChild()"></A>
        <H1 CLASS="refHeading">ObjCompMoveChild()</H1>
<PRE CLASS="syntax">void ObjCompMoveChild(optr obj, /*親のoptr*/optr objToMove, /*移動する子のoptr*/word flags, /*CompChildFlags*/word masterOffset, /*マスタパーツへのオフセット*/word compOffset, /*マスタパーツのコンポーネントフィールドへのオフセット*/word linkOffset);/*マスタパーツのリンクフィールドへのオフセット*/</PRE>
<P>このルーチンは、指定された子を親の子リスト内に移動します。 このルーチンは、ある親から別の親に子を移動することはありませんが、親の子を再編成できます。 このルーチンを使用することはあまりありませんが、以下の「関連項目」に一覧表示されているメッセージを使用することはよくあります。</P>
<P>このルーチンのパラメータを以下に示します。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>親オブジェクトのオブジェクト。</DD>
<DT>
          <CODE>objToMove</CODE>
        </DT><DD>移動する子のオブジェクトを指定します。 optrが有効な子を指していない場合、動作は未定義であり、エラーが発生する可能性があります。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>CompChildFlags</CODE>子の新しい位置と、リンクをダーティとしてマークするかどうかを示します。</DD>
<DT><CODE>masterOffset</DT><DD></CODE>親のインスタンス・チャンク内の、マスター・グループのオフセットに対するオフセット。 (親クラスに表示される値は&#39;<CODE>クラス_masterOffset</CODE>の<CODE>ClassStruct</CODE>構造)</DD>
<DT>
          <CODE>compOffset</CODE>
        </DT><DD>親のインスタンス・チャンク内の複合フィールドへのオフセット。</DD>
<DT>
          <CODE>linkOffset</CODE>
        </DT><DD>親のインスタンスチャンク内のリンクフィールドへのオフセット。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、LMemおよび/またはオブジェクトブロックにそれらのチャンクを移動またはシャッフルさせ、それによってセグメントアドレスまたはポインタを無効にすることができる。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_GEN_MOVE_CHILD(子の移動)</CODE><CODE>MSG_VIS_MOVE_CHILD[子を移動]</CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_76.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_76.htm_IX_ObjCompProcessChildren()"></A>
        <H1 CLASS="refHeading">ObjCompProcessChildren()</H1>
<PRE CLASS="syntax">Boolean ObjCompProcessChildren(optr obj, /*親のoptr*/optr firstChild, /*処理する最初の子のoptr*/ObjCompCallType stdCallback, /*標準のコールバックタイプ*/void*cbData, /*コールバックに渡されるデータ*/word masterOffset, /*マスタパーツへのオフセット*/word compOffset, /*コンポーネントフィールドへのオフセット*/word linkOffset);/*リンクフィールドへのオフセット*/Boolean_pascal(*callback)(optr parent, optr child, void*cbData));</PRE>
<P>このルーチンは、オブジェクトの子のすべてまたは一部に対して、特定のアクションセットを実行します。 このルーチンを使用することは非常にまれです。通常は、親のすべての子にメッセージを送信する必要があります。 ただし、このルーチンを使用する場合は、影響を受ける子ごとに1回実行されるコールバックルーチンも記述する必要があります。</P>
<P><CODE>ObjCompProcessChildren()</CODE>戻る<CODE>真</CODE>(ゼロ以外)すべての子が処理される前に停止された場合のみ。 これが返されるのは、エラーが発生した場合と、コールバックが<CODE>真</CODE>ボタンをクリックします。</P>
<P>このルーチンのパラメータは次のとおりです。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>子が処理されるコンポジットのoptr。</DD>
<DT>
          <CODE>firstChild(英語の可能性あり</CODE>
        </DT><DD>処理される最初の子のoptr。 このルーチンは、渡された子で開始され、後続のすべての子で継続されます。 ルーチンで取得された、コンポジットの最初の子のoptrを渡します。<CODE><A HREF="../../CRef/Routines/R_74.htm#IX_ObjCompFindChildByNumber()">ObjCompFindChildByNumber()</A></CODE>--すべての子を処理します。</DD>
<DT><CODE>stdCallback</DT><DD></CODE>の値<CODE>ObjCompCallType</CODE>バッファ内のデータが<CODE>CBデータ</CODE>がコールバックルーチンに渡されます。 これらの値については、以下で詳しく説明します。</DD>
<DT>
          <CODE>CBデータ</CODE>
        </DT><DD>データをコールバックルーチンに渡すことができるバッファへのポインタ。 このバッファはコールバックによって変更できます。</DD>
<DT><CODE>masterOffset</DT><DD></CODE>親のインスタンス・チャンク内の、マスター・グループのオフセットに対するオフセット。 (親クラスに表示される値は&#39;<CODE>クラス_masterOffset</CODE>の<CODE>ClassStruct</CODE>構造)</DD>
<DT>
          <CODE>compOffset</CODE>
        </DT><DD>親のインスタンス・チャンク内の複合フィールドへのオフセット。</DD>
<DT>
          <CODE>linkOffset</CODE>
        </DT><DD>親のインスタンスチャンク内のリンクフィールドへのオフセット。</DD>
<DT><CODE>コールバック</DT><DD></CODE>各子に対して1回実行される実際のコールバックルーチンへのポインタ。 コールバックは、geodeの固定メモリにあるはずです。 コールバックルーチンのパラメータと戻り値を以下に示します。</DD>
</DL>
<P>コールバックルーチンは3つのパラメータを受け取り、ブール値を返します。 _pascalと宣言する必要があります。 コールバックの3つのパラメータを次に示します。</P>
<DL>
<DT>
          <CODE>親</CODE>
        </DT><DD>親コンポジットのoptr。</DD>
<DT>
          <CODE>子供</CODE>
        </DT><DD>現在処理されている子のoptr。</DD>
<DT>
          <CODE>CBデータ</CODE>
        </DT><DD>の元の呼び出し元から渡されたバッファへのポインタ<CODE>ObjCompProcessChildren()</CODE>このバッファに実際に何があるかは、元のバッファの値によって異なります。<CODE>sdtCallback</CODE>パラメータ;バッファが保存されず<CODE>ObjCompProcessChildren()</CODE>子の間では、各子は前の子によって変更されたデータを受け取ることができます。</DD>
</DL>
<P>コールバックルーチンは、が指すバッファにアクセスして変更できます。<CODE>CBデータ</CODE>、または子を照会したり、子を破棄する以外の操作を実行したりできます。 次のブール値を返します。<CODE>真</CODE>条件<CODE>ObjCompProcessChildren()</CODE>中止する必要があります。<CODE>偽の</CODE>そうすべきではありません</P>
<P>に渡すことができる値<CODE>ObjCompProcessChildren()</CODE>の<CODE>stdCallback</CODE>タイプの<CODE>ObjCompCallType</CODE>次のいずれかの値を使用して<CODE>CBデータ</CODE>は次の子のコールバックルーチンに渡されます。</P>
<DL>
<DT>OCCT_SAVE_PARAMS_TEST_ABORT</DT><DD>渡されたバッファを保存する<CODE>CBデータ</CODE>各子プロセスを呼び出す前。コールバックが返ってきたらルーチンを中止する。<CODE>真</CODE>ボタンをクリックし</DD>
<DT>OCCT_SAVE_PARAMS_DONT_TEST_ABORT</DT><DD>渡されたバッファを保存する<CODE>CBデータ</CODE>次の子に進む前に、コールバックの戻り値をチェックしないでください。</DD>
<DT>OCCT_DONT_SAVE_PARAMS_TEST_ABORT</DT><DD>バッファを保存しない<CODE>CBデータ</CODE>、コールバックルーチンが戻った場合は中止する<CODE>真</CODE>ボタンをクリックし</DD>
<DT>OCCT_DONT_SAVE_PARAMS_DONT_TEST_ABORT</DT><DD>バッファを保存しない<CODE>CBデータ</CODE>コールバックルーチンの戻り値はチェックしません。</DD>
<DT>OCCT_ABORT_AFTER_FIRST</DT><DD>子プロセスを1つだけ実行した後で処理を中止する(通常は<EM>n番目</EM>子)。</DD>
<DT>OCCT_COUNT_CHILDREN</DT><DD>それぞれを呼び出すのではなく、子の数をカウントします。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>@送信</CODE><CODE>@呼び出し</CODE><CODE>MSG_META_SEND_CLASSED_EVENTイベント</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_76.htm_IX_ObjCompRemoveChild()"></A>
        <H1 CLASS="refHeading">ObjCompRemoveChild()</H1>
<PRE CLASS="syntax">void ObjCompRemoveChild(optr obj, /*親のoptr*/optr objToRemove/*削除する子のoptr*/word flags, /*CompChildFlags*/word masterOffset, /*マスタパーツへのオフセット*/word compOffset, /*マスタパーツのコンポーネントフィールドへのオフセット*/word linkOffset);/*マスタパーツのリンクフィールドへのオフセット*/</PRE>
<P>このルーチンは、指定した子を指定した親コンポジットから削除します。 子はオブジェクトツリーから完全に削除されますが、分離または解放されることはありません。 このルーチンのパラメータを以下に示します。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>親コンポジットのoptr。</DD>
<DT><CODE>objToRemove</DT><DD></CODE>削除する子のoptr。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>CompChildFlags</CODE>操作後に親と子をダーティとしてマークするかどうかを示します。</DD>
<DT><CODE>masterOffset</DT><DD></CODE>親のインスタンス・チャンク内の、マスター・グループのオフセットに対するオフセット。 (親クラスに表示される値は&#39;<CODE>クラス_masterOffset</CODE>の<CODE>ClassStruct</CODE>構造)</DD>
<DT>
          <CODE>compOffset</CODE>
        </DT><DD>親のインスタンス・チャンク内の複合フィールドへのオフセット。</DD>
<DT>
          <CODE>linkOffset</CODE>
        </DT><DD>親のインスタンスチャンク内のリンクフィールドへのオフセット。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
</DIV>
<DIV>
          <A NAME="R_76.htm_IX_ObjDecInteractibleCount()"></A>
        <H1 CLASS="refHeading">ObjDecInteractibleCount()</H1>
<PRE CLASS="syntax">void ObjDecInteractibleCount(MemHandle mh);/*サブジェクトオブジェクトブロック*/</PRE>
<P>このルーチンは、指定されたオブジェクト・ブロックの対話可能カウントをデクリメントします。 最初に次のようにインクリメントせずに、インタラクティブなカウントをデクリメントしないでください。<CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInteractibleCount()">ObjIncInteractibleCount()</A></CODE>表示されているオブジェクトは<CODE>MSG_VIS_CLOSE[表示終了]</CODE>ハンドラ。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInteractibleCount()">ObjIncInteractibleCount()</A></CODE><CODE>MSG_VIS_CLOSE[表示終了]</CODE><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_76.htm_IX_ObjDecInUseCount()"></A>
        <H1 CLASS="refHeading">ObjDecInUseCount()</H1>
<PRE CLASS="syntax">void ObjDecInUseCount(MemHandle mh);/*サブジェクトオブジェクトブロック*/</PRE>
<P>このルーチンは、指定されたオブジェクトブロックの使用中カウントをデクリメントします。 使用中のカウントが0に達すると、ブロックは安全に解放されます。 ブロックの使用中カウントは、次のいずれかの時点で最初にインクリメントしない限り、デクリメントしないでください。<CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInUseCount()">ObjIncInUseCount()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>最初にインクリメントせずに使用中カウントを減分しないこと。 エラーが発生します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInUseCount()">ObjIncInUseCount()</A></CODE><CODE><A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInteractibleCount()">ObjDecInteractibleCount()</A></CODE><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_77.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_77.htm_IX_ObjDeref()"></A>
        <H1 CLASS="refHeading">ObjDeref()</H1>
<PRE CLASS="syntax">void*ObjDeref(optr obj/*参照解除するoptr*/word masterLevel);/*参照解除する特定のマスターレベル*/</PRE>
<P>このルーチンは、指定されたoptrおよびマスター・レベルを参照解除して、メッセージ・パラメータをリセットします。<CODE>自分自身</CODE>多くのルーチンやメッセージが呼び出し側オブジェクトのインスタンスチャンクを移動させる可能性があるため<CODE>自分自身</CODE>パラメータが無効になる場合があります。 2つのパラメータ<CODE>ObjDeref()</CODE>である</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>参照を解除するオブジェクトのoptr。<CODE>オーセルフ</CODE>ボタンをクリックし</DD>
<DT><CODE>masterLevel</DT><DD></CODE>参照解除される部品のマスターレベル。 これは、マスター部品へのオフセットが保存されているインスタンスチャンクへのオフセットです。 以降<CODE>自分自身</CODE>がマスタパートの先頭バイトを指している場合、どのマスタパートを逆参照するかを指定する必要がある。</DD>
</DL>
<P>たとえば、可視オブジェクトが<CODE>VisClass</CODE>インスタンス・データはこのルーチンを次のように呼び出します。</P>
<PRE>pself=ObjDeref(oself, 4);</PRE>
<P>ただし<CODE>ObjDeref1()</CODE>および<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDerefVis()">ObjDerefVis()</A></CODE>表示マスター部品の参照を解除するために存在します。<CODE>ObjDeref2()</CODE>および<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDerefGen()">ObjDerefGen()</A></CODE>Genマスター部品の参照を解除します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref1()">ObjDeref1()</A></CODE><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref2()">ObjDeref2()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_77.htm_IX_ObjDerefHandles()"></A>
        <H1 CLASS="refHeading">ObjDerefHandles()</H1>
<PRE CLASS="syntax">void*ObjDerefHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/word masterLevel);/*参照解除するマスターレベル*/</PRE>
<P>このルーチンは、とまったく同じです。<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>ただし、optrは独立したハンドルとして指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_77.htm_IX_ObjDeref1()"></A>
        <H1 CLASS="refHeading">ObjDeref1()</H1>
<PRE CLASS="syntax">void*ObjDeref1(optr obj);/*参照解除されるオブジェクトのoptr*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>これはオブジェクトの最初のマスタ部分を逆参照します。 可視オブジェクトはこのルーチンを使用する必要があります。<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDerefVis()">ObjDerefVis()</A></CODE>の代わりに<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref2()">ObjDeref2()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_77.htm_IX_ObjDeref1Handles()"></A>
        <H1 CLASS="refHeading">ObjDeref 1ハンドル()</H1>
<PRE CLASS="syntax">void*ObjDeref 1ハンドル(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch,);/*optrのチャンクハンドル部分*/</PRE>
<P>このルーチンは<CODE>ObjDeref1()</CODE>ただし、optrは独立したハンドルとして指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_77.htm_IX_ObjDeref2()"></A>
        <H1 CLASS="refHeading">ObjDeref2()</H1>
<PRE CLASS="syntax">void*ObjDeref2(optr obj);/*参照解除されるオブジェクトのoptr*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>これはオブジェクトの2番目のマスタ部分を逆参照します。 汎用オブジェクトはこのルーチンを使用するか<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDerefGen()">ObjDerefGen()</A></CODE>の代わりに<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref1()">ObjDeref1()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_77.htm_IX_ObjDeref2Handles()"></A>
        <H1 CLASS="refHeading">ObjDeref 2ハンドル()</H1>
<PRE CLASS="syntax">void*ObjDeref2Handles(MemHandle mh,//*optrのハンドル部分*/ChunkHandle ch);/*optrのチャンク部分*/</PRE>
<P>このルーチンは<CODE>ObjDeref2()</CODE>ただし、optrは独立したハンドルとして指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_77.htm_IX_ObjDerefGen()"></A>
        <H1 CLASS="refHeading">ObjDerefGen()</H1>
<PRE CLASS="syntax">void*ObjDerefGen(optr obj);/*参照解除される汎用オブジェクト*/</PRE>
<P>このルーチンは、とまったく同じです。<CODE>ObjDeref2()</CODE>ジェネリックオブジェクトのGenマスター部分の参照を解除します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref2()">ObjDeref2()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_77.htm_IX_ObjDerefVis()"></A>
        <H1 CLASS="refHeading">ObjDerefVis()</H1>
<PRE CLASS="syntax">void*ObjDerefVis(optr obj);/*参照解除される可視オブジェクト*/</PRE>
<P>このルーチンは、とまったく同じです。<CODE>ObjDeref1()</CODE>可視オブジェクトまたは可視実現汎用オブジェクトのVisマスタ部分の参照を解除します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE><CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref1()">ObjDeref1()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_78.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_78.htm_IX_ObjDoRelocation()"></A>
        <H1 CLASS="refHeading">ObjDoRelocation()</H1>
<PRE CLASS="syntax">Boolean ObjDoRelocation(/*戻り値<EM>真</EM>エラーの場合*/ObjRelocationTypeタイプ、/*再配置のタイプ*/MemHandleブロック、/*情報ブロックのハンドル*/void*sourceData、/*再配置のソース*/void*destData);/*再配置された値*/</PRE>
<P>このルーチンは、指定されたwordまたはdword引数を再配置し、移動可能なオブジェクトへのハンドルとポインタを解決するために使用されます。 ほとんどの場合、再配置と再配置解除は、リソースがロード、スワップ、または保存されるときに行われ、ほとんどの場合、これはカーネルによって処理されます。</P>
<P><CODE>ObjDoRelocation()</CODE>は4つのパラメータを取ります。</P>
<DL>
<DT>
          <CODE>種類</CODE>
        </DT><DD>実行する再配置のタイプ(<CODE>RelocationType</CODE>)をクリックします。 これは、次に示す3つの値のいずれかになります。</DD>
<DT>
          <CODE>ブロック(block)</CODE>
        </DT><DD>再配置を含むブロックのハンドル。</DD>
<DT>
          <CODE>ソースデータ</CODE>
        </DT><DD>再配置のソースへのポインタ。このポインタは、ルーチンを呼び出すときに適切な型(wordまたはdword)にキャストされる必要があります。</DD>
<DT>
          <CODE>destData</CODE>
        </DT><DD>返される値へのポインタ。このポインタは、ルーチンが呼び出されたときに適切にキャストされる必要があります。 戻り値の正確な型は<CODE>ソースデータ</CODE>および<CODE>種類</CODE>」を参照してください。</DD>
</DL>
<P>実行される再配置のタイプは、渡されるデータのタイプに影響します。<CODE>ソースデータ</CODE>および<CODE>destData</CODE>再配置タイプはtypeパラメータで渡され、次のいずれかの列挙である必要があります。<CODE>RelocationType</CODE>キーを押します</P>
<DL>
<DT>「再配置ハンドル」(RELOC_RELOC_HANDLE)</DT><DD>再配置は、リソースIDからハンドルに対して行われます。 の<CODE>ソースデータ</CODE>ポインタはword型にキャストされ<CODE>destData</CODE>ポインタをHandle型にキャストする必要があります。</DD>
<DT>「再配置セグメント」(RELOC_RELOC_SEGMENT)</DT><DD>再配置は、リソースIDからセグメント・アドレスに行われます。 の<CODE>ソースデータ</CODE>ポインタはword型にキャストされ<CODE>destData</CODE>ポインタをSegment型にキャストする必要があります。</DD>
<DT>「再配置」(RELOC_RELOC_ENTRY_POINT)</DT><DD>再配置は、リソースIDまたは項目番号のいずれかから項目ポイントに対して行われます。 両方の<CODE>ソースデータ</CODE>ポインタと<CODE>destData</CODE>ポインタをdword型にキャストする必要があります。</DD>
</DL>
<P><CODE>ObjDoRelocation()</CODE>はエラーフラグを返す。<CODE>真</CODE>エラーが発生した場合<CODE>偽の</CODE>そうでなければ。</P>
<P>このルーチンによって実行された再配置は<CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjDoUnRelocation()">ObjDoUnRelocation()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_78.htm_IX_ObjDoUnRelocation()"></A>
        <H1 CLASS="refHeading">ObjDoUnRelocation()</H1>
<PRE CLASS="syntax">Boolean ObjDoUnRelocation(/*戻り値<EM>真</EM>エラーの場合*/ObjRelocationTypeタイプ、/*再配置のタイプ*/MemHandleブロック、/*情報ブロックのハンドル*/void*sourceData、/*再配置のソース*/void*destData);/*再配置された値*/</PRE>
<P>このルーチンは、指定された単語またはdwordをunrelocatesします。 ハンドル、セグメント・アドレス、またはエントリー・ポイントをリソースIDに変換して戻します。 実行される変換は<CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjDoRelocation()">ObjDoRelocation()</A></CODE>詳細については、上記のルーチンを参照してください。</P>
<P><CODE>ObjDoUnRelocation()</CODE>はエラーフラグを返す。<CODE>真</CODE>エラーが発生し<CODE>偽の</CODE>再配置解除が成功した場合。 再配置されていないリソースIDは<CODE>destData</CODE>ポインタ。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjDoRelocation()">ObjDoRelocation()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_78.htm_IX_ObjDuplicateMessage()"></A>
        <H1 CLASS="refHeading">ObjDuplicateMessage()</H1>
<PRE CLASS="syntax">EventHandle ObjDuplicateMessage(EventHandle msg);/*複製するイベント*/</PRE>
<P>このルーチンは、事前に記録されたイベントを複製し、新しいイベントのイベントハンドルを返します。 複製するイベントのハンドルを渡します。 その後、次のようにしてイベントに関する情報を変更できます。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MessageSetDestination()">MessageSetDestination()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_78.htm_IX_ObjDuplicateResource()"></A>
        <H1 CLASS="refHeading">ObjDuplicateResource()</H1>
<PRE CLASS="syntax">MemHandle ObjDuplicateResource(MemHandle blockToDup/*リソースのハンドル;must*<EM>しない</EM>ロードされる*/</PRE>
<PRE CLASS="syntax">GeodeHandleオーナー、/*重複のオーナー*/ThreadHandle burdenThread);/*重複の負担スレッド*/</PRE>
<P>このルーチンは、オブジェクトリソースブロック全体を複製します。 新しいブロックは「保存済みのブロック」リストに追加され、geodeの状態ファイルに保存されます。 通常、これはUIによって使用され、アプリケーションのUIリソースの編集可能なコピーを作成して、適切な状態情報が確実に保存されるようにします。 このルーチンには、次の3つのパラメータがあります。</P>
<DL>
<DT>
          <CODE>blockToDup</CODE>
        </DT><DD>複製するブロックのハンドル。 このブロックは、次の場合にはメモリに常駐させないでください。<CODE>ObjDuplicateResource()</CODE>が呼び出されます。 また、「テンプレート」リソース(UIやアプリケーションによって直接使用されず、このルーチンを介してのみコピーされるリソース)にすることもできます。</DD>
<DT>
          <CODE>オーナー</CODE>
        </DT><DD>新しいブロックの所有者のジオード。 これは、所有するgeodeのgeodeハンドルであるか、呼び出し元のgeodeに所有させるには0である必要があります。 合格した場合<CODE>オーナー</CODE>-1の場合、新しいブロックは元のブロックと同じgeodeによって所有されます。</DD>
<DT>
          <CODE>burdenThread</CODE>
        </DT><DD>ブロックを実行し、そのメッセージを処理するスレッド。 呼び出しスレッドにブロックを実行させるには、これをスレッドハンドルまたは0にする必要があります。 aを渡す<CODE>burdenThread</CODE>が-1の場合、新しいリソースは元のリソースと同じ負荷スレッドを持ちます。</DD>
</DL>
<P><CODE>ObjDuplicateResource()</CODE>は、新しく作成されたブロックのハンドルを返します。このブロックはロック解除され、メモリに存在する場合と存在しない場合があります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjFreeDuplicate()">ObjFreeDuplicate()</A></CODE><CODE>MSG_META_BLOCK_FREE(メタブロック解放)</CODE><CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjLockObjBlock()">ObjLockObjBlock()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_78.htm_IX_ObjEnableDetach()"></A>
        <H1 CLASS="refHeading">ObjEnableDetach()</H1>
<PRE CLASS="syntax">void ObjEnableDetach(optr obj);/*このルーチンを呼び出すオブジェクト*/</PRE>
<P>このルーチンは、以下の場合にオブジェクトのハンドラとして動作します。<CODE>MSG_META_ACKメッセージ</CODE>このハンドラは、確認応答カウントをデクリメントします(<CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncDetach()">ObjIncDetach()</A></CODE>)、カウントが0の場合はデタッチメカニズムが有効になり、オブジェクトを完全にデタッチできます。 デタッチメカニズムは<CODE>メタクラス</CODE>このルーチンを呼び出すことはまずありません。</P>
<P>このルーチンの唯一のパラメータは、呼び出し元のオブジェクトのoptr(<CODE>MSG_META_ACKメッセージ</CODE>、確認応答を送信するオブジェクト)。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、チャンクおよびオブジェクトブロックをサイズ変更および/または移動することができ、それによって、すべてのポインタおよびセグメントアドレスを無効にする。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_META_DETACH(メタデタッチ)</CODE><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitDetach()">ObjInitDetach()</A></CODE><CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncDetach()">ObjIncDetach()</A></CODE><CODE>MSG_META_ACKメッセージ</CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_79.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjFreeChunk()"></A>
        <H1 CLASS="refHeading">ObjFreeChunk()</H1>
<PRE CLASS="syntax">void ObjFreeChunk(optr o);/*解放されるチャンクのoptr*/</PRE>
<P>このルーチンは、渡されたオブジェクトのインスタンスチャンクを解放します。 ただし、オブジェクトがロードされたリソースからのものである場合、オブジェクトのサイズは0に変更され、実際に解放されるのではなくダーティとマークされます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>オブジェクトを安全に解放するには、オブジェクトが完全にデタッチされ、メッセージキューが空である必要があります。 これらはすべて<CODE>MSG_META_DETACH(メタデタッチ)</CODE>および<CODE>MSG_META_OBJ_FREE(メタオブジェクト解放)</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_META_DETACH(メタデタッチ)</CODE><CODE>MSG_META_OBJ_FREE(メタオブジェクト解放)</CODE><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjFreeChunkHandles()"></A>
        <H1 CLASS="refHeading">ObjFreeChunkHandles()</H1>
<PRE CLASS="syntax">void ObjFreeChunkHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch);/*optrのチャンク部分*/</PRE>
<P>このルーチンはObjFreeChunk()と同じで、チャンクはoptrではなくハンドルによって指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjFreeDuplicate()"></A>
        <H1 CLASS="refHeading">ObjFreeDuplicate()</H1>
<PRE CLASS="syntax">void ObjFreeDuplicate(MemHandle mh);/*解放する重複ブロックのハンドル*/</PRE>
<P>このルーチンは、で保存したブロックを解放します。<CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSaveBlock()">ObjSaveBlock()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjDuplicateResource()">ObjDuplicateResource()</A></CODE>複製されたリソースのメモリーハンドルを渡す必要があります。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>複製されたリソース内のすべてのオブジェクトは、ブロック内のオブジェクトにメッセージを送信しようとするものがないことを保証するために、適切にデタッチされる必要があります。 さらに、ブロックの使用中カウントと対話可能カウントは0である必要があります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjDuplicateResource()">ObjDuplicateResource()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSaveBlock()">ObjSaveBlock()</A></CODE><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjFreeMessage()"></A>
        <H1 CLASS="refHeading">ObjFreeMessage()</H1>
<PRE CLASS="syntax">void ObjFreeMessage(EventHandleイベント);/*解放されるイベント*/</PRE>
<P>このルーチンは、イベントハンドルとそれに関連付けられたイベントを解放します。 これがカーネル以外のもので使われることは、たとえあったとしても稀です。 カーネルはこのルーチンを使って、処理された後のイベントを解放します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjFreeObjBlock()"></A>
        <H1 CLASS="refHeading">ObjFreeObjBlock()</H1>
<PRE CLASS="syntax">void ObjFreeObjBlock(MemHandleブロック);/*解放されるオブジェクトブロックのハンドル*/</PRE>
<P>このルーチンは、指定されたオブジェクトブロックを解放します。 最初にブロックの使用中カウントをチェックして、ブロックへの外部参照が保持されているかどうかを確認します。 使用中カウントがゼロ以外の場合<CODE>ObjFreeObjBlock()</CODE>は単にブロックの自動解放ビットを設定してリターンするだけである。ブロックは、使用中のカウントが初めて0になったときに解放される。 使用中のカウントが0(外部参照なし)の場合、ブロックはすぐに解放されます。</P>
<P>渡されたオブジェクトブロックが呼び出しスレッドによって実行されていない場合、操作はオブジェクトブロックのスレッド内のリモート呼び出しによって処理されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjFreeDuplicate()">ObjFreeDuplicate()</A></CODE><CODE>MSG_META_BLOCK_FREE(メタブロック解放)</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjGetFlags()"></A>
        <H1 CLASS="refHeading">ObjGetFlags()</H1>
<PRE CLASS="syntax">ObjChunkFlags ObjGetFlags(optr o);/*対象オブジェクトのoptr*/</PRE>
<P>このルーチンは、指定したオブジェクトに関連付けられたオブジェクトフラグを返します。 オブジェクトは渡されたoptrによって指定され、フラグはオブジェクトの<CODE>ObjChunkFlags</CODE>レコード。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A></CODE><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjChunkFlags">ObjChunkFlags</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjGetFlagsHandles()"></A>
        <H1 CLASS="refHeading">ObjGetFlagsHandles()</H1>
<PRE CLASS="syntax">ObjChunkFlags ObjGetFlagsHandles(Memhandle mh、/*optrのハンドル部分*/ChunkHandle ch);/*optrのチャンク部分*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjGetFlags()">ObjGetFlags()</A></CODE>、オブジェクトはoptrではなくハンドルで指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjGetMessageInfo()"></A>
        <H1 CLASS="refHeading">ObjGetMessageInfo()</H1>
<PRE CLASS="syntax">メッセージObjGetMessageInfo(EventHandleイベント、/*照会されるイベント*/optr*dest);/*宛先optrのバッファ*/</PRE>
<P>このルーチンは、指定された<CODE>事件</CODE>戻り値は、イベントのメッセージ番号です。 の<CODE>宛先</CODE>パラメータはoptrへのポインタである。 このルーチンは、イベントの宛先オブジェクトを表すoptrとともに戻ります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjIncDetach()"></A>
        <H1 CLASS="refHeading">ObjIncDetach()</H1>
<PRE CLASS="syntax">void ObjIncDetach(optr obj);/*呼び出し元オブジェクトのoptr*/</PRE>
<P>このルーチンは、オブジェクトが安全にデタッチできるようになるまでに受信する必要があるデタッチ確認応答の数を増やします。 デタッチしているオブジェクトがデタッチの通知を送信するたびに<CODE>ObjIncDetach()</CODE>対応するデタッチ確認応答(<CODE>MSG_META_ACKメッセージ</CODE>)をクリックします。</P>
<P>呼び出し元のオブジェクトは<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitDetach()">ObjInitDetach()</A></CODE>デタッチメカニズムは<CODE>メタクラス</CODE>このルーチンを呼び出す必要が生じることはほとんどありません。<CODE>ObjIncDetach()</CODE>は、呼び出し元オブジェクトのoptrという1つのパラメータを取ります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_META_DETACH(メタデタッチ)</CODE><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitDetach()">ObjInitDetach()</A></CODE><CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjEnableDetach()">ObjEnableDetach()</A></CODE><CODE>MSG_META_ACKメッセージ</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjIncInteractibleCount()"></A>
        <H1 CLASS="refHeading">ObjIncInteractibleCount()</H1>
<PRE CLASS="syntax">void ObjIncInteractibleCount(MemHandle mh);/*オブジェクトブロックのハンドル*/</PRE>
<P>このルーチンは、指定されたオブジェクト・ブロックの対話可能カウントを増分します。 相互作用可能なカウントは、ユーザに現在見えるオブジェクトの数、またはユーザによって(例えば、キーボードアクセラレータを介して)作用されようとしているオブジェクトの数を維持する。 インタラクティブなカウントはUIによって維持されます。カウントを増減する必要があるのは、非常に特殊な場合だけです。 カウントを減らすには<CODE><A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInteractibleCount()">ObjDecInteractibleCount()</A></CODE>ボタンをクリックし</P>
<P>表示されているオブジェクトは<CODE>MSG_VIS_OPEN[ビューを開く]</CODE>ハンドラを削除し<CODE>MSG_VIS_CLOSE[表示終了]</CODE>ハンドラ。 これは<CODE>VisClass</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInteractibleCount()">ObjDecInteractibleCount()</A></CODE><CODE>MSG_VIS_OPEN[ビューを開く]</CODE><CODE>MSG_VIS_CLOSE[表示終了]</CODE><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_79.htm_IX_ObjIncInUseCount()"></A>
        <H1 CLASS="refHeading">ObjIncInUseCount()</H1>
<PRE CLASS="syntax">void ObjIncInUseCount(MemHandle mh);/*オブジェクトブロックのハンドル*/</PRE>
<P>このルーチンは、指定されたオブジェクトブロックの使用中カウントをインクリメントします。 使用中カウントは、このオブジェクトブロックへの外部参照の数を保持します。外部参照は他の場所に格納され、ブロックを安全に解放する前に削除する必要があります。 optrをオブジェクト・ブロックに保管する場合は、ブロックの使用中カウントを増分する必要があります。</P>
<P>ブロックへの参照が削除されると、使用中のカウントは次のようにデクリメントされます。<CODE><A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInUseCount()">ObjDecInUseCount()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInUseCount()">ObjDecInUseCount()</A></CODE><CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInteractibleCount()">ObjIncInteractibleCount()</A></CODE><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_7a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_7a.htm_IX_ObjInitDetach()"></A>
        <H1 CLASS="refHeading">ObjInitDetach()</H1>
<PRE CLASS="syntax">void ObjInitDetach(MetaMessages msg, optr obj/*分離されるオブジェクト*/word callerID, /*呼び出し側の識別子トークン*/optr ackOD);/*ackが送信されるオブジェクト*/</PRE>
<P>指定したオブジェクトのデタッチシーケンスを初期化します。 デタッチシーケンスは、システムとオブジェクト間のすべての結合を切断し、他のオブジェクトや測地が接続を試みることなく、オブジェクトを破棄できるようにします。 このルーチンを呼び出すことはまずありません。<CODE>MSG_META_DETACH(メタデタッチ)</CODE>または、このルーチンを呼び出す汎用オブジェクト・メッセージまたは可視オブジェクト・メッセージのいずれかです。 このルーチンのパラメータは次のとおりです。</P>
<DL>
<DT>
          <EM>メッセージ</EM>
          <CODE>
        </DT><DD>デタッチメッセージ。</CODE></DD>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>デタッチするオブジェクトのオブジェクト名。</DD>
<DT>
          <CODE>発信者ID</CODE>
        </DT><DD>呼び出し元オブジェクトのID。</DD>
<DT>
          <CODE>ackOD</CODE>
        </DT><DD>デタッチの確認通知を受信する発信側オブジェクトまたは別のオブジェクトのoptr。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_META_DETACH(メタデタッチ)</CODE><CODE>MSG_GEN_DESTROY[メッセージ生成破棄]</CODE><CODE>MSG_VIS_REMOVE[ビュー削除]</CODE><CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncDetach()">ObjIncDetach()</A></CODE><CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjEnableDetach()">ObjEnableDetach()</A></CODE><CODE>MSG_META_ACKメッセージ</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7a.htm_IX_ObjInitializeMaster()"></A>
        <H1 CLASS="refHeading">ObjInitializeMaster()</H1>
<PRE CLASS="syntax">void ObjInitializeMaster(optr obj, /*初期化するオブジェクト*/ClassStruct*クラス);/*マスターグループ内のクラス*/</PRE>
<P>このルーチンは、渡されたオブジェクトの適切なマスタ部分を初期化し、必要に応じてインスタンスチャンクのサイズを変更します。 次の2つのパラメータを取ります。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>マスター・パートを初期化するオブジェクトのoptr。</DD>
<DT>
          <CODE>階級</CODE>
        </DT><DD>該当するマスター・グループ内のクラスのクラス定義へのポインタ。 これはマスタークラスである必要はありません。マスターグループ内のクラスである必要があります。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、チャンクまたはオブジェクトブロックをサイズ変更および/または移動することができ、それによってポインタおよびセグメントアドレスを無効にする。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjResizeMaster()">ObjResizeMaster()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializePart()">ObjInitializePart()</A></CODE><CODE><A HREF="../../CRef/Structs/S_6.htm#IX_ClassStruct">ClassStruct</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7a.htm_IX_ObjInitializeMasterHandles()"></A>
        <H1 CLASS="refHeading">ObjInitializeMasterHandles()</H1>
<PRE CLASS="syntax">void ObjInitializeMasterHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/ClassStruct*クラス);/*マスターグループ内のクラス*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializeMaster()">ObjInitializeMaster()</A></CODE>ただし、optrではなくハンドルを使用してオブジェクトを指定する点が異なります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7a.htm_IX_ObjInitializePart()"></A>
        <H1 CLASS="refHeading">ObjInitializePart()</H1>
<PRE CLASS="syntax">void ObjInitializePart(optr obj, /*初期化されたパートを持つオブジェクト*/word masterOffset);/*チャンク内のマスタオフセットへのオフセット*/</PRE>
<P>このルーチンは、指定されたオブジェクトのすべてのマスタパーツを<CODE>masterOffset</CODE>必要に応じてチャンクのサイズを変更し、必要に応じて指定されたマスターグループより上のバリアントクラスを解決します。 このルーチンには2つのパラメータがあります。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>初期化するオブジェクトのoptr。</DD>
<DT><CODE>masterOffset</DT><DD></CODE>マスター・グループのオフセットに対する親のインスタンス・チャンク内のオフセット(親クラスに表示される値)<CODE>クラス_masterOffset</CODE>の<CODE>ClassStruct</CODE>構造)。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、チャンクまたはオブジェクトブロックを移動および/またはサイズ変更し、それによってポインタおよびセグメントアドレスを無効にすることができる。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjResizeMaster()">ObjResizeMaster()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializeMaster()">ObjInitializeMaster()</A></CODE><CODE>MSG_META_RESOLVE_VARIANT_SUPERCLASS■サービス名の場合■</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7a.htm_IX_ObjInitializePartHandles()"></A>
        <H1 CLASS="refHeading">ObjInitializePartHandles()</H1>
<PRE CLASS="syntax">void ObjInitializePartHandles(Memhandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/word masterOffset);/*マスターグループオフセット*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializePart()">ObjInitializePart()</A></CODE>ただし、optrではなくハンドルを使用してオブジェクトを指定する点が異なります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7a.htm_IX_ObjInstantiate()"></A>
        <H1 CLASS="refHeading">ObjInstantiate()</H1>
<PRE CLASS="syntax">optr ObjInstantiate(MemHandleブロック,/*新しいオブジェクト*がインスタンス化されるブロック*/</PRE>
<PRE CLASS="syntax">ClassStruct*クラス);/*新しいオブジェクトのクラス*/</PRE>
<P>このルーチンは、新しいオブジェクトをインスタンス化し、適切なサイズのインスタンス・チャンクを割り当てます。 新しいオブジェクトのoptrを返します。このoptrは、セットアップメッセージやその他のメッセージ(オブジェクトツリーへのオブジェクトの追加、使用可能なオブジェクトの設定など)の送信に使用できます。</P>
<P>新しいオブジェクトのインスタンスデータは、マスタパーツがない場合(の直接の子孫である場合)、すべてゼロに初期化されます。<CODE>メタクラス</CODE>)をクリックします。 マスター・グループのメンバーである場合は、基本構造(マスター・オフセットとクラス・ポインタ)に十分な領域のみが割り当てられます。 いずれの場合も、インスタンス・データの初期化は後で行われます。</P>
<P><CODE>ObjInstantiate()</CODE>は2つのパラメータを取ります。</P>
<DL>
<DT>
          <CODE>ブロック(block)</CODE>
        </DT><DD>オブジェクトのインスタンスチャンクが割り当てられるオブジェクトブロックのメモリハンドル。 このブロック<EM>しなければならない</EM>呼び出し元のスレッドによって実行される必要はありませんが、オブジェクトブロックです。 ブロックが別のスレッドによって実行されている場合、ルーチンはリモート呼び出しとして実行されます。</DD>
<DT>
          <CODE>階級</CODE>
        </DT><DD>へのポインタ<CODE>ClassStruct</CODE>新しいオブジェクトのクラスの構造。 このポインタは、オブジェクトのクラスポインタ(インスタンスチャンクの最初の4バイト)に設定されます。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは新しいチャンクを割り当てるため、LMemブロックとObjectブロックを移動またはサイズ変更して、ポインタとセグメントアドレスを無効にする場合があります。 このルーチンを呼び出した後は、必ずポインタの参照を解除してください。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiateForThread()">ObjInstantiateForThread()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7a.htm_IX_ObjInstantiateForThread()"></A>
        <H1 CLASS="refHeading">ObjInstantiateForThread()</H1>
<PRE CLASS="syntax">optr ObjInstantiateForThread(ThreadHandleスレッド,/*新しいオブジェクトを実行するスレッド*/ClassStruct*クラス);/*新しいオブジェクトのクラス*/</PRE>
<P>このルーチンは、以下に似ています。<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>ただし、(新規オブジェクトを保管するための)オブジェクト・ブロックへのメモリー・ハンドルではなく、新規オブジェクトを実行するためのスレッドを渡します。 現在のスレッドを指定するには<EM>糸</EM>このルーチンは、必要に応じてメモリブロックを自動的に割り当てます。 新しいオブジェクトにoptrを返します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_7b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjIsClassADescendant()"></A>
        <H1 CLASS="refHeading">ObjIsClassADescendant()</H1>
<PRE CLASS="syntax">ブーリアンObjIsClassADescendant(ClassStruct*クラス1,/*提案された先祖*/ClassStruct*クラス2);/*提案された子孫*/</PRE>
<P>このルーチンは、次のことをチェックします。<CODE>クラス2</CODE>のdescendandである<CODE>クラス1</CODE>戻り値<CODE>真</CODE>です。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjIsObjectInClass()"></A>
        <H1 CLASS="refHeading">ObjIsObjectInClass()</H1>
<PRE CLASS="syntax">Boolean ObjIsObjectInClass(optr obj, /*チェックするオブジェクト*/ClassStruct*クラス);/*提案されたクラス*/</PRE>
<P>このルーチンは、渡されたオブジェクトが指定されたクラスのメンバーであるかどうかをチェックします。 スーパークラスもチェックしますが、未解決のバリアントクラスが検出された場合、バリアントは<EM>しない</EM>解決されます。 過去のバリアントクラスのリンクを検索する場合は<CODE>MSG_META_DUMMY(メタダミー)</CODE>の順にクリックします。 このルーチンの2つのパラメータは、次のとおりです。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>チェックするオブジェクトのオプション。 このルーチンを呼び出す前に、オブジェクトブロックをロックしておく必要があります。 (オブジェクトのブロックがロックされていない可能性がある場合は<A HREF="../../SysObjects/Meta/MetaClass_4.htm#IX_MSG_META_IS_OBJECT_IN_CLASS">MSG_META_IS_OBJECT_IN_CLASS■サービス名の場合■</A>このルーチンを呼び出す代わりに、オブジェクトに対して呼び出します。</DD>
<DT>
          <CODE>階級</CODE>
        </DT><DD>対象クラスへのポインタ&#39;<CODE>ClassStruct</CODE>定義。</DD>
</DL>
<P><CODE>ObjIsObjectInClass()</CODE>戻る<CODE>真</CODE>オブジェクトがクラス内にある場合<CODE>偽の</CODE>(ゼロ)を返します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjIsObjectInClassHandles()"></A>
        <H1 CLASS="refHeading">ObjIsObjectInClassHandles()</H1>
<PRE CLASS="syntax">Boolean ObjIsObjectInClassHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/ClassStruct*クラス);/*提案されたクラス*/</PRE>
<P>このルーチンは次のようなものです。<CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjIsObjectInClass()">ObjIsObjectInClass()</A></CODE>ただし、オブジェクトはoptrではなくハンドルを介して指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjLinkFindParent()"></A>
        <H1 CLASS="refHeading">ObjLinkFindParent()</H1>
<PRE CLASS="syntax">optr ObjLinkFindParent(optr obj, /*子のoptr*/ワードmasterOffset, /*リンクフィールド付きマスタパーツへのオフセット*/ワードlinkOffset);/*リンクフィールドへのマスタパーツ内のオフセット*/</PRE>
<P>このルーチンは、指定されたオブジェクトの親のoptrを返します。 次のものを渡す必要があります。</P>
<DL>
<DT>
          <EM>オブジェクト</EM>
        </DT><DD>親を検索するオブジェクトのオブジェクト番号。</DD>
<DT>
          <CODE>masterOffset</CODE>
        </DT><DD>マスター・グループのオフセットに対するオブジェクトのインスタンス・チャンク内のオフセット(<CODE>クラス_masterOffset</CODE>の<CODE>ClassStruct</CODE>構造)。</DD>
<DT>
          <CODE>linkOffset</CODE>
        </DT><DD>オブジェクトのインスタンスチャンク内のリンクフィールドへのオフセット。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_VIS_FIND_PARENT(親の検索)</CODE><CODE>MSG_GEN_FIND_PARENT(親を検索)</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjLockObjBlock()"></A>
        <H1 CLASS="refHeading">ObjLockObjBlock()</H1>
<PRE CLASS="syntax">void*ObjLockObjBlock(MemHandle mh);/*オブジェクトブロックのハンドル*/</PRE>
<P>このルーチンは、オブジェクトブロックをロックし、必要に応じてブロックをロードします。 これにはブロックのハンドルを渡す必要があり、ロックされたブロックのセグメントアドレスを返します。 呼び出し側がブロックの使用を終了したら、次のようにロックを解除する必要があります。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ブロックの使用が終了したら、必ずロックを解除します。<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLock()">MemLock()関数</A></CODE><CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjMapSavedToState()"></A>
        <H1 CLASS="refHeading">ObjMapSavedToState()</H1>
<PRE CLASS="syntax">VMBlockHandle ObjMapSavedToState(MemHandle mh);/*オブジェクトブロックのハンドル*/</PRE>
<P>このルーチンは、渡されたオブジェクトブロックに対応する状態ファイルブロックのVMブロックハンドルを返します。 指定したオブジェクトブロックに対応する状態ファイルがない場合は、ヌルハンドルが返されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjMapStateToSaved()"></A>
        <H1 CLASS="refHeading">ObjMapStateToSaved()</H1>
<PRE CLASS="syntax">MemHandle ObjMapStateToSaved(VMBlockHandle vmbh, /*州ブロックのVMブロックハンドル*/GeodeHandle gh);/*ジオード所有ブロックのハンドル*/</PRE>
<P>このルーチンは、VMブロックハンドルとgeodeハンドルを受け取り、VMブロックに対応するメモリブロックがあればそれを返します。 次の2つのパラメータがあります。</P>
<DL>
<DT>
          <CODE>ビデオ</CODE>
        </DT><DD>マッピングされるVMブロックのVMブロックハンドル。</DD>
<DT>
          <CODE>ぐ</CODE>
        </DT><DD>ブロックの所有者のgeodeハンドル。呼び出し元のgeodeのハンドルを使用する場合は0。</DD>
</DL>
<P>ブロックが見つかった場合は<CODE>ObjMapStateToSaved()</CODE>はハンドルを返す。 ブロックが見つからない場合は、nullハンドルが返されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjMarkDirty()"></A>
        <H1 CLASS="refHeading">ObjMarkDirty()</H1>
<PRE CLASS="syntax">void dirty(optr o);/*ObjMarkDirtyとしてマークされるオブジェクト*/</PRE>
<P>このルーチンは、オブジェクトにダーティのマークを付けます。これは、オブジェクトブロックが保存されるときに、オブジェクトへの変更を保存する必要があることを示します。 オブジェクトへの変更を保存する場合は、そのオブジェクトにダーティのマークを付けます。</P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>他のルーチンへのパラメータやフラグによってオブジェクトが自動的にダーティに設定されるため、多くの場合、このルーチンは必要ありません。 ただし、疑問がある場合は、このルーチンを使用する必要があります。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjChunkFlags">ObjChunkFlags</A></CODE><CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjMarkDirtyHandles()"></A>
        <H1 CLASS="refHeading">ObjMarkDirtyHandles()</H1>
<PRE CLASS="syntax">void ObjMarkDirtyHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch);/*optrのチャンク部分*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjMarkDirty()">ObjMarkDirty()</A></CODE>ただし、optrではなくハンドルを使用してオブジェクトを指定する点が異なります。</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjProcBroadcastMessage()"></A>
        <H1 CLASS="refHeading">ObjProcBroadcastMessage()</H1>
<PRE CLASS="syntax">void ObjProcBroadcastMessage(EventHandleイベント);/*放送されるイベント*/</PRE>
<P>このルーチンは、指定されたイベントをメッセージキューを持つすべてのスレッドにブロードキャストします。 カプセル化されたイベント(通常は<CODE>@レコード</CODE>)を返し、何も返しません。 これは通常、通知の目的で使用されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>メタC・ゴー</P>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjRelocateEntryPoint()"></A>
        <H1 CLASS="refHeading">ObjRelocateEntryPoint()</H1>
<PRE CLASS="syntax">void*ObjRelocateEntryPoint(EntryPointRelocation*relocData);</PRE>
</DIV>
<DIV>
          <A NAME="R_7b.htm_IX_ObjRelocOrUnRelocSuper()"></A>
        <H1 CLASS="refHeading">ObjRelocOrUnRelocSuper()</H1>
<PRE CLASS="syntax">void ObjRelocOrUnRelocSuper(optr oself, ClassStruct*class, word frame);</PRE>
<P>このルーチンを呼び出して、オブジェクトのスーパークラスを再配置します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<HR>
          <A NAME="R_7c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_7c.htm_IX_ObjResizeMaster()"></A>
        <H1 CLASS="refHeading">ObjResizeMaster()</H1>
<PRE CLASS="syntax">void ObjResizeMaster(optr obj, /*マスタパーツをリサイズするオブジェクト*/word masterOffset, /*適切なマスタパーツのマスタオフセット*/word newSize);/*マスタパーツの新しいサイズ*/</PRE>
<P>このルーチンは、オブジェクトのインスタンスチャンクのマスタ部分のサイズを変更します。 通常は、マスタパーツにスペースを割り当てたり、マスタパーツのサイズをゼロに変更したりするために使用されます(可視オブジェクトの表示部分が<CODE>MSG_VIS_CLOSE[表示終了]</CODE>)をクリックします。 このルーチンには、次の3つのパラメータを渡す必要があります。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>マスタシェイプのサイズを変更するオブジェクトのオブジェクト範囲を指定します。</DD>
<DT><CODE>masterOffset</DT><DD></CODE>マスタパーツへのオフセットが保持されているオブジェクトのインスタンスチャンクへのオフセット(これはマスタクラスで保持されているオフセットと同じです)<CODE>クラス_masterOffset</CODE>フィールド)。</DD>
<DT>
          <CODE>新しいサイズ</CODE>
        </DT><DD>マスタパーツの新しいサイズです。 これは、マスタークラス&#39;<CODE>クラスインスタンスサイズ</CODE>見出しページを開きます。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、チャンクまたはオブジェクトブロックをサイズ変更および/または移動することができ、それによって、格納されたセグメントアドレスおよびポインタを無効にする。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_6.htm#IX_ClassStruct">ClassStruct</A></CODE><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializeMaster()">ObjInitializeMaster()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializePart()">ObjInitializePart()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7c.htm_IX_ObjResizeMasterHandles()"></A>
        <H1 CLASS="refHeading">ObjResizeMasterHandles()</H1>
<PRE CLASS="syntax">void ObjResizeMasterHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/word masterOffset, /*マスタパートへのオフセット*/word newSize);/*マスタパートの新しいサイズ*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjResizeMaster()">ObjResizeMaster()</A></CODE>ただし、オブジェクトはoptrではなくハンドルで指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7c.htm_IX_ObjSaveBlock()"></A>
        <H1 CLASS="refHeading">ObjSaveBlock()</H1>
<PRE CLASS="syntax">void ObjSaveBlock(MemHandle mh);/*保存用にマークされるブロックのハンドル*/</PRE>
<P>このルーチンは、オブジェクトまたはLMemブロックがオーナーの状態ファイルに保存されるように設定します。 ブロックのハンドルを渡す必要があります<CODE>モデム</CODE>ブロックはオブジェクトブロックでなければなりません。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjMapSavedToState()">ObjMapSavedToState()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjMapStateToSaved()">ObjMapStateToSaved()</A></CODE>ボタンをクリックし</P>
</DIV>

<DIV>
          <A NAME="R_7c.htm_IX_ObjSetFlags()"></A>
        <H1 CLASS="refHeading">ObjSetFlags()</H1>
<PRE CLASS="syntax">void ObjSetFlags(optr o, /*フラグが設定されるオブジェクト*/ObjChunkFlags bitsToSet, /*フラグを設定する*/ObjChunkFlags bitsToClear);/*フラグをクリアする*/</PRE>
<P>このルーチンは、指定されたオブジェクトのチャンクフラグを設定します。 設定されるべきフラグが渡されます。<CODE>bitsToSet</CODE>、クリアする必要があるフラグが渡されます。<CODE>bitsToClear</CODE>通常、アプリケーションはこのルーチンを使用せず、カーネルにオブジェクトのフラグを保持させます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjGetFlags()">ObjGetFlags()</A></CODE><CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjChunkFlags">ObjChunkFlags</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7c.htm_IX_ObjSetFlagsHandles()"></A>
        <H1 CLASS="refHeading">ObjSetFlagsHandles()</H1>
<PRE CLASS="syntax">void ObjSetFlagsHandles(MemHandle mh、/*optrのハンドル部分*/ChunkHandle ch、/*optrのチャンク部分*/ObjChunkFlags bitsToSet、/*設定するフラグ*/ObjChunkFlags bitsToClear);/*クリアするフラグ*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A></CODE>ただし、オブジェクトはoptrではなくハンドルを介して指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7c.htm_IX_ObjTestIfObjBlockRunByCurThread()"></A>
        <H1 CLASS="refHeading">ObjTestIfObjBlockRunByCurThread()</H1>
<PRE CLASS="syntax">Boolean ObjTestIfObjBlockRunByCurThread(MemHandle mh);/*オブジェクトブロックのハンドル*/</PRE>
<P>このルーチンは、呼び出しスレッドが指定されたオブジェクトブロックを実行しているかどうかをチェックします。 このルーチンを使用すると、ブロック内のオブジェクトへの呼び出しがスレッド間で行われているのか、呼び出しスレッドの内部で行われているのかを判断できます。 このルーチンに、チェックするオブジェクトブロックのハンドルを渡します。オブジェクトブロックがVMブロックの場合は、ブロックのスレッドではなく、VMファイルのスレッドがチェックされます。</P>
<P>ブロックが呼び出しスレッドによって実行される場合、戻り値は次のようになります。<CODE>真</CODE>別のスレッドがブロックを実行した場合、戻り値は<CODE>偽の</CODE>(ゼロ)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7c.htm_IX_ObjUnrelocateEntryPoint()"></A>
        <H1 CLASS="refHeading">ObjUnrelocateEntryPoint()</H1>
<PRE CLASS="syntax">void ObjUnrelocateEntryPoint(EntryPointRelocation*relocData, void*entryPoint);</PRE>
</DIV>
<HR>
          <A NAME="R_7d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_7d.htm_IX_ObjVarAddData()"></A>
        <H1 CLASS="refHeading">ObjVarAddData()</H1>
<PRE CLASS="syntax">void*ObjVarAddData(optr obj, /*vardataを*/VardataKey dataTypeに追加するオブジェクト,/*vardata type*/word dataSize);/*vardata dataSize,if any*/</PRE>
<P>このルーチンは、指定したオブジェクトの変数データエントリを追加または変更します。 データ型が現在インスタンスチャンクに存在しない場合は、そのデータ型が割り当てられ、チャンクに追加されます。 存在する場合、エントリの余分なデータはすべてゼロに再初期化されます。</P>
<P>このルーチンは、新しいエントリまたは変更されたエントリの余分なデータへのポインタを返します。エントリに余分なデータがない場合は、エントリへの不透明ポインタが渡されます。このポインタは<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>いずれの場合も、オブジェクトはダーティとマークされます。</P>
<P>オブジェクトの変数データの最初の/唯一のフィールドを追加する可能性がある場合は、オブジェクトの<CODE>OCF_VARDATA_RELOC[OCF変数データ再配置]</CODE>フラグを<A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A>ルーチンまたは<A HREF="../../SysObjects/Meta/MetaClass_6.htm#IX_MSG_META_SET_FLAGS">MSG_META_SET_フラグ</A>ボタンをクリックし</P>
<P>このルーチンのパラメータは次のとおりです。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>影響を受けるオブジェクトのオプション。 これは呼び出し側のoptrでなければなりません。</DD>
<DT>
          <CODE>データ型</CODE>
        </DT><DD>の<CODE>VardataKey</CODE>データ型とそのフラグを宣言するワード。 VDF_SAVE_TO_STATEフラグを正しく設定する必要があります。ただし、VDF_EXTRA_DATAフラグは無視されます。これは、ルーチンによって正しく設定されるためです。</DD>
<DT>
          <CODE>データサイズ</CODE>
        </DT><DD>この型の追加データのサイズ。 型に余分なデータがない場合は、0を渡します。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、vardataが影響を受けるオブジェクトからのみ呼び出す必要があります。 他のオブジェクトの変数データをリモートで操作するには<CODE>メタクラス</CODE>(下記の「関連項目」を参照してください)。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_META_ADD_VAR_DATA(変数データの追加)</CODE><CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7d.htm_IX_ObjVarAddDataHandles()"></A>
        <H1 CLASS="refHeading">ObjVarAddDataHandles()</H1>
<PRE CLASS="syntax">void*ObjVarAddDataHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/VardataKey dataType, /*vardata型*/word dataSize);/*vardataデータサイズ、もしあれば*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarAddData()">ObjVarAddData()</A></CODE>ただし、オブジェクトはoptrではなくハンドルを介して指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7d.htm_IX_ObjVarCopyDataRange()"></A>
        <H1 CLASS="refHeading">ObjVarCopyDataRange()</H1>
<PRE CLASS="syntax">void ObjVarCopyDataRange(optr source, /*コピー元オブジェクトのoptr*/optr dest, /*コピー先(呼び出し側)オブジェクトのoptr*/word rangeStart, /*コピーされるデータ型の最小値*/word rangeEnd);/*コピーされるデータ型の最大値*/</PRE>
<P>このルーチンは、指定された範囲内のすべてのvardataエントリを<CODE>源泉</CODE>オブジェクトを<CODE>宛先</CODE>オブジェクトを作成します。 コピーされる範囲はデータ型によって指定され、その範囲は<CODE>範囲開始(rangeStart)</CODE>および<CODE>範囲終了</CODE>を含む。 データエントリがコピーされると、コピー先のオブジェクトはダーティとしてマークされます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、宛先オブジェクトによってのみ呼び出される必要があります。あるオブジェクトが別のオブジェクトのインスタンス・データを変更することは、OOPの原則に反します。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7d.htm_IX_ObjVarDeleteData()"></A>
        <H1 CLASS="refHeading">ObjVarDeleteData()</H1>
<PRE CLASS="syntax">Boolean ObjVarDeleteData(optr obj, /*削除するオブジェクト*/VardataKey dataType);/*削除するデータ型*/</PRE>
<P>このルーチンは、指定されたオブジェクトのインスタンスチャンクからvardataエントリを削除します(エントリが存在する場合)。 エントリはそのデータ型によって指定されます。ポインタで指定されたエントリを削除するには<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>」を参照してください。 エラーフラグを返します。<CODE>真</CODE>エントリが見つからない場合は<CODE>偽の</CODE>エントリが正常に削除された場合。 また、オブジェクトはルーチンによってダーティとマークされます。</P>
<P>このルーチンのパラメータは次のとおりです。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>影響を受けるオブジェクトのオプション。 これは呼び出し側のoptrでなければなりません。</DD>
<DT>
          <CODE>データ型</CODE>
        </DT><DD>の<CODE>VardataKey</CODE>データ型とそのフラグを宣言するワード。 VDF_SAVE_TO_STATEフラグとVDF_EXTRA_DATAフラグはどちらも無視されます。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、vardataが影響を受けるオブジェクトからのみ呼び出す必要があります。 他のオブジェクトの変数データをリモートで操作するには<CODE>メタクラス</CODE>(下記の「関連項目」を参照してください)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_META_DELETE_VAR_DATA(変数データの削除)</CODE><CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7d.htm_IX_ObjVarDeleteDataHandles()"></A>
        <H1 CLASS="refHeading">ObjVarDeleteDataHandles()</H1>
<PRE CLASS="syntax">Boolean ObjVarDeleteDataHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/VardataKey dataType);/*削除するデータ型*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarDeleteData()">ObjVarDeleteData()</A></CODE>ただし、オブジェクトはoptrではなくハンドルを介して指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<HR>
          <A NAME="R_7e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_7e.htm_IX_ObjVarDeleteDataAt()"></A>
        <H1 CLASS="refHeading">ObjVarDeleteDataAt()</H1>
<PRE CLASS="syntax">void ObjVarDeleteDataAt(optr obj, /*削除するオブジェクト*/word extraDataOffset);/*削除する追加データへのオフセット*/</PRE>
<P>このルーチンは、指定されたオブジェクトのインスタンスチャンクから、指定されたvardataエントリを削除します。 vardataエントリは、によって返されるポインタによって指定されます<CODE><A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarAddData()">ObjVarAddData()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>、および<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDerefData()">ObjVarDerefData()</A></CODE>データ型で指定されたエントリを削除するには<CODE><A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarDeleteData()">ObjVarDeleteData()</A></CODE>」を参照してください。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、vardataが影響を受けるオブジェクトからのみ呼び出す必要があります。 他のオブジェクトの変数データをリモートで操作するには<CODE>メタクラス</CODE>(下記の「関連項目」を参照してください)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_META_DELETE_VAR_DATA(変数データの削除)</CODE><CODE><A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarDeleteData()">ObjVarDeleteData()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7e.htm_IX_ObjVarDeleteDataAtHandles()"></A>
        <H1 CLASS="refHeading">ObjVarDeleteDataAtHandles()</H1>
<PRE CLASS="syntax">void ObjVarDeleteDataAtHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/word extraDataOffset);/*削除する追加データへのオフセット*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>ただし、オブジェクトはoptrではなくハンドルを介して指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7e.htm_IX_ObjVarDeleteDataRange()"></A>
        <H1 CLASS="refHeading">ObjVarDeleteDataRange()</H1>
<PRE CLASS="syntax">void flag(optr obj, /*削除するオブジェクト*/word rangeStart, /*範囲の開始*/word rangeEnd, /*範囲の終了*/Boolean ObjVarDeleteDataRange);/*stateフラグに保存*/useStateFlag</PRE>
<P>このルーチンは、渡されたオブジェクトの指定された範囲内のすべてのデータエントリを削除します。 範囲は、開始データ型と終了データ型によって指定され、両端を含みます。 このルーチンには次の4つのパラメータがあります。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>データエントリを削除するオブジェクトのオブジェクト番号を指定します。</DD>
<DT>
          <CODE>範囲開始(rangeStart)</CODE>
        </DT><DD>削除する最小の数値データ型です。 VDF_SAVE_TO_STATEフラグとVDF_EXTRA_DATAフラグはどちらも無視されます。</DD>
<DT>
          <CODE>範囲終了</CODE>
        </DT><DD>削除するデータ型の最大値を指定します。 VDF_SAVE_TO_STATEフラグとVDF_EXTRA_DATAフラグはどちらも無視されます。</DD>
<DT><CODE>useStateFlag</DT><DD></CODE>VDF_SAVE_TO_STATEフラグを持つエントリを削除するかどうかを示すフラグ。 パス(Pass)<CODE>真</CODE>(ゼロ以外)を指定すると、状態フラグが考慮されます。<CODE>偽の</CODE>(ゼロ)を指定すると、範囲内のすべてのエントリが削除されます。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、vardataが影響を受けるオブジェクトからのみ呼び出す必要があります。 他のオブジェクトの変数データをリモートで操作するには<CODE>メタクラス</CODE>(下記の「関連項目」を参照してください)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_META_DELETE_VAR_DATA(変数データの削除)</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7e.htm_IX_ObjVarDeleteDataRangeHandles()"></A>
        <H1 CLASS="refHeading">ObjVarDeleteDataRangeHandles()</H1>
<PRE CLASS="syntax">void flag(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/word rangeStart, /*rangeの開始*/word rangeEnd, /*rangeの終了*/Boolean useStateFlag);/*state ObjVarDeleteDataRangeHandlesに保存*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataRange()">ObjVarDeleteDataRange()</A></CODE>ただし、オブジェクトはoptrではなくハンドルを介して指定されます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>object.hと入力します。</P>
</DIV>
<DIV>
          <A NAME="R_7e.htm_IX_ObjVarDerefData()"></A>
        <H1 CLASS="refHeading">ObjVarDerefData()</H1>
<PRE CLASS="syntax">void*ObjVarDerefData(optr obj, /*データ型を持つオブジェクト*/VardataKey dataType);/*間接参照するデータ型*/</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>ただし、データ型が見つからない場合にはヌルポインタを返さない点が異なります。 データ型がオブジェクト内にあることが確実でない限り、このルーチンを使用しないでください。そうしないと、結果が予測できなくなります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">object.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7e.htm_IX_ObjVarDerefDataHandles()"></A>
        <H1 CLASS="refHeading">ObjVarDerefDataHandles()</H1>
<PRE CLASS="syntax">void*ObjVarDerefDataHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/VardataKey dataType);/*間接参照するデータ型*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDerefData()">ObjVarDerefData()</A></CODE>ただし、オブジェクトはoptrではなくハンドルを介して指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">object.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_7e.htm_IX_ObjVarFindData()"></A>
        <H1 CLASS="refHeading">ObjVarFindData()</H1>
<PRE CLASS="syntax">void*ObjVarFindData(optr obj, /*チェックするオブジェクト*/VardataKey dataType);/*検索するデータ型*/</PRE>
<P>このルーチンは、オブジェクトの変数データから指定されたデータ型を検索します。 タイプが見つかった場合は<CODE>ObjVarFindData()</CODE>はエントリの余分なデータへのポインタを返す。エントリに余分なデータがない場合は、opaqueポインタが返される。<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>エントリが見つからない場合は、ヌルポインタが返されます。 このルーチンによって返されるポインタは、オブジェクトのブロックに対する後続の操作の前に使用する必要があります。ポインタは、他のLMemまたはオブジェクト操作によって無効にされる場合があります。</P>
<P>このルーチンの2つのパラメータは次のとおりです。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>影響を受けるオブジェクトのオプション。 これは呼び出し側のoptrでなければなりません。</DD>
<DT>
          <CODE>データ型</CODE>
        </DT><DD>の<CODE>VardataKey</CODE>データ型とそのフラグを宣言するワード。 VDF_SAVE_TO_STATEフラグとVDF_EXTRA_DATAフラグはどちらも無視されます。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、vardataが影響を受けるオブジェクトからのみ呼び出す必要があります。 他のオブジェクトの変数データをリモートで操作するには<CODE>メタクラス</CODE>(下記の「関連項目」を参照してください)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">object.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE>MSG_META_FIND_VAR_DATA■サービス名の場合■</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7e.htm_IX_ObjVarFindDataHandles()"></A>
        <H1 CLASS="refHeading">ObjVarFindDataHandles()</H1>
<PRE CLASS="syntax">void*ObjVarFindDataHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/VardataKey dataType);/*検索するデータ型*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>ただし、オブジェクトはoptrではなくハンドルを介して指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">object.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_7f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_7f.htm_IX_ObjVarScanData()"></A>
        <H1 CLASS="refHeading">ObjVarScanData()</H1>
<PRE CLASS="syntax">void ObjVarScanData(optr obj, /*スキャンするオブジェクト*/word numHandlers, /*テーブル内のハンドラの数*/VarDataCHandler*handlerTable, /*ハンドラテーブルへのポインタ*/void*handlerData);/*ハンドラデータへのポインタ*/</PRE>
<P>このルーチンは、オブジェクトのvardataをスキャンし、渡されたハンドラテーブルで指定されているすべてのvardataハンドラを呼び出します。 次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>オブジェクト</CODE>
        </DT><DD>変数データテーブルがスキャンされるオブジェクトのoptr。</DD>
<DT><CODE>numHandlers</DT><DD></CODE>渡されたハンドラテーブルで指定されたハンドラの数。</DD>
<DT><CODE>handlerTable</DT><DD></CODE>リストへのポインタ<CODE>VarDataCHandler</CODE>構造。 これらの各構造体には、vardataデータ型と、それを処理するルーチンへのポインタが含まれています。 すべてのハンドラルーチンは、ハンドラテーブルと同じセグメント内にある必要があります。</DD>
<DT><CODE>handlerData</DT><DD></CODE>ハンドラに渡されるバッファへのポインタ。 これには、アプリケーションまたはハンドラにとって特に重要な情報を含めることができます。</DD>
</DL>
<P CLASS="refField"><STRONG><STRONG>Vardataハンドラの形式:</STRONG><BR></STRONG>vardataハンドラルーチンは、次の形式である必要があります。</P>
<PRE>void_pascal(MemHandle mh, ChunkHandle chnk, VarDataEntry*extraData, ワードデータ型,void*handlerData)</PRE>
<P>ハンドラーはオブジェクト・チャンクを解放したり、オブジェクトを破壊したりするべきではありません。ハンドラーは、それが望む他のことを行うことができます。 ハンドラは何も返さず、次のパラメータを使用します。</P>
<DL>
<DT>
          <CODE>mh:チェック</CODE>
        </DT><DD>参照されているオブジェクトのメモリーハンドルとチャンクハンドル。 これらが一緒になって、オブジェクトのoptrを構成します。</DD>
<DT>
          <CODE>extraData</CODE>
        </DT><DD>データ型の追加データへのポインタ(追加データがある場合)。 このポインタは以下のマクロで解析できます。<CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VarDataTypePtr() macro">VarDataTypePtr()</A></CODE><CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VarDataFlagsPtr() macro">VarDataFlagsPtr()</A></CODE>、および<CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VarDataSizePtr() macro">VarDataSizePtr()</A></CODE>ボタンをクリックし</DD>
<DT>
          <CODE>データ型</CODE>
        </DT><DD>処理されるデータ入力のデータ型。 これはタイプのレコードです<CODE>VardataKey</CODE>ボタンをクリックし</DD>
<DT><CODE>handlerData</DT><DD></CODE>によって渡されたバッファへのポインタ<CODE>ObjVarScanData()</CODE>このバッファは、ハンドラに追加データを渡すために使用できます。</DD>
</DL>
<P CLASS="refField"><STRONG>構造:</STRONG>の<CODE>VarDataCHandler</CODE>構造には、次の2つの要素が含まれ</P>
<PRE>typedef struct{word VDCH_dataType;void_pascal(*VDCH_handler)(MemHandle mh, ChunkHandle chnk, VarDataEntry*extraData, word dataType void*handlerData);}VarDataCHandler;</PRE>
<P>最初の要素はデータ型であり、データ型とvardataフラグを含むレコードです。 2番目の要素は、その型のハンドラルーチンへのfarポインタです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">object.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_7f.htm_IX_ObjVarScanDataHandles()"></A>
        <H1 CLASS="refHeading">ObjVarScanDataHandles()</H1>
<PRE CLASS="syntax">void ObjVarScanDataHandles(MemHandle mh, /*optrのハンドル部分*/ChunkHandle ch, /*optrのチャンク部分*/word numHandlers, /*テーブル内のハンドラの数*/VarDataCHandler*handlerTable, /*ハンドラテーブルへのポインタ*/void*handlerData);/*ハンドラデータへのポインタ*/</PRE>
<P>このルーチンは、以下と同じです。<CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_ObjVarScanData()">ObjVarScanData()</A></CODE>ただし、オブジェクトはoptrではなくハンドルを介して指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">object.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_7f.htm_IX_offsetof()"></A>
        <H1 CLASS="refHeading">のオフセット()</H1>
<PRE CLASS="syntax">単語のオフセット(<EM>構造</EM><EM>畑</EM>)</PRE>
<P>このマクロは、指定した構造体内の指定したフィールドのオフセットを返します。</P>
</DIV>
<DIV>
          <A NAME="R_7f.htm_IX_OptrToChunk()"></A>
        <H1 CLASS="refHeading">OptrToChunk()</H1>
<PRE CLASS="syntax">ChunkHandle OptrToChunk(<EM>動作</EM>);optr<EM>動作</EM>;をクリックし</PRE>
<P>このマクロは、指定されたoptrのチャンクハンドル部分を抽出します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ConstructOptr() macro">ConstructOptr()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToHandle()">OptrToHandle()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_7f.htm_IX_OptrToHandle()"></A>
        <H1 CLASS="refHeading">OptrToHandle()</H1>
<PRE CLASS="syntax">MemHandle OptrToHandle(<EM>動作</EM>);optr<EM>動作</EM>;をクリックし</PRE>
<P>このマクロは、指定されたoptrのMemHandle部分を抽出します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ConstructOptr() macro">ConstructOptr()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToChunk()">OptrToChunk()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_80.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_ParallelClose()"></A>
        <H1 CLASS="refHeading">ParallelClose()</H1>
<PRE CLASS="syntax">StreamError・ParallelClose(GeodeHandle・ドライバー、ParallelUnit・ユニット、ブール・リンガー)</PRE>
<P>パラレルポートへのストリームを閉じます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">streamC.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_ParallelGetError()"></A>
        <H1 CLASS="refHeading">ParallelGetError()</H1>
<PRE CLASS="syntax">StreamError ParallelGetError(ハンドルドライバー、ParallelUnitユニット、StreamRolesロール、ParallelError*エラーコード);</PRE>
<P>このルーチンは、並列ドライバへの最後の呼び出しで設定された並列ドライバ固有のエラーコードを返します。</P>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_ParallelOpen()"></A>
        <H1 CLASS="refHeading">ParallelOpen()</H1>
<PRE CLASS="syntax">StreamError ParallelOpen(GeodeHandleドライバー、ParallelUnitユニット、StreamOpenFlagsフラグ、ワードoutBuffSize、ワードタイムアウト);</PRE>
<P>このルーチンは、指定されたパラレルポートにストリームをオープンします。 次の引数が渡されます。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>パラレルドライバの</DD>
<DT>
          <CODE>単位</CODE>
        </DT><DD>開くパラレルポート。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>ポートがビジー状態の場合にコールを失敗させるか、ポートが解放されるかどうかを確認するためにしばらく待機するかを指定します。</DD>
<DT>
          <CODE>出力バッファサイズ</CODE>
        </DT><DD>パラレルポートへの出力に使用されるストリームバッファのサイズ。</DD>
<DT>
          <CODE>タイムアウト(timeout)</CODE>
        </DT><DD>ポートが解放されるまで待機するクロックティックの数。 (この引数は<CODE>フラグふらぐ</CODE>はSTREAM_OPEN_TIMEOUTではありません)。</DD>
</DL>
<P>ルーチンが成功した場合は、0を返します。 失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">streamC.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_ParallelSetError()"></A>
        <H1 CLASS="refHeading">ParallelSetError()</H1>
<PRE CLASS="syntax">StreamError ParallelSetError(ハンドルドライバー、ParallelUnitユニット、StreamRolesロール、ParallelError*エラーコード);</PRE>
<P>このルーチンは、指定されたパラレルポートのデバイス固有のエラーコードを設定します。</P>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_ParallelWrite()"></A>
        <H1 CLASS="refHeading">ParallelWrite()</H1>
<PRE CLASS="syntax">StreamError ParallelWrite(GeodeHandleドライバー、ParallelUnitユニット、StreamBlockerブロッカー、ワードbuffSize、const byte*buffer、word*numBytesWritten);</PRE>
<P>パラレルポートにデータを書き込みます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">streamC.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_ParallelWriteByte()"></A>
        <H1 CLASS="refHeading">ParallelWriteByte()</H1>
<PRE CLASS="syntax">StreamError ParallelWrite(GeodeHandleドライバー、ParallelUnitユニット、StreamBlockerブロッカー、ワードbuffSize、バイトdataByte);</PRE>
<P>パラレルポートに1バイトのデータを書き込みます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">streamC.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_ParserParseString()"></A>
        <H1 CLASS="refHeading">ParserParseString()</H1>
<PRE CLASS="syntax">ParserScannerEvaluatorError ParserParseString(char*textBuffer、byte*tokenBuffer、CParserStruct*parserParams、CParserReturnStruct*retVal);</PRE>
<P>文字列をトークンのシーケンスにパースします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">構文解析.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_ParserEvalExpression()"></A>
        <H1 CLASS="refHeading">ParserEvalExpression()</H1>
<PRE CLASS="syntax">ParserScannerEvaluatorError ParserEvalExpression(byte*scratchBuffer, byte*resultBuffer, word bufSize, CEvalStruct*evalParams);</PRE>
<P>解析された式を評価します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">構文解析.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_ParserFormatExpression()"></A>
        <H1 CLASS="refHeading">ParserFormatExpression()</H1>
<PRE CLASS="syntax">ParserScannerEvaluatorError ParserFormatExpression(バイト*tokenBuffer、チャー*textBuffer、CFormatStruct*formatParams);</PRE>
<P>解析されたデータから式を書式設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">構文解析.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_80.htm_IX_PCB()"></A>
        <H1 CLASS="refHeading">プリント基板()</H1>
<PRE CLASS="syntax">#define PCB(return_type, pointer_name, args)\return_type_pascal(*pointer_name)args</PRE>
<P>このマクロは、pascal呼び出し規約を使用する関数へのポインタを宣言するのに便利です。 例えば、2つの文字列を渡されて整数を返す関数へのポインタを宣言するには、次のように記述します。</P>
<PRE>PCB(int, func_ptr, (const char*,const char*));という文字列を返します。</PRE>
<P>これは次のように拡張されます。</P>
<PRE>int_pascal(*func_ptr)(const char*,const char*);</PRE>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CCB() macro">CCB()様</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_81.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_81.htm_IX_PCCOMABORT()"></A>
        <H1 CLASS="refHeading">PCCOMABORT()</H1>
<PRE CLASS="syntax">void PCCOMABORT(void)</PRE>
<P>このルーチンは、PCComライブラリによって実行されている現在のファイル転送操作を中止します。 それはPCCom図書館の3番目の入り口です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">pccom・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_81.htm_IX_PCCOMEXIT()"></A>
        <H1 CLASS="refHeading">PCCOMEXIT()</H1>
<PRE CLASS="syntax">PCComReturnType PCCOMEXIT x</PRE>
<P>このルーチンは、PCCOMINIT()で開始されたようなpccomスレッドを強制終了します。 それはPCCom図書館の2番目の入り口です。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef ByteEnum PCComReturnType;#define PCCRT_NO_ERROR 0#define PCCRT_CANNOT_LOAD_SERIAL_DRIVER 1#define PCCRT_CANNOT_CREATE_THREAD 2#define PCCRT_CANNOT_ALLOC_STREAM 3#define PCCRT_ALREADY_INITIALIZED 4</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">pccom・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_81.htm_IX_PCCOMINIT()"></A>
        <H1 CLASS="refHeading">PCCOMINIT()</H1>
<PRE CLASS="syntax">PCComReturnType PCCOMINIT(SerialPortNumポート、SerialBaudボー、ワードタイムアウト、optr callbackOptr、PCComInitFlagsフラグ);</PRE>
<P>PCComライブラリのこのエントリポイントは、シリアルポートを監視し、パッシブPCComターミナルとして動作する新しいスレッドを生成します。 このルーチンは、PCCom図書館の最初の入り口である。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>港</EM>
        </DT><DD>ア<CODE>SerialPortNum</CODE>pccom接続に使用するシリアルポートを指定する値。 システムのデフォルト値として-1を渡します。<CODE>コム1</CODE>ズーマーのために<CODE>コム2</CODE>デスクトップ製品用です。</DD>
<DT>
          <EM>ボー</EM>
        </DT><DD>ア<CODE>SerialBaud</CODE>使用する速度を指定する値。 システムのデフォルト値として-1を渡します。Zoomerの場合は19200ボー、デスクトップ製品の場合は38400ボーです。</DD>
<DT>
          <EM>タイムアウト(timeout)</EM>
        </DT><DD>接続を許可するクロックティック数(1ティックは1/60秒)。</DD>
<DT><EM>callbackOptr</DT><DD></EM>特定のイベントの通知メッセージを受信するオブジェクト。 値0は、通知が送信されないことを意味します。</DD>
<DT>
          <EM>フラグふらぐ</EM>
        </DT><DD>オブジェクトが通知メッセージを受信する場合、これらのフラグは送信される通知の種類を決定します。</DD>
</DL>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef ByteEnum PCComReturnType;#define PCCRT_NO_ERROR 0#define PCCRT_CANNOT_LOAD_SERIAL_DRIVER 1#define PCCRT_CANNOT_CREATE_THREAD 2#define PCCRT_CANNOT_ALLOC_STREAM 3#define PCCRT_ALREADY_INITIALIZED 4 typedef WordFlags PCComInitFlags;/*テキストが表示可能になったときに通知を送信*/#define PCCIF_NOTIFY_OUTPUT 0x8000/*リモートマシンが*シリアルライン*/をシャットダウンしたときに通知を送信</PRE>
<PRE CLASS="syntax">#define PCCIF_NOTIFY_EXIT 0x4000</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">pccom・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_81.htm_IX_ProcCallFixedOrMovable_cdecl()"></A>
        <H1 CLASS="refHeading">ProcCallFixedOrMovable_cdecl()</H1>
<PRE CLASS="syntax">dワードProcCallFixedOrMovable_cdecl(void(*routine),.)</PRE>
<P>このルーチンは、ポイントされたルーチンを呼び出し、呼び出されたルーチンに他の引数を渡します。 呼び出されるルーチンは、Cの呼び出し規則を使用する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">resource.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_81.htm_IX_ProcCallFixedOrMovable_pascal()"></A>
        <H1 CLASS="refHeading">ProcCallFixedOrMovable_pascal()も参照下さい。</H1>
<PRE CLASS="syntax">dword ProcCallFixedOrMovable_pascal(.,void(*routine))</PRE>
<P>このルーチンは、ポイントされたルーチンを呼び出し、呼び出されたルーチンに他の引数を渡します。 呼び出されるルーチンは、Pascalの呼び出し規約を使用する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">resource.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_81.htm_IX_ProcGetLibraryEntry()"></A>
        <H1 CLASS="refHeading">ProcGetLibraryEntry()</H1>
<PRE CLASS="syntax">void*ProcGetLibraryEntry(GeodeHandle図書館、ワードentryNumber)</PRE>
<P>このルーチンは、ライブラリのエントリポイントへのポインタを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">resource.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_81.htm_IX_ProcInfo()"></A>
        <H1 CLASS="refHeading">関数ProcInfo()</H1>
<PRE CLASS="syntax">ThreadHandle ProcInfo(GeodeHandle gh);/*チェックするgeodeのハンドル*/</PRE>
<P>このルーチンは、指定されたgeodeプロセスの最初のスレッドを返します。 geodeがプロセスでない場合、ルーチンはnullハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_81.htm_IX_PtrToOffset()"></A>
        <H1 CLASS="refHeading">PtrToOffset()</H1>
<PRE CLASS="syntax">単語PtrToOffset(<EM>ポインタ</EM>);dワード<EM>ポインタ</EM>;をクリックし</PRE>
<P>このマクロは、与えられたdwordの下位16ビットだけを返します。 これは、ファーポインタのオフセット部分を抽出する場合に最も便利です。</P>
</DIV>
<DIV>
          <A NAME="R_81.htm_IX_PtrToSegment()"></A>
        <H1 CLASS="refHeading">PtrToSegment()</H1>
<PRE CLASS="syntax">単語PtrToSegment(<EM>ポインタ</EM>);dワード<EM>ポインタ</EM>;をクリックし</PRE>
<P>このマクロは、与えられたdwordの上位16ビットだけを返します。 これは、ファーポインタのセグメントアドレスを抽出するのに最も便利です。</P>
</DIV>
<HR>
          <A NAME="R_82.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_82.htm_IX_qsort"></A>
        <H1 CLASS="refHeading">qsort[クイックソート]</H1>
<PRE CLASS="syntax">extern void_pascal qsort(void*配列,word count, word elementSize, PCB(int, compare, (const void*,const void*)));</PRE>
<P>これは標準的なクイックソートルーチンです。 コールバックルーチンはdecared_pascalでなければなりません。</P>
</DIV>
<DIV>
          <A NAME="R_82.htm_IX_QueueGetMessage()"></A>
        <H1 CLASS="refHeading">QueueGetMessage()</H1>
<PRE CLASS="syntax">EventHandle QueueGetMessage(QueueHandle qh);/*照会するキュー*/</PRE>
<P>このルーチンは、指定されたキューの次のメッセージを返し、キューが空の場合はブロックします。 空のキューに新しいメッセージが追加されると、このルーチンはスレッドのブロックを解除し、メッセージを返します。 このルーチンは、カーネルによってほぼ独占的に使用されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_82.htm_IX_QueuePostMessage()"></A>
        <H1 CLASS="refHeading">QueuePostMessage()</H1>
<PRE CLASS="syntax">void QueuePostMessage(QueueHandle qh, /*イベントを追加するキュー*/EventHandleイベント,/*キューに追加するイベント*/MessageFlagsフラグ);/*MF_INSERT_AT_FRONTまたはゼロ*/</PRE>
<P>このルーチンは、指定された<CODE>事件</CODE>渡された<CODE>待ち行列</CODE>このルーチンの有効なフラグはMF_INSERT_AT_FRONTのみで、イベントをキューの最初の場所に配置します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geode.hと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_82.htm_IX_RangeEnum()"></A>
          <A NAME="R_82.htm_IX_RangeEnumCallbackParams"></A>
          <A NAME="R_82.htm_IX_RECP_&ldots;"></A>
        <H1 CLASS="refHeading">RangeEnum()</H1>
<PRE CLASS="syntax">ブーリアンRangeEnum(CellFunctionParameters*cfp, /*CellFunctionParameters*/RangeEnumParams*params);/*special other parameters*/</PRE>
<P>このルーチンは、指定された範囲内の各セルに対してコールバックルーチンを呼び出します。 このルーチンは、以下に示す2つの構造体へのポインタを渡します。 戻ります<EM>偽の</EM>全ての細胞が処理されれば<EM>真</EM>範囲の終わりに達する前に、いずれかのセルによってルーチンが中断された場合。</P>
<P CLASS="refField">
          <STRONG>
            <STRONG>コールバックパラメータ:</STRONG>
          </STRONG>
        </P>
<P>コールバックルーチン(_pascalと宣言する必要があります)は<CODE>RangeEnumCallbackParams</CODE>次のように定義されています。</P>
<PRE>typedef struct{RangeEnumParams*RECP_params;/*下記参照*//*セルの現在の行、列、およびセルデータ*/word RECP_row;word RECP_column;word RECP_cellData;}RangeEnumCallbackParams;</PRE>
<P>コールバックルーチンは、セル情報に対して任意の操作を実行できます。 戻るはずです<EM>偽の</EM>エラーが発生した場合、または<CODE>RangeEnum()</CODE>が返されます。<EM>真</EM>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_82.htm_IX_RangeExists()"></A>
        <H1 CLASS="refHeading">RangeExists()</H1>
<PRE CLASS="syntax">Boolean RangeExists(/*範囲内にセルがある場合は0以外を返す*/CellFunctionParameters*cfp, /*RangeEnum()を参照*/word firstRow, /*範囲の区切り文字*/byte firstColumn, word lastRow, byte lastColumn);</PRE>
<P>このルーチンは<EM>真</EM>チェックボックスをオフにします。 このオブジェクトには<CODE>CellFunctionParameters</CODE>セルファイルの構造、およびチェックする範囲の最初と最後の行、最初と最後の列のインデックス。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_82.htm_IX_RangeInsert()"></A>
          <A NAME="R_82.htm_IX_RangeInsertParams"></A>
          <A NAME="R_82.htm_IX_RIP_&ldots;"></A>
        <H1 CLASS="refHeading">RangeInsert()</H1>
<PRE CLASS="syntax">void RangeInsert(CellFunctionParameters*cfp, /*RangeEnum()*/RangeInsertParams*repを参照);/*パラメータ構造*/</PRE>
<P>このルーチンは、既存のセルを移動して、新しいセルのためのスペースを作ります。 (実際に新しいセルを作成するわけではありません)。 どのセルをどの方向にシフトするかは<CODE>RangeInsertParams</CODE>構造:</P>
<DL>
<DT><CODE>RIP境界</DT><DD></CODE>ア<CODE>長方形</CODE>どのセルをシフトするかを指定する構造体。 現在この範囲内にあるセルは<CODE>RIPデルタ</CODE>;シフトされたセルは、セルファイルの表示部分の端まで、より多くのセルを置き換えます。 行全体を挿入する(行の一部を挿入するよりもはるかに高速)には、RIP<CODE>_boundsです。</CODE>アール<CODE>レフト(_L)</CODE>=0およびRIP<CODE>_boundsです。</CODE>アール<CODE>右=</CODE>LARGESt_COLUMN(最大列)<CODE>ボタンをクリックし</CODE></DD>
<DT><CODE>RIPデルタ</DT><DD></CODE>ア<CODE>[点]</CODE>構造体で、セルをシフトする距離と方向を指定します。 セル範囲を水平方向にシフトする場合は<CODE>RIP_deltaを使用します。</CODE>Pキー<CODE>_x様</CODE>セルをシフトする距離を指定する必要があります。<CODE>RIP_deltaを使用します。</CODE>Pキー<CODE>y(_Y)</CODE>はゼロである必要があります。 セルを垂直方向に移動する場合は<CODE>RIP_deltaを使用します。</CODE>Pキー<CODE>y(_Y)</CODE>セルをシフトする距離を指定する必要があります。<CODE>RIP_deltaを使用します。</CODE>Pキー<CODE>_x様</CODE>はゼロである必要があります。</DD>
<DT><CODE>RIP_cfp&lt;ファイル名></DT><DD></CODE>これは<CODE>CellFunctionParameters</CODE>構造。 これを初期化する必要はありません。ルーチンが自動的に初期化します。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>セルがセルファイルの「可視」部分からシフトされている場合、行番号または列番号でアクセスすることはできませんが、削除はされません。 このため、このようなセルはすべて解放する必要があります。<EM>前に</EM>呼び出し<CODE>RangeInsert()</CODE>(エッジにセルがあるかどうかを調べるには<CODE><A HREF="../../CRef/Routines/R_82.htm#IX_RangeExists()">RangeExists()</A></CODE>」を参照してください。 セルファイルの「可視」部分と「スクラッチパッド」部分の説明については<A HREF="../../DataMgmt/Cell/CellLibrary_1.htm#99717">Cellライブラリーの資料</A>ボタンをクリックし</P></DIV>
<HR>
          <A NAME="R_83.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_realloc()"></A>
        <H1 CLASS="refHeading">参照):realloc()</H1>
<PRE CLASS="syntax">void*realloc(void*blockPtr, /*リサイズするメモリのアドレス*/size_t newSize);/*メモリの新しいサイズ(バイト単位)*/</PRE>
<P>の<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>ファミリーのルーチンが標準Cとの互換性のために提供されている。 geodeが少量の固定メモリを必要とする場合、ルーチンの1つを呼び出すことができます。 カーネルはgeodeの値を満足する固定ブロックを割り当てます。<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>はこのブロックからメモリを割り当てる。 ブロックがいっぱいになると、別の固定malloc-blockが割り当てられます。 ブロック内のすべてのメモリが解放されると、メモリマネージャは自動的にブロックを解放します。</P>
<P>geodeに割り当てられたメモリセクションのサイズを変更する必要がある場合<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>ルーチンのファミリー<CODE>参照):realloc()</CODE>ボタンをクリックし<CODE>参照):realloc()</CODE>は指定されたメモリのサイズを変更し、メモリの新しいベースアドレスを返す。</P>
<P>新しいサイズが前のサイズより小さい場合、バイトは最後から切り取られます。 要求の成功は保証されています。 さらに、メモリは移動されず、返されるアドレスは渡されたアドレスと同じになります。</P>
<P>新しいサイズが前のサイズより大きい場合は<CODE>参照):realloc()</CODE>は、要求に対応するためにデータを移動できます。 そうであれば、新しい住所を返します。 新しいメモリが追加されました<EM>しない</EM>はゼロ初期化されます。 次の場合<CODE>参照):realloc()</CODE>は要求を満たすことができず、NULLポインタを返し、メモリは変更されない。</P>
<P>メモリのサイズを0バイトに変更することは<CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">関数free()</A></CODE>にヌルアドレスを渡すと<CODE>参照):realloc()</CODE>と同じ方法でメモリを割り当てます。<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>します。</P>
<P>メモリは、geode呼び出しに割り当てられたmalloc-blockにある必要があります。<CODE>参照):realloc()</CODE>別のgeodeのmalloc-blockのメモリサイズを変更したい場合は<CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoReAlloc()">GeoReAlloc()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>メモリを割り当てたときに返されたアドレスとまったく同じアドレスを渡します。 異なるアドレスを渡すと、結果は未定義になります。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_3.htm#IX_calloc()">関数calloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">関数free()</A></CODE><CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE><CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoReAlloc()">GeoReAlloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_RecentContactsEraseStack()"></A>
        <H1 CLASS="refHeading">RecentContactsEraseStack()</H1>
<PRE CLASS="syntax">BooleanRecentContactsEraseStack(RecentContactsType rcType)</PRE>
<P>この関数は、特定のタイプのすべてのログエントリをログから消去します。 エラーがなければ0を返し、なければ0以外の値を返します。 RC_SENT_CALLS、RC_RECEIVED_CALLS、RC_MISSED_CALLS、RC_SENT_FAXS、RC_RECEIVED_FAXS、RC_SENT_SMS、またはRC_RECEIVED_SMSのいずれかを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_RecentContactsGetCount()"></A>
        <H1 CLASS="refHeading">RecentContactsGetCount()</H1>
<PRE CLASS="syntax">ワードRecentContactsGetCount(RecentContactsType rcType)</PRE>
<P>この関数は、最近行われた、あるタイプのコンタクトの数を返します。 RC_SENT_CALLS、RC_RECEIVED_CALLS、RC_MISSED_CALLS、RC_SENT_FAXS、RC_RECEIVED_FAXS、RC_SENT_SMS、またはRC_RECEIVED_SMSのいずれかを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_RecentContactsGetEntry()"></A>
        <H1 CLASS="refHeading">RecentContactsGetEntry()</H1>
<PRE CLASS="syntax">word RecentContactsGetEntry(RecentContactsType rcType, int item, LogEntry*buffer);</PRE>
<P>この関数は、コールのエントリログを取得します。 コールは、コールタイプとインデックス番号で識別されます。 コールタイプは、RC_SENT_CALLS、RC_RECEIVED_CALLS、RC_MISSED_CALLS、RC_SENT_FAXS、RC_RECEIVED_FAXS、RC_SENT_SMS、またはRC_RECEIVED_SMSのいずれかです。 インデックス番号は、0以上で<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_RecentContactsGetCount()">RecentContactsGetCount()</A></CODE>この関数は、渡された<CODE>ログエントリ</CODE>エントリーの情報を保持するバッファー。 エラーが発生した場合は0以外の値が返され、エラーが発生しなかった場合は0が返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_RecentContactsGetMissedCallsTotalCount()"></A>
        <H1 CLASS="refHeading">RecentContactsGetMissedCallsTotalCount()</H1>
<PRE CLASS="syntax">単語RecentContactsResetMissedCallsTotalCount();</PRE>
<P>この関数は、前回からの不在着信回数を返します。<CODE>RecentContactsGetMissedCallsTotalCount()</CODE>が呼び出されました。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_RecentContactsGetNewCount()"></A>
        <H1 CLASS="refHeading">RecentContactsGetNewCount()</H1>
<PRE CLASS="syntax">ワードRecentContactsGetNewCount(RecentContactsType rcType)</PRE>
<P>この関数は、前回以降に記録されたコンタクトの数を返します。<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_RecentContactsResetNewCount()">RecentContactsResetNewCount()</A></CODE>が呼び出されました。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_RecentContactsResetMissedCallsTotalCount()"></A>
        <H1 CLASS="refHeading">RecentContactsResetMissedCallsTotalCount()</H1>
<PRE CLASS="syntax">voidRecentContactsResetMissedCallTotalsCount x</PRE>
<P>この機能は、によって使用される不在着信の数をリセットします<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_RecentContactsGetMissedCallsTotalCount()">RecentContactsGetMissedCallsTotalCount()</A></CODE>見出しページを開きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_RecentContactsResetNewCount()"></A>
        <H1 CLASS="refHeading">RecentContactsResetNewCount()</H1>
<PRE CLASS="syntax">voidRecentContactsResetNewCount(RecentContactsType rcType)</PRE>
<P>この関数は、ログに記録された「新しい」連絡先の数を<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_RecentContactsGetNewCount()">RecentContactsGetNewCount()</A></CODE>見出しページを開きます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contlog・ゴー</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_83.htm_IX_RespGetPDAHardwareInfo()"></A>
        <H1 CLASS="refHeading">RespGetPDAHardwareInfo()</H1>
<PRE CLASS="syntax">PDAHardwareInfo RespGetPDAHardwareInfo(ボイド)</PRE>
<P>このルーチンは、現在のPDAハードウェアに関する情報を取得します。具体的には、PDAのタイプと、PDAにバックライトが付いているかどうかを取得します。 次のビットマスクを使用して<CODE>PDAHardwareInfo</CODE>ビットフィールド:</P>

<PRE CLASS="syntax">typedef ByteFlags PDAHardwareInfo;/*5ビット未使用*/#define PDAHI_BACKLIGHT_AVAILABLE(0x04)#define PDAHI_PDA_TYPE(0x02 0x01)/*PDAType*/</PRE>

<P>の<CODE>PDAType</CODE>は次のように列挙されます。</P>

<PRE CLASS="syntax">typedef ByteEnum PDAType;#define PDAT_PC_EMULATOR 0x0#define PDAT_N9000 0x1#define PDAT_N9000i 0x2</PRE>

<P>このルーチンは、Nokia 9000i Communicatorのビルド4以降でのみ使用できます(を参照)。<A HREF = "../../Nokia9000/Versions/Update_1.htm">バージョン</A>」を参照してください)。</P>

<P CLASS="refField"><STRONG>次を含む:</STRONG>respondr・ゴー</P>
</DIV>

<DIV>
          <A NAME="R_83.htm_IX_SerialClose()"></A>
        <H1 CLASS="refHeading">SerialClose()</H1>
<PRE CLASS="syntax">StreamError・SerialClose(GeodeHandle・ドライバー、SerialUnit・ユニット、ブール・リンガー)</PRE>
<P>シリアルポートへのストリームを閉じます。</P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_SerialCloseWithoutReset()"></A>
        <H1 CLASS="refHeading">SerialCloseWithoutReset()</H1>
<PRE CLASS="syntax">StreamError・SerialClose(GeodeHandle・ドライバー、SerialUnit・ユニット、ブール・リンガー)</PRE>
<P>実際にポートをリセットせずに、シリアルポートへのストリームを閉じます。</P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_SerialFlush()"></A>
        <H1 CLASS="refHeading">SerialFlush()</H1>
<PRE CLASS="syntax">StreamError・SerialFlush(GeodeHandleのドライバー、SerialUnit部門、StreamRolesの役割)</PRE>
<P>シリアルポートの入力バッファまたは出力バッファに保留されているすべてのデータをフラッシュします(<CODE>ロール</CODE>)をクリックします。</P>
</DIV>
<DIV>
          <A NAME="R_83.htm_IX_SerialGetError()"></A>
        <H1 CLASS="refHeading">SerialGetError()</H1>
<PRE CLASS="syntax">StreamError SerialGetError(ハンドルドライバー、SerialUnitユニット、StreamRolesロール、SerialError*エラーコード);</PRE>
<P>このルーチンは、シリアルドライバへの最後の呼び出しに関するエラー情報を返します。 の<CODE>SerialError</CODE>で定義されていないシリアルドライバ固有のエラーコードが返される場合があります。<CODE>SerialError</CODE>列挙型。</P>
</DIV>
<HR>
          <A NAME="R_84.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialGetFormat()"></A>
        <H1 CLASS="refHeading">SerialGetFormat()</H1>
<PRE CLASS="syntax">StreamError SerialGetFormat(GeodeHandleドライバー、SerialUnitユニット、SerialFormat*フォーマット、SerialMode*モード、SerialBaud*ボー);</PRE>
<P>指定したシリアルポートへのストリームの形式を取得します。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialGetModem()"></A>
        <H1 CLASS="refHeading">SerialGetModem()</H1>
<PRE CLASS="syntax">StreamError SerialGetModem(GeodeHandleドライバー、SerialUnitユニット、SerialModem*モデム)</PRE>
<P>モデムのハードウェアフロー制御ビットを読み取ります。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialOpen()"></A>
        <H1 CLASS="refHeading">SerialOpen()</H1>
<PRE CLASS="syntax">StreamError SerialOpen(GeodeHandleドライバー、SerialUnitユニット、StreamOpenFlagsフラグ、ワードinBuffSize、ワードoutBuffSize、ワードタイムアウト);</PRE>
<P>このルーチンは、指定されたシリアルポートにストリームをオープンします。 次の引数が渡されます。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>シリアルドライバの</DD>
<DT>
          <CODE>単位</CODE>
        </DT><DD>開くシリアルポート。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>ポートがビジー状態の場合にコールを失敗させるか、ポートが解放されるかどうかを確認するためにしばらく待機するかを指定します。</DD>
<DT>
          <CODE>inBuffSize</CODE>
        </DT><DD>シリアルポートからの入力に使用されるストリームバッファのサイズ。</DD>
<DT>
          <CODE>出力バッファサイズ</CODE>
        </DT><DD>シリアルポートへの出力に使用されるストリームバッファのサイズ。</DD>
<DT>
          <CODE>タイムアウト(timeout)</CODE>
        </DT><DD>ポートが解放されるまで待機するクロックティックの数。 (この引数は<CODE>フラグふらぐ</CODE>はSTREAM_OPEN_TIMEOUTではありません)。</DD>
</DL>
<P>ルーチンが成功した場合は、0を返します。 失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialQuery()"></A>
        <H1 CLASS="refHeading">SerialQuery()</H1>
<PRE CLASS="syntax">StreamError SerialQuery(GeodeHandleドライバー、SerialUnitユニット、StreamRolesロール、ワード*bytesAvailable);</PRE>
<P>シリアルバッファにどれだけの空き容量があるか、あるいはどれだけのデータが読み込まれるのを待っているかを調べます。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialRead()"></A>
        <H1 CLASS="refHeading">SerialRead()</H1>
<PRE CLASS="syntax">StreamError SerialRead(ハンドルドライバー、SerialUnitユニット、StreamBlockerブロッカー、ワードbuffSize、バイト*バッファー、ワード*numBytesRead);</PRE>
<P>シリアルポートからデータを読み込み、渡されたバッファに書き込みます。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialReadByte()"></A>
        <H1 CLASS="refHeading">SerialReadByte()</H1>
<PRE CLASS="syntax">StreamError SerialReadByte(ハンドルドライバー、SerialUnitユニット、StreamBlockerブロッカー、バイト*データバイト);</PRE>
<P>シリアルポートから1バイトのデータを読み込み、渡された変数に書き込みます。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialSetError()"></A>
        <H1 CLASS="refHeading">SerialSetError()</H1>
<PRE CLASS="syntax">StreamError SerialSetError(ハンドルドライバー、SerialUnitユニット、StreamRolesロール、SerialErrorエラーコード);</PRE>
<P>このルーチンはシリアルドライバ固有のエラーコードを設定します。<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_SerialGetError()">SerialGetError()</A></CODE>ボタンをクリックし<CODE></CODE></P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialSetFlowControl()"></A>
        <H1 CLASS="refHeading">SerialSetFlowControl()</H1>
<PRE CLASS="syntax">StreamError SerialSetFlowControl(ハンドルドライバー、SerialUnitユニット、SerialFlowControlフロー、SerialModemモデム、SerialModemStatusステータス);</PRE>
<P>このルーチンは、ソフトウェアフロー制御を有効または無効にします。 flow引数には、SFC_HARDWAREとSFC_SOFTWAREの2つのフラグがあります。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialSetFormat()"></A>
        <H1 CLASS="refHeading">SerialSetFormat()</H1>
<PRE CLASS="syntax">StreamError SerialSetFormat(GeodeHandleドライバー、SerialUnitユニット、SerialFormatフォーマット、SerialModeモード、SerialBaudボー);</PRE>
<P>ストリームの形式を指定されたシリアルポートに設定します。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialSetModem()"></A>
        <H1 CLASS="refHeading">SerialSetModem()</H1>
<PRE CLASS="syntax">StreamError SerialSetModem(GeodeHandleドライバー、SerialUnitユニット、SerialModemモデム);</PRE>
<P>モデムのハードウェアフロー制御ビットを設定します。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialWrite()"></A>
        <H1 CLASS="refHeading">SerialWrite()</H1>
<PRE CLASS="syntax">StreamError SerialWrite(GeodeHandleドライバー、SerialUnitユニット、StreamBlockerブロッカー、ワードbuffSize、const byte*buffer、word*numBytesWritten);</PRE>
<P>シリアルポートにデータを書き込みます。</P>
</DIV>
<DIV>
          <A NAME="R_84.htm_IX_SerialWriteByte()"></A>
        <H1 CLASS="refHeading">SerialWriteByte()</H1>
<PRE CLASS="syntax">StreamError SerialWrite(GeodeHandleドライバー、SerialUnitユニット、StreamBlockerブロッカー、ワードbuffSize、バイトdataByte);</PRE>
<P>シリアルポートに1バイトのデータを書き込みます。</P>
</DIV>
<HR>
          <A NAME="R_85.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_85.htm_IX_SGC_MACHINE() macro"></A>
        <H1 CLASS="refHeading">SGC_マシン</H1>
<PRE CLASS="syntax">バイトのSGC_MACHINE(<EM>値</EM>);dワード<EM>値</EM>;をクリックし</PRE>
<P>このマクロは、マシンタイプを<CODE><A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>戻り値</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">システム・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_85.htm_IX_SGC_PROCESSOR() macro"></A>
        <H1 CLASS="refHeading">SGC_プロセッサ</H1>
<PRE CLASS="syntax">バイトのSGC_PROCESSOR(<EM>値</EM>);dワード<EM>値</EM>;をクリックし</PRE>
<P>このマクロを使用して<CODE><A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>戻り値</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">システム・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_85.htm_IX_SocketAccept()"></A>
        <H1 CLASS="refHeading">SocketAccept()</H1>
<PRE CLASS="syntax">ソケットSocketAccept(ソケットs、int timeout)</PRE>
<P>ソケットを接続待ち状態にして接続を受け入れるには<CODE>SocketAccept()</CODE>ソケットはリスニングソケットである必要があります(<CODE><A HREF="../../CRef/Routines/R_89.htm#IX_SocketListen()">SocketListen()</A></CODE>)をクリックします。 なぜなら、スレッドは接続が確立されるまでブロックするからです。<CODE>SocketAccept()</CODE>がタイムアウトした場合、プログラムは通常、メイン実行スレッドでこのルーチンを呼び出さない。 代わりに、別のスレッドが接続の受け入れと接続からのデータの受信を処理します。</P>
<P>受け入れる接続がない場合は<CODE>SocketAccept()</CODE>はSE_LISTEN_QUEUE_EMPTYエラーを設定する。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>秒</EM>
        </DT><DD>リスニングソケット(<CODE><A HREF="../../CRef/Routines/R_89.htm#IX_SocketListen()">SocketListen()</A></CODE>)をクリックします。</DD>
<DT>
          <EM>タイムアウト(timeout)</EM>
        </DT><DD>成功を待つ時間(1/60秒単位)、または試行時間をSOCKET_NO_TIMEOUTで指定します。</DD>
</DL>
<P>接続を介してデータを送受信するために使用されるソケットを返します。 戻り値がゼロの場合は、エラーが発生しています。 コール(Call)<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>エラー値を調べます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_89.htm#IX_SocketListen()">SocketListen()</A></CODE><CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketConnect()">SocketConnect()</A></CODE><CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_85.htm_IX_SocketAddLoadOnMsg()"></A>
        <H1 CLASS="refHeading">SocketAddLoadOnMsg()</H1>
<PRE CLASS="syntax">SocketError SocketAddLoadOnMsg(SocketPort p、SocketLoadType slt、ワードディスク、TCHAR*パス);</PRE>
<P>特定のポートでパケットを受信したときにSocketライブラリがプログラムをロードするようにするには<CODE>SocketAddLoadOnMsg()</CODE>ソケットライブラリは、GEOS.INIファイルの[socket]カテゴリにキー「LoadOnMsg」を持つエントリを書き出します。 ソケットライブラリは、起動時にこれらのGEOS.INIファイルエントリを参照し、パケットを受信したときにそれに応じて動作します。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>ページ</EM>
        </DT><DD>監視するポート。</DD>
<DT>
          <EM>スラット</EM>
        </DT><DD>アプリケーションのロード方法(次のいずれか)<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>ボタンをクリックし</DD>
<DT>
          <EM>円板</EM>
        </DT><DD><CODE>DiskHandle</CODE>アプリケーションをロードします。 これは<CODE>StandardPath</CODE>値を入力します。</DD>
<DT>
          <EM>経路</EM>
        </DT><DD>ロードするアプリケーションのバッファ保持パス。</DD>
</DL>
<P>成功した場合、ルーチンはSE_NORMAL(すなわち0)を返す。 それ以外の場合は<CODE>SocketError</CODE>値を入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAddLoadOnMsgInDomain()">SocketAddLoadOnMsgInDomain()</A></CODE><CODE><A HREF="../../CRef/Routines/R_8a.htm#IX_SocketRemoveLoadOnMsg()">SocketRemoveLoadOnMsg()</A></CODE><CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE><CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_85.htm_IX_SocketAddLoadOnMsgInDomain()"></A>
        <H1 CLASS="refHeading">SocketAddLoadOnMsgInDomain()</H1>
<PRE CLASS="syntax">SocketError SocketAddLoadOnMsgInDomain(SocketPort p、SocketLoadType slt、ワードディスク、TCHAR*パス、TCHAR*ドメイン);</PRE>
<P>特定のドメイン内の特定のポートでパケットを受信したときにSocketライブラリがプログラムをロードするようにするには、次の関数を呼び出します。<CODE>SocketAddLoadOnMsgInDomain()</CODE>ソケットライブラリは、GEOS.INIファイルの[socket]カテゴリにキー「LoadOnMsg」を持つエントリを書き出します。 ソケットライブラリは、起動時にこれらのGEOS.INIファイルエントリを参照し、パケットを受信したときにそれに応じて動作します。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>ページ</EM>
        </DT><DD>監視するポート。</DD>
<DT>
          <EM>スラット</EM>
        </DT><DD>アプリケーションのロード方法(次のいずれか)<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>ボタンをクリックし</DD>
<DT>
          <EM>円板</EM>
        </DT><DD><CODE>DiskHandle</CODE>アプリケーションをロードします。 これは<CODE>StandardPath</CODE>値を入力します。</DD>
<DT>
          <EM>経路</EM>
        </DT><DD>ロードするアプリケーションのバッファ保持パス。</DD>
<DT>
          <EM>領域</EM>
        </DT><DD>監視するドメインの名前を保持するバッファ。</DD>
</DL>
<P>成功した場合、ルーチンはSE_NORMAL(すなわち0)を返す。 それ以外の場合は<CODE>SocketError</CODE>値を入力します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAddLoadOnMsg()">SocketAddLoadOnMsg()</A></CODE><CODE><A HREF="../../CRef/Routines/R_8a.htm#IX_SocketRemoveLoadOnMsgInDomain()">SocketRemoveLoadOnMsgInDomain()</A></CODE><CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE><CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_86.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_86.htm_IX_SocketBind()"></A>
        <H1 CLASS="refHeading">SocketBind()</H1>
<PRE CLASS="syntax">SocketError SocketBind(ソケットs、SocketPort p、SocketBindFlagsの旗);</PRE>
<P>次を使用します。<CODE>SocketBind()</CODE>ルーチンを使用して、ソケットを接続のこちら側のポート番号に関連付けます。</P>
<P>任意のドメインに対して、通常、マシン上の1つのソケットだけが任意のポート番号にバインドされます。 を使用したことがある場合は<CODE>SocketBind()</CODE>他のソケットをこのポートにバインドするには、flags引数にSBF_REUSE_PORTを設定することによってのみ、別のソケットをポートにバインドできます。 を使用したことがある場合は<CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBindInDomain()">SocketBindInDomain()</A></CODE>他のソケットをこのポートにバインドするには<CODE>SocketBind()</CODE>別のソケットをポートにバインドします。</P>
<P>特定のソケットは、1つのポートにしかバインドできません。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>秒</EM>
        </DT><DD>バインドするソケット。</DD>
<DT>
          <EM>ページ</EM>
        </DT><DD>監視するポート。</DD>
<DT>
          <EM>フラグふらぐ</EM>
        </DT><DD>別のソケットがバインドされている場合でも、ソケットをポートにバインドするには、SBF_REUSE_PORTを設定します。 (このフラグはデータグラムソケットでは使用できません)。</DD>
</DL>
<P>成功した場合、ルーチンはSE_NORMAL(すなわち0)を返す。 それ以外の場合は<CODE>SocketError</CODE>値を入力します。 SE_SOCKET_ALREADY_BOUND、SE_PORT_IN_USE、またはSE_BIND_CONFLICTに注意してください。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBindInDomain()">SocketBindInDomain()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_86.htm_IX_SocketBindInDomain()"></A>
        <H1 CLASS="refHeading">SocketBindInDomain()</H1>
<PRE CLASS="syntax">SocketError SocketBindInDomain(ソケットs、SocketPort p、SocketBindFlagsフラグ、TCHAR*ドメイン);</PRE>
<P>次を使用します。<CODE>SocketBindInDomain()</CODE>接続のこちら側で、ソケットをポート番号とドメインに関連付けるルーチン。</P>
<P>任意のドメインに対して、通常、マシン上の1つのソケットだけが、任意のドメインの任意のポート番号にバインドされます。 を使用したことがある場合は<CODE>SocketBindInDomain()</CODE>他のソケットをこのポートとドメインにバインドするには、flags引き数にSBF_REUSE_PORTを設定することによってのみ、別のソケットをポートとドメインにバインドできます。 を使用したことがある場合は<CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>他のソケットをこのポートにバインドするには<CODE>SocketBindInDomain()</CODE>別のソケットをポートにバインドします。</P>
<P>特定のソケットは、1つのポートにしかバインドできません。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>秒</EM>
        </DT><DD>バインドするソケット</DD>
<DT>
          <EM>ページ</EM>
        </DT><DD>監視するポート</DD>
<DT>
          <EM>フラグふらぐ</EM>
        </DT><DD>別のソケットがバインドされている場合でも、ソケットをポートにバインドするには、SBF_REUSE_PORTを設定します。</DD>
<DT>
          <EM>領域</EM>
        </DT><DD>監視するドメイン</DD>
</DL>
<P>成功した場合、ルーチンはSE_NORMAL(すなわち0)を返す。 それ以外の場合は<CODE>SocketError</CODE>値を入力します。 SE_SOCKET_ALREADY_BOUND、SE_PORT_IN_USE、またはSE_BIND_CONFLICTに注意してください。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_86.htm_IX_SocketCheckListen()"></A>
        <H1 CLASS="refHeading">SocketCheckListen()</H1>
<PRE CLASS="syntax">int SocketCheckListen(SocketPort p, TCHAR*domain, int bufsize);</PRE>
<P>次を使用します。<CODE>SocketCheckListen()</CODE>コマンドを使用して、リスニングソケット上の最初の接続要求(つまり、まだ受け入れられていない最初の接続要求)のドメインを検出します。 これは「発信者ID」の限定された形式と考えることができます。これは、着信接続を受け入れる前に、着信接続について少し調べる機会です。 次の場合<CODE>SocketCheckListen()</CODE>はSE_PORT_NOT_LISTENINGを返す。これは、ソケットがリッスンしているポートを渡していないことを意味する。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>ページ</EM>
        </DT><DD>確認するポート</DD>
<DT>
          <EM>領域</EM>
        </DT><DD>ドメイン名を保持するバッファ</DD>
<DT>
          <EM>bufsize[バッファサイズ]</EM>
        </DT><DD>のサイズ<EM>領域</EM>緩衝剤</DD>
</DL>
<P>ドメイン名の長さを返します。 戻り値が0の場合は、エラーが発生しています。 SE_PORT_NOT_LISTENINGに注意してください。これは、リッスンしている問題のポートにバインドされているソケットがないことを示します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE><CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBindInDomain()">SocketBindInDomain()</A></CODE><CODE><A HREF="../../CRef/Routines/R_89.htm#IX_SocketListen()">SocketListen()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_86.htm_IX_SocketCheckReady()"></A>
        <H1 CLASS="refHeading">SocketCheckReady()</H1>
<PRE CLASS="syntax">int SocketCheckReady(SocketCheckRequest*リクエスト、int numRequests、int timeout);</PRE>
<P>1つまたは複数のソケットをチェックして、データを受信したか、接続要求を受信したか、書き込みの準備ができているかを確認するには<CODE>SocketCheckReady()</CODE>着信データの接続をチェックすることも、緊急データの着信だけをチェックすることもできる。</P>
<P>多くのソケットをポーリングする必要があるプログラムでは<CODE>SocketCheckReady()</CODE>は、ソケットごとにスレッドを生成することなく、これを行うための適切な手段を提供します。</P>
<P>の<CODE>SocketCheckReady()</CODE>ルーチンは以下の配列を取る<CODE>SocketCheckRequest</CODE>構造。 これらの構造体にはそれぞれ、ソケットと条件が含まれています。<CODE>SocketCheckReady()</CODE>それぞれを見る<CODE>SocketCheckRequest</CODE>構造体を配列に格納し、ソケットが条件を満たす最初の構造体のインデックスを返す。</P>
<P>したがって、与えられたソケットがデータを送信できるように適切に設定されているかどうかを判断するには<CODE>SocketCheckReady()</CODE>1要素の配列(擬似コードで表現):</P>
<PRE>{mySocket, SC_WRITE, 0}</PRE>
<P>いくつかのソケットをチェックして、それらのいずれかが接続要求を受信したかどうかを確認するには、pass<CODE>SocketCheckReady()</CODE>次の形式の配列(擬似コードで表現):</P>
<PRE>{socket1, SC_ACCEPT, 0},{socket2, SC_ACCEPT, 0},{socket3, SC_ACCEPT, 0}です。</PRE>
<P>どのソケットでも、次の条件を1つ以上チェックできます。</P>
<DL>
<DT>SC_ACCEPT(同意する)</DT><DD>ソケットが接続をリッスンしている場合、この状態は、別のソケットが実際にリッスンしているソケットに接続しようとしていることを示します。</DD>
<DT>SC_読み取り</DT><DD>ソケットが接続されている場合、この状態は、データのパケットが着信し、読み取りの準備ができていることを示します。</DD>
<DT>SC_例外</DT><DD>ソケットが接続されている場合、この状態は、ソケットが接続に何らかの問題があることを認識したことを示します。</DD>
<DT>SC_緊急</DT><DD>ソケットが接続されている場合、この状態は、緊急とマークされたデータのパケットを受信したことを示します。</DD>
<DT>SC_書き込み</DT><DD>この状態は、データがソケットを介して送信される可能性があることを示します。</DD>
</DL>
<P>現在の状態に当てはまらない条件をソケットに問い合わせた場合(例えば、受け入れ準備ができているかどうかを非リスニングソケットに問い合わせた場合)<CODE>SocketCheckReady()</CODE>はSE_IMPROPER_CONDITIONを返す。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>要求</EM>
        </DT><DD>の配列<CODE>SocketCheckRequests</CODE>上で説明した構造</DD>
<DT><EM>numRequests</DT><DD></EM>内の要素数<EM>要求</EM>配列。</DD>
<DT>
          <EM>タイムアウト(timeout)</EM>
        </DT><DD>成功を待つ時間(1/60秒単位)、または試行時間をSOCKET_NO_TIMEOUTで指定します。</DD>
</DL>
<P>このルーチンは、最初のインデックスを返します。<CODE>SocketCheckRequest</CODE>条件を満たす必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_87.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_87.htm_IX_SocketClose()"></A>
        <H1 CLASS="refHeading">SocketClose()</H1>
<PRE CLASS="syntax">SocketError SocketClose(ソケット)</PRE>
<P>の<CODE>SocketClose()</CODE>ルーチンはソケットをクローズして解放する。 これを使用して、データグラムソケットを閉じて解放します。 SE_CONNECTION_CLOSED例外に応答するときに呼び出すルーチンです。<CODE>SocketClose()</CODE>は任意の状態のソケットで使用でき、送信データと受信データの両方をシャットダウンし、クリーンアップし、ソケットを解放します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketCloseSend()">SocketCloseSend()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_87.htm_IX_SocketCloseDomainMedium()"></A>
        <H1 CLASS="refHeading">SocketCloseDomainMedium()</H1>
<PRE CLASS="syntax">SocketError SocketCloseDomainMedium(char*domain, MediumAndUnit*mau, Boolean force);</PRE>
<P>このルーチンは、ソケット接続のハードウェア面を「ハングアップ」させます。 メディアを使用するソケット接続がない場合にのみ、これを行うように要求できます。 メディアを使用するソケット接続でメディアを強制的に閉じると、接続は通知を受け取りません(SE_CONNECTION_RESETエラーが発生するだけです)。したがって、極端な状況でのみメディアを強制的に閉じる必要があります。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>領域</EM>
        </DT><DD>ドメイン名を保持する文字列へのポインタ。</DD>
<DT>
          <EM>マウ</EM>
        </DT><DD>へのポインタ<CODE>MediumAndUnit</CODE>どのメディアを「ハングアップ」させるかを指定する構造体。</DD>
<DT>
          <EM>力</EM>
        </DT><DD>メディアを使用しているアクティブな接続がある場合にメディアをそのままにするには0、アクティブな接続がある場合でもメディアを強制的に閉じるには0以外の値を指定します。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_87.htm_IX_SocketCloseSend()"></A>
        <H1 CLASS="refHeading">SocketCloseSend()</H1>
<PRE CLASS="syntax">SocketError SocketCloseSend(ソケット)</PRE>
<P>の<CODE>SocketCloseSend()</CODE>ルーチンは接続されたソケットでのみ動作します。 (常に<CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketClose()">SocketClose()</A></CODE>を使ってデータグラムソケットを閉じる)。 ソケットを部分的にシャットダウンして、ソケットがデータを送信できないようにします。<CODE><A HREF="../../CRef/Routines/R_8a.htm#IX_SocketSend()">SocketSend()</A></CODE>は、部分的に閉じたソケットが渡された場合にSE_SOCKET_CLOSEDを返す。 ただし、ソケットを介してデータを受信することはできます。<CODE><A HREF="../../CRef/Routines/R_89.htm#IX_SocketRecv()">SocketRecv()</A></CODE>SE_CONNECTION_CLOSED例外をチェックします。<CODE>SocketCloseSend()</CODE>はSE_CONNECTION_CLOSED例外パケットを接続の相手側に送信します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_87.htm_IX_SocketConnect()"></A>
        <H1 CLASS="refHeading">SocketConnect()</H1>
<PRE CLASS="syntax">SocketError SocketConnect(Socket s, SocketAddress*addr, int timeout);</PRE>
<P>接続を確立するには<CODE>SocketConnect()</CODE>によって作成されたソケットを<CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketCreate()">SocketCreate()関数</A></CODE>、接続先のアドレス、およびタイムアウト値です。</P>
<P>データグラムソケットを使用して真の接続を形成することはできません。 ただし<CODE>SocketConnect()</CODE>データグラムソケットを使用して、パケットの送信時に使用するデフォルトの宛先アドレスを指定します。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>秒</EM>
        </DT><DD>接続を行うソケット。</DD>
<DT>
          <EM>アドレス</EM>
        </DT><DD>接続先のアドレス。 これは、以下によって返されるプリミティブアドレスである必要があります。<CODE><A HREF="../../CRef/Routines/R_8a.htm#IX_SocketResolve()">SocketResolve()</A></CODE>ボタンをクリックし</DD>
<DT>
          <EM>タイムアウト(timeout)</EM>
        </DT><DD>成功を待つ時間(1/60秒単位)、または試行時間をSOCKET_NO_TIMEOUTで指定します。</DD>
</DL>
<P>の<CODE>SocketConnect()</CODE>ルーチンは<CODE>SocketError</CODE>値を入力します。 ルーチンがSE_NORMALを返した場合、接続は正常に確立されました。 SE_CONNECTION_REFUSEDが返された場合、リモート・サイトは接続を受け入れる準備ができていませんでした。 SE_CONNECTION_ERRORが返された場合、何らかの理由で接続が確立されませんでした。 SE_NON_UNIQUE_CONNECTIONが返された場合、別の接続と同一の接続を作成しようとしています。つまり、同じ送信元アドレス、送信元ポート、宛先アドレス、宛先ポート、および配信タイプです。 これらの接続を区別する方法はありません。 両方の側から同時に同じ接続を開こうとすると、両方ともSE_NON_UNIQUE_CONNECTIONで失敗することがあります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_87.htm_IX_SocketCreate()"></A>
        <H1 CLASS="refHeading">SocketCreate()関数</H1>
<PRE CLASS="syntax">SocketSocketCreate(SocketDeliveryTypeへの配送)</PRE>
<P>新しいソケットを作成するには<CODE>SocketCreate()関数</CODE>ソケットの配信タイプ(SDT_DATAGRAM、SDT_SEQ_PACKET(シーケンシャルパケット)、またはSDT_STREAM)を指定する必要があります。 0が返された場合は、エラーが発生しています。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>エラー値aを取得します。<CODE>SocketError</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_88.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_88.htm_IX_SocketGetAddressController()"></A>
        <H1 CLASS="refHeading">SocketGetAddressController()</H1>
<PRE CLASS="syntax">ClassStruct*SocketGetAddressController(炭*ドメイン)</PRE>
<P>ドメイン名を指定すると、そのドメイン内のアドレスを選択するためのUIガジェットを作成できます。 コール(Call)<CODE>SocketGetAddressController()</CODE>適切なコントローラのクラスを取得します。</P>
<P>このルーチンは、コントローラを作成するドメインの名前を含むバッファを取ります。 を返します。<CODE>ClassStruct</CODE>渡されるポインタ<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>ボタンをクリックし</P>
<P>アドレスコントローラのAPI情報については、XXX XREFソケットの章XXXを参照してください。</P>
<P>ルーチンが0を返す場合は、エラーが発生しています。 コール(Call)<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>エラーの内容を確認します(<CODE>SocketError</CODE>値)。 SE_UNKNOWN_DOMAINに注意してください。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_88.htm#IX_SocketGetDomains()">SocketGetDomains()</A></CODE><CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_88.htm_IX_SocketGetAddressMedium()"></A>
        <H1 CLASS="refHeading">SocketGetAddressMedium()</H1>
<PRE CLASS="syntax">SocketError SocketGetAddressMedium(SocketAddress*sa, MediumAndUnit*mau);</PRE>
<P>特定のアドレスへの接続に使用されるポートを確認するには<CODE>SocketGetAddressMedium()</CODE>ソケットが実際に接続されている必要はありません。 使用するメディアによっては、他のドメインを介して他のサイトに接続しようとしたり、接続をまったく行わない場合があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_88.htm_IX_SocketGetAddressSize()"></A>
        <H1 CLASS="refHeading">SocketGetAddressSize()</H1>
<PRE CLASS="syntax">int domain(char*SocketGetAddressSize);</PRE>
<P>指定したドメインの最大アドレスデータサイズを調べるには<CODE>SocketGetAddressSize()</CODE>これは、完全なアドレスを処理するのに十分な大きさのメモリを割り当てる場合に役立ちます。</P>
<P>このルーチンは、エラー時に0を返します。 エラーの内容を確認するには、ThreadGetError()を呼び出します。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>が0を返した場合、実際にはエラーは発生していない。このドメインはアドレスバッファを必要としない。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_88.htm_IX_SocketGetDomainMedia()"></A>
        <H1 CLASS="refHeading">SocketGetDomainMedia()</H1>
<PRE CLASS="syntax">ChunkHandle SocketGetDomainMedia(char*domain, optr mediaList);</PRE>
<P>ユーザーのマシンが特定のドメインに接続するために使用しているハードウェアポートの種類を知りたい場合は<CODE>SocketGetDomainMedia()</CODE>のチャンク配列を返します。<CODE>メディアタイプ</CODE>構造。 特定の接続を行うためのドメインを選択できる場合は、どのメディアを使用して接続を行うかを検討できます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_88.htm_IX_SocketGetDomains()"></A>
        <H1 CLASS="refHeading">SocketGetDomains()</H1>
<PRE CLASS="syntax">ChunkHandle SocketGetDomains(optr domainList);</PRE>
<P>の<CODE>SocketGetDomains()</CODE>ルーチンはチャンク配列のoptrを取得し、その配列に要素を入力します。各要素には文字列が含まれ、各文字列はサポートされているドメインの名前です。 このチャンク配列には標準があります<CODE>ChunkArrayHeader</CODE>ヘッダーと可変サイズの要素。</P>
<P>戻り値が0の場合は、エラーが発生しています。 コール(Call)<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>それが何なのか調べました</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_88.htm_IX_SocketGetMediumAddress()"></A>
        <H1 CLASS="refHeading">SocketGetMediumAddress()</H1>
<PRE CLASS="syntax">SocketError SocketGetMediumAddress(char*domain, bye*buffer, int*bufsize, MediumAndUnit*mau);</PRE>
<P>このルーチンは、特定のメディアを使用して接続のローカルアドレスを決定します。 別のマシンがそのメディアを介してこのマシンに接続する場合、このアドレスが使用されます。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>領域</EM>
        </DT><DD>ドメイン名(ヌルで終了する文字列)。</DD>
<DT>
          <EM>緩衝剤</EM>
        </DT><DD>アドレス情報を保持するバッファ。</DD>
<DT>
          <EM>bufsize[バッファサイズ]</EM>
        </DT><DD>バッファのサイズ(バイト単位)。</DD>
<DT>
          <EM>マウ</EM>
        </DT><DD>媒体だ</DD>
</DL>
<P>ルーチンがSE_NORMALを返した場合、アドレスは正常に計算されました。 の<EM>緩衝剤</EM>バッファはアドレスデータでいっぱいになります。<EM>bufsize[バッファサイズ]</EM>numberは、アドレスデータの合計サイズに変更されます。<EM>緩衝剤</EM>の場合、アドレスは切り捨てられました。</P>
</DIV>
<DIV>
          <A NAME="R_88.htm_IX_SocketGetPeerName()"></A>
        <H1 CLASS="refHeading">SocketGetPeerName()</H1>
<PRE CLASS="syntax">SocketError SocketGetPeerName(Socket s, SocketAddress*addr);</PRE>
<P>ソケットが接続されている場合は<CODE>SocketGetPeerName()</CODE>接続の反対側にあるソケットのアドレスを取得します。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>秒</EM>
        </DT><DD>検査する接続ソケット。</DD>
<DT>
          <EM>アドレス</EM>
        </DT><DD>バッファ保持用中空<CODE>ソケットアドレス</CODE>構造。 の<CODE>SAドメイン</CODE><CODE>SA_ドメインサイズ</CODE>、および<CODE>SA_addressSize</CODE>フィールドを初期化する必要があります。 バッファは<CODE>ソケットアドレス</CODE>構造とアドレスのデータ</DD>
</DL>
<P>エラーがなければSE_NORMAL(すなわち0)を返す。<CODE>SocketError</CODE>値を入力します。 addrバッファはアドレス情報で埋められます。 ドメイン名またはアドレスバッファのいずれかが文字列を保持するのに十分な大きさでない場合、結果として切り捨てられた文字列はNULL終端されません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_88.htm_IX_SocketGetSocketName()"></A>
        <H1 CLASS="refHeading">SocketGetSocketName()</H1>
<PRE CLASS="syntax">SocketError SocketGetSocketName(Socket s, SocketAddress*addr);</PRE>
<P>接続のソケット自身の側を表すために使用されるアドレスを見つけるには<CODE>SocketGetSocketName()</CODE>ボタンをクリックし</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>秒</EM>
        </DT><DD>検査する接続ソケット。</DD>
<DT>
          <EM>アドレス</EM>
        </DT><DD>バッファ保持用中空<CODE>ソケットアドレス</CODE>構造。 の<CODE>SAドメイン</CODE><CODE>SA_ドメインサイズ</CODE>、および<CODE>SA_addressSize</CODE>フィールドを初期化する必要があります。 バッファは<CODE>ソケットアドレス</CODE>構造とアドレスのデータ</DD>
</DL>
<P>エラーがなければSE_NORMAL(すなわち0)を返す。<CODE>SocketError</CODE>値を入力します。 addrバッファはアドレス情報で埋められます。 ドメイン名またはアドレスバッファのいずれかが文字列を保持するのに十分な大きさでない場合、結果として切り捨てられた文字列はNULL終端されません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_88.htm_IX_SocketGetIntSocketOption()"></A>
        <H1 CLASS="refHeading">SocketGetIntSocketOption()</H1>
<PRE CLASS="syntax">int SocketGetIntSocketOption(ソケットskt、SocketOption opt);</PRE>
<P>このルーチンはソケットのオプションの1つをチェックし、そのオプションの現在の設定を返します。 戻り値の意味は、渡された</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>ショット</EM>
        </DT><DD>確認するソケット。</DD>
<DT>
          <EM>選ぶ</EM>
        </DT><DD>どのオプションをチェックするか。 次のオプションを使用できます。</DD>
<DT></DT><DD>SO_RECV_BUF:着信データ用のソケットのバッファの最大サイズ。値-1は制限がないことを意味します。</DD>
<DT></DT><DD>SO_SEND_BUF:送信データ用のソケットのバッファの最大サイズ。値-1は制限がないことを意味します。</DD>
<DT></DT><DD>SO_INLINE:緊急データを通常のデータと同じキューに入れる場合は0以外、緊急データを特別に扱う場合は0。</DD>
<DT></DT><DD>SO_NODELAY:ドメインドライバが全てのパケットを即座に送信する場合は0以外の値を、より大きなブロックとして送信するためにパケットを保存する場合は0を指定します。</DD>
<DT></DT><DD>SO_OWNER:ソケットを所有するスレッドのハンドルを取得します。</DD>
</DIV>
</DL>
<HR>
          <A NAME="R_89.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_89.htm_IX_SocketInterrupt()"></A>
        <H1 CLASS="refHeading">SocketInterrupt()</H1>
<PRE CLASS="syntax">SocketError SocketInterrupt(ソケット)</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAccept()">SocketAccept()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_89.htm#IX_SocketRecv()">SocketRecv()</A></CODE>渡されたソケットで保留中<EM>秒</EM>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_89.htm_IX_SocketInterruptResolve()"></A>
        <H1 CLASS="refHeading">SocketInterruptResolve()</H1>
<PRE CLASS="syntax">SocketError SocketInterruptResolve(TCHAR*domain, byte*address, int addrSize);</PRE>
<P>このルーチンは、指定されたアドレスの解決を中断しようとします。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>領域</EM>
        </DT><DD>ドメインの名前。</DD>
<DT>
          <EM>住所</EM>
        </DT><DD>解決されるアドレス。</DD>
<DT>
          <EM>addrSize</EM>
        </DT><DD>のサイズ<EM>住所</EM>バッファ。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>この機能は信頼性に欠ける。 解決呼び出しの処理が開始される前に実行された場合、目的の解決呼び出しを中断することはできません。 の場合、同じドメイン内の他の並列解決が中断されることもあります。</P>
</DIV>
<DIV>
          <A NAME="R_89.htm_IX_SocketListen()"></A>
        <H1 CLASS="refHeading">SocketListen()</H1>
<PRE CLASS="syntax">SocketError SocketListen(ソケットs、int qSize);</PRE>
<P>シーケンス処理された着信パケットまたはストリーム接続をリッスンするには<CODE>SocketListen()</CODE>ソケットは、リッスンする前にポートにバインドされている必要があります。ポートを介した複数の接続を許可することができます。接続の最大数を引数として指定して<CODE>SocketListen()</CODE>ボタンをクリックし</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>秒</EM>
        </DT><DD>の<CODE>ソケット</CODE>着信接続をリッスンする必要があります。 ソケットはポートにバインドする必要があります。</DD>
<DT>
          <EM>サイズ(S)</EM>
        </DT><DD>ソケットを介して受け入れられる着信接続の数。</DD>
</DL>
<P>の<CODE>SocketListen()</CODE>ルーチンは、渡されたソケットが接続を受け入れるために&quot;listen&quot;するようにします。 別のソケットがすでにポートをリッスンしている場合<CODE>SocketListen()</CODE>ルーチンはSE_PORT_ALREADY_LISTENINGを返す。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE><CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAccept()">SocketAccept()</A></CODE><CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketCheckReady()">SocketCheckReady()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_89.htm_IX_SocketOpenDomainMedium()"></A>
        <H1 CLASS="refHeading">SocketOpenDomainMedium()</H1>
<PRE CLASS="syntax">SocketError SocketOpenDomainMedium(SocketAddress*addr, int timeout);</PRE>
<P>このルーチンは、指定されたメディアを使用して「raw」接続を開きます。 「生の」接続が正確に何を意味するかは、関係するドメインによって異なります。 TCPの場合、このルーチンはモデムにダイヤルし、PPPサーバへのPPP接続を作成しますが、TCPパケットは送信しません。</P>
<P>&quot;raw&quot;接続が既に存在する場合、このルーチンはSE_NORMALを返します。これは接続をオープンした直後と同じです。</P>
<P>デバイスの電話機がビジー状態の場合、このルーチンはSE_MEDIUM_BUSYを返します。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>アドレス</DT><DD>接続先のアドレス。</DD>
<DT>タイムアウト(timeout)</DT><DD>接続を待機する1/60秒のティック数。 永久に待機するには、SOCKET_NO_TIMEOUTを渡します。</DD>
</DL>
<P>接続が完了したら、次のコマンドで接続を閉じます。<CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketCloseDomainMedium()">SocketCloseDomainMedium()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketCloseDomainMedium()">SocketCloseDomainMedium()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_89.htm_IX_SocketRecv()"></A>
        <H1 CLASS="refHeading">SocketRecv()</H1>
<PRE CLASS="syntax">int SocketRecv(Socket s, void*buffer, int bufSize, int timeout, SocketRecvFlagsフラグ,SocketAddress*addr);</PRE>
<P>の<CODE>SocketRecv()</CODE>ルーチンはソケットからデータを受信する。 渡されたバッファをデータで満たした後、ソケットは受信したデータのコピーを破棄して、次の着信データのためのスペースを作ります。</P>
<P>着信データの次のパケットを「覗き見る」には<CODE>SocketRecv()</CODE>SRF_PEEKフラグを渡します。 これにより、着信データの次のパケットのサイズを取得し、そのパケットの内容を非破壊的に確認することもできます。</P>
<P>パケットベースの配信タイプのソケット(シーケンスパケットまたはデータグラム配信ソケット)を使用する場合、パケット全体しか受信できません。ソケットからデータを取得しても、パケット内のすべてのデータを取得しないと、残りのデータは失われます。 したがって、これらの配信タイプを使用するソケットの最大パケットサイズを設定することをお勧めします。パケットを受信するために必要なスペースがわからない場合は<CODE>SocketRecv()</CODE>SRF_PEEKフラグ-ソケットにコピーを破棄させることなく、受信データを「覗き見る」ことができます。</P>
<P>の<CODE>SocketRecv()</CODE>ルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>秒</EM>
        </DT><DD>データを取得するソケット。</DD>
<DT>
          <EM>緩衝剤</EM>
        </DT><DD>データを格納するバッファ。</DD>
<DT>
          <EM>bufSize/ファイルサイズ</EM>
        </DT><DD>データ・バッファのサイズ。 これがデータ量よりも小さく、ソケットの配信タイプがパケットベースの場合、バッファに収まらないデータは失われます。ソケットがストリームソケットの場合、残りのデータはソケットに保持されます。</DD>
<DT>
          <EM>タイムアウト(timeout)</EM>
        </DT><DD>受信データを待機する1/60秒のティック数。 永久に待機するには、SOCKET_NO_TIMEOUTを渡します。</DD>
<DT>
          <EM>フラグふらぐ</EM>
        </DT><DD>このフラグフィールドでは、いくつかのオプションを指定できます。 SRF_ADDRESSフラグを設定して、送信マシンのアドレスを<EM>アドレス</EM>SRF_URGENTフラグを設定して、緊急とマークされたパケットだけを受信します。 SRF_PEEKフラグを設定して、着信パケットを「ピーク」し、ソケットに残します。</DD>
<DT>
          <EM>アドレス</EM>
          <STRONG>
        </DT><DD></STRONG>SRF_ADDRESS_FLAGを渡した場合は、空の<CODE>ソケットアドレス</CODE>バッファ。 バッファにアドレスデータ用のスペースがあることを確認してください。<CODE>ソケットアドレス</CODE>構造。 構造の<CODE>SAドメイン</CODE><CODE>SA_ドメインサイズ</CODE>、および<CODE>SA_addressSize</CODE>フィールドを初期化する必要があります。 ドメインバッファかアドレスバッファのどちらかが文字列を保持するのに十分な長さでない場合、結果として切り捨てられた文字列はNULL終端されません。</DD>
</DL>
<P>の<CODE>SocketRecv()</CODE>ルーチンは受信したバッファのサイズを返す。 このサイズがゼロの場合は、接続にエラーがある可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_8a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_8a.htm_IX_SocketRemoveLoadOnMsg()"></A>
        <H1 CLASS="refHeading">SocketRemoveLoadOnMsg()</H1>
<PRE CLASS="syntax">SocketError SocketRemoveLoadOnMsg(SocketPort p)</PRE>
<P>ポートにパケットが到着したことを検知したときにプログラムをロードするようにSocketライブラリに要求した場合は<CODE>SocketRemoveLoadOnMsg()</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAddLoadOnMsg()">SocketAddLoadOnMsg()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8a.htm_IX_SocketRemoveLoadOnMsgInDomain()"></A>
        <H1 CLASS="refHeading">SocketRemoveLoadOnMsgInDomain()</H1>
<PRE CLASS="syntax">SocketError SocketRemoveLoadOnMsgInDomain(SocketPort p、TCHAR*ドメイン);</PRE>
<P>Socketライブラリに対して、特定のドメインのポートにパケットが到着したことを検知したときにプログラムをロードするように要求した場合は<CODE>SocketRemoveLoadOnMsgInDomain()</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAddLoadOnMsgInDomain()">SocketAddLoadOnMsgInDomain()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8a.htm_IX_SocketResolve()"></A>
        <H1 CLASS="refHeading">SocketResolve()</H1>
<PRE CLASS="syntax">int SocketResolve(char*domainName, byte*rawAddr, int addrSize, byte*result, int resultBuffSize);</PRE>
<P>アドレスが最もプリミティブな形式でない限り、そのアドレスを他のソケットライブラリルーチンで使用することはできません。 このプリミティブ形式は、アドレスの上位形式を取得し、それを<CODE>SocketResolve()</CODE>ルーチン。 アドレスコントローラによって返されるアドレスは、最も基本的な形式ではないことを思い出してください。 アドレスのプリミティブ形式は不安定になる可能性があります。短期間に複数の接続を行う場合は、それらを自由に再利用してください。ただし、アドレスが最後に解決されてから長い時間が経過している場合は、アドレスを再解決してください。 アドレスの解決に関しては、大きなオーバーヘッドが発生する可能性があることに注意してください。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT><STRONG>ドメイン名</DT><DD></STRONG>ヌル終端されたドメイン名文字列を含むバッファ。</DD>
<DT>
          <STRONG>rawAddr</STRONG>
        </DT><DD>アドレスの未解決形式を含むバッファ。 通常、これは<CODE>SACAddress</CODE>に応じてSocketAddressControlによって戻される<CODE>MSG_SOCKET_ADDRESS_CONTROL_GET_ADDRESSES&lt;アドレス></CODE>ボタンをクリックし</DD>
<DT></DT><DD>SocketAddressControlからアドレスを解決するのではなく、実際にはゼロから生のアドレスを構築する必要がある場合は、のマニュアルを参照してください。<CODE>SACAddress</CODE>ボタンをクリックし</DD>
<DT>
          <STRONG>addrSize</STRONG>
        </DT><DD>のサイズ<EM>rawAddr</EM>バッファ(通常は<CODE>SACA_opaqueSize</CODE>に反応してSocketAddressControlが返したSACAddressからの畑<CODE>MSG_SOCKET_ADDRESS_CONTROL_GET_ADDRESSES&lt;アドレス></CODE>ボタンをクリックし</DD>
<DT>
          <STRONG>結果#ケッ</STRONG>
        </DT><DD>解決されたアドレスを保持するバッファ。 これは通常<CODE>ソケットアドレス</CODE>構造。</DD>
<DT><STRONG>結果バッファサイズ</DT><DD></STRONG>のサイズ<EM>結果#ケッ</EM>バッファ。</DD>
</DL>
<P>解決されたアドレスのサイズを返します。 0が返された場合は、エラーが発生しています。 コール(Call)<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>エラーの内容を確認します。 注意すべき一般的なエラーは、SE_BUFFER_TOO_SMALL、SE_DESTINATION_UNREACHABLE、およびSE_TEMPORARY_ERRORです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8a.htm_IX_SocketSend()"></A>
        <H1 CLASS="refHeading">SocketSend()</H1>
<PRE CLASS="syntax">SocketError SocketSend(Socket s, void*buffer, int bufSize, SocketSendFlags flags, SocketAddress*addr);</PRE>
<P>の<CODE>SocketSend()</CODE>ルーチンはソケット経由でデータを送信する。 これにはいくつかの引数があります。</P>
<DL>
<DT>
          <EM>秒</EM>
        </DT><DD>データの送信に使用するソケット</DD>
<DT>
          <EM>緩衝剤</EM>
        </DT><DD>送信するデータを含むバッファ</DD>
<DT>
          <EM>bufSize/ファイルサイズ</EM>
        </DT><DD>データバッファのサイズ。</DD>
<DT>
          <EM>フラグふらぐ</EM>
        </DT><DD>送信時に使用するオプション。 アドレスを渡す場合はSSF_ADDRESSを設定します。<EM>アドレス</EM>パケットに緊急のマークを付けるには、SSF_URGENTを設定します。</DD>
<DT><EM>アドレス</DT><DD></EM>データの送信先アドレス。</DD>
<DT></DT><DD>ソケットがシーケンスパケットまたはストリーム配信タイプのソケットである場合、このオプションのアドレスは無視されます。</DD>
<DT></DT><DD>ソケットがデータグラム配信タイプのソケットである場合、ソケットが後述のデフォルトの宛先アドレスを持っていない限り、ここでパケットの宛先アドレスを指定します。</DD>
<DT></DT><DD>データグラムソケットは<CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketConnect()">SocketConnect()</A></CODE>ルーチンを使用して、デフォルトの宛先アドレスを指定します。 デフォルトアドレスがない場合は、ここでパケットの宛先アドレスを指定する必要があります。 デフォルトの宛先アドレスがあり、このオプションのアドレスを渡してもそれらのアドレスが一致しない場合、ソケットライブラリは致命的なエラーを生成します。</DD>
</DL>
<P>通常<CODE>SocketSend()</CODE>はSE_NORMALを返す。 エラーを検出した場合は<CODE>SocketError</CODE>値を入力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8a.htm_IX_SocketSetIntSocketOption()"></A>
        <H1 CLASS="refHeading">SocketSetIntSocketOption()</H1>
<PRE CLASS="syntax">void SocketSetIntSocketOption(Socket skt, SocketOption opt, int newval);</PRE>
<P>このルーチンは、ソケットのオプションの設定を変更します。</P>
<P>このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <EM>ショット</EM>
        </DT><DD>ソケット。</DD>
<DT>
          <EM>選ぶ</EM>
        </DT><DD>変更するオプション。 次のオプションを使用できます。</DD>
<DT></DT><DD>SO_RECV_BUF:着信データ用のソケットのバッファの最大サイズ。値-1は制限がないことを意味します。</DD>
<DT></DT><DD>SO_SEND_BUF:送信データ用のソケットのバッファの最大サイズ。値-1は制限がないことを意味します。</DD>
<DT></DT><DD>SO_INLINE:緊急データを通常のデータと同じキューに入れる場合は0以外、緊急データを特別に扱う場合は0。</DD>
<DT></DT><DD>SO_NODELAY:ドメインドライバが全てのパケットを即座に送信する場合は0以外の値を、より大きなブロックとして送信するためにパケットを保存する場合は0を指定します。</DD>
<DT></DT><DD>SO_OWNER:ソケットの新しい所有スレッドを指定してください。</DD>
<DT>
          <EM>ニューバール</EM>
        </DT><DD>オプションの新しい設定を指定します。 この値の意味は、変更するオプションによって異なります。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_8b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_8b.htm_IX_SoundAllocMusic()"></A>
        <H1 CLASS="refHeading">SoundAllocMusic()</H1>
<PRE CLASS="syntax">word SoundAllocMusic(/*SOUND_ERROR_value*/const word*song, word voices, MemHandle*controlを返します);</PRE>
<P>このルーチンは、音楽の固定バッファへのポインタを取り<CODE>MemHandle</CODE>これは次に<CODE><A HREF="../../CRef/Routines/R_8c.htm#IX_SoundPlayMusic()">SoundPlayMusic()</A></CODE>音楽を演奏しました ハンドルは<EM>制御</EM>ボタンをクリックし<CODE>SoundAllocMusic()</CODE>は、音楽ブロックを割り当てようとしてエラーが発生した場合、0以外の値を返す。</P>
<P>音楽バッファが移動可能なリソースにある場合は<CODE><A HREF="../../CRef/Routines/R_8c.htm#IX_SoundInitMusic()">SoundInitMusic()</A></CODE>の代わりに<CODE>SoundAllocMusic()</CODE>である。<EM>ボイス</EM>argumentは、バッファ内の音声の数です。</P>
</DIV>
<DIV>
          <A NAME="R_8b.htm_IX_SoundAllocMusicNote()"></A>
        <H1 CLASS="refHeading">SoundAllocMusicNote()</H1>
<PRE CLASS="syntax">word SoundAllocMusicNote(/*SOUND_ERROR_.を返します。 値を入力します。 */InstrumentPatch計器、ワードinstTable、ワード頻度、ワードボリューム、SoundStreamDeltaTimeTypeデルタタイプ、ワード継続時間、MemHandle*コントロール);</PRE>
<P>このルーチンは<CODE>MemHandle</CODE>これは<CODE><A HREF="../../CRef/Routines/R_8c.htm#IX_SoundPlayMusicNote()">SoundPlayMusicNote()</A></CODE>ノートに関するすべての情報(頻度、ボリューム、期間)を指定する必要があります。</P>
<P>標準楽器を使用して音符を演奏するには<EM>器具</EM>と0 in<EM>instTable</EM>カスタム音源を使用するには<EM>instTable</EM>キーを押します<EM>器具</EM>は、計測器へのポインタである必要があります。</P>
<P>周波数をヘルツ単位で指定するか、MIDDLE_C_bなどの定数の1つを使用して標準の音符の周波数を指定します。 音量の範囲は0から0 xffffまでです--音量を選択したい場合は、DYNAMIC_FFFのような定数値を使用することもできます。 音符の継続時間は、SSDTT_MSEC、SSDTT_TICKS、SSDTT_TEMPOのいずれかのデルタタイプによって決まります。 SSDTT_MSECまたはSSDTT_TICKSを渡した場合、継続時間はミリ秒またはティック(各ティックは60分の1秒)単位で測定されます。 SSDTT_TEMPOを渡した場合は<CODE><A HREF="../../CRef/Routines/R_8c.htm#IX_SoundPlayMusicNote()">SoundPlayMusicNote()</A></CODE>である。<EM>継続時間</EM>では、音符が再生される時間の単位数を決定します。 データ型がSSDTT_TICKSで<EM>継続時間</EM>30の場合、音は半秒間鳴ります。</P>
<P>新しく割り当てられたノートのハンドルは<EM>制御</EM>ボタンをクリックし<CODE>SoundAllocMusicNote()</CODE>ノートの割り当てでエラーが発生した場合、は0以外の値を返します。</P>
</DIV>
<DIV>
          <A NAME="R_8b.htm_IX_SoundAllocMusicStream()"></A>
        <H1 CLASS="refHeading">SoundAllocMusicStream()</H1>
<PRE CLASS="syntax">word SoundAllocMusicStream(/*SOUND_ERROR_.を返します。 value*/word streamType, word priority, word voices, word tempo, MemHandle*control);</PRE>
<P>このルーチンは、に渡すのに適したハンドルを割り当てます。<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundPlayToMusicStream()">SoundPlayToMusicStream()</A></CODE>ハンドルは、コントロールで指定されたアドレスで返されます。<CODE>SoundAllocMusicStream()</CODE>ハンドルの割り当てでエラーが発生した場合、は0以外の値を返します。</P>
<P>いくつかの引数が渡されます。 の<CODE>SoundStreamType</CODE>はストリームに割り当てる容量を決定し、は一度にストリームに書き込むことができるデータの量を決定します。 SST_ONE_SHOTを渡すと、ストリームは明示的に破棄されず、曲の終了時にストリームがストリームを破棄する必要があることを示します。 音楽バッファに含まれるボイスの数を指定する必要があります。 また、スターティング<EM>テンポ</EM>音楽ストリームのためです</P>
</DIV>
<DIV>
          <A NAME="R_8b.htm_IX_SoundAllocSampleStream()"></A>
        <H1 CLASS="refHeading">SoundAllocSampleStream()</H1>
<PRE CLASS="syntax">word SoundAllocSampleStream(/*SOUND_ERROR_.を返します。 値*/MemHandle*コントロール)</PRE>
<P>このルーチンは、サンプルストリームハンドルを割り当てます。 返されるハンドルが<EM>ヌル</EM>、ライブラリは使用できませんでした(つまり、他のスレッドが排他アクセスを獲得しました)。</P>
</DIV>
<DIV>
          <A NAME="R_8b.htm_IX_SoundDisableSampleStream()"></A>
        <H1 CLASS="refHeading">SoundDisableSampleStream()</H1>
<PRE CLASS="syntax">空隙SoundDisableSampleStream(MemHandle mh)</PRE>
<P>このルーチンは、渡されたサンプルハンドルからDACプレイヤーの関連付けを解除します。 ハンドルを使用してさらにサウンドを再生する前に<CODE>SoundEnableSampleStream()</CODE>に登録してあるもの</P>
</DIV>
<DIV>
          <A NAME="R_8b.htm_IX_SoundEnableSampleStream()"></A>
        <H1 CLASS="refHeading">SoundEnableSampleStream()</H1>
<PRE CLASS="syntax">word SoundEnableSampleStream(/*SOUND_ERROR_.を返します。 値*/MemHandle mh、SoundPriorityプライオリティ、ワードレート、ワードメーカーID、DACSampleFormatフォーマット)</PRE>
<P>このルーチンは、DACプレイヤーを割り当てられたサンプルハンドルに関連付けます。 が返すサウンドハンドルを渡す必要があります。<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocSampleStream()">SoundAllocSampleStream()</A></CODE>また、DACデバイスで再生するサウンドに関する特定の情報も渡す必要があります。<EM>優先権</EM>DACプレーヤー(例:SP_STANDARD)、サンプリングレート、および<EM>書式</EM>サンプルの<EM>製造者ID</EM>および<CODE>DACSampleFormat</CODE>値)。</P>
</DIV>
<HR>
          <A NAME="R_8c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_8c.htm_IX_SoundFreeMusic()"></A>
        <H1 CLASS="refHeading">SoundFreeMusic()</H1>
<PRE CLASS="syntax"><CODE>空虚</CODE>SoundFreeMusic(MemHandle mh)</PRE>
<P>このルーチンは、音楽ハンドルを解放します。 音楽が流れていないこと。<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusic()">SoundStopMusic()</A></CODE>このルーチンを呼び出した後、音楽ハンドルを使用することはできません。</P>
</DIV>
<DIV>
          <A NAME="R_8c.htm_IX_SoundFreeMusicNote()"></A>
        <H1 CLASS="refHeading">SoundFreeMusicNote()</H1>
<PRE CLASS="syntax">空隙SoundFreeMusicNote(MemHandle mh)</PRE>
<P>このルーチンは、渡されたノートハンドルを解放します。 このルーチンを呼び出すときは、ノートが再生されていない必要があります。<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusicNote()">SoundStopMusicNote()</A></CODE>注記を解放した後は、注記のハンドルを使用しないでください。</P>
</DIV>
<DIV>
          <A NAME="R_8c.htm_IX_SoundFreeMusicStream()"></A>
        <H1 CLASS="refHeading">SoundFreeMusicStream()</H1>
<PRE CLASS="syntax"><CODE>空虚</CODE>SoundFreeMusicStream(MemHandle mh)</PRE>
<P>このルーチンは、音楽ストリームのトークンを解放します。 ストリーム経由で音楽が再生されていないこと。<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusicStream()">SoundStopMusicStream()</A></CODE>よくわからない場合は このルーチンを呼び出した後は、ストリームを使用しないでください。</P>
</DIV>
<DIV>
          <A NAME="R_8c.htm_IX_SoundFreeSampleStream()"></A>
        <H1 CLASS="refHeading">SoundFreeSampleStream()</H1>
<PRE CLASS="syntax">空隙SoundFreeSampleStream(MemHandle mh)</PRE>
<P>このルーチンは、渡されたサンプルサウンドハンドルを解放します。 このルーチンを呼び出した後は、このハンドルを使用しないでください。</P>
</DIV>
<DIV>
          <A NAME="R_8c.htm_IX_SoundGetExclusive()"></A>
        <H1 CLASS="refHeading">SoundGetExclusive()</H1>
<PRE CLASS="syntax">void SoundGetExclusive(void)</PRE>
<P>このルーチンは、サウンドライブラリの排他セマフォを取得します。別のスレッドがすでに排他を取得している場合、このルーチンは排他が解放されるまで待機します。 現在再生中のサウンドは終了が許可されますが、これ以降は、このルーチンを呼び出しているスレッドだけが新しいサウンドを再生できます。 サウンドライブラリ専用の設定が完了したら<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundReleaseExclusive()">SoundReleaseExclusive()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_8c.htm_IX_SoundGetExclusiveNB()"></A>
        <H1 CLASS="refHeading">SoundGetExclusiveNB()</H1>
<PRE CLASS="syntax">ブール値SoundGetExclusiveNB(void);</PRE>
<P>このルーチンは、サウンドライブラリの排他セマフォを取得します。これは、他のスレッドがすでに排他セマフォを取得している場合でも行われます。 現在再生中のサウンドは終了が許可されますが、これ以降は、このルーチンを呼び出しているスレッドだけが新しいサウンドを再生できます。 このルーチンは<EM>真</EM>別のスレッドがすでに排他アクセス権を持っている場合。</P>
<P>サウンドライブラリ専用の設定が完了したら<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundReleaseExclusive()">SoundReleaseExclusive()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_8c.htm_IX_SoundInitMusic()"></A>
        <H1 CLASS="refHeading">SoundInitMusic()</H1>
<PRE CLASS="syntax">void SoundInitMusic(MemHandle mh, バイトボイス);</PRE>
<P>このルーチンは、あらかじめ定義されたシンプルな音楽バッファ構造体を初期化します。 音楽バッファが固定ブロックに保存されている場合は<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusic()">SoundAllocMusic()</A></CODE>見出しページを開きます。 これにより、ポインタによって参照されるブロックに格納された音楽バッファを<CODE><A HREF="../../CRef/Routines/R_8c.htm#IX_SoundPlayMusic()">SoundPlayMusic()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_8c.htm_IX_SoundPlayMusic()"></A>
        <H1 CLASS="refHeading">SoundPlayMusic()</H1>
<PRE CLASS="syntax">word SoundPlayMusic(/*SOUND_ERROR_.を返します。 値*/MemHandle mh、ワードプライオリティ、ワードテンポ、EndOfSongFlagsフラグ);</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_8c.htm#IX_SoundInitMusic()">SoundInitMusic()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusic()">SoundAllocMusic()</A></CODE>優先度の値は、他のサウンドがすでに音声を占有している場合にサウンドを再生するかどうかを決定します。SP_STANDARDなどの値を渡します。 の<EM>テンポ</EM>値は、1/128ノートの長さを決定するために使用されます。 音楽バッファに、SSDTT_TEMPOデルタタイプで測定された長さの音符が含まれている場合は、それに応じてこの値を設定する必要があります。 の<EM>フラグふらぐ</EM>引数は、サウンドの再生が終了したときに、音楽のハンドルを自動的に解放するかどうかを決定します。 フラグUNLOCK_ON_EOSまたはDESTROY_ON_EOSのいずれか、または両方を渡すことができます。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>サウンド.h</P>
</DIV>
<DIV>
          <A NAME="R_8c.htm_IX_SoundPlayMusicNote()"></A>
        <H1 CLASS="refHeading">SoundPlayMusicNote()</H1>
<PRE CLASS="syntax">word SoundPlayMusicNote(/*SOUND_ERROR_.を返します。 value*/MemHandle mh, /*ノートのハンドル*/word priority, word tempo, EndOfSongFlagsフラグ);</PRE>
<P>このルーチンは<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicNote()">SoundAllocMusicNote()</A></CODE>--その関数の戻り値は<EM>モデム</EM>優先度の値は、他のサウンドがすでに音声を占有している場合にサウンドを再生するかどうかを決定します。SP_STANDARDなどの値を渡します。 の<EM>テンポ</EM>値は、1/128ノートの長さを決定するために使用されます。 ノートのDelta TypeがSSDTT_TEMPOの場合は、それに応じてこの値を設定する必要があります。 の<EM>フラグふらぐ</EM>引数は、ノートの再生が終了したときに、ノートのハンドルを自動的に解放するかどうかを決定します。 フラグUNLOCK_ON_EOSまたはDESTROY_ON_EOSのいずれか、または両方を渡すことができます。</P>
<P>このルーチンは<EM>真</EM>ライブラリが使用できない場合(つまり、他のスレッドがサウンドエクスクルーシブを取得した場合)。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>サウンド.h</P>
</DIV>
<HR>
          <A NAME="R_8d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundPlayToMusicStream()"></A>
        <H1 CLASS="refHeading">SoundPlayToMusicStream()</H1>
<PRE CLASS="syntax">word SoundPlayToMusicStream(/*SOUND_ERROR_.を返します。 value*/MemHandle mh, const word*song, word size);</PRE>
<P>このルーチンは、ストリームに対して音楽バッファを再生します。 によって返されるトークンを使用して、再生するストリームを指定します。<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicStream()">SoundAllocMusicStream()</A></CODE>バッファに音楽を再生するには、再生するバッファのサイズと曲の先頭へのポインタを渡します。 このバッファは、イベント全体で構成されている必要があります。つまり、イベントの途中で開始または終了することはできません(たとえば、頻度で始まる可能性のあるストリームに対して別のバッファを再生する予定がある場合でも、ノートを再生するように指定することはできませんが、その頻度を指定することはできません)。</P>
<P>GE_END_OF_SONGの後のバッファ内のデータは無視されます。</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundPlayToMusicStreamNB()"></A>
        <H1 CLASS="refHeading">SoundPlayToMusicStreamNB()</H1>
<PRE CLASS="syntax">word SoundPlayToMusicStreamNB(/*SOUND_ERROR_.を返します。 value*/MemHandle mh, const word*song, word size, word*bytesWritten);</PRE>
<P>このルーチンは次のように動作します。<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundPlayToMusicStream()">SoundPlayToMusicStream()</A></CODE>(ルーチンがブロックする場合を除く)。 音楽ストリームが一杯になると<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundPlayToMusicStream()">SoundPlayToMusicStream()</A></CODE>ブロックし、ストリームに空きができるまで待ちます。<CODE>SoundPlayToMusicStreamNB()</CODE>は終了し、ストリームへの書き込みに成功したバイト数を返す。</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundPlayToSampleStream()"></A>
        <H1 CLASS="refHeading">SoundPlayToSampleStream()</H1>
<PRE CLASS="syntax">word SoundPlayToSampleStream(/*SOUND_ERROR_.を返します。 value*/MemHandle mh, word_far*sample, word size, SampleFormatDescription*format);</PRE>
<P>このルーチンは、サンプリングされたサウンドデータをDACプレーヤーに渡します。 このルーチンにはサンプルのサウンドハンドルを渡す必要があります。<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocSampleStream()">SoundAllocSampleStream()</A></CODE>サンプルのサウンドハンドルは、DACプレーヤーに関連付けられている必要があります。ハンドルを関連付けるには<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundEnableSampleStream()">SoundEnableSampleStream()</A></CODE>へのポインタを渡す必要があります<EM>見本</EM>データ、および<EM>寸法</EM>バイト単位で測定されたサンプルの 次を変更できます。<EM>書式</EM>DACプレーヤーがデータを処理する方法を決定する情報。</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundReallocMusic()"></A>
        <H1 CLASS="refHeading">SoundReallocMusic()</H1>
<PRE CLASS="syntax">word SoundReallocMusic(/*SOUND_ERROR_.を返します。 値*/MemHandle mh, word_far*song);</PRE>
<P>このルーチンを使用すると、新しい音楽バッファを既存の音楽ハンドルに関連付けることができます。 新しい音楽バッファには、最初に要求されたよりも多くの音声を含めることはできません。<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusic()">SoundAllocMusic()</A></CODE>再生中のサウンドのハンドルを使用してこのルーチンを呼び出さないでください。<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusic()">SoundStopMusic()</A></CODE>よくわからない場合は、ハンドルに</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundReallocMusicNote()"></A>
        <H1 CLASS="refHeading">SoundReallocMusicNote()</H1>
<PRE CLASS="syntax"><CODE>言葉</CODE>SoundReallocMusicNote(/*SOUND_ERROR_.を返します。 値*/MemHandle mh、ワードfreq、ワードvol、SoundStreamDeltaTimeTypeタイマー、ワードデュラ、ワードインストラム、ワードinstTable);</PRE>
<P>このルーチンを使用すると、既存のノートハンドルに新しいノート値を関連付けることができます。 再生中のノートのハンドルを指定してこのルーチンを呼び出さないでください。<CODE><A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusicNote()">SoundStopMusicNote()</A></CODE>よくわからない場合は、ハンドルに</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundReleaseExclusive()"></A>
        <H1 CLASS="refHeading">SoundReleaseExclusive()</H1>
<PRE CLASS="syntax">void SoundReleaseExclusive(void)</PRE>
<P>このルーチンは、サウンドライブラリの排他セマフォを解放します。 コードがを呼び出さない限り、このルーチンを呼び出す必要はありません。<CODE><A HREF="../../CRef/Routines/R_8c.htm#IX_SoundGetExclusive()">SoundGetExclusive()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_8c.htm#IX_SoundGetExclusiveNB()">SoundGetExclusiveNB()</A></CODE>このルーチンは、他のスレッドがサウンドを再生できるようにします。 別のスレッドが<CODE><A HREF="../../CRef/Routines/R_8c.htm#IX_SoundGetExclusive()">SoundGetExclusive()</A></CODE>スレッドには排他制御がありましたが、今度は排他制御を獲得します。</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundSampleDriverInfo()"></A>
        <H1 CLASS="refHeading">SoundSampleDriverInfo()</H1>
<PRE CLASS="syntax">void SoundSampleDriverInfo(word_far*voices, SoundDriverCapability_far*capability);</PRE>
<P>このルーチンは、録音されたサウンドを再生するマシンの機能を決定します。</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundStopMusic()"></A>
        <H1 CLASS="refHeading">SoundStopMusic()</H1>
<PRE CLASS="syntax">word SoundStopMusic(/*SOUND_ERROR_.を返します。 value*/MemHandle mh);/*音楽バッファのハンドル*/</PRE>
<P>このルーチンは、単純な音楽バッファの再生を停止します。 ライブラリが使用できなかった場合(つまり、他のスレッドがエクスクルーシブを取得した場合)はtrueを返します。</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundStopMusicNote()"></A>
        <H1 CLASS="refHeading">SoundStopMusicNote()</H1>
<PRE CLASS="syntax">word SoundStopMusicNote(/*SOUND_ERROR_.を返します。 値*/MemHandle mh)</PRE>
<P>このルーチンは、再生中の音符を停止します。 によって返されたノートのハンドルを渡します。<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicNote()">SoundAllocMusicNote()</A></CODE>このルーチンは、サウンドライブラリが使用できなかった場合(つまり、他のスレッドがエクスクルーシブを取得した場合)にtrueを返します。</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundStopMusicStream()"></A>
        <H1 CLASS="refHeading">SoundStopMusicStream()</H1>
<PRE CLASS="syntax">word SoundStopMusicStream(/*SOUND_ERROR_.を返します。 値*/MemHandle mh)</PRE>
<P>このルーチンは、ストリームに対して再生されている音楽を停止します。 すべてのサウンドがストリームから消去されます。 この関数は1つの引数(サウンドストリームのトークン)を取ります。<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicStream()">SoundAllocMusicStream()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_8d.htm_IX_SoundSynthDriverInfo()"></A>
        <H1 CLASS="refHeading">SoundSynthDriverInfo()</H1>
<PRE CLASS="syntax">void SoundSynthDriverInfo(word_far*voices, SupportedEnvelopeFormat_far*format, SoundDriverCapability_far*capability)</PRE>
<P>このルーチンは、マシンの音楽再生能力を記述します。</P>
</DIV>
<HR>
          <A NAME="R_8e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpeedDialGetNumber()"></A>
        <H1 CLASS="refHeading">SpeedDialGetNumber()</H1>
<PRE CLASS="syntax">int SpeedDialGetNumber(intスロット,TCHAR*buf);</PRE>
<P>この関数は、短縮ダイヤル番号に関連付けられた電話番号を取得します。 この関数は、渡された<EM>バッファ</EM>電話番号を含む文字列。 該当する短縮ダイヤル番号がない場合、関数は-1を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpeedDialGetRecord()"></A>
        <H1 CLASS="refHeading">SpeedDialGetRecord()</H1>
<PRE CLASS="syntax">int field(int slot, RecordID*rid, SpeedDialGetRecord ID*fid);</PRE>
<P>この関数は、渡された短縮ダイヤル番号に対応する連絡先とフィールドを返します。 該当する短縮ダイヤル番号がない場合、関数は-1を返します。 この関数は、次の引数を取ります。</P>
<DL>
<DT>
          <EM>スロット</EM>
        </DT><DD>短縮ダイヤル番号。</DD>
<DT>
          <EM>取り除く</EM>
        </DT><DD>へのポインタ<CODE>レコードID</CODE>バッファ。 この関数は<CODE>レコードID</CODE>連絡先レコードの</DD>
<DT>
          <EM>フィッド</EM>
        </DT><DD>へのポインタ<CODE>フィールドID</CODE>バッファ。 この関数は、このバッファに<CODE>フィールドID</CODE>選択した電話番号を持つ連絡先のフィールドの</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpeedDialGetSlot()"></A>
        <H1 CLASS="refHeading">SpeedDialGetSlot()</H1>
<PRE CLASS="syntax">int field(レコードID rid, フィールドID fid);int field(レコードID rid, SpeedDialGetSlot ID fid);</PRE>
<P>この関数は、渡された関数で表される連絡先電話番号の短縮ダイヤル番号を取得します。<CODE>レコードID</CODE>および<CODE>フィールドID</CODE>番号 該当する短縮ダイヤル番号がない場合、関数は-1を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpeedDialSetRecord()"></A>
        <H1 CLASS="refHeading">SpeedDialSetRecord()</H1>
<PRE CLASS="syntax">int field(int slot, RecordID rid, FieldID fid);int SpeedDialSetSlot(int slot, RecordID rid, FieldID fid);</PRE>
<P>この関数は、渡された関数で表される連絡先電話番号の短縮ダイヤル番号を設定します。<CODE>レコードID</CODE>および<CODE>フィールドID</CODE>番号 その短縮ダイヤルスロットが以前に空でなかった場合、関数は-1を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">contdb・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpoolConvertPaperSize()"></A>
        <H1 CLASS="refHeading">SpoolConvertPaperSize()</H1>
<PRE CLASS="syntax">word width(word width, /*用紙のSpoolConvertPaperSize*/word height, /*用紙の高さ*/PageType PageType);/*ページの種類*/</PRE>
<P>このルーチンは、幅と高さをページサイズ番号に変換します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpollCreatePaperSize()"></A>
        <H1 CLASS="refHeading">SpoolCreatePaperSize()</H1>
<PRE CLASS="syntax">word SpoolCreatePaperSize(/*失敗した場合は0を返す*/char*paperSizeString, /*記述名MAX_PAPER_STRING_LENGTH*/word width, /*width of paper*/word height, /*length of paper*/PageLayout laytout, /*PageLayout*/PageType PageType);/*PageType*/</PRE>
<P>このルーチンは、ユーザが後で使用するための新しい用紙サイズを定義して保存します。 成功した場合は、新しい用紙サイズを表す数値(128～255の値)が返されます。失敗した場合は、0が返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpoolCreatePrinter()"></A>
        <H1 CLASS="refHeading">SpoolCreatePrinter()</H1>
<PRE CLASS="syntax">word SpoolCreatePrinter(/*プリンタ番号を返します。エラーが発生した場合は-1を返します*/</PRE>
<PRE CLASS="syntax">char*printerName, /*プリンタ名*/PrinterDriverTypeタイプ);/*デバイスタイプ*/</PRE>
<P>現在インストールされているプリンタの一覧にプリンタを追加し、新しいプリンタ番号を返します。 このルーチンは通常、Preferencesマネージャ内から呼び出されます。 ルーチンが0 xffffを返した場合、プリンタはすでに存在しているため、作成できませんでした。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpoolDelayJob()"></A>
        <H1 CLASS="refHeading">SpoolDelayJob()</H1>
<PRE CLASS="syntax">SpoolOpStatus SpoolDelayJob(word JobID);</PRE>
<P>このルーチンは、印刷ジョブを印刷キューの最後に移動します。</P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpoolDeletePaperSize()"></A>
        <H1 CLASS="refHeading">SpoolDeletePaperSize()</H1>
<PRE CLASS="syntax">Boolean SpoolDeletePaperSize(単語paperSizeNum, /*削除するサイズ番号*/PageType PageType);/*ページタイプ*/</PRE>
<P>このルーチンは、ユーザ定義の用紙サイズを削除します。 戻ります<EM>真</EM>(つまり、ゼロ以外の値)を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpoolDeletePrinter()"></A>
        <H1 CLASS="refHeading">SpoolDeletePrinter()</H1>
<PRE CLASS="syntax">void SpoolDeletePrinter(int prtrNum);/*削除するプリンタ番号*/</PRE>
<P>要求されたプリンタをシステムから削除します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpoolDelJob()"></A>
        <H1 CLASS="refHeading">SpoolDelJob()</H1>
<PRE CLASS="syntax">SpoolOpStatus SpoolDelJob(word jobID);</PRE>
<P>このルーチンは、プリンタジョブを削除します。</P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpoolGetDefaultPageSizeInfo()"></A>
        <H1 CLASS="refHeading">SpoolGetDefaultPageSizeInfo()</H1>
<PRE CLASS="syntax">空隙SpoolGetDefaultPageSizeInfo(PageSizeReport*psr)</PRE>
<P>このルーチンは、システムのデフォルトページサイズの寸法を取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8e.htm_IX_SpoolGetDefaultPrinter()"></A>
        <H1 CLASS="refHeading">SpoolGetDefaultPrinter()</H1>
<PRE CLASS="syntax">int SpoolGetDefaultPrinter();/*プリンタ番号を返す*/</PRE>
<P>システムのデフォルトプリンタを返します。このプリンタは<CODE>PrintControlClass</CODE>印刷するデフォルトのプリンタとして設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_8f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_8f.htm_IX_SpoolGetNumPaperSizes()"></A>
          <A NAME="R_8f.htm_IX_NumPaperSizesInfo"></A>
          <A NAME="R_8f.htm_IX_NPSI_&ldots;"></A>
        <H1 CLASS="refHeading">SpoolGetNumPaperSizes()</H1>
<PRE CLASS="syntax">void SpoolGetNumPaperSizes(NumPaperSizesInfo*sizesInfo, PageTypeタイプ);</PRE>
<P>このルーチンを使用して、用紙サイズリストに表示される用紙サイズの数(定義済みとユーザー定義の両方)を検索します。 用紙サイズの数は、既定の用紙サイズのインデックスと共に、Num</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef struct{word NPSI_numSizes;word NPSI_defaultSize;}NumPaperSizesInfo;</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8f.htm_IX_SpoolGetNumPrinters()"></A>
        <H1 CLASS="refHeading">SpoolGetNumPrinters()</H1>
<PRE CLASS="syntax">ワードSpoolGetNumPrinters(PrinterDriverTypeタイプ、/*ドライバタイプ*/バイトlocalOnlyFlag);/*ローカルに定義されたプリンタのみをカウントする場合*は0以外。 (注)</PRE>
<P>このルーチンは、指定されたタイプのプリンタがインストールされている数を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8f.htm_IX_SpoolGetPaperSize()"></A>
          <A NAME="R_8f.htm_IX_PaperSizeInfo"></A>
          <A NAME="R_8f.htm_IX_PSI_&ldots;"></A>
        <H1 CLASS="refHeading">SpoolGetPaperSize()</H1>
<PRE CLASS="syntax">void SpoolGetPaperSize(PaperSizeInfo sizeInfo, /*これは0からSpoolGetNumPaperSizes()の戻り値*の間でなければなりません*/</PRE>
<PRE CLASS="syntax">ワードpaperSizeNum、/*0からSpoolGetNumPaperSizes()までの用紙サイズ番号*/</PRE>
<PRE CLASS="syntax">pageType*pageType);/*ページタイプ*/</PRE>
<P>このルーチンを使用して、用紙サイズの寸法を決定します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef struct{word PSI_width;/*width, in points*/word PSI_height;/*height, in points*/PageLayout PSI_defaultLayout;}PaperSizeInfo;</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8f.htm_IX_SpoolGetPaperSizeOrder()"></A>
          <A NAME="R_8f.htm_IX_PSOI_&ldots;"></A>
          <A NAME="R_8f.htm_IX_PaperSizeOrderInfo"></A>
        <H1 CLASS="refHeading">SpoolGetPaperSizeOrder()</H1>
<PRE CLASS="syntax"><CODE>空虚</CODE>SpoolGetPaperSizeOrder(byte*order, /*サイズのバッファMAX_PAPER_SIZES*//*返されると、このバッファには*表示に対応する*順序で配置された*ページサイズ番号が*入力されます*/</PRE>
<PRE CLASS="syntax">byte*userSizes, /*サイズのバッファMAX_PAPER_SIZES*//*返されると、ユーザの用紙サイズの配列*を保持します。 (注)</PRE>
<PRE CLASS="syntax">PaperSizeOrderInfo*numBuf、/*空のPaperSizeOrderInfo構造体*/</PRE>
<PRE CLASS="syntax">pageType pageType);/*どのような種類の論文に興味があるか*/</PRE>
<P>このルーチンは、用紙サイズの順序配列を取得します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef struct{word PSOI_numOrdered;/*順序付けられたサイズの数*/word PSOI_numUnused;/*未使用のサイズの数*/}PaperSizeOrderInfo;</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8f.htm_IX_SpoolGetPaperString()"></A>
        <H1 CLASS="refHeading">SpoolGetPaperString()</H1>
<PRE CLASS="syntax">word SpoolGetPaperString(/*エラーの場合true*/char*stringBuf, /*空のバッファMAX_PAPER_STRING_LENGTH*/word paperSizeNum, /*返された名前文字列*/PageType prtrNum);/*プリンタ番号*/</PRE>
<P>このルーチンを使用して、特定の用紙サイズに対して表示する文字列を決定します。 帰国後<CODE>stringBuf</CODE>は、その論文を説明するヌル終端文字列で埋められている。 このルーチンの戻り値は、NULLターミネータを含まない、ペーパー文字列の長さです。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8f.htm_IX_SpoolGetPrinterString()"></A>
        <H1 CLASS="refHeading">SpoolGetPrinterString()</H1>
<PRE CLASS="syntax">Boolean SpoolGetPrinterString(/*エラーの場合にtrueを返す*/PrinterStringInfo*retInfo, /*空の構造体を渡す*/word printerNum);/*プリンタ番号*/</PRE>
<P>このルーチンは、要求されたNULL終端のプリンタ名文字列をバッファに格納します。 プリンタが見つからなかった場合、戻り値は次のようになります。<CODE>真</CODE>(エラー用に設定)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_8f.htm_IX_SpoolHurryJob()"></A>
        <H1 CLASS="refHeading">SpoolHurryJob()</H1>
<PRE CLASS="syntax">SpoolOpStatus SpoolHurryJob(word JobID);</PRE>
<P>このルーチンは、印刷ジョブを印刷キューの先頭に移動します。</P>
</DIV>
<DIV>
          <A NAME="R_8f.htm_IX_SpoolInfoParams"></A>
          <A NAME="R_8f.htm_IX_SIP_&ldots;"></A>
          <A NAME="R_8f.htm_IX_SpoolInfoQueueParams"></A>
          <A NAME="R_8f.htm_IX_SIQP_&ldots;"></A>
          <A NAME="R_8f.htm_IX_SpoolInfoJobParams"></A>
          <A NAME="R_8f.htm_IX_SIJP_&ldots;"></A>
          <A NAME="R_8f.htm_IX_JobStatus"></A>
          <A NAME="R_8f.htm_IX_JS_&ldots;"></A>
        <H1 CLASS="refHeading">SpoolInfo()</H1>
<PRE CLASS="syntax">SpoolOpStatus SpoolInfo(SpoolInfoType infoType, SpoolInfoParams*params);</PRE>
<P>このルーチンは、印刷キューの状態に関するさまざまな種類の情報を返します。 キューまたはキュー上の任意のジョブに関する情報を要求できます。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef enum/*word*/{SIT_JOB_INFO=0, SIT_QUEUE_INFO=2}SpoolInfoType;</PRE>
<P>合格した<CODE>SpoolInfoType</CODE>印刷キューに関する情報を検索するか、キューの1つのジョブに関する情報を検索するかを指定します。</P>
<PRE CLASS="syntax">typedef union{SpoolInfoQueueParams SIP_queueParams;SpoolInfoJobParams SIP_jobParams;}SpoolInfoParams;</PRE>
<P>使用されるパラメータのタイプは、渡された<CODE>SpoolInfoType</CODE>ボタンをクリックし</P>
<PRE CLASS="syntax">typedef struct{Boolean SIQP_activityQuery;PrintPortInfo*SIQP_portInfo;MemHandle SIQP_retBlock;単語SIQP_retNumJobs;}SpoolInfoQueueParams;</PRE>
<P>この構造体には、印刷キューと<CODE>SIQP_retBlock</CODE>フィールドはブロックを指す<CODE>ジョブの状態</CODE>構造。</P>
<PRE CLASS="syntax">typedef struct{word SIJP_jobID;MemHandle SIJP_retBlock;}SpoolInfoJobParams;</PRE>
<P>この構造体は、記述するジョブのIDを渡すために使用されます。 渡されたブロックはlaを保持します。<CODE>ジョブの状態</CODE>を返します。</P>
<PRE CLASS="syntax">typedef struct{char JS_fname[13];/*std DOS(8.3)spool filename*/char JS_parent[FILE_LONGNAME_LENGTH+1];/*親アプリケーションの名前*/char JS_documentName[FILE_LONGNAME_LENGTH+1];/*ドキュメント名*/word JS_numPages;/*ドキュメント内の#pages*/SpoolTimeStruct JS_time;/*スプールされた時間*/byte JS_printing;/*印刷する場合はTRUE/FALSE*/}JobStatus;</PRE>
<P>各<CODE>ジョブの状態</CODE>構造体は、単一の印刷ジョブを記述する。</P>
</DIV>
<HR>
          <A NAME="R_90.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_SpoolModifyPriority()"></A>
        <H1 CLASS="refHeading">SpoolModifyPriority()</H1>
<PRE CLASS="syntax">SpoolOpStatus SpoolModifyPriority(word jobID, ThreadPriority priority);</PRE>
<P>このルーチンを使用して、印刷ジョブの印刷キューを処理するスレッドの優先度を変更します。</P>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_SpoolSetDefaultPageSizeInfo()"></A>
        <H1 CLASS="refHeading">SpoolSetDefaultPageSizeInfo()</H1>
<PRE CLASS="syntax">空隙SpoolSetDefaultPageSizeInfo(PageSizeReport*psr)</PRE>
<P>デフォルトのシステム・ページの次元を設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_SpoolSetDefaultPrinter()"></A>
        <H1 CLASS="refHeading">SpoolSetDefaultPrinter()</H1>
<PRE CLASS="syntax">void SpoolSetDefaultPrinter(int prtrNum);/*プリンタ番号*/</PRE>
<P>システムのデフォルトプリンタを設定します。たとえば、次のように使用されます。<CODE>PrintControlClass</CODE>を通常使うプリンタとして設定します。 このルーチンは通常、Preferencesマネージャ内から呼び出されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_SpoolSetDocSize()"></A>
        <H1 CLASS="refHeading">SpoolSetDocSize()</H1>
<PRE CLASS="syntax">void SpoolSetDocSize(Boolean open;/*ドキュメントが閉じている場合はfalse*/PageSizeInfo*psr);/*ドキュメントが閉じている場合はNULL*/</PRE>
<P>このルーチンは、アプリケーションのPageSizeControlオブジェクトにドキュメントのサイズを伝えます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_SpoolSetPaperSizeOrder()"></A>
        <H1 CLASS="refHeading">SpoolSetPaperSizeOrder()</H1>
<PRE CLASS="syntax">void SpoolSetPaperSizeOrder(byte*orderArray, /*ペーパーsiaeの配列。 各要素は、*0-127:事前に定義された用紙サイズ、または*128-255:ユーザー定義の用紙サイズを表す*バイトです。 (注)</PRE>
<PRE CLASS="syntax">ワード番号、/*配列内のエントリ数*/PageType PageType);/*ページタイプ(用紙、封筒、ラベル)*/</PRE>
<P>このルーチンは、ユーザに表示される用紙サイズの順序をリセットします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スプールゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_SpoolVerifyPrinterPort()"></A>
        <H1 CLASS="refHeading">SpoolVerifyPrinterPort()</H1>
<PRE CLASS="syntax">SpoolOpStatus・SpoolVerifyPrinterPort(PrintPortInfo*portInfo)</PRE>
<P>このルーチンを使用して、プリンタポートの存在を確認します。</P>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_SpreadsheetInitFile()"></A>
          <A NAME="R_90.htm_IX_SpreadsheetInitFileData"></A>
          <A NAME="R_90.htm_IX_SIFD_&ldots;"></A>
          <A NAME="R_90.htm_IX_SpreadsheetDrawFlags"></A>
          <A NAME="R_90.htm_IX_SDF_DRAW_&ldots;"></A>
        <H1 CLASS="refHeading">SpreadsheetInitFile()</H1>
<PRE CLASS="syntax">VMBlockHandle SpreadsheetInitFile(const SpreadsheetInitFileData*ifd)</PRE>
<P>このルーチンは、スプレッドシート・オブジェクトが使用するVMファイルを初期化します。 ファイル内にスプレッドシートマップブロックを割り当て、このブロックを初期化します。 このルーチンはマップブロックのハンドルを返します。アプリケーションはこのハンドルを覚えておく必要があります。 VMファイル内の既存のブロックは変更されません。</P>
<P>の<EM>IFD[イメージ</EM>パラメータは<CODE>SpreadsheetInitFileData</CODE>構造体には、ファイルハンドルと、割り当てる行数と列数が含まれます。</P>
<P CLASS="refField"><STRONG>構造:</STRONG>の<STRONG CLASS="fileName">SpreadsheetInitFileData</STRONG>構造は以下のように定義される:</P>
<PRE>typedef struct{word SIFD_file;word SIFD_numRows;word SIFD_numCols;SpreadsheetDrawFlags SIFD_drawFlags;}SpreadsheetInitFileData;</PRE>
<PRE>/*SpreadsheetDrawFlags:*SDF_DRAW_GRAPHICS*SDF_DRAW_NOTE_BUTTON*SDF_DRAW_HEADER_FOOTER_BUTTON*SDF_DRAW_GRID*/</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ssheet.gohと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_StreamClose()"></A>
        <H1 CLASS="refHeading">StreamClose()</H1>
<PRE CLASS="syntax">StreamError・StreamClose(GeodeHandle・ドライバー、StreamToken・ストリーム、ブール・リンガー);</PRE>
<P>このルーチンはストリームをシャットダウンします。 次の引数が渡されます。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>流れ</CODE>
        </DT><DD>の<CODE>StreamToken</CODE>流れの。</DD>
<DT>
          <CODE>ぐずぐず</CODE>
        </DT><DD>設定(Set)<EM>真</EM>現在ストリーム中にあるデータを読み出すまで保持する必要がある場合には<EM>偽の</EM>データをすぐにフラッシュします。</DD>
</DL>
<P>ルーチンが成功した場合は、0を返します。 失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_StreamFlush()"></A>
        <H1 CLASS="refHeading">StreamFlush()</H1>
<PRE CLASS="syntax">StreamError・StreamFlush(GeodeHandle・ドライバー、StreamToken・ストリーム)</PRE>
<P>このルーチンは、ストリームに保留されているすべてのデータをフラッシュします。 次の引数が渡されます。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>流れ</CODE>
        </DT><DD>の<CODE>StreamToken</CODE>流れの。</DD>
</DL>
<P>ルーチンが成功した場合は、0を返します。 失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<DIV>
          <A NAME="R_90.htm_IX_StreamGetError()"></A>
        <H1 CLASS="refHeading">StreamGetError()</H1>
<PRE CLASS="syntax">StreamError StreamGetError(ハンドルドライバ、StreamTokenストリーム、StreamRolesロール、word*errorCode);</PRE>
<P>このルーチンは、ストリームルーチンへの最後の呼び出しで設定されたドライバ固有のエラーコードを返します。 次の引数を取ります。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>流れ</CODE>
        </DT><DD>の<CODE>StreamToken</CODE>流れの。</DD>
<DT>
          <CODE>役柄</CODE>
        </DT><DD>これがSTREAM_ROLES_WRITERの場合、ルーチンは書き込み操作の最後のエラーを返します。 STREAM_ROLES_READERの場合は、読み込み操作の最後のエラーを返します。</DD>
<DT>
          <CODE>エラーコード</CODE>
        </DT><DD>ワードサイズの変数へのポインタ。 デバイスのエラー・コードがこの変数に書き込まれます。</DD>
</DL>
<P>ルーチンが成功した場合は0を返し、デバイスの最後のエラーコードを<CODE>エラーコード</CODE>変数。 失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<HR>
          <A NAME="R_91.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_91.htm_IX_StreamOpen()"></A>
        <H1 CLASS="refHeading">StreamOpen()[ストリームを開く]</H1>
<PRE CLASS="syntax">StreamErrorストリームオープン(GeodeHandleドライバー、ワードバフサイズ、GeodeHandleオーナー、heapFlags heapFlags、StreamToken*ストリーム);</PRE>
<P>このルーチンはストリームをオープンします。 次のように渡されます。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>buffSize(バフサイズ)</CODE>
        </DT><DD>ストリームバッファのサイズ(バイト単位)。</DD>
<DT>
          <CODE>オーナー</CODE>
        </DT><DD>小川を所有するジオード。</DD>
<DT>
          <CODE>heapFlags</CODE>
        </DT><DD>バッファブロックを作成するためのフラグ。</DD>
<DT>
          <CODE>*ストリーム</CODE>
        </DT><DD>ストリームトークンはここに書き込まれます。</DD>
</DL>
<P>次の場合<CODE>StreamOpen()[ストリームを開く]</CODE>が成功した場合は0を返し、ストリームのトークンを<CODE>*ストリーム</CODE>失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<DIV>
          <A NAME="R_91.htm_IX_StreamQuery()"></A>
        <H1 CLASS="refHeading">StreamQuery()</H1>
<PRE CLASS="syntax">StreamError StreamQuery(GeodeHandleドライバー、StreamTokenストリーム、StreamRolesロール、ワード*bytesAvailable);</PRE>
<P>このルーチンは、ストリームのバッファにどれだけの空き容量があるか、あるいはどれだけのデータが読み込まれるのを待っているかを調べます。 次の引数が渡されます。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>流れ</CODE>
        </DT><DD>の<CODE>StreamToken</CODE>流れの。</DD>
<DT>
          <CODE>役柄</CODE>
        </DT><DD>これがSTREAM_ROLES_WRITERである場合、ルーチンはストリームバッファで使用可能な空き領域の量を返します。 STREAM_ROLES_READERの場合は、読み取りを待機しているデータの量を返します。</DD>
<DT><CODE>*bytesAvailable</DT><DD></CODE>ルーチンは、(書き込みまたは読み取りに)使用可能なバイト数をこの変数に書き込みます。</DD>
</DL>
<P>ルーチンが成功した場合は、0を返します。 失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<DIV>
          <A NAME="R_91.htm_IX_StreamRead()"></A>
        <H1 CLASS="refHeading">StreamRead()</H1>
<PRE CLASS="syntax">StreamError StreamRead(GeodeHandleドライバー、StreamTokenストリーム、StreamBlockerブロッカー、ワードbuffSize、バイト*バッファー、ワード*numBytesRead);</PRE>
<P>このルーチンは、ストリームからデータを読み取ります。 このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>流れ</CODE>
        </DT><DD>の<CODE>StreamToken</CODE>流れの。</DD>
<DT>
          <CODE>遮断剤</CODE>
        </DT><DD>読取りを待機しているデータが十分にない場合にブロックするかどうかを指定します。</DD>
<DT>
          <CODE>バフサイズ</CODE>
        </DT><DD>渡されたバッファのサイズ(つまり、ストリームから読み取るデータの量)。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>ストリームからのデータが書き込まれるバッファへのポインタ。</DD>
<DT><CODE>*numBytesReadRead</DT><DD></CODE><CODE>StreamRead()</CODE>は、ストリームから実際に読み込んだバイト数をこの変数に書き込む。</DD>
</DL>
<P>次の場合<CODE>StreamRead()</CODE>が成功した場合は0を返す。 失敗した場合、またはストリームから要求されたすべてのデータを読み取ることができなかった場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<DIV>
          <A NAME="R_91.htm_IX_StreamReadByte()"></A>
        <H1 CLASS="refHeading">StreamReadByte()</H1>
<PRE CLASS="syntax">StreamError StreamWriteByte(GeodeHandleドライバー、StreamTokenストリーム、StreamBlockerブロッカー、byte*dataByte);</PRE>
<P>このルーチンは、ストリームから1バイトを読み取ります。 次の引数を取ります。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>流れ</CODE>
        </DT><DD>の<CODE>StreamToken</CODE>流れの。</DD>
<DT>
          <CODE>遮断剤</CODE>
        </DT><DD>データを書き込むための十分な領域がない場合にブロックするかどうかを指定します。</DD>
<DT>
          <CODE>*データバイト</CODE>
        </DT><DD>ストリームからバイトを読み込み、この変数に書き込みます。</DD>
</DL>
<P>ルーチンが成功した場合は、0を返します。 失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<DIV>
          <A NAME="R_91.htm_IX_StreamSetError()"></A>
        <H1 CLASS="refHeading">StreamSetError()</H1>
<PRE CLASS="syntax">StreamError StreamSetError(ハンドルドライバ、StreamTokenストリーム、StreamRolesロール、ワードerrorCode)</PRE>
<P>このルーチンは、ストリームのデバイス固有のエラーコードを設定します。このコードは、後で次の方法で回復できます。<CODE><A HREF="../../CRef/Routines/R_90.htm#IX_StreamGetError()">StreamGetError()</A></CODE>次の引数を取ります。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>流れ</CODE>
        </DT><DD>の<CODE>StreamToken</CODE>流れの。</DD>
<DT>
          <CODE>役柄</CODE>
        </DT><DD>STREAM_ROLES_WRITERまたはSTREAM_ROLES_READERのいずれか。</DD>
<DT>
          <CODE>エラーコード</CODE>
        </DT><DD>16ビットのデバイス固有のエラーコード。<CODE></CODE></DD>
</DL>
<P>ルーチンが成功した場合は、0を返します。 失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<HR>
          <A NAME="R_92.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_92.htm_IX_StreamWrite()"></A>
        <H1 CLASS="refHeading">StreamWrite()関数</H1>
<PRE CLASS="syntax">StreamError StreamWrite(GeodeHandleドライバ,StreamTokenストリーム,StreamBlockerブロッカ,ワードbuffSize, const byte*バッファ,ワード*numBytesWritten);</PRE>
<P>このルーチンはストリームにデータを書き込みます。 このルーチンは、次の引数を取ります。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>流れ</CODE>
        </DT><DD>の<CODE>StreamToken</CODE>流れの。</DD>
<DT>
          <CODE>遮断剤</CODE>
        </DT><DD>すべてのデータを書き込むための十分な領域がない場合にブロックするかどうかを指定します。</DD>
<DT>
          <CODE>バフサイズ</CODE>
        </DT><DD>渡されたデータ・バッファのサイズ(ストリームに書き込むデータの量など)。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>ストリームに書き込むデータへのポインタ。</DD>
<DT><CODE>*numBytesWritten</DT><DD></CODE><CODE>StreamWrite()関数</CODE>は、実際にストリームに書き込まれたバイト数をこの変数に書き込む。</DD>
</DL>
<P>次の場合<CODE>StreamWrite()関数</CODE>が成功した場合は0を返す。 失敗した場合、またはすべてのデータをストリームに書き込めなかった場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<DIV>
          <A NAME="R_92.htm_IX_StreamWriteByte()"></A>
        <H1 CLASS="refHeading">StreamWriteByte()</H1>
<PRE CLASS="syntax">StreamError StreamWriteByte(GeodeHandleドライバー、StreamTokenストリーム、StreamBlockerブロッカー、バイトデータバイト);</PRE>
<P>このルーチンは、1バイトをストリームに書き込みます。 次の引数を取ります。</P>
<DL>
<DT>
          <CODE>ドライバー</CODE>
        </DT><DD>の<CODE>GeodeToken</CODE>ストリームドライバの</DD>
<DT>
          <CODE>流れ</CODE>
        </DT><DD>の<CODE>StreamToken</CODE>流れの。</DD>
<DT>
          <CODE>遮断剤</CODE>
        </DT><DD>データを書き込むための十分な領域がない場合にブロックするかどうかを指定します。</DD>
<DT>
          <CODE>データバイト</CODE>
        </DT><DD>このバイトをストリームに書き込みます。</DD>
</DL>
<P>ルーチンが成功した場合は、0を返します。 失敗した場合は<CODE>StreamError</CODE>列挙型。</P>
</DIV>
<DIV>
          <A NAME="R_92.htm_IX_SysGetConfig()"></A>
        <H1 CLASS="refHeading">SysGetConfig()</H1>
<PRE CLASS="syntax">dワードSysGetConfig();</PRE>
<P>このルーチンは、システム設定を定義する値のセットを返します。 返されるdワードには、以下に示す最下位バイトから最上位バイトまでの4バイトの値が含まれます。</P>
<DL>
<DT><STRONG>設定フラグ</DT><DD></STRONG>このバイトには<CODE>SysConfigFlags</CODE>システムステータスを反映します。 このレコードには、システムがどのように起動されたか、Swatがそれを実行しているかどうか、システムが再起動されたかどうかなどの情報が含まれます。</DD>
<DT><STRONG>予約バイト</DT><DD></STRONG>このバイトには、アプリケーションで使用できない予約済みの情報が含まれます。</DD>
<DT><STRONG>プロセッサの種類</DT><DD></STRONG>このバイトには、GEOSを実行しているマシンのプロセッサタイプを反映する値が含まれます。 これはタイプです<CODE>SysProcessorType</CODE>SPT_8088、SPT_8086、SPT_80186、SPT_80286、SPT_80386、またはSPT_80486のいずれかです。 マクロSGC_PROCESSOR()を使用して、返されたdwordからこの値を抽出します。</DD>
<DT><STRONG>マシンタイプ</DT><DD></STRONG>このバイトには<CODE>SysMachineType</CODE>GEOSを実行しているマシンのタイプを示します。 次の値のいずれかになります:SMT_UNKNOWN、SMT_PC、SMT_PC_CONV、SMT_PC_JR、SMT_PC_XT、SMT_PC_XT_286、SMT_PC_AT、SMT_PS2_30、SMT_PS2_50、SMT_PS2_60、SMT_PS2_80、またはSMT_PS1。 マクロSGC_MACHINE()を使用して、返されたdwordからこの値を抽出します。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">system.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_92.htm_IX_SysGetDosEnvironment()"></A>
        <H1 CLASS="refHeading">SysGetDosEnvironment()</H1>
<PRE CLASS="syntax">Boolean SysGetDosEnvironment(/*エラー(見つからない)の場合はtrue*/const char*変数、/*環境変数*/char*バッファ、/*戻り値のバッファ*/word bufSize);/*戻り文字列の最大長*/</PRE>
<P>このルーチンは、指定されたDOS環境変数を環境バッファ内で検索します。 次の3つのパラメータを使用します。</P>
<DL>
<DT>
          <CODE>変光星</CODE>
        </DT><DD>検索する変数の名前を表すNULL終端文字列へのポインタ。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>変数の値が返されるロックされたバッファまたは固定バッファへのポインタ。</DD>
<DT>
          <CODE>bufSize/ファイルサイズ</CODE>
        </DT><DD>渡されたバッファのバイト単位のサイズ(終端のヌル文字を含めて返される最大文字数)。</DD>
</DL>
<P>変数が見つからない場合は、次のエラーフラグが返されます。<CODE>真</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">system.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_92.htm_IX_ErrorCheckingFlags:SysGetECLevel()"></A>
          <A NAME="R_92.htm_IX_SysGetECLevel()"></A>
          <A NAME="R_92.htm_IX_Error checking:SysGetECLevel()"></A>
        <H1 CLASS="refHeading">SysGetECLevel()</H1>
<PRE CLASS="syntax">ErrorCheckingFlags・SysGetECLevel(MemHandle*checksumBlock)</PRE>
<P>このルーチンは、システムの現在のエラーチェックレベルをチェックします。 返されたレコード<CODE>ErrorCheckingFlags</CODE>に、どのレベルのエラーチェックをオンにし、どのレベルのエラーチェックをオフにするかを示します。 チェックサムエラーチェック(ECF_BLOCK_CHECKSUM)がオンの場合、チェックサムが実行されるブロックのハンドルへのポインタを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_92.htm_IX_SysGetInfo()"></A>
          <A NAME="R_92.htm_IX_SysGetInfoType"></A>
          <A NAME="R_92.htm_IX_SGIT_&ldots;"></A>
          <A NAME="R_92.htm_IX_Handles:finding number of"></A>
          <A NAME="R_92.htm_IX_Heap:finding size of"></A>
          <A NAME="R_92.htm_IX_Volumes (file system):finding number of"></A>
          <A NAME="R_92.htm_IX_Geodes:finding number of"></A>
          <A NAME="R_92.htm_IX_Libraries:finding number of"></A>
          <A NAME="R_92.htm_IX_Drivers:finding number of"></A>
          <A NAME="R_92.htm_IX_Performance:CPU speed"></A>
        <H1 CLASS="refHeading">SysGetInfo()</H1>
<PRE CLASS="syntax">dword SysGetInfo(SysGetInfoType情報);/*取得する情報のタイプ*/</PRE>
<P>このルーチンは、一般的なシステム情報を返します。 返される情報の型を渡します。返される値は、渡された型によって異なります。<CODE>情報(info)</CODE>最大の戻り値はdwordであることに注意してください。<CODE>SysGetInfo()</CODE>ボタンをクリックし</P>
<P>の<CODE>情報(info)</CODE>パラメータ(/<CODE>SysGetInfoType</CODE>)には、次のいずれかの値を指定できます。</P>
<DL>
<DT>SGIT_TOTAL_HANDLES[合計ハンドル数]</DT><DD>カーネルのハンドルテーブルにあるハンドルの総数を返します。</DD>
<DT>SGIT_ヒープサイズ</DT><DD>合計ヒープサイズをバイト単位で返します。</DD>
<DT>SGIT_LARGESt_FREE_BLOCK(最大空きブロック)</DT><DD>その時点で割り当て可能な最大ブロックのサイズ(バイト単位)を返します。</DD>
<DT>SGIT合計カウント</DT><DD>GEOSの現在のセッションが開始されてからのクロックティックの合計数を返します(現在の時刻からシステムクロックの初期値を引きます)。</DD>
<DT>SGITボリューム数</DT><DD>システムに登録されているボリュームの合計数を返します。</DD>
<DT>SGIT合計測地座標系</DT><DD>現在ロードされている測地の合計数を返します。</DD>
<DT>SGITプロセス数</DT><DD>現在ロードされているプロセスの合計数を返します。</DD>
<DT>SGITライブラリの数</DT><DD>現在ロードされているライブラリの総数を返します。</DD>
<DT>SGITドライバの数</DT><DD>現在ロードされているドライバの合計数を返します。</DD>
<DT>SGIT_CPU_速度</DT><DD>プロセッサのCPU速度を返します。 返される値は、ベースXTプロセッサに対するCPU速度の比率の10倍になります。</DD>
<DT>SGITシステムディスク</DT><DD>GEOS(GEOS.INIファイル)が存在するディスクのディスクハンドルを返します。</DD>
<DT>SGIT_UIプロセス</DT>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sysstats.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_93.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_93.htm_IX_SysGetPenMode()"></A>
          <A NAME="R_93.htm_IX_Pen input:SysGetPenMode()"></A>
          <A NAME="R_93.htm_IX_Ink:SysGetPenMode()"></A>
        <H1 CLASS="refHeading">SysGetPenMode()</H1>
<PRE CLASS="syntax">ブール値SysGetPenMode();</PRE>
<P>このルーチンは、GEOSがペンベースのシステムで実行されている場合はtrueを返し、そうでない場合はfalseを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">system.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_93.htm_IX_SysLocateFileInDosPath()"></A>
        <H1 CLASS="refHeading">SysLocateFileInDosPath()</H1>
<PRE CLASS="syntax">DiskHandle SysLocateFileInDosPath(/*スレッドのエラー値を設定*/const char*fname, /*ファイル名*/char*buffer);/*ファイルのパスを返しました*/</PRE>
<P>このルーチンは、DOS環境変数PATHで指定された検索パスに沿って、指定されたファイルを検索します。 パラメータは次のとおりです。</P>
<DL>
<DT>
          <CODE>ファイル名</CODE>
        </DT><DD>検索するNULL終端ファイル名へのポインタ。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>ファイルのフルパスが格納される、ロックされたバッファまたは固定バッファへのポインタ。</DD>
</DL>
<P>このルーチンは、ファイルが存在するディスクのディスクハンドルと、ファイルのフルパス(ドライブ名を含む)を<CODE>緩衝剤</CODE>返されるパスは、NULLで終了する文字列です。 ファイルが見つからなかった場合は、ヌルのディスクハンドルが返されます。 エラー値は次のようにして取得できます。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">system.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_93.htm_IX_SysNotify()"></A>
          <A NAME="R_93.htm_IX_SysNotifyFlags"></A>
          <A NAME="R_93.htm_IX_SNF_&ldots;"></A>
        <H1 CLASS="refHeading">SysNotify()</H1>
<PRE CLASS="syntax">word SysNotify(SysNotifyFlagsフラグ、/*ユーザーに提供するオプション*/const char*string1、/*表示する最初の文字列*/const char*string2);/*表示する2番目の文字列*/</PRE>
<P>このルーチンは、カーネルに標準の通知ダイアログボックスを画面に表示させます。 このダイアログボックスは白地に黒枠で表示され、カーネルによるエラー通知にほぼ独占的に使用されます。 このルーチンに次のパラメータを渡します。</P>
<DL>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>SysNotifyFlags</CODE>ダイアログがユーザに提示するオプションを示します。 これらのフラグを以下に示します。</DD>
<DT>
          <CODE>文字列1</CODE>
        </DT><DD>ダイアログボックスに表示されるNULL終端文字列へのポインタ(NULLポインタの場合もあります)。</DD>
<DT>
          <CODE>文字列2</CODE>
        </DT><DD>ダイアログボックスに表示される2番目のNULL終端文字列へのポインタ(NULLポインタの場合もあります)。</DD>
</DL>
<P>返される単語は<CODE>SysNotifyFlags</CODE>(下記参照)。</P>
<P CLASS="refField"><STRONG>構造:</STRONG><CODE>SysNotifyFlags</CODE>は複数のフラグの記録です。一度に設定できるフラグは、なし、一部、またはすべてです。 5つのフラグは次のとおりです。</P>
<DL>
<DT>再試行</DT><DD>通知ボックスを表示した操作をユーザーが再試行できるようにします。 ユーザがこのオプションを選択すると、ルーチンから返されます。</DD>
<DT>SNF_EXIT(終了)</DT><DD>ユーザーがGEOSを完全に終了できるようにします。 ユーザーがこのオプションを選択すると、SST_CLEAN_FORCEDシャットダウンが開始された後にルーチンによって返されます。</DD>
<DT>SNF_ABORT(中止)</DT><DD>通知ボックスを表示した操作をユーザーが中止できるようにします。 ユーザがこのオプションを選択すると、ルーチンから返されます。</DD>
<DT>SNF_CONTINUE(継続)</DT><DD>ユーザーが操作を続行できるようにします。 ユーザがこのオプションを選択すると、ルーチンから返されます。</DD>
<DT>再起動</DT><DD>ユーザーがGEOSを直接シャットダウンして再起動できるようにします。 ユーザーがこのオプションを選択すると、ルーチンは戻りません。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">system.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_93.htm_IX_SysRegisterScreen()"></A>
        <H1 CLASS="refHeading">SysRegisterScreen()</H1>
<PRE CLASS="syntax">void SysRegisterScreen(GeodeHandleドライバ、WindowHandleルート);</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="R_93.htm_IX_SysSetECLevel()"></A>
          <A NAME="R_93.htm_IX_ErrorCheckingFlags:SysSetECLevel()"></A>
        <H1 CLASS="refHeading">SysSetECLevel()</H1>
<PRE CLASS="syntax">void SysSetECLevel(ErrorCheckingFlagsフラグ,/*エラーチェックのレベル*/MemHandle checksumBlock);/*もしあれば、チェックするブロック*/</PRE>
<P>このルーチンは、ソフトウェアのエラーチェックレベルを設定します。 レコードを渡す<CODE>ErrorCheckingFlags</CODE>どのレベルのエラー・チェックを使用すべきかを示します。 チェックサム・チェック(ECF_BLOCK_CHECKSUM)がオンになっている場合、チェックサムが実行されるブロックのハンドルも渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">例:ec.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_93.htm_IX_SysSetExitFlags()"></A>
        <H1 CLASS="refHeading">SysSetExitFlags()</H1>
<PRE CLASS="syntax">ワードSysGetExitFlags(ExitFlags bitsToSet、ExitFlags bitsToClear);</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="R_94.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_94.htm_IX_SysShutdown()"></A>
          <A NAME="R_94.htm_IX_SysShutdownType"></A>
          <A NAME="R_94.htm_IX_SST_&ldots;  (SysShutdownType)"></A>
        <H1 CLASS="refHeading">SysShutdown()</H1>
<PRE CLASS="syntax">ブーリアンSysShutdown(SysShutdownTypeタイプ、.);</PRE>
<P>このルーチンは、システムをシャットダウンし、ネイティブオペレーティングシステム(通常はDOS)を終了します。 最初のパラメータに応じて可変パラメータを使用します。 最初のパラメータは、要求されたシャットダウンのタイプで、ルーチンの呼び出し形式を決定します。<CODE>SysShutdown()</CODE>は、シャットダウンのタイプに依存するブール値を返します。</P>
<P>このルーチンのパラメータと呼び出し形式は<CODE>種類</CODE>パラメータを指定します。 指定可能な値(<CODE>SysShutdownType</CODE>)は、関連するパラメータと戻り値の情報とともに以下にリストされます。</P>
<DL>
<DT CLASS="FIXME_WorListWide">SST_CLEAN[サーフェスクリーンアップ]</DT><DD>すべてのアプリケーションを正常にシャットダウンし、シャットダウンを中止したいすべてのアプリケーションを許可します。 ルーチンが戻る<CODE>真</CODE>コールの時点でシステムのシャットダウンがすでに進行中の場合。 このタイプのシャットダウンでは<CODE>MSG_META_CONFIRM_SHUTDOWNメッセージ</CODE>MANUFACTURER_ID_GEOWORKS:GCNSLT_SHUTDOWN_CONTROL GCNリストに登録されているすべてのオブジェクトに適用されます(ただし、シャットダウンがキャンセルされていない場合のみ)。 そのリスト上の各オブジェクトは、シャットダウンの確認応答を返す必要があります。 パラメータの形式とパラメータは次のとおりです。</DD>
<PRE>ブーリアンSysShutdown(SysShutdownType型,optr notificationOD, メッセージmsg);</PRE>
<DT><CODE>notificationOD</DT><DD></CODE>渡されたメッセージを受け取るオブジェクトのoptr<CODE>メッセージ</CODE>シャットダウンが確認された後。 デフォルトの通知を使用するには、null optrを渡します(<CODE>MSG_META_DETACH(メタデタッチ)</CODE>UIに送信されます)。</DD>
<DT>
          <CODE>メッセージ</CODE>
        </DT><DD>のオブジェクトに送信されるメッセージ<CODE>notificationOD</CODE>ボタンをクリックし</DD>
<DT CLASS="FIXME_WorListWide">「サーフェスクリーンアップ強制」(SST_CLEAN_FORCED)</DT><DD>キャンセルの可能性なしに、すべてのアプリケーションを正常にシャットダウンします。 このタイプは追加のパラメータを取らず、他の測地がシャットダウンを中止することを許可しません。 戻りますが、戻り値は意味を持ちません。</DD>
<DT CLASS="FIXME_WorListWide">SST_ダーティ</DT><DD>アプリケーションをシャットダウンせずに、デバイスドライバを終了し、すべてのファイルを閉じてみます。 戻りません。 このタイプのパラメータは次のとおりです。</DD>
<PRE>Boolean SysShutdown{SysShutdownTypeの種類,/*SST_DIRTY*/const char*reason);</PRE>
<DT CLASS="FIXME_WorListWide"></DT><DD>の<CODE>道理</CODE>パラメータは、ダーティシャットダウンの理由としてユーザに提示されるテキスト文字列へのポインタです。 文字列はNULLで終了します。 理由を指定しない場合は、-1を渡します。</DD>
<DT CLASS="FIXME_WorListWide">SST_パニック</DT><DD>アプリケーションを終了したりファイルを閉じたりせずに、システムデバイスドライバ(GA_SYSTEM)を終了します。 これはシステムに悪影響を及ぼす可能性があるため、緊急時にのみ使用する必要があります。 このタイプのシャットダウンは、追加のパラメーターを取らず、戻りません。</DD>
<DT CLASS="FIXME_WorListWide">SST_再起動</DT><DD>これは、GEOSでユーザが<CODE>Ctrl-Alt-Delキー</CODE>アプリケーションはこれを呼び出すべきではありません。</DD>
<DT CLASS="FIXME_WorListWide">SST_リスタート</DT><DD>これは上記のSST_CLEAN_FORCEDと似ていますが、完全に終了するのではなく、シャットダウン後にGEOSをリロードします。 追加のパラメータは必要ありません。システムを再起動できなかった場合はTRUEを返し、シャットダウンが開始された場合はFALSEを返します。</DD>
<DT CLASS="FIXME_WorListWide">SST_最終</DT><DD>シャットダウンの最終フェーズを実行します。 このルーチンは、次のように呼び出されます。<CODE>のみ</CODE>SST_CLEAN_FORCEDシャットダウンが完了したときにUIによって実行されます。 この型は戻りませんが、1つの追加パラメータを取ります。 このタイプの呼び出し形式とパラメータは次のとおりです。</DD>
<PRE>Boolean SysShutdown(SysShutdownType型,const char*reason);</PRE>
<DT CLASS="FIXME_WorListWide"></DT><DD>の<CODE>道理</CODE>パラメータは、最終的なシャットダウンの理由(通常はエラー)を説明する文字列です。</DD>
<DT CLASS="FIXME_WorListWide">SST_SUSPEND[一時停止]</DT><DD>タスクの切り替えに備えてシステムの動作を中断し、ブロードキャストする<CODE>MSG_META_CONFIRM_SHUTDOWNメッセージ</CODE>MANUFACTURER_ID_GEOWORKS:GCNSLT_SHUTDOWN_CONTROL GCNリスト上のすべてのオブジェクト(<CODE>メタクラス</CODE>)をクリックします。 通知されたすべてのオブジェクトは、シャットダウンの確認応答を返す必要があります。 このタイプの<CODE>SysShutdown()</CODE>戻る<CODE>真</CODE>別のシステムシャットダウンがすでに進行中の場合。 これには2つのパラメータが追加されます。</DD>
<PRE>ブーリアンSysShutdown(SysShutdownType型,optr notificationOD, メッセージmsg);</PRE>
<DT><CODE>notificationOD</DT><DD></CODE>渡されたメッセージを受け取るオブジェクトのoptr<CODE>メッセージ</CODE>シャットダウンが確認された後。 デフォルトの通知を使用するには、null optrを渡します(<CODE>MSG_META_DETACH(メタデタッチ)</CODE>これは通常、呼び出しの意図ではありませんが、UIに送信されます。</DD>
<DT>
          <CODE>メッセージ</CODE>
        </DT><DD>のオブジェクトに送信されるメッセージ<CODE>notificationOD</CODE>ボタンをクリックし</DD>
<DT CLASS="FIXME_WorListWide">「開始を確認」(SST_CONFIRM_START)</DT><DD>受信者によって呼び出される<CODE>MSG_META_CONFIRM_SHUTDOWNメッセージ</CODE>これにより、シャットダウンの確認ダイアログボックスをユーザに表示できます。 このタイプの発信者は、以前のすべての発信者が確認手順を完了するまでブロックされます。 次の場合<CODE>SysShutdown()</CODE>が戻ると、呼び出し元は確認ダイアログを表示し、シャットダウンを続行するか中止することができます。 次の場合<CODE>SysShutdown()</CODE>戻る<CODE>真</CODE>発信者は、このタイプのコールから<EM>しない</EM>ユーザーに確認ダイアログを表示し<CODE>SysShutdown()</CODE>SST_CONFIRM_END;別のスレッドがシャットダウンをキャンセルしました。 この型は追加のパラメータを取りません。</DD>
<DT CLASS="FIXME_WorListWide">SST_CONFIRM_END(終了を確認)</DT><DD>SST_CONFIRM_STARTに対応するもので、オブジェクトの<CODE>MSG_META_CONFIRM_SHUTDOWNメッセージ</CODE>ハンドラ。 追加のパラメータを1つ取り、何も返しません。 呼び出し形式を次に示します。</DD>
<PRE>ボイドSysShutdown(SysShutdownTypeタイプ、Boolean confirm)</PRE>
<DT CLASS="FIXME_WorListWide"></DT><DD>の<CODE>確認する</CODE>パラメータは、シャットダウンを続行する場合はTRUE、シャットダウンを中止する場合はFALSEにする必要があります。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">system.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>ほとんどのアプリケーションは<CODE>SysShutdown()</CODE>実行する場合は、細心の注意を払って実行する必要があります。</P>
</DIV>
<DIV>
          <A NAME="R_94.htm_IX_SysStatistics()"></A>
          <A NAME="R_94.htm_IX_Performance:SysStatistics()"></A>
        <H1 CLASS="refHeading">システム統計()</H1>
<PRE CLASS="syntax">void SysStatistics(SysStats*stats);/*返された統計情報*/</PRE>
<P>このルーチンは、システムパフォーマンス統計情報を返します。 空へのポインタを渡す<CODE>システム統計</CODE>ルーチンは該当するフィールドに値を入力します。<CODE>システム統計</CODE>の構造は次のとおりです。</P>
<PRE>typedef struct{dword SS_idleCount;SysSwapInfo SS_swapOuts;SysSwapInfo SS_swapIns;word SS_contextSwitches;word SS_interrupts;word SS_runQueue;}SysStats;</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sysstats.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_94.htm_IX_SysUnlockBIOS()"></A>
        <H1 CLASS="refHeading">SysUnlockBIOS()</H1>
<PRE CLASS="syntax">void SysUnlockBIOS(void)</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="R_95.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_95.htm_IX_TextSearchInString()"></A>
        <H1 CLASS="refHeading">TextSearchInString()</H1>
<PRE CLASS="syntax">char*TextSearchInSTring(const char*str1, conat char*startPtr, const char*endPtr, word strSize, const char*str2, word str2Size, word searchOptions, word*matchLen);</PRE>
<P>このルーチンは、渡されたテキスト文字列を1つのテキストチャンク内で検索します。 一致が見つかった場合、その一致へのポインタ(および一致の長さ)が渡されたバッファに返されます。</P>
<P><EM>str1(文字列1)</EM>は、検索するメイン文字列へのポインタです。</P>
<P><EM>startPtr</EM>および<EM>エンドPtr</EM>内の位置へのポインタ<EM>str1(文字列1)</EM>の順にクリックし、検索を開始および終了します。</P>
<P><EM>サイズ(S)</EM>サイズを格納します<EM>str1(文字列1)</EM>、NULL終端の場合は0。</P>
<P><EM>str2(文字列2)</EM>マッチ文字列を格納します。マッチ文字列には、ワイルドカード(<CODE>ワイルドカード(WilD</CODE>)をクリックします。</P>
<P><EM>str 2サイズ</EM>サイズを格納します<EM>str2(文字列2)</EM>、NULL終端の場合は0。</P>
<P><EM>検索オプション</EM>には<CODE>検索オプション</CODE>検索メカニズムで使用します。 上位バイトはゼロにする必要があります。</P>
<P><EM>マッチ長さ</EM>は、一致した単語のサイズを格納するバッファを格納します。 (一致した単語自体がルーチンから返されます)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">オブジェクト/vTextC.goh</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_95.htm_IX_TextSearchInHugeArray()"></A>
        <H1 CLASS="refHeading">TextSearchInHugeArray()</H1>
<PRE CLASS="syntax">dword TextSearchInSTring(char*str2, word str2Size, dword str1Size, dword curOffset, dword endOffset, FileHandle hugeArrayFile, VMBlockHandle hugeArrayBlock, word searchOptions, word*matchLen);</PRE>
<P>このルーチンは、渡されたテキスト文字列を巨大な配列で検索します。 マッチが見つかった場合、マッチに対するdwordオフセット(およびマッチの長さ)が渡されたバッファに返されます。</P>
<P><EM>str2(文字列2)</EM>マッチ文字列を格納します。マッチ文字列には、ワイルドカード(<CODE>ワイルドカード(WilD</CODE>)をクリックします。</P>
<P><EM>str 2サイズ</EM>サイズを格納します<EM>str2(文字列2)</EM>、NULL終端の場合は0。</P>
<P><EM>str 1サイズ</EM>検索する文字列の長さの合計が格納されます。</P>
<P><EM>curOffset</EM>str1の先頭からチェックする最初の文字までのオフセットを格納する。</P>
<P><EM>終点オフセット</EM>str1の先頭からチェックする最後の文字までのオフセットを格納する。</P>
<P><EM>hugeArrayFile</EM>巨大な配列のファイルハンドルを格納します。</P>
<P><EM>hugeArrayBlock</EM>巨大な配列のVMブロックハンドルを格納します。</P>
<P><EM>検索オプション</EM>には<CODE>検索オプション</CODE>検索メカニズムで使用します。 上位バイトはゼロにする必要があります。</P>
<P><EM>マッチ長さ</EM>は、一致した単語のサイズを格納するバッファを格納します。 (一致した単語自体がルーチンから返されます)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">オブジェクト/vTextC.goh</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_95.htm_IX_TGI_PRIORITY() macro"></A>
        <H1 CLASS="refHeading">TGI_PRIORITY()も参照下さい。</H1>
<PRE CLASS="syntax">バイトのTGI_PRIORITY(<EM>値</EM>);単語<EM>値</EM>;をクリックし</PRE>
<P>このマクロは、スレッドの優先度を<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetInfo()">ThreadGetInfo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_95.htm_IX_TGI_RECENT_CPU_USAGE() macro"></A>
        <H1 CLASS="refHeading">TGI_RECENT_CPU_USAGE()を参照してください。</H1>
<PRE CLASS="syntax">バイトのTGI_RECENT_CPU_USAGE(<EM>値</EM>);単語<EM>値</EM>;をクリックし</PRE>
<P>このマクロは、最新のCPU使用率を<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetInfo()">ThreadGetInfo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_95.htm_IX_ThreadAllocSem()"></A>
        <H1 CLASS="refHeading">ThreadAllocSem()</H1>
<PRE CLASS="syntax">SemaphoreHandle ThreadAllocSem(ワード値);/*セマフォに許されるロック*/</PRE>
<P>このルーチンは、マルチスレッドアプリケーションがプライベートに使用する新しいセマフォを割り当て、初期化します。 セマフォーを初期化する値を渡します。この値は、他のグラブ試行がブロックされる前に、セマフォーをグラブできるスレッドの数を表します。 通常、渡される値は1です。 このルーチンは、新しいセマフォのハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sem.hを入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadFreeSem()">ThreadFreeSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_95.htm_IX_ThreadAllocThreadLock()"></A>
        <H1 CLASS="refHeading">ThreadAllocThreadLock()</H1>
<PRE CLASS="syntax">ThreadLockHandle ThreadAllocThreadLock x</PRE>
<P>このルーチンは、スレッドロックと呼ばれる特殊なセマフォーを割り当てます。 通常のセマフォーでは、セマフォーを解放せずに2回取得するスレッドはデッドロックします。スレッド・ロックでは、スレッドは連続して2回以上取得できます。 ただし、スレッドは、スレッドロックを獲得するたびに1回解放する必要があります。</P>
<P>しかし、他のすべての面では、スレッド・ロックは通常のセマフォーに似ています。<CODE>ThreadAllocThreadLock()</CODE>新しいスレッドロックのハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sem.hを入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGrabThreadLock()">ThreadGrabThreadLock()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadReleaseThreadLock()">ThreadReleaseThreadLock()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_96.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_96.htm_IX_ThreadAttachToQueue()"></A>
        <H1 CLASS="refHeading">ThreadAttachToQueue()</H1>
<PRE CLASS="syntax">void ThreadAttachToQueue(QueueHandle qh, /*アタッチするキュー*/ClassStruct*クラス);/*スレッドのプライマリクラス*/</PRE>
<P>このルーチンは、渡されたイベントキューに呼び出しスレッドをアタッチします。これは、イベント駆動型スレッドでのみ使用されます。 通常、このルーチンはスレッドの作成時に呼び出されます。ほとんどの場合、キューへの割り当ては自動的に行われるため、このルーチンが必要になることはほとんどありません。</P>
<P>キューのハンドルを渡す<CODE>クフ</CODE>とクラスポインタ<CODE>階級</CODE>クラスはイベントキューにアタッチされ、スレッドに直接送信されるすべてのメッセージを処理します。 このクラスはほぼ常にのサブクラスであるべきです<CODE>プロセスクラス</CODE>ボタンをクリックし</P>
<P>0のキューハンドルが渡された場合、スレッドは現在のキューに「再アタッチ」しようとします。これは通常、イベント駆動型スレッドのシャットダウン時に使用され、ほとんどの場合<CODE>プロセスクラス</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スレッド.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_96.htm_IX_ThreadCreate()"></A>
          <A NAME="R_96.htm_IX_PRIORITY_&ldots;"></A>
        <H1 CLASS="refHeading">ThreadCreate()メソッド</H1>
<PRE CLASS="syntax">ThreadHandle ThreadCreate(word priority, /*新しいスレッドの初期ベース優先度*/word valueToPass, /*新しいスレッドに渡すオプションデータ*/word(*startRoutine)(word valuePassed),/*エントリルーチンへのポインタ*/</PRE>
<PRE CLASS="syntax">word stackSize, /*新しいスレッドのスタックのサイズ*/GeodeHandle owner);/*新しいスレッドを所有するGeode*/</PRE>
<P>このルーチンは、プロセスの新しいプロシージャスレッドを作成します。 新しいイベント駆動型スレッドが必要な場合は<CODE>MSG_PROCESS_CREATE_EVENT_THREAD(イベントスレッドの作成)</CODE>をプロセスオブジェクトに適用します。</P>
<P>次のパラメータをこのルーチンに渡します。</P>
<DL>
<DT>
          <CODE>優先権</CODE>
        </DT><DD>新しいスレッドの優先度。 通常、これは標準的なスレッド優先順位の1つです(下記参照)。</DD>
<DT><CODE>valueToPass</DT><DD></CODE>新しいスレッドのエントリルーチンに渡されるオプションデータのワード。 これは、たとえば、スレッドの初期コンテキストを示したり、スレッド変数を初期化するために使用できます。</DD>
<DT><CODE>startRoutine</DT><DD></CODE>スレッドに対して即時に実行されるエントリルーチンへのポインタ。 これは、固定メモリまたは可動メモリのいずれかにあります。 セグメントは仮想セグメントである必要があります。 ルーチンが移動可能なメモリ内にある場合、スレッドの存続期間中はヒープのパフォーマンスが低下する可能性があることに注意してください(移動可能なブロックは長時間ロックされたままになります)。 ルーチンは、スレッドの終了コードを返すか<CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadDestroy()">ThreadDestroy()</A></CODE>直接。</DD>
<DT>
          <CODE>スタックサイズ</CODE>
        </DT><DD>スレッドに割り当てられたスタック・サイズ。 通常、UIもファイルシステムも処理しないスレッドには512バイトで十分ですが、ファイルシステムを処理するスレッドには1 Kバイトが必要です。 UIオブジェクトを処理するスレッドには3 Kが必要です。</DD>
<DT>
          <CODE>オーナー</CODE>
        </DT><DD>ねじを所有するgeodeのgeodeハンドル。 呼び出しスレッドのgeodeが新しいスレッドを所有する場合、そのスレッドは<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeGetProcessHandle()">GeodeGetProcessHandle()</A></CODE>呼び出す前に<CODE>ThreadCreate()メソッド</CODE>ボタンをクリックし</DD>
</DL>
<P><CODE>ThreadCreate()メソッド</CODE>新しいスレッドのスレッドハンドルを返します。 エラーが発生すると、呼び出しスレッドのエラーコードが設定され、ヌルハンドルが返されます。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>を使用して、新しいスレッドの作成後にエラーコードを取得します。 からNO_ERROR_RETURNEDが返されました。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>エラーが発生しなかったことを意味します。</P>
<P>標準スレッドの優先順位は<CODE>優先権</CODE>パラメータは次のとおりです。</P>
<DL>
<DT>優先度_時間_クリティカル</DT><DD>すべての中で最も高い優先度です。他のほとんどすべてのスレッドをプリエンプトするため、一般的には使用しないでください。 (ただし、デバッグ中に役立つ場合があります)。</DD>
<DT>優先度-高</DT><DD>優先度が高く、通常は重要度の高いスレッドにのみ使用されます。</DD>
<DT>優先度UI</DT><DD>もう1つの高い優先度。これは、ユーザーインタフェーススレッドがユーザーのアクションに迅速に応答するために使用されます。</DD>
<DT>「優先度フォーカス」(PRIORITY_FOCUS)</DT><DD>中レベルの優先度。現在の入力フォーカスを持つスレッド(ユーザが現在作業しているスレッド)に使用されます。</DD>
<DT>「優先度標準」(PRIORITY_STANDARD)</DT><DD>標準のアプリケーションスレッドの優先度。通常、新しいスレッドを作成するときに使用します。</DD>
<DT>優先度-低</DT><DD>バックグラウンドで実行できるタスクの優先度は低くなります。</DD>
<DT>PRIORITY_LOWEST(優先度</DT><DD>最も低い標準優先度。完了までに時間がかかるスレッドに使用されます。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スレッド.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_96.htm_IX_ThreadDestroy()"></A>
        <H1 CLASS="refHeading">ThreadDestroy()</H1>
<PRE CLASS="syntax">void ThreadDestroy(word errorCode, /*破壊の原因を示すエラーコード*/optr ackObject, /*破壊確認を受け取るオブジェクト*/word ackData);/*渡すべきデータの追加ワード(MSG_META_ACKのソースに対するoptrのlow*ワードとして)*/</PRE>
<P>このルーチンは、現在の(呼び出し元の)スレッドを終了させ、その後スレッド自体を破棄します。 スレッドは、割り当てられたリソースが残っていないことや、セマフォーがロックされていないことを確認する責任があります。</P>
<P>アプリケーションおよびアプリケーション内の他のスレッドにとって意味のあるエラー・コードまたは終了コードを渡します。 このエラー・コードは、スレッドの終了の原因を判別するためにデバッガーによって使用されます。ヌル・エラー・コードは通常、スレッドのタスクが正常に完了したことを示します。</P>
<P>また、スレッドの破棄の確認を受け取るオブジェクトのoptrも渡します。 指定されたオブジェクトは<CODE>MSG_META_ACKメッセージ</CODE>呼び出しスレッドが完全に破棄された後。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>スレッドを終了する前に、必ずクリーンアップしてください。 ロックされたリソースのロックを解除したり、割り当てられたメモリを解放したりします。アプリケーションのプライマリスレッドに対してこれらの操作を行う必要はありません。プロセスオブジェクト(プライマリスレッド)は自動的にクリーンアップします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スレッド.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_96.htm_IX_ThreadFreeSem()"></A>
        <H1 CLASS="refHeading">ThreadFreeSem()</H1>
<PRE CLASS="syntax">void ThreadFreeSem(SemaphoreHandle sem);/*解放されるセマフォ*/</PRE>
<P>このルーチンは、指定されたセマフォを解放する。<CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE>セマフォーを使用しているスレッドがないこと、または解放後にセマフォーを使用するスレッドがないことを確認する必要があります。 その後のアクセス試行では、不正なハンドル・エラーが発生するか、さらに悪化します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sem.hを入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_96.htm_IX_ThreadFreeThreadLock()"></A>
        <H1 CLASS="refHeading">ThreadFreeThreadLock()</H1>
<PRE CLASS="syntax">void ThreadFreeThreadLock(ThreadLockHandle sem);/*解放されるスレッドロック*/</PRE>
<P>このルーチンは、指定されたスレッドロックを解放します。<CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>スレッド・ロックを使用しているスレッド、または解放後に使用するスレッドがないことを確認する必要があります。 その後、スレッドロックを獲得または解放しようとすると、不正なハンドルエラーが発生する可能性があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sem.hを入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_97.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_97.htm_IX_ThreadGetError()"></A>
        <H1 CLASS="refHeading">ThreadGetError()</H1>
<PRE CLASS="syntax">単語ThreadGetError(void)</PRE>
<P>このルーチンは、スレッドの現在のエラー値を返します。</P>
</DIV>
<DIV>
          <A NAME="R_97.htm_IX_Threads:finding priority"></A>
          <A NAME="R_97.htm_IX_Threads:finding handle"></A>
          <A NAME="R_97.htm_IX_ThreadGetInfo()"></A>
          <A NAME="R_97.htm_IX_ThreadGetInfoType"></A>
          <A NAME="R_97.htm_IX_TGIT_&ldots;"></A>
          <A NAME="R_97.htm_IX_Event queues:from thread handle"></A>
        <H1 CLASS="refHeading">ThreadGetInfo()</H1>
<PRE CLASS="syntax">word ThreadGetInfo(ThreadHandle th, /*ThreadGetInfoType情報に関する情報を取得するスレッド);/*取得する情報のタイプ*/</PRE>
<P>このルーチンは、指定されたスレッドに関する情報を取得します。 必要な情報は<CODE>情報(info)</CODE>対象となるスレッドは<CODE>番目</CODE>パラメータを指定します。 渡されたスレッド・ハンドルがゼロまたはNULLハンドルの場合、ルーチンは呼び出しスレッドに関する情報を返します。</P>
<P>の<CODE>情報(info)</CODE>パラメータは、次のいずれかの値です。<CODE>ThreadGetInfoType</CODE>によって返される情報の種類を指定します。<CODE>ThreadGetInfo()</CODE>キーを押します</P>
<DL>
<DT>TGIT_PRIORITY_AND_USAGE[優先順位と使用法]</DT><DD>返されるワードには、スレッドの優先順位とスレッドの最近のCPU使用率の両方が含まれます。 スレッドの優先度を抽出するには、マクロTGI_PRIORITYを使用します。最近のCPU使用率を抽出するには、マクロTGI_RECENT_CPU_USAGEを使用します。</DD>
<DT>「ねじハンドル」(TGIT_THREAD_HANDLE)</DT><DD>このオプションは<CODE>番目</CODE>パラメータが0の場合、対象スレッドのスレッドハンドルを返します。 次の場合<CODE>番目</CODE>が0の場合、呼び出しスレッドのハンドルが返される。</DD>
<DT>TGIT_QUEUEハンドル</DT><DD>返される単語には<CODE>番目</CODE>指定されたスレッドがイベント駆動型でない場合は、nullキューハンドルが返されます。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スレッド.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_97.htm_IX_ThreadGrabThreadLock()"></A>
        <H1 CLASS="refHeading">ThreadGrabThreadLock()</H1>
<PRE CLASS="syntax">void ThreadGrabThreadLock(ThreadLockHandle sem);/*つかむためのスレッドロック*/</PRE>
<P>このルーチンは、呼び出しスレッドのスレッド・ロックを獲得しようとします。 スレッド・ロックが現在別のスレッドによって保持されている場合、呼び出し側はロックが使用可能になるまでブロックします。 呼び出し側がすでにスレッド・ロックを持っている場合、呼び出し側は再びロックを獲得し、実行を継続します。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>スレッドロックは<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadReleaseThreadLock()">ThreadReleaseThreadLock()</A></CODE>つかまれるたびに1回。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、複数のスレッドに対してデッドロック保護を提供しません。 複数のスレッドが複数のスレッドロックを獲得する場合、デッドロックの可能性を最小限に抑えるために、ロックは常に同じ順序で獲得される必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sem.hを入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadReleaseThreadLock()">ThreadReleaseThreadLock()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_97.htm_IX_ThreadHandleException()"></A>
          <A NAME="R_97.htm_IX_ThreadException"></A>
          <A NAME="R_97.htm_IX_TE_&ldots;  (ThreadException type)"></A>
        <H1 CLASS="refHeading">ThreadHandleException()</H1>
<PRE CLASS="syntax">void ThreadHandleException(ThreadHandle th, /*例外を処理するスレッド*/ThreadExceptions例外,/*処理する例外*/void(*handler)());/*ハンドラへのポインタ*/</PRE>
<P>このルーチンは、スレッドがプロセッサ例外のハンドラを設定できるようにします。 これはデバッグの目的に役立ちます。 次の3つのパラメータを渡します。</P>
<DL>
<DT>
          <CODE>番目</CODE>
        </DT><DD>例外を処理するスレッドのハンドル。 現在のスレッドにゼロを渡します。</DD>
<DT>
          <CODE>例外</CODE>
        </DT><DD>ア<CODE>ThreadException</CODE>タイプ(下記参照)。</DD>
<DT>
          <CODE>取扱者</CODE>
        </DT><DD>固定メモリまたはロックされたメモリ内のハンドラへのポインタ。 GEOSデフォルト例外ハンドラを使用するには、nullポインタを渡します。</DD>
</DL>
<P CLASS="refField"><STRONG>構造:</STRONG>の<CODE>ThreadException</CODE>typeには次の値があります。</P>
<PRE>TE_DIVIDE_BY_ZERO TE_OVERFLOW TE_BOUND TE_FPU_EXCEPTION TE_SINGLE_STEP TE_BREAKPOINT■サービス名の場合■</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スレッド.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_97.htm_IX_ThreadModify()"></A>
        <H1 CLASS="refHeading">ThreadModify()</H1>
<PRE CLASS="syntax">void priority(ThreadHandle ThreadModify,/*変更するスレッド*/word newBasePriority, /*スレッドの新しいベース優先度*/ThreadModifyFlagsフラグ);/*フラグ(下記参照)*/</PRE>
<P>このルーチンは、指定したスレッドの優先順位を変更します。 これを使用して、スレッドの基本優先度を設定するか、現在のCPU使用率をゼロにリセットします。 パラメータには、次の値が必要です。</P>
<DL>
<DT>
          <CODE>番目</CODE>
        </DT><DD>スレッドハンドル。呼び出しスレッドの優先度を変更するには、0を渡します。</DD>
<DT><CODE>newBasePriority</DT><DD></CODE>スレッドの新しい基本優先度。 標準の優先度のいずれかを使用します。「」を参照してください。<CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadCreate()">ThreadCreate()メソッド</A></CODE>--または0～255の値を使用します。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>ThreadModifyFlags</CODE>;スレッドのベース優先度を変更するにはTMF_BASE_PRIOを、スレッドの最近のCPU使用率を0にリセットするにはTMF_ZERO_USAGEを渡します。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>スレッドがタイミング・クリティカルでない限り、基本優先度を0に設定しないでください。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スレッド.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_97.htm_IX_ThreadPrivAlloc()"></A>
        <H1 CLASS="refHeading">ThreadPrivAlloc()</H1>
<PRE CLASS="syntax">word ThreadPrivAlloc(word wordsRequested, /*割り当てる単語数*/GeodeHandle owner);/*データを所有するgeodeのハンドル*/</PRE>
<P>このルーチンは、すべての測地(ロードされたものとロードされていないもの)のプライベートデータに、いくつかの連続するワードを割り当てます。 とまったく同じです。<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>;そのルーチンのエントリを参照してください。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スレッド.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_97.htm_IX_ThreadPrivFree()"></A>
        <H1 CLASS="refHeading">ThreadPrivFree()</H1>
<PRE CLASS="syntax">void ThreadPrivFree(word range, /*解放する最初のワードまでのオフセット*/word wordsRequested);/*解放するワード数*/</PRE>
<P>このルーチンは、以前に割り当てられたいくつかの連続したプライベートデータワードを解放します。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadPrivAlloc()">ThreadPrivAlloc()</A></CODE>に似ています。<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivFree()">GeodePrivFree()</A></CODE>詳細については、そのルーチンのエントリを参照してください。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">スレッド.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivFree()">GeodePrivFree()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_98.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_98.htm_IX_ThreadPSem()"></A>
        <H1 CLASS="refHeading">ThreadPSem()</H1>
<PRE CLASS="syntax">SemaphoreError ThreadPSem(SemaphoreHandle sem);/*つかむためのセマフォ*/</PRE>
<P>このルーチンは、渡されたセマフォを&quot;P&quot;操作で獲得しようとします。 セマフォーがすでにグラブされている場合、そのセマフォーが使用可能になるまで、スレッドはブロックします。これは、そのセマフォーが同じスレッドによってグラブされた場合でも同様です。</P>
<P><CODE>ThreadPSem()</CODE>タイプのエラーコードを返す<CODE>SemaphoreError</CODE>エラー・コードは、前のスレッドが異常終了したことを示すためのものです。セマフォーが使用可能にならない場合、スレッドは無期限にブロックされ、ルーチンは終了しません。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>スレッドがセマフォを必要としなくなったら、次のようにセマフォを解放する必要があります。<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、デッドロック保護を提供しません。 スレッドが複数の共通セマフォーを獲得する場合は、デッドロックの可能性を最小限に抑えるために、常に同じ順序でそれらを獲得/解放する必要があります。</P>
<P>スレッドは、特定のセマフォーを2回取得しようとしても、取得と取得の間に解放する必要があります。 スレッドは自分自身をブロックし、デッドロックします。 スレッドが連続して2回セマフォを取得する必要がある場合は、代わりにスレッドロックを使用する必要があります(<CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>」を参照してください)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sem.hを入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadFreeSem()">ThreadFreeSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_98.htm_IX_ThreadPTimedSem()"></A>
        <H1 CLASS="refHeading">ThreadPTimedSem()</H1>
<PRE CLASS="syntax">SemaphoreError ThreadPTimedSem(SemaphoreHandle sem, /*セマフォからグラブ*/ワードタイムアウト);/*タイムアウト前にティック*/</PRE>
<P>このルーチンは、渡されたセマフォを&quot;P&quot;操作で獲得しようとします。 セマフォーがすでにつかまれている場合、スレッドは<CODE>タイムアウト(timeout)</CODE>ボタンをクリックし</P>
<P>頻繁に<CODE>タイムアウト(timeout)</CODE>が0として渡された場合、セマフォーが現在使用できない場合、スレッドは他のアクションを続行します。</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>スレッドがセマフォを必要としなくなったら、次のようにセマフォを解放する必要があります。<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、デッドロック保護を提供しません。 スレッドが複数の共通セマフォーを獲得する場合は、デッドロックの可能性を最小限に抑えるために、常に同じ順序でそれらを獲得/解放する必要があります。</P>
<P>スレッドは、特定のセマフォーを2回取得しようとしても、取得と取得の間に解放する必要があります。 スレッドは自分自身をブロックし、デッドロックします。 スレッドがセマフォを2回続けて獲得する必要がある場合は、代わりにスレッドロックを使用する必要があります。<CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>」を参照してください)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sem.hを入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadFreeSem()">ThreadFreeSem()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_98.htm_IX_ThreadReleaseThreadLock()"></A>
        <H1 CLASS="refHeading">ThreadReleaseThreadLock()</H1>
<PRE CLASS="syntax">void ThreadReleaseThreadLock(ThreadLockHandle sem);/*ねじロックを解除する*/</PRE>
<P>このルーチンは、指定されたスレッドロックを解放します。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGrabThreadLock()">ThreadGrabThreadLock()</A></CODE>によって返されたスレッドロックのハンドルを渡します。<CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>ボタンをクリックし</P>
<P>まだグラブされていないスレッド・ロックは解放しないでください。 結果は予測できません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sem.hを入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE><CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGrabThreadLock()">ThreadGrabThreadLock()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_98.htm_IX_ThreadVSem()"></A>
        <H1 CLASS="refHeading">ThreadVSem()</H1>
<PRE CLASS="syntax">void ThreadVSem(SemaphoreHandle sem);/*解放するセマフォ*/</PRE>
<P>このルーチンは、でグラブされたセマフォーを解放します。<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>によって返されたセマフォーのハンドルを渡します。<CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE>ボタンをクリックし</P>
<P>上記のルーチンのいずれかでグラブされていないセマフォを解放しようとしないでください。 結果は予測できません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">sem.hを入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadFreeSem()">ThreadFreeSem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_98.htm_IX_TimerGetCount()"></A>
        <H1 CLASS="refHeading">TimerGetCount()</H1>
<PRE CLASS="syntax">dワードTimerGetCount();</PRE>
<P>このルーチンは、システムカウンタの値を返します。 戻り値は、GEOSが開始されてからのティック数です。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">タイマーh</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_98.htm_IX_TimerGetDateAndTime()"></A>
        <H1 CLASS="refHeading">TimerGetDateAndTime()</H1>
<PRE CLASS="syntax">void TimerGetDateAndTime(TimerDateAndTime*dateAndTime);/*戻り値のバッファ*/</PRE>
<P>このルーチンは、現在の日時を返します。 空へのポインタを渡す<CODE>TimerDateAndTime</CODE>ルーチンによって入力される構造体。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">timedate.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_98.htm_IX_TimerGetFileDateTime"></A>
        <H1 CLASS="refHeading">TimerGetFileDateTime</H1>
<PRE CLASS="syntax">TimerFileDateTime TimerGetFileDateTime x</PRE>
<P>このルーチンは、現在の日付と時刻を<CODE>FileDateAndTime</CODE>そのため、ファイルのタイムスタンプを作成するのに便利です。</P>
</DIV>
<DIV>
          <A NAME="R_98.htm_IX_TimerSetDateAndTime()"></A>
        <H1 CLASS="refHeading">TimerSetDateAndTime()</H1>
<PRE CLASS="syntax">void TimerSetDateAndTime(単語フラグ,/*設定する項目*/const TimerDateAndTime*dateAndTime);/*新しい値*/</PRE>
<P>このルーチンは、システムの現在の日付や時刻を設定します。 次のように渡します。</P>
<DL>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>旗の言葉 日、月、年を設定するにはTIME_SET_DATEを渡し、時、分、秒を設定するにはTIME_SET_TIMEを渡します。 両方を設定するには、bothを渡します。</DD>
<DT><CODE>日付と時刻</DT><DD></CODE>へのポインタ<CODE>TimerDateAndTime</CODE>設定する情報を含む構造体。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">timedate.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_99.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_99.htm_IX_TimerSleep()"></A>
        <H1 CLASS="refHeading">TimerSleep()</H1>
<PRE CLASS="syntax">void tick(単語TimerSleep);/*スレッドがスリープするティック数*/</PRE>
<P>このルーチンは、呼び出しスレッドを指定されたティック数だけスリープ状態にする「スリープ・タイマー」を呼び出します。 時間の終わりに、スレッドは次の命令で実行を継続します。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>スレッド同期用のセマフォーの代わりにスリープタイマーを使用しないでください。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">タイマーh</STRONG>
        </P>
</DIV>
<DIV><A NAME="R_99.htm_IX_TimerStart()"></A>キーを押します<A NAME="R_99.htm_IX_TimerType"></A><A NAME="R_99.htm_IX_TIMER_&ldots;"></A><A NAME="R_99.htm_IX_Power management:waking up by timer"></A><H1 CLASS="refHeading">TimerStart()</H1>
<PRE CLASS="syntax">TimerHandle TimerStart(timerType timerType、/*開始するタイマーのタイプ*/optr destObject、/*タイマーの期限が切れたときに通知を受信するオブジェクト*/</PRE>
<PRE CLASS="syntax">ワードティック、/*実行時間*/メッセージメッセージ、/*通知メッセージ*/ワード間隔、/*連続タイマーの間隔*/ワード*id);/*返されたタイマーIDのバッファ*/</PRE>
<P>このルーチンは、任意のタイプのタイマーを開始します。 タイマーは指定された数のティックに対して実行され、指定されたメッセージを宛先オブジェクトに送信します。 メッセージはフラグMF_FORCE_QUEUE、MF_CHECK_DUPLICATE、およびMF_REPLACEを付けて送信されます。したがって、メッセージは常に受信側のキューに置かれ、すでにキューにあるすべての重複を常に置き換えます。 このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>timerType</CODE>
        </DT><DD>の値<CODE>TimerType</CODE>開始するタイマーのタイプを示します。</DD>
<DT>
          <CODE>destObject</CODE>
        </DT><DD>指定した時間が経過したときに、指定したメッセージが送信されるオブジェクトのoptr。</DD>
<DT>
          <CODE>ティック</CODE>
        </DT><DD>タイマーを実行するティック数。 (60ティックは1秒に相当します)。 連続タイマーの場合、これは最初のタイムアウトまでの時間です。</DD>
<DT>
          <CODE>メッセージ</CODE>
        </DT><DD>時間切れになったときに宛先オブジェクトに送信されるメッセージ。</DD>
<DT>
          <CODE>インターバル</CODE>
        </DT><DD>連続タイマーの場合、メッセージを宛先オブジェクトに送信する間隔(ティック数)。 タイマーは、各インターバルの終わりに1回メッセージを送信します。 最初のメッセージが送信されます<CODE>ティック</CODE>タイマーが開始された後のティック。 2番目のメッセージが送信されます<CODE>インターバル</CODE>その後のティック。</DD>
<DT>
          <CODE>イド</CODE>
        </DT><DD>タイマーのIDが返されるワードへのポインタ。 このIDが必要になるのは<CODE><A HREF="../../CRef/Routines/R_99.htm#IX_TimerStop()">TimerStop()</A></CODE>ボタンをクリックし</DD>
</DL>
<P>このルーチンは、タイマーのハンドルを返すとともに<CODE>イド</CODE>パラメータを指定します。 のハンドルとIDが必要です。<CODE><A HREF="../../CRef/Routines/R_99.htm#IX_TimerStop()">TimerStop()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<P><CODE>TimerType</CODE>の<CODE>TimerType</CODE>enumerated typeは、開始するタイマーのタイプを定義します。 次の値があります。</P>
<DL>
<DT>TIMER_ROUTINE_ONE_SHOT[タイマルーチン1ショット]</DT><DD>ルーチンを呼び出すタイマーを開始し、時間が経過するとタイマー自体を解放します。 この型はアセンブリではサポートされていますが、Cではサポートされていません。</DD>
<DT>TIMER_ROUTINE_CONTINUAL[タイマルーチン継続</DT><DD>1回に1回ルーチンを呼び出すタイマーを開始します<EM>インターバル</EM>(の後から開始)<EM>ティック</EM>ティック)まで<CODE><A HREF="../../CRef/Routines/R_99.htm#IX_TimerStop()">TimerStop()</A></CODE>が呼び出されます。</DD>
<DT>TIMER_EVENT_ONE_SHOT[タイマイベント1ショット]</DT><DD>指定されたオブジェクトにメッセージを送信するタイマーを開始し、時間が経過したらタイマーを解放します。</DD>
<DT>TIMER_EVENT_CONTINUAL[タイマイベント継続]</DT><DD>指定したオブジェクトに1回ずつメッセージを送信するタイマーを開始します。<EM>インターバル</EM>(の後から開始)<EM>ティック</EM>ティック)まで<CODE><A HREF="../../CRef/Routines/R_99.htm#IX_TimerStop()">TimerStop()</A></CODE>が呼び出されます。</DD>
<DT>TIMER_MS_ROUTINE_ONE_SHOT(タイマー_MS_ルーチン_単発)</DT><DD>ミリ秒の精度を持つタイマーを開始します。 このタイマーでは、ティックの数は実際にはミリ秒の数になります。 タイマーは指定されたルーチンを呼び出し、時間が経過するとタイマー自体を解放します。 この型はアセンブリではサポートされていますが、Cではサポートされていません。</DD>
<DT>TIMER_EVENT_REAL_TIME(タイマー_イベント_実時間)</DT><DD>特定の日時にルーチンを呼び出すタイマーを開始します。 このようなタイマーをサポートするデバイスでは、このイベントによってスリープ状態のマシンがスリープ解除されます。</DD>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>タイマーh</P>
</DIV>
<DIV>
          <A NAME="R_99.htm_IX_TimerStop()"></A>
        <H1 CLASS="refHeading">TimerStop()</H1>
<PRE CLASS="syntax">Boolean TimerStop(TimerHandle th, /*停止するタイマーのハンドル*/word id);/*タイマーID(TimerStart()が返す)*/</PRE>
<P>このルーチンは、で開始されたタイマーを停止して破棄します。<CODE><A HREF="../../CRef/Routines/R_99.htm#IX_TimerStart()">TimerStart()</A></CODE>タイマーハンドルと、そのルーチンから返されたIDを渡します(連続タイマーのIDは常に0になります)。</P>
<P>返されるエラーフラグは次のようになります。<CODE>真</CODE>タイマーが見つからなかった場合。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>電話する場合<CODE>TimerStop()</CODE>スレッド間でメッセージを送信する継続的なタイマーを停止するために、受信側のイベントキューにタイマーイベントが残っている場合があります。 この状況では、すべてのタイマー・イベントが処理されたと想定するのは危険です。 タイマー・メッセージが処理されたことを確認するには、MF_FORCE_QUEUEフラグを指定して「all-safe」メッセージを宛先に送信します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">タイマーh</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_99.htm_IX_TocDBLock()"></A>
        <H1 CLASS="refHeading">TocDBLock()</H1>
<PRE CLASS="syntax">void*TocDBLock(DBGroupAndItemのようなもの)</PRE>
<P>このルーチンを使用して、PrefTocListオブジェクトによって保持される名前配列をロックします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.gohと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_99.htm_IX_TocDBLockGetRef()"></A>
        <H1 CLASS="refHeading">TocDBLockGetRef()</H1>
<PRE CLASS="syntax">void*TocDBLockGetRef(DBGroupAndItemのこと、optr*refPtr);</PRE>
<P>このルーチンは、PrefTocListオブジェクトによって保持されているname配列をロックし、項目のポインタとoptrを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.gohと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_99.htm_IX_TocFindCategory()"></A>
        <H1 CLASS="refHeading">TocFindCategory()</H1>
<PRE CLASS="syntax">ブーリアンTocFindCategory(TocCategoryStruct*cat);</PRE>
<P>このルーチンは、PrefTocListオブジェクトの名前リストから指定されたトークンを検索します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef struct{tokenChars TCS_tokenChars;DBGroupAndItem TCS_files;/*ファイル名配列*/DBGroupAndItem TCS_devices;/*デバイス名配列--*TCF_EXTENDED_DEVICE_DRIVERS*が設定されている場合のみ。 */}TocCategoryStruct</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.gohと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_99.htm_IX_TocGetFileHandle()"></A>
        <H1 CLASS="refHeading">TocGetFileHandle()</H1>
<PRE CLASS="syntax">単語TocGetFileHandle();</PRE>
<P>このルーチンを使用して、PrefTocListsが名前配列データを格納するために使用するファイルのハンドルを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.gohと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_99.htm_IX_TocNameArrayAdd()"></A>
        <H1 CLASS="refHeading">TocNameArrayAdd()</H1>
<PRE CLASS="syntax">word TocNameArrayAdd(DBGroupAndItem配列,const char*nameToFind, const void*data);</PRE>
<P>このルーチンを使用して、PrefTocListオブジェクトによって保持される名前配列に名前を追加します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_9a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_9a.htm_IX_TocNameArrayFind()"></A>
        <H1 CLASS="refHeading">TocNameArrayFind()</H1>
<PRE CLASS="syntax">word TocNameArrayGetElement(DBGroupAndItem配列,word要素,void*バッファ);</PRE>
<P>このルーチンを使用して、PrefTocListオブジェクトによって保持されている名前リスト内の名前を検索します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.gohと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9a.htm_IX_TocNameArrayGetElement()"></A>
        <H1 CLASS="refHeading">TocNameArrayGetElement()</H1>
<PRE CLASS="syntax">word TocNameArrayGetElement(DBGroupAndItem配列,word要素,void*バッファ);</PRE>
<P>このルーチンを使用して、PrefTocListオブジェクトによって保持されている名前配列から特定のエレメントを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.gohと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9a.htm_IX_TocSortedNameArrayAdd()"></A>
        <H1 CLASS="refHeading">TocSortedNameArrayAdd()</H1>
<PRE CLASS="syntax">word TocSortedNameArrayAdd(word arr, const char*nameToAdd, NameArrayAddFlags flags, const void*data);</PRE>
<P>このルーチンは、PrefTocListオブジェクトに関連付けられたソート済みのname配列に名前を追加します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef WordFlags NameArrayAddFlags;#define NAAF_SET_DATA_ON_REPLACE 0x8000</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.gohと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9a.htm_IX_TocSortedNameArrayFind()"></A>
          <A NAME="R_9a.htm_IX_SortedNameArrayAddFlags"></A>
          <A NAME="R_9a.htm_IX_SNAAF_&ldots;"></A>
        <H1 CLASS="refHeading">TocSortedNameArrayFind()</H1>
<PRE CLASS="syntax">Boolean TocSortedNameArrayFind(word arr, const char*nameToFind, SortedNameArrayFindFlags flags, void*バッファ,word*elementNum);</PRE>
<P>このルーチンは、PrefTocListオブジェクトに関連付けられたソート済みのname配列内の名前を検索します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef WordFlags SortedNameArrayFindFlags;#define SNAFF_IGNORE_CASE 0x0080</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.gohと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9a.htm_IX_TocUpdateCategory()"></A>
          <A NAME="R_9a.htm_IX_TocUpdateCategoryParams()"></A>
          <A NAME="R_9a.htm_IX_TUCP_&ldots;"></A>
          <A NAME="R_9a.htm_IX_TocUpdateAddCallback() prototype"></A>
        <H1 CLASS="refHeading">TocUpdateCategory()</H1>
<PRE CLASS="syntax">空隙TocUpdateCategory(TocUpdateCategoryParams*params)</PRE>
<P>このルーチンを使用して、特定のトークンを持つ特定のディレクトリ内のファイルに基づいてPrefTocListオブジェクトを更新します。</P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef struct{TocUpdateCategoryFlags TUCP_flags;TokenChars TUCP_TokenChars;バイトTUCP_fileArrayElementSize;TocUpdateAddCallback*TUCP_addCallback;バイトTUCP_pad;/*単語整列をしたい*/}TocUpdateCategoryParams;typedef word_pascal TocUpdateAddCallback(const char*filename, optr chunkArray);/*追加が中止された場合は0を返し、それ以外の場合は*block*内の新しい要素のオフセットを返す</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">config.gohと入力します</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9a.htm_IX_TOKEN_CHARS() macro"></A>
        <H1 CLASS="refHeading">TOKEN_CHARS()も参照下さい。</H1>
<PRE CLASS="syntax">dワードTOKEN_CHARS(<EM>ア</EM><EM>イ</EM><EM>ハ</EM><EM>エ</EM>)をクリックし</PRE>
<P>このマクロは、与えられた4文字から1つのdword値を作成します。 これは、特定のトークンのトークン文字値を作成する場合に便利です。 渡される最初の2文字はcharsで、次の2文字はdwordsにキャストする必要があります。 簡単な例を示します。</P>
<PRE>TOKEN_CHARS(`S&#39;,`A&#39;,(dワード)) `M&#39;、(dワード) 「P」);</PRE>
</DIV>
<DIV>
          <A NAME="R_9a.htm_IX_TokenCloseLocalTokenDB()"></A>
        <H1 CLASS="refHeading">TokenCloseLocalTokenDB()</H1>
<PRE CLASS="syntax">void TokenCloseLocalTokenDB()</PRE>
<P>このルーチンは、ローカル・トークン・データベースをクローズします。</P>
</DIV>
<HR>
          <A NAME="R_9b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_9b.htm_IX_TokenDefineToken()"></A>
        <H1 CLASS="refHeading">TokenDefineToken()</H1>
<PRE CLASS="syntax">word TokenDefineToken(dword tokenChars, /*トークン4文字*/ManufacturerID ManufacturerID,/*トークンのManufacturerID*/optr monikerList, /*monikerListのoptr*/TokenFlagsフラグ);/*トークンフラグ*/</PRE>
<P>このルーチンは、新しいトークンとモニカ・リストをトークン・データベースに追加します。トークンがトークンDBにすでに存在する場合は、古いトークンが新しいトークンに置き換えられます。 このルーチンは、渡されたモニカまたはモニカリストが存在するブロックをロックできるスレッドによってのみ呼び出されます。 このルーチンには、次のパラメータを渡す必要があります。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークン・データベース内でこのモニカまたはモニカ・リストを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdword値を作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
<DT><CODE>monikerList</DT><DD></CODE>トークン・データベースに追加するモニカ・リストのオプション。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>の記録<CODE>TokenFlags</CODE>モニカリストの再配置ステータスを示します。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、ロックされたLMemブロック(トークンデータベース項目)を合法的に移動することができ、それによってトークンデータベース項目へのすべてのポインタを無効にする。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9b.htm_IX_TokenGetTokenInfo()"></A>
        <H1 CLASS="refHeading">TokenGetTokenInfo()</H1>
<PRE CLASS="syntax">Boolean TokenGetTokenInfo(dword tokenChars, /*トークンの4文字*/manufacturerID manufacturerID, /*トークンの製造者ID*/TokenFlags*flags);/*返されたトークンフラグ*/</PRE>
<P>このルーチンは、指定されたトークンに関する情報を返します。 次のように渡します。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークンデータベースエントリを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdワードを作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>空のフラグレコードへのポインタ。指定されたトークン(存在する場合)に設定されているフラグ(存在する場合)がここに返されます。</DD>
</DL>
<P>このルーチンは、トークンがトークン・データベースで検出された場合、ゼロ以外の値を戻します。トークンが検出されなかった場合は、ゼロを戻します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9b.htm_IX_TokenListTokens()"></A>
        <H1 CLASS="refHeading">TokenListTokens()</H1>
<PRE CLASS="syntax">dword TokenListTokens(tokenRangeFlags tokenRangeFlags, word headerSize, manufacturerID manufacturerID));</PRE>
<P>このルーチンは、トークン・データベース内のすべてのトークンをリストします。グローバル・ヒープ上に新しいブロックを割り当て、その中に配列を書き込みます。<CODE>GeodeToken</CODE>構造。 このルーチンは、トークン・グループではなく、実際のトークンを返します。</P>
<P>返されるdワードは、次の2つの値で構成されます。 上位ワードは、返されたブロック内のトークンの数を表し、マクロで抽出できます。<CODE><A HREF="../../CRef/Routines/R_9b.htm#IX_TokenListTokensCountFromDWord()">TokenListTokensCountFromDWord()</A></CODE>下位ワードは、新しく割り当てられたブロックのハンドルを表し、マクロで抽出できます。<CODE><A HREF="../../CRef/Routines/R_9b.htm#IX_TokenListTokensHandleFromDWord()">TokenListTokensHandleFromDWord()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9b.htm_IX_TokenListTokensCountFromDWord()"></A>
        <H1 CLASS="refHeading">TokenListTokensCountFromDWord()</H1>
<PRE CLASS="syntax">単語TokenListTokensCountFromDWord(<EM>エ</EM>);dワード<EM>エ</EM>;をクリックし</PRE>
<P>このマクロは、以下によって返される値からトークンの数を抽出します。<CODE><A HREF="../../CRef/Routines/R_9b.htm#IX_TokenListTokens()">TokenListTokens()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_9b.htm_IX_TokenListTokensHandleFromDWord()"></A>
        <H1 CLASS="refHeading">TokenListTokensHandleFromDWord()</H1>
<PRE CLASS="syntax">単語TokenListTokensHandleFromDWord(<EM>エ</EM>);dワード<EM>エ</EM>;をクリックし</PRE>
<P>このルーチンは、によって返された値からMemHandleを抽出します。<CODE><A HREF="../../CRef/Routines/R_9b.htm#IX_TokenListTokens()">TokenListTokens()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_9b.htm_IX_TokenLoadMonikerBlock()"></A>
        <H1 CLASS="refHeading">TokenLoadMonikerBlock()</H1>
<PRE CLASS="syntax">ブーリアンTokenLoadMonikerBlock(dword tokenChars、/*トークンの4文字*/ManufacturerID ManufacturerID、/*トークンのManufacturerID*/displayType displayType、/*トークンの表示タイプ*/VisMonikerSearchFlags searchFlags、/*トークンを検索するためのフラグ*/word*blockSize、/*返されたブロックサイズ*/MemHandle*blockHandle);/*返されたブロックハンドル*/</PRE>
<P>このルーチンは、指定されたトークンのモニカをロードし、モニカ用の新しいグローバルメモリブロックを割り当てます。 返されるブール値は次のようになります。<CODE>偽の</CODE>もし名前が見つかったら<CODE>真</CODE>そうでなければ。 名前に関する情報は<CODE>ブロックサイズ(blockSize)</CODE>(新しく割り当てられたブロックのサイズ)と<CODE>blockHandle(ブロックハンドル)</CODE>(新しいブロックのハンドル)。 モニカが見つからない場合、両方のリターンポインタはNULLになり、ブロックは割り当てられません。</P>
<P>このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークンデータベースエントリを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdワードを作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
<DT><CODE>表示タイプ</DT><DD></CODE>の値<CODE>表示タイプ</CODE>ディスプレイのサイズを示します(主に、小さな画面のデバイスを示すために使用されます)。</DD>
<DT><CODE>検索フラグ</DT><DD></CODE>の記録<CODE>VisMonikerSearchFlags</CODE>どのタイプのモニカが要求されているかを示します。</DD>
<DT>
          <CODE>ブロックサイズ(blockSize)</CODE>
        </DT><DD>新しいブロックのサイズが返されるワードへのポインタ。</DD>
<DT><CODE>blockHandle(ブロックハンドル)</DT><DD></CODE>新しいブロックのハンドルが返されるハンドルへのポインタ。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_9c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_9c.htm_IX_TokenLoadMonikerBuffer()"></A>
        <H1 CLASS="refHeading">TokenLoadMonikerBuffer()</H1>
<PRE CLASS="syntax">ブールTokenLoadMonikerBuffer(dword tokenChars、/*トークンの4文字*/ManufacturerID ManufacturerID、/*トークンのManufacturerID*/displayType displayType、/*トークンの表示タイプ*/VisMonikerSearchFlags searchFlags、/*トークンを検索するためのフラグ*/void*buffer、/*トークンのバッファへのポインタ*/word bufSize、/*渡されたバッファのサイズ*/word*bytesReturned);/*返されたバイト数*/</PRE>
<P>このルーチンは、指定されたトークンのモニカを指定されたバッファにロードします。 戻り値は次のようになります。<CODE>偽の</CODE>もし名前が見つかったら<CODE>真</CODE>そうでなければ。 返されるモニカのサイズは<CODE>bytesReturned</CODE>パラメータを指定します。</P>
<P>このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークンデータベースエントリを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdワードを作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
<DT><CODE>表示タイプ</DT><DD></CODE>の値<CODE>表示タイプ</CODE>ディスプレイのサイズを示します(主に、小さな画面のデバイスを示すために使用されます)。</DD>
<DT><CODE>検索フラグ</DT><DD></CODE>の記録<CODE>VisMonikerSearchFlags</CODE>どのタイプのモニカが要求されているかを示します。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>モニカがコピーされるロックされたバッファまたは固定バッファへのポインタ。</DD>
<DT>
          <CODE>bufSize/ファイルサイズ</CODE>
        </DT><DD>渡されたバッファのサイズ。また、返される可能性のあるモニカの最大サイズ。</DD>
<DT><CODE>bytesReturned</DT><DD></CODE>バッファに実際に返されたモニカのサイズ。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9c.htm_IX_TokenLoadMonikerChunk()"></A>
        <H1 CLASS="refHeading">TokenLoadMonikerChunk()</H1>
<PRE CLASS="syntax">ブーリアンTokenLoadMonikerChunk(dword tokenChars、/*トークンの4文字*/manufacturerID manufacturerID、/*トークンのmanufacturerID*/displayType displayType、/*トークンの表示タイプ*/VisMonikerSearchFlags searchFlags、/*トークンを検索するためのフラグ*/MemHandle lmemBlock、/*新しいチャンクのロックされたブロック*/word*chunkSize、/*返された新しいチャンクサイズ*/chunkHandle*chunkHandle);/*返された新しいチャンクハンドル*/</PRE>
<P>このルーチンは、指定されたトークンのモニカをロードし、モニカ用のローカルメモリブロックに新しいチャンクを割り当てます。 返されるエラーフラグは次のようになります。<CODE>真</CODE>名前が見つからない場合は<CODE>偽の</CODE>そうでなければ。</P>
<P>このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークンデータベースエントリを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdワードを作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
<DT><CODE>表示タイプ</DT><DD></CODE>の値<CODE>表示タイプ</CODE>ディスプレイのサイズを示します(主に、小さな画面のデバイスを示すために使用されます)。</DD>
<DT><CODE>検索フラグ</DT><DD></CODE>の記録<CODE>VisMonikerSearchFlags</CODE>どのタイプのモニカが要求されているかを示します。</DD>
<DT>
          <CODE>lmemBlock</CODE>
        </DT><DD>新しいチャンクが割り当てられるローカルメモリブロックのMemHandle。 ブロックがロックされている場合は、このルーチンを呼び出した後にグローバルハンドルの参照を解除する必要があります。</DD>
<DT>
          <CODE>チャンクサイズ(chunkSize)</CODE>
        </DT><DD>割り当てられたチャンクのサイズが返されるワードへのポインタ。</DD>
<DT><CODE>chunkhandle</DT><DD></CODE>新たに割り当てられたチャンクのハンドルが返されるチャンクハンドルへのポインタ。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、渡されたブロック内のチャンクを移動できるため、ブロック内の任意のチャンクへのポインタが無効になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9c.htm_IX_TokenLoadTokenBlock()"></A>
        <H1 CLASS="refHeading">TokenLoadTokenBlock()</H1>
<PRE CLASS="syntax">ブーリアンTokenLoadTokenBlock(dword tokenChars, /*トークンの4文字*/ManufacturerID ManufacturerID,/*トークンのManufacturerID*/word*blockSize, /*返された新しいブロックのサイズ*/MemHandle*blockHandle);/*返されたブロックのハンドル*/</PRE>
<P>このルーチンは、指定されたトークンの<CODE>TokenEntry</CODE>構造体を新たに割り当てられたグローバルメモリブロックに変換する。 トークンが見つからない場合、返されるエラーフラグは次のようになります<CODE>真</CODE>;それ以外の場合は<CODE>偽の</CODE>ボタンをクリックし</P>
<P>このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークンデータベースエントリを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdワードを作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
<DT>
          <CODE>ブロックサイズ(blockSize)</CODE>
        </DT><DD>新しく割り当てられたブロックのサイズが返されるワードへのポインタ。</DD>
<DT><CODE>blockHandle(ブロックハンドル)</DT><DD></CODE>新しく割り当てられたブロックのハンドルが返されるグローバルハンドルへのポインタ。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9c.htm_IX_TokenLoadTokenBuffer()"></A>
        <H1 CLASS="refHeading">TokenLoadTokenBuffer()</H1>
<PRE CLASS="syntax">Boolean TokenLoadTokenBuffer(dword tokenChars, /*トークンの4文字*/manufacturerID manufacturerID, /*トークンの製造者ID*/TokenEntry*バッファ);/*返されるトークンのバッファ*/</PRE>
<P>このルーチンは、指定されたトークンの<CODE>TokenEntry</CODE>構造体を渡したバッファに格納する。 返されるエラーフラグは次のようになります。<CODE>真</CODE>トークンが見つからなかった場合<CODE>偽の</CODE>そうでなければ。 このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークンデータベースエントリを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdワードを作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
<DT>
          <CODE>緩衝剤</CODE>
        </DT><DD>トークン・エントリのコピー先となる、ロックされたバッファまたは固定バッファへのポインタ。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_9d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_9d.htm_IX_TokenLoadTokenChunk()"></A>
        <H1 CLASS="refHeading">TokenLoadTokenChunk()</H1>
<PRE CLASS="syntax">ブールTokenLoadTokenChunk(dword tokenChars、/*トークンの4文字*/ManufacturerID ManufacturerID、/*トークンの製造者ID*/MemHandle lmemBlock、/*チャンクのブロックのハンドル*/word*chunkSize、/*新しいチャンクの返されたサイズ*/ChunkHandle*ChunkHandle);/*返されたチャンクハンドル*/</PRE>
<P>このルーチンは、指定されたトークンの<CODE>TokenEntry</CODE>構造を新たに割り当てられたチャンクに変換します。 返されるエラーフラグは次のようになります。<CODE>真</CODE>トークンが見つからない場合は<CODE>偽の</CODE>そうでなければ。</P>
<P>このルーチンを次のように渡します。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークンデータベースエントリを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdワードを作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
<DT>
          <CODE>lmemBlock</CODE>
        </DT><DD>新しいチャンクが割り当てられるローカルメモリブロックのMemHandle。 ブロックがロックされている場合は、ルーチン呼び出しの後にこのハンドルを手動で参照解除する必要があります。</DD>
<DT>
          <CODE>チャンクサイズ</CODE>
        </DT><DD>新たに割り当てられたチャンクのサイズが返されるワードへのポインタ。</DD>
<DT><CODE>chunkHandle</DT><DD></CODE>新たに割り当てられたチャンクのハンドルが返されるチャンクハンドルへのポインタ。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、渡されたブロック内のチャンクを移動できるため、ブロック内の任意のチャンクへのポインタが無効になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9d.htm_IX_TokenLockTokenMoniker()"></A>
        <H1 CLASS="refHeading">TokenLockTokenMoniker()</H1>
<PRE CLASS="syntax">void*TokenLockTokenMoniker(tokenMonikerInfo tokenMonikerInfo);/*TokenLookupMonikerから返されたDBグループおよび項目番号*()*/</PRE>
<P>このルーチンは、描画されるようにトークンのモニカをロックします。モニカ情報を含むロックされたチャンクへのポインタを返します。 によって返された構造体を<CODE><A HREF="../../CRef/Routines/R_9d.htm#IX_TokenLookupMoniker()">TokenLookupMoniker()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>次のことを確認してください。</STRONG>ニックネームのロックを解除する<CODE><A HREF="../../CRef/Routines/R_9d.htm#IX_TokenUnlockTokenMoniker()">TokenUnlockTokenMoniker()</A></CODE>の順にクリックします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9d.htm_IX_TokenLookupMoniker()"></A>
        <H1 CLASS="refHeading">TokenLookupMoniker()</H1>
<PRE CLASS="syntax">ブールTokenLookupMoniker(dword tokenChars、/*トークンの4文字*/ManufacturerID ManufacturerID、/*トークンのManufacturerID*/displayType displayType、/*トークンの表示タイプ*/VisMonikerSearchFlags searchFlags、/*トークンを検索するためのフラグ*/tokenMonikerInfo*tokenMonikerInfo);/*トークンのDBグループと項目*/</PRE>
<P>このルーチンは、トークンの表示タイプとその他の属性も指定して、指定されたトークンの特定のモニカへのポインタを検索して取得します。 次のものを渡します。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークン・データベース内でこのモニカまたはモニカ・リストを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdword値を作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
<DT><CODE>表示タイプ</DT><DD></CODE>の値<CODE>表示タイプ</CODE>ディスプレイのサイズを示します(主に、小さな画面のデバイスを示すために使用されます)。</DD>
<DT><CODE>検索フラグ</DT><DD></CODE>の記録<CODE>VisMonikerSearchFlags</CODE>どのタイプのモニカが要求されているかを示します。</DD>
<DT><CODE>tokenDBItem</DT><DD></CODE>空のへのポインタ<CODE>TokenMonikerInfo</CODE>この構造体では、トークンのグループ番号と項目番号が返されます。</DD>
</DL>
<P>戻り値はエラーフラグです。<CODE>真</CODE>トークン・データベースで項目が見つからなかった場合<CODE>偽の</CODE>そうでなければ。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9d.htm_IX_TokenOpenLocalTokenDB()"></A>
        <H1 CLASS="refHeading">TokenOpenLocalTokenDB()</H1>
<PRE CLASS="syntax">word TokenOpenLocalTokenDB()</PRE>
<P>このルーチンは、ローカルトークンデータベースを開きます。成功した場合は0を返し、失敗した場合は<CODE>VMStatus</CODE>失敗時のエラーコード。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9d.htm_IX_TokenRemoveToken()"></A>
        <H1 CLASS="refHeading">TokenRemoveToken</H1>
<PRE CLASS="syntax">ブーリアンTokenRemoveToken(dワードtokenChars、/*トークンの4文字*/manufacturerID manufacturerID、/*トークンの製造者ID*/</PRE>
<P>このルーチンは、指定されたトークンとそのモニカ・リストをトークン・データベースから削除します。トークンが見つからなかった場合は、次のエラー・フラグを戻します。<CODE>真</CODE>;それ以外の場合は<CODE>偽の</CODE>次のものを渡します。</P>
<DL>
<DT>
          <CODE>tokenChars</CODE>
        </DT><DD>トークン・データベース内でこのモニカまたはモニカ・リストを識別する4つのトークン文字。 マクロTOKEN_CHARSを使用して、4つの文字からこのdword値を作成します。</DD>
<DT><CODE>製造者ID</DT><DD></CODE>トークンデータベースエントリを担当する製造元の製造元ID番号。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9d.htm_IX_TokenUnlockTokenMoniker()"></A>
        <H1 CLASS="refHeading">TokenUnlockTokenMoniker()</H1>
<PRE CLASS="syntax">void TokenUnlockTokenMoniker(void*moniker)</PRE>
<P>このルーチンは、ロックされていたモニカのロックを解除します。<CODE><A HREF="../../CRef/Routines/R_9d.htm#IX_TokenLockTokenMoniker()">TokenLockTokenMoniker()</A></CODE>ロックルーチンから返される、ロックされたモニカへのポインタを渡します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">トークン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9d.htm_IX_ClipboardItemFormatID:TypeFromFormatID() macro"></A>
          <A NAME="R_9d.htm_IX_TypeFromFormatID()"></A>
        <H1 CLASS="refHeading">TypeFromFormatID()</H1>
<PRE CLASS="syntax">word TypeFromFormatID(id);ClipboardItemFormatID id;</PRE>
<P>このマクロは、ワードサイズのフォーマットID(<CODE>ClipboardItemFormat</CODE>)から<CODE>クリップボード形式ID</CODE>引数を指定します。</P>
</DIV>
<HR>
          <A NAME="R_9e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_9e.htm_IX_UserAllocObjBlock"></A>
        <H1 CLASS="refHeading">UserAllocObjBlock</H1>
<PRE CLASS="syntax">MemHandle UserAllocObjBlock(ThreadHandle ThreadHandle)</PRE>
<P>このルーチンは、UIオブジェクトを保持するために使用するメモリブロックをヒープに割り当てます。 この関数はブロックのハンドルを返します。 1つの引数が渡されます。</P>
<DL>
<DT>
          <EM>threadHandle</EM>
        </DT><DD>ブロックを管理するスレッドのハンドル。 現在のスレッドを使用するには、0を渡します。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ui.goh(英語の可能性</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9e.htm_IX_execOnStartup INI file field:UserAddAutoExec()"></A>
          <A NAME="R_9e.htm_IX_UserAddAutoExec()"></A>
        <H1 CLASS="refHeading">UserAddAutoExec()</H1>
<PRE CLASS="syntax">void UserAddAutoExec(const char*appName);</PRE>
<P>このルーチンは、ロード時にUIによって自動的に起動されるアプリケーション(Welcomeなど)のリストにアプリケーションを追加します。 アプリケーション名は、GEOS.INIファイルの適切な場所に追加されます。 1つの引数が渡されます。</P>
<DL>
<DT>
          <CODE>アプリケーション名</CODE>
        </DT><DD>これは、アプリケーションの名前を含むヌル終了文字列へのポインタです。 アプリケーションは、SP_APPLICATIONまたはSP_SYS_APPLICATIONに存在する必要があります。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ui.goh(英語の可能性</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9e.htm_IX_UserCreateDialog()"></A>
          <A NAME="R_9e.htm_IX_Dialog boxes:UserCreateDialog()"></A>
        <H1 CLASS="refHeading">UserCreateDialog()</H1>
<PRE CLASS="syntax">optr UserCreateDialog(optr dialogBox);</PRE>
<P>このルーチンは、テンプレート・ダイアログ・ボックスを複製し、そのダイアログ・ボックスをアプリケーション・オブジェクトに付加して、完全にGS_USABLEに設定します。<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserDoDialog()">UserDoDialog()</A></CODE>このような方法で作成されたダイアログボックスは<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserDestroyDialog()">UserDestroyDialog()</A></CODE>必要とされなくなったときです</P>
<DL>
<DT>
          <EM>ダイアログボックス</EM>
        </DT><DD>[テンプレートへのオプション]ダイアログボックス(テンプレートオブジェクトブロック内) ブロックは共有可能で読み取り専用でなければならず、このルーチンで呼び出される最上位のツリーは汎用GenInteractionにリンクされていてはなりません。 戻されるoptrは、作成された、完全に使用可能なダイアログ・ボックスです。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserDestroyDialog()">UserDestroyDialog()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_9e.htm_IX_InkDestinationInfo:UserCreateInkDestinationInfo()"></A>
          <A NAME="R_9e.htm_IX_UserCreateInkDestinationInfo()"></A>
          <A NAME="R_9e.htm_IX_GestureCallback() prototype"></A>
        <H1 CLASS="refHeading">UserCreateInkDestinationInfo()</H1>
<PRE CLASS="syntax">MemHandle UserCreateInkDestinationInfo(optr dest、GStateHandle gs、word brushSize、GestureCallback*コールバック);</PRE>
<P>このルーチンは<CODE>InkDestinationInfo</CODE>MSG_META_QUERY_IF_PRESS_IS_INKで返される構造体。 コールバックルーチンは、_pascalと宣言する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ui.goh(英語の可能性</STRONG>
        </P>
<P CLASS="refField">
          <STRONG>構造:</STRONG>
        </P>
<PRE CLASS="syntax">typedef Boolean_pascal GestureCallback(Point*arrayOfInkPoints, word numPoints, word numStrokes);</PRE>
</DIV>
<DIV>
          <A NAME="R_9e.htm_IX_UserDestroyDialog()"></A>
        <H1 CLASS="refHeading">UserDestroyDialog()</H1>
<PRE CLASS="syntax">void UserDestroyDialog(optr dialogBox);</PRE>
<P>このルーチンは、渡されたダイアログボックスを破棄します。このダイアログボックスは通常<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserCreateDialog()">UserCreateDialog()</A></CODE>このルーチンは、単一のブロックを占有するダイアログボックスを破棄するためにのみ使用できます。また、ブロックには、破棄するダイアログボックス以外のものを保持しないようにする必要があります。 このため、このルーチンを使用するのは<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserCreateDialog()">UserCreateDialog()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserCreateDialog()">UserCreateDialog()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_9e.htm_IX_UserDoDialog()"></A>
          <A NAME="R_9e.htm_IX_Dialog boxes:UserDoDialog()"></A>
          <A NAME="R_9e.htm_IX_InteractionCommand"></A>
          <A NAME="R_9e.htm_IX_IC_&ldots;"></A>
        <H1 CLASS="refHeading">UserDoDialog()</H1>
<PRE CLASS="syntax">InteractionCommand UserDoDialog(optr dialogBox);</PRE>
<P><CODE>UserDoDialog()</CODE>は、事前にインスタンス化されたダイアログボックスを画面上に表示し、ユーザがダイアログに応答するまで呼び出しスレッドをブロックします。 GIA_INITIATED_VIA_USER_DO_DIALOGとGIA_MODALの両方が設定されているGIV_DIALOGインタラクションのoptrを渡す必要があります。</P>
<P>このルーチンは<CODE>InteractionCommand</CODE>ユーザーによって選択された特定の応答トリガーの この<CODE>InteractionCommand</CODE>は、事前定義されたタイプ(IC_YESなど)か、IC_CUSTOM_STARTを使用して定義されたカスタムタイプのいずれかです。</P>
<P>事前に定義された<CODE>InteractionCommand</CODE>sは以下のとおりである:</P>
<PRE>IC_NULL IC_DISMISS IC_APPLY IC_RESET IC_OK IC_YES IC_NO IC_STOP IC_EXIT IC_HELP IC_INTERACTION_COMPLETE(IC_NULL IC_DISMISS IC_APPLY IC_RESET IC_OK IC_YES IC_NO IC_STOP IC_EXIT IC_HELP IC_</PRE>
<P>このルーチンは、ユーザーが応答を入力する前にシステムのシャットダウンによってダイアログが終了した場合に、IC_NULLを返すことがあります。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>このルーチンは、ダイアログボックスがMSG_GEN_GUP_INTERACTION_COMMANDを受け取るまで、呼び出しスレッドをブロックします。 アプリケーション・スレッドはブロックされているため、このメッセージを送信したり、応答トリガーからのメッセージを処理したりすることはできません。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_9f.htm#IX_UserStandardDialog()">UserStandardDialog()</A></CODE><CODE><A HREF="../../CRef/Routines/R_9f.htm#IX_UserStandardDialogOptr()">UserStandardDialogOptr()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_9e.htm_IX_UserGetInterfaceLevel()"></A>
          <A NAME="R_9e.htm_IX_UIInterfaceLevel"></A>
          <A NAME="R_9e.htm_IX_UIIL_&ldots;"></A>
        <H1 CLASS="refHeading">UserGetInterfaceLevel()</H1>
<PRE CLASS="syntax">UIInterfaceLevel UserGetInterfaceLevel(void)</PRE>
<P>このルーチンは現在の<CODE>UIInterfaceLevel</CODE>これは、ワードサイズの列挙型です。 次の値があります。</P>
<PRE>UIIL_初心者UIIL_BEGINNING_INTERMEDIATE UIIL_ADVANCED_INTERMEDIATE UIIL_ADVANCED UIIL_GURU</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ui.goh(英語の可能性</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9e.htm_IX_UserLoadApplication()"></A>
        <H1 CLASS="refHeading">UserLoadApplication()</H1>
<PRE CLASS="syntax">extern GeodeHandle UserLoadApplication(AppLaunchFlags alf, メッセージattachMethod, MemHandle appLaunchBlock, char*ファイル名,StandardPath sPath, GeodeLoadError*err);</PRE>
<P>アプリケーションをロードします。 渡されたファイル名でGeodeLoadを試行する前に、標準アプリケーションディレクトリに変更します。 起動されるファイル名を<CODE>AppLaunchBlock</CODE>したがって、このアプリケーション・インスタンスをリストアするために必要な情報は、必要に応じて後で提供されます。</P>
</DIV>
<HR>
          <A NAME="R_9f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_9f.htm_IX_UserRemoveAutoExec()"></A>
          <A NAME="R_9f.htm_IX_execOnStartup INI file field:UserRemoveAutoExec()"></A>
        <H1 CLASS="refHeading">UserRemoveAutoExec()</H1>
<PRE CLASS="syntax">void UserRemoveAutoExec(const char*appName);</PRE>
<P>このルーチンは、起動時に起動されるアプリケーションのリストからアプリケーションを削除します。 1つの引数が渡されます。</P>
<DL>
<DT>
          <CODE>アプリケーション名</CODE>
        </DT><DD>これは、アプリケーションの名前を含むヌル終了文字列へのポインタです。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ui.goh(英語の可能性</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_9f.htm_IX_UserStandardDialog()"></A>
          <A NAME="R_9f.htm_IX_Dialog boxes:UserStandardDialog()"></A>
        <H1 CLASS="refHeading"><A NAME="R_9f.htm_37754"></A>UserStandardDialog()</H1>
<PRE CLASS="syntax">word UserStandardDialog(char*helpContext, char*customTriggers, char*arg2, char*arg1, char*文字列,CustomDialogBoxFlags dialogFlags);</PRE>
<P><CODE>UserStandardDialog()</CODE>は、カスタムダイアログボックス、または定義済みの標準ダイアログボックスのいずれかを作成して表示します。</P>
<P>ほとんどの場合、このルーチンを使用して、標準化されたダイアログボックスに準拠するカスタムダイアログボックスを作成します。 この場合は<CODE>CustomDialogType</CODE>ルーチンの最後の引数としてSDBT_CUSTOMの カスタムダイアログボックスを作成するには、他のパラメータを指定する必要があります。</P>
<P>代わりに、事前に定義された<CODE>CustomDialogType</CODE>その型をこのルーチンの最後の引数として渡す必要があります。 これらの標準タイプの中には、文字列パラメータを渡す必要があるものがあります。 その他の引数はNULLとして渡す必要があります。</P>
<P>カスタムダイアログボックスの場合は<CODE>CustomDialogType</CODE>(CDT_WARNING、CDT_NOTIFICATION、CDT_QUESTION、またはCDT_ERROR)。 これにより、ダイアログボックス内に表示する適切なアイコン記号が選択されます。 (例えば、CDT_WARNINGダイアログには大きな感嘆符のグリフが含まれているかもしれません。 この値を渡すには、必ずCDBF_DIALOG_TYPE_OFFSETを使用してください。 例:</P>
<PRE>(GIT_AFFIRMATION&lt;&lt;CDBF_INTERACTION_TYPE_OFFSET)(CDT_WARNING CDBF_DIALOG_TYPE_OFFSET)</PRE>
<P>また、有効な<CODE>GenInteractionType</CODE>ほとんどの場合、これはGIT_NOTIFICATION、GIT_AFFIRM、またはGIT_MULTIPLE_RESPONSEのいずれかになります。 この値を渡すには、必ずCDBF_INTERACTION_TYPE_OFFSETを使用してください。 例:</P>
<PRE>(GIT_AFFIRMATION&lt;&lt;CDBF_INTERACTION_TYPE_OFFSET)(CDT_WARNING CDBF_DIALOG_TYPE_OFFSET)</PRE>
<P>ルーチンaも渡す<CODE>ストリング</CODE>ユーザーに表示します。 この<CODE>ストリング</CODE>は、テキストベースまたはグラフィックベースのいずれかです。 の<CODE>引数1</CODE>および<CODE>引数2</CODE>文字列は、この文字列と一緒に使用できます。<CODE>ストリング</CODE>には、任意のctrl-Aまたはctrl-B文字(それぞれASCII値1と2)が含まれ、その後に<CODE>引数1</CODE>または<CODE>引数2</CODE>その場所に挿入されます。</P>
<P>次の場合<CODE>CustomDialogType</CODE>がGIT_MULTIPLE_RESPONSEの場合、いくつかのトリガパラメータを持つResponse Trigger Tableも設定する必要があります。 customTrigger引数は、これらのパラメータを含む構造体へのポインタである必要があります。 構造の種類は、トリガの数によって異なります。<CODE>標準ダイアログ1(ResponseTriggerTable)</CODE><CODE>標準ダイアログ2(ResponseTriggerTable)</CODE><CODE>標準ダイアログ3(ResponseTriggerTable)</CODE><CODE>標準ダイアログ4(ResponseTriggerTable)</CODE>いずれの場合も、トリガーの数、各トリガーの名前と応答値を指定するフィールドに入力する必要があります。</P>
<P>の<CODE>ヘルプコンテキスト</CODE>値はヘルプシステムによって使用されます。これは、ユーザがこのダイアログでヘルプを要求したときに移動するgeodeのヘルプのページの「コンテキスト」名です。 ヌルポインタは、デフォルトのヘルプコンテキストを使用する必要があることを示します。</P>
<P>このルーチンは、InteractionCommandの値を返します。 対話がシステムによって終了された場合(システムのシャットダウンなど)、IC_NULLになります。</P>
</DIV>
<DIV>
          <A NAME="R_9f.htm_IX_UserStandardDialogOptr()"></A>
        <H1 CLASS="refHeading">UserStandardDialogOptr()</H1>
<PRE CLASS="syntax">word UserStandardDialogOptr(optr helpContext, optr customTriggers, optr arg2, optr arg1, optr string CustomDialogBoxFlags dialogFlags);</PRE>
<P><CODE>UserStandardDialogOptr()</CODE>と同じ機能を提供します。<CODE>UserStandardDialog()</CODE>ただし、fptrsの代わりに文字列へのoptrsと文字列パラメータが渡されます。 これは、リソースブロック内のローカライズされた文字列に便利です。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_9f.htm#IX_UserStandardDialog()">UserStandardDialog()</A></CODE><CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserDoDialog()">UserDoDialog()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_9f.htm_IX_UserStandardSound()"></A>
          <A NAME="R_9f.htm_IX_StandardSoundType"></A>
          <A NAME="R_9f.htm_IX_SST_&ldots;  (StandardSoundType type)"></A>
        <H1 CLASS="refHeading">UserStandardSound()</H1>
<PRE CLASS="syntax">ワードUserStandardSound(StandardSoundTypeの種類、.)</PRE>
<P>このルーチンは、音符の単純なシーケンスを再生します。 標準のシステムサウンド、単一のカスタムトーン、または一連のトーンを再生するために使用できます。</P>
<P>このルーチンは可変数の引数を取ります。 最初の引数は<CODE>StandardSoundType</CODE>列挙型。 この引数は、再生されるトーンの種類を指定します。 に応じて<CODE>StandardSoundType</CODE>が渡された場合、0個、1個、または2個の追加引数が必要になることがあります。<CODE>StandardSoundType</CODE>には、次のメンバが含まれています。</P>
<DL>
<DT>SST_エラー</DT><DD>これは、「エラー」ダイアログが表示されたときに再生されるサウンドです。 これ以上の引数は必要ありません。</DD>
<DT>SST_警告</DT><DD>これは一般的な警報音です。 これ以上の引数は必要ありません。</DD>
<DT>SST_NOTIFY(通知)</DT><DD>これは一般的な通知音です。 これ以上の引数は必要ありません。</DD>
<DT>SST_NO_入力</DT><DD>これは、ユーザの入力がどこにも行かないとき(たとえば、モーダルダイアログボックスの外でマウスをクリックしたとき)に再生されるサウンドです。</DD>
<DT>SST_キー_クリック</DT><DD>これは、キーボードが押されたとき、またはユーザーがフローティングキーボードをクリックしたときに生成されるサウンドです。 これ以上の引数は必要ありません。</DD>
<DT>SST_カスタム_サウンド</DT><DD>カスタムサンプリングしたサウンドを再生します。 これにはもう1つの引数、つまり再生されるサウンドのメモリハンドルが必要です。</DD>
<DT>SST_CUSTOM_BUFFER(カスタムバッファ)</DT><DD>インストゥルメンタルサウンドのカスタムバッファを再生します。 これにはもう1つの引数、サウンドバッファを含むメモリブロックへのポインタが必要です。 このバッファを再生するために使用される「テンポ」値は、30秒ごとに1ティックであり、おそらく他の方法で予想されるよりもはるかに高速であることに注意してください。</DD>
<DT>SST_CUSTOM_NOTE[カスタム注記]</DT><DD>この引数を渡すと、1つのカスタムノートを再生できます。 もう1つ引数を指定する必要があります。<CODE><A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicNote()">SoundAllocMusicNote()</A></CODE>)をクリックします。</DD>
</DL>
<P>この関数は、ワード長のトークン値を返します。 この値は<A NAME="R_9f.htm_#IX_UserStopStandardSound()">UserStopStandardSound()</A>ルーチン。</DIV>

<DIV>
          <A NAME="R_9f.htm_IX_UserStopStandardSound()"></A>
        <H1 CLASS="refHeading">UserStopStandardSound()</H1>
<PRE CLASS="syntax">ワードUserStandardSound(StandardSoundTypeタイプ、ワードcountID)</PRE>
<P>このルーチンは、によって開始されたサウンドを停止します<A HREF="#IX_UserStandardSound()">UserStandardSound</A>ボタンをクリックし</P>
<P>停止するサウンドは、そのタイプと<A HREF="#IX_UserStandardSound()">UserStandardSound</A>ボタンをクリックし</P>

<P>この関数はSST_CUSTOM_.を停止しません。 サウンド。</P>
</DIV>


<HR>
          <A NAME="R_a0.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_a0.htm_IX_UtilAsciiToHex32()"></A>
          <A NAME="R_a0.htm_IX_Math:UtilAsciiToHex32()"></A>
          <A NAME="R_a0.htm_IX_UtilAsciiToHexError"></A>
          <A NAME="R_a0.htm_IX_UATH_&ldots;"></A>
        <H1 CLASS="refHeading">UtilAsciiToHex32()</H1>
<PRE CLASS="syntax">Boolean UtilAsciiToHex32(const char*文字列,dword*値);</PRE>
<P>このルーチンは、NULL終端されたASCII文字列を32ビットの整数に変換します。 文字列は、負の数を示すハイフンで始めることができます。 それとは別に、文字列にはヌル終端まで数字しか含まれない場合があります。 空白を含めることはできません。</P>
<P>ルーチンが成功した場合は、次のように戻ります。<EM>偽の</EM>と等価な符号付きロング整数を<EM>*値</EM>失敗した場合は<EM>真</EM>のメンバーを作成します。<CODE>UtilAsciiToHexError</CODE>列挙型から<EM>*値</EM>この型には、次のメンバーが含まれます:</P>
<DL>
<DT>UATH_NON_NUMERIC_DIGIT_IN_STRING■サービス名の場合■</DT><DD>この文字列には、末尾のNULLの前に数字以外の文字が含まれていました(先頭のハイフン以外)。</DD>
<DT>UATH_CONVERT_OVERFLOW(オーバーフロー)</DT><DD>文字列は、符号付き32ビット整数として表される数値を指定しました。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">system.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a0.htm_IX_Math:UtilHex32ToAscii()"></A>
          <A NAME="R_a0.htm_IX_UtilHex32ToAscii()"></A>
        <H1 CLASS="refHeading">UtilHex32ToAscii()</H1>
<PRE CLASS="syntax">word UtilHex32ToAscii(char*バッファ,dword値,UtilHexToAsciiFlagsフラグ);</PRE>
<P>このルーチンは、32ビットの符号なし整数をASCII表現に変換し、指定されたバッファに書き込みます。 文字列の長さを返します(ヌル終端がある場合は、ヌル終端をカウントしません)。 このルーチンには、次の引数が渡されます。</P>
<DL>
<DT>
          <EM>緩衝剤</EM>
        </DT><DD>これは文字バッファへのポインタです。 バッファは、最大の文字列を格納するのに十分な長さである必要があります。つまり、文字には10バイト、(必要に応じて)末尾のヌルには1バイトが必要です。</DD>
<DT>
          <CODE>値(value)</CODE>
        </DT><DD>これはASCIIに変換する値です。</DD>
<DT>
          <CODE>フラグふらぐ</CODE>
        </DT><DD>これは<CODE>UtilHexToAscii</CODE>フラグ。 次のフラグを使用できます。</DD>
<DT>UHTAF_INCLUDE_LEADING_ZEROS</DT><DD>先頭にゼロを追加して、合計10文字の長さにします。</DD>
<DT>UHTAF_NULL_TERMINATE</DT><DD>文字列の最後にヌルを追加します。 このフラグが設定されている場合、バッファの長さは少なくとも11バイトでなければなりません。 クリアされている場合、バッファの長さは10バイトになります。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">system.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a0.htm_IX_VarDataFlagsPtr() macro"></A>
        <H1 CLASS="refHeading">VarDataFlagsPtr()</H1>
<PRE CLASS="syntax">VarDataFlags VarDataFlagsPtr(void*ptr);</PRE>
<P>このマクロは、変数データ型の追加データへのポインタが与えられたときに、その型のフラグを取得します。 フラグは<CODE>VarDataFlags</CODE>レコード。 フラグVDF_EXTRA_DATAおよび/またはVDF_SAVE_TO_STATEのみが返されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">object.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>へのポインタを渡す必要があります<EM>始め</EM>vardataエントリの余分なデータ領域の</P>
</DIV>
<DIV>
          <A NAME="R_a0.htm_IX_VarDataSizePtr() macro"></A>
        <H1 CLASS="refHeading">VarDataSizePtr()</H1>
<PRE CLASS="syntax">word VarDataSizePtr(void*ptr);と入力します。</PRE>
<P>このマクロは、型の追加データへのポインタが与えられたときに、変数データエントリのサイズを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">object.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>へのポインタを渡す必要があります<EM>始め</EM>vardataエントリの余分なデータ領域の</P>
</DIV>
<DIV>
          <A NAME="R_a0.htm_IX_VarDataTypePtr() macro"></A>
        <H1 CLASS="refHeading">VarDataTypePtr()</H1>
<PRE CLASS="syntax">word VarDataTypePtr(void*ptr);と入力します。</PRE>
<P>このマクロは、エントリの追加データへのポインタが与えられたときに、変数データエントリの型を取得します。 型は<CODE>VarDataFlags</CODE>レコード。 VDF_TYPEセクションの外側にあるすべてのフラグがクリアされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">object.hと入力します。</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>へのポインタを渡す必要があります<EM>始め</EM>vardataエントリの余分なデータ領域の</P>
</DIV>

<DIV>
          <A NAME="R_a0.htm_IX_VirtualSerialClose()"></A>
        <H1 CLASS="refHeading">VirtualSerialClose()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSerialClose(ボイド)</PRE>
<P>すべての発信データがリモートユニットに送信されるまで待機してから、着信データバッファをフラッシュし、リモートユニットへの接続を閉じます。</P>
<P>データが正常に書き込まれた場合は、VS_OKを返します。</P>
<P>ストリームがすでに閉じられている場合は、VS_CLOSEDを返します。</P>
<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>これは低レベルのルーチンであり<CODE>ModemClose()</CODE>以下の場合を除き、Virtual Serial関数を呼び出さないでください。<CODE>VirtualSerialOpen()</CODE>関数を呼び出した後</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialOpen()">VirtualSerialOpen()</A></CODE>ボタンをクリックし</P>
</DIV>

<DIV>
          <A NAME="R_a0.htm_IX_VirtualSerialFlush()"></A>
        <H1 CLASS="refHeading">VirtualSerialFlush()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSerialFlush(word flushMode);</PRE>
<P>着信バッファからデータをフラッシュします。 の<EM>フラッシュモード(flushMode)</EM>操作方向を設定します。 次の場合があります。<DL>
<DT>ストリーム読取り<DD>着信データバッファをフラッシュします。<DT>ストリーム書き込み<DD>無視されます。<DT>ストリーム_両方<DD>STREAM_READと同じです。</DL>
<P>ストリームが正常にフラッシュされた場合は、VS_OKを返します。<P>ストリームが開いていない場合は、VS_CLOSEDを返します。</P>
<P CLASS="refField">
          <STRONG>
        </P>次を含む:<STRONG CLASS="fileName">vserlib.h</STRONG></P>
</DIV>

<DIV>
          <A NAME="R_a0.htm_IX_VirtualSerialOpen()"></A>
        <H1 CLASS="refHeading">VirtualSerialOpen()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSerialOpen(VSOpenFlags stream_open_mode, /*ストリームがビジーなら失敗するか待つ*/word input_buffer_size, /*#of bytes 1.4096 of input buffer*/word output_buffer_size, /*無視する。 自動的に4352バイトに設定されます。 */word timeout);/*ストリームがビジーの場合に待機して再試行するティック数。*/</PRE>
<P>このルーチンにより、クライアントは電話機へのストリームを開くことができます。 仮想電話データリソースが使用中であるかどうか、および<EM>ストリームオープンモード</EM>がSOF_NOBLOCKに設定されている場合、関数は即座に失敗する。<EM>ストリームオープンモード</EM>がSOF_TIMEOUTに設定されている場合、関数は成功するまで再試行する。<EM>タイムアウト(timeout)</EM>ティック数(1.32768)が経過します。<EM>入力バッファサイズ</EM>は、入力バッファのサイズ(バイト1～4096)です。 の<EM>出力バッファサイズ</EM>出力バッファが4352バイトに設定されているため、は無視されます。<P>成功した場合はVS_OKを返します。</P>
<P>VPデータリソースが既に使用されている場合は、VS_DATA_RESOURCE_RESERVEDを返します。<P>ストリームが別のクライアントによってすでに開かれている場合は、VS_STREAM_ALREADY_OPENを返します。<P>ストリームバッファにメモリを割り当てられない場合は、VS_CANNOT_ALLOCを返します。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>これは低レベルのルーチンであり<CODE>ModemOpen()</CODE>このルーチンは、クライアントが他の仮想シリアル関数の使用を開始する前に、VS_OKを返す必要があります。 出力データはVirtualSerialライブラリにバッファされず、呼び出し元のクライアントのバッファから直接送信されます。</P>
</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialClose()">VirtualSerialClose()</A></CODE>ボタンをクリックし</P>
</DIV>



<DIV>
          <A NAME="R_a0.htm_IX_VirtualSerialRead()"></A>
        <H1 CLASS="refHeading">VirtualSerialRead()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSerialRead(VSBlockingMode blocking_mode, /*ブロックするかしないか*/word data_size, /*読み込まれるデータのバイト数*/byte*ptr_to_buffer, /*データを保持するバッファ*/word*bytes_read);/*実際に読み込まれるバイト数*/</PRE>
<P>着信データをバッファにコピーします。 より少ない場合<EM>データサイズ</EM>バッファ内のバイト数とSTREAM_BLOCKが<EM>ブロッキングモード</EM>、十分なデータが利用可能になるまでブロックします。<EM>データサイズ</EM>バッファ内のバイト数とSTREAM_NO_BLOCKが指定されている場合、VS_SHORT_READ_WRITEを使用してただちに戻ります。</P>
<P>データが正常に書き込まれた場合は、VS_OKを返します。</P>
<P>ストリームが開いていない場合は、VS_CLOSEDを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialReadByte()">VirtualSerialReadByte()</A></CODE>ボタンをクリックし</P>
</DIV>

<DIV>
          <A NAME="R_a0.htm_IX_VirtualSerialReadByte()"></A>
        <H1 CLASS="refHeading">VirtualSerialReadByte()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSerialReadByte(VSBlockingMode blockingMode, /*ブロックするかしないか*/byte*dataByte);/*読み出しデータを保持するバッファ*/</PRE>
     
<P>このルーチンは、ストリームから1バイトを読み込み<EM>データバイト</EM>ストリームが空で<EM>ブロッキングモード(blockingMode)</EM>がSTREAM_BLOCKに設定されている場合、ルーチンは要求が満たされるのを待つ。STREAM_NO_BLOCKが指定されている場合、ルーチンは直ちにエラーを返す。<P>データが正常に書き込まれた場合はVS_OKを返します。<EM>データバイト</EM>ボタンをクリックし</P>
<P>データが使用できず、STREAM_NO_BLOCKが指定されている場合は、VS_SHORT_READ_WRITEを返します。<P>ストリームが開いていない場合は、VS_CLOSEDを返します。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>STREAM_BLOCKモードの使用は危険です。相手側がデータを送信しない場合、この関数は永久にブロックされます。</P>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialRead()">VirtualSerialRead()</A></CODE><CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VirtualSerialWriteByte()">VirtualSerialWriteByte()</A></CODE>ボタンをクリックし</P>
</DIV>


<DIV>
          <A NAME="R_a0.htm_IX_VirtualSerialSendDTR()"></A>
        <H1 CLASS="refHeading">VirtualSerialSendDTR()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSendDTR(byte DTR_status);</PRE>
<P>Data Terminal Readyステータスをモデムに送信します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
          <CODE></CODE>
        </P>
</DIV>


<DIV>
          <A NAME="R_a0.htm_IX_VirtualSerialSetFlowControl()"></A>
        <H1 CLASS="refHeading">VirtualSerialSetFlowControl()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSerialSetFlowControl(VSFlowControl flow_control_mode);/*ソフトウェアまたはハードウェア*/</PRE>
<P>モデムとVirtualSerialライブラリ間で使用されるフロー制御方式を選択します。<EM>フロー制御モード</EM>はVSFC_SOFTWAREまたはVSFC_HARDWAREのいずれかに設定できます。</P>
<P>正常に設定された場合はVS_OKを返し、ストリームが開いていない場合はVS_CLOSEDを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
          <CODE></CODE>
        </P>
</DIV>

<HR>
          <A NAME="R_a1.htm"></A>
        <DIV>
</DIV>


<DIV>
          <A NAME="R_a1.htm_IX_VirtualSerialSetFormat()"></A>
        <H1 CLASS="refHeading">VirtualSerialSetFormat()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSetFormat(VSSerialFormat形式、/*データ形式*/VSSerialBaudボー);/*ボーレート*/</PRE>
<P>モデムのデータ形式と速度を設定します。 正常に設定された場合はVS_OKを返し、ストリームが開いていない場合はVS_CLOSEDを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
          <CODE></CODE>
        </P>
</DIV>

<DIV>
          <A NAME="R_a1.htm_IX_VirtualSerialSetNotify()"></A>
        <H1 CLASS="refHeading">VirtualSerialSetNotify()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSerialSetNotify(VSNotifyType notifyTpe、/*どのイベントをどのように受信するか*/optr destination、/*Destination object*/word method);/*Message to pass to destination object*/</PRE>
<P>このルーチンは、可能性のある関連イベントの通知者を登録します。 パラメータ<EM>notifyType</EM>は、どのイベントがオブジェクトになるかを指定するように設定されています。<EM>着側</EM>メッセージの送信<EM>方法</EM>である。</EM>notifyType</EM>1つのVSNT_、1つのVSNE_、および1つのVSNM_パラメータのORで設定する必要があります。<P>これらのパラメータのセットは次のとおりです。</P>
<DL>
<DT>
          <CODE>VSNTリーダー</CODE>
        </DT>
	<DD>通知リーダ</DD>
<DT>
          <CODE>VSNEデータ</CODE>
        </DT>
	<DD>データ/スペース使用可能通知</DD>
<DT>
          <CODE>VSNEモデム</CODE>
        </DT>
	<DD>モデムの入力信号が変化したときに通知する</DD>
<DT>
          <CODE>VSNM_なし</CODE>
        </DT>
	<DD>通知を無効にする</DD>
<DT>
          <CODE>VSNM_メッセージ</CODE>
        </DT>
	<DD>メッセージcx:dxを送信して通知する</DD>
</DL>次に例を示します。<CODE>notifyType=VSNT_READER VSNE_DATA VSNM_MESSAGE</CODE>:これにより、メッセージングを使用して利用可能なデータについてリーダーに通知されます。<P>通知が正常に登録された場合、このルーチンはVS_OKを返します。<P>通知機能がサポートされていない場合は、VS_NOT_SUPPORTEDを返します。<P>ストリームが開いていない場合は、VS_CLOSEDを返します。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>これは低レベルのルーチンであり<CODE>ModemSetRoutineDataNotify x、ModemSetMessageDataNotify x、ModemSetRoutineResponseNotify x、ModemSetMessageResponseNotify x</CODE>および<CODE>ModemSetMessageEndCallNotify()</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
          <CODE></CODE>
        </P>
</DIV>




<DIV>
          <A NAME="R_a1.htm_IX_VirtualSerialWrite()"></A>
        <H1 CLASS="refHeading">VirtualSerialWrite()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSerialWrite(VSBlockingMode blocking_mode, /*ブロックするかしないか*/word buffer_size, /*書き込むデータのバイト数*/const byte*ptr_to_buffer, /*ストリームに書き込むデータ*/word*bytes_written);/*実際に書き込まれたバイト数*/</PRE>
<P>書き込み<EM>バッファサイズ</EM>バッファからストリームへのデータのバイト数。 ストリームに十分なスペースがなく、STREAM_BLOCKが<EM>ブロッキングモード</EM>ストリームに十分な領域がなく、STREAM_NO_BLOCKが指定されていた場合、VS_SHORT_READ_WRITEを返します。</P>
<P>データが正常に書き込まれた場合は、VS_OKを返します。</P>
<P>ストリームが開いていない場合は、VS_CLOSEDを返します。</P>
<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>STREAM_BLOCKを使用するのは危険です。反対の終端がデータを読み取らない場合、ストリームは常にいっぱいになり、ルーチンは最大2分間ブロックを続けます。 2分後、ルーチンはVS_SHORT_READ_WRITEを返し、データを破棄します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
        </P>
</DIV>

<DIV>
          <A NAME="R_a1.htm_IX_VirtualSerialWriteByte()"></A>
        <H1 CLASS="refHeading">VirtualSerialWriteByte()</H1>
<PRE CLASS="syntax">VirtualSerialStatus VirtualSerialWriteByte(VSBlockingMode blockingMode, /*ブロックするかしないか.*/byte dataByte);/*書き込むデータ*/</PRE>
     
<P>このルーチンは、バイト<EM>データバイト</EM>川に流れ込みます ストリームがいっぱいで<EM>ブロッキングモード(blockingMode)</EM>がSTREAM_BLOCKに設定されている場合、ルーチンは要求が満たされるのを待つ。STREAM_NO_BLOCKが指定されている場合、ルーチンは直ちにエラーを返す。<P>データが正常に書き込まれた場合は、VS_OKを返します。</P>
<P>領域が使用可能でなく、STREAM_NO_BLOCKが指定されている場合は、VS_SHORT_READ_WRITEを返します。<P>ストリームが開いていない場合は、VS_CLOSEDを返します。<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>STREAM_BLOCKモードを使用するのは危険です。反対側がデータを読み取らない場合、ストリームは常にいっぱいになる可能性があり、この関数は最大2分間ブロックされます。 2分後、ルーチンはVS_SHORT_READ_WRITEを返し、指定されたデータを破棄します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">vserlib.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VirtualSerialWrite()">VirtualSerialWrite()</A></CODE><CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialReadByte()">VirtualSerialReadByte()</A></CODE>ボタンをクリックし</P>
</DIV>



<DIV>
          <A NAME="R_a1.htm_IX_VisObjectHandlesInkReply()"></A>
          <A NAME="R_a1.htm_IX_Ink:VisObjectHandlesInkReply()"></A>
          <A NAME="R_a1.htm_IX_Pen input:VisObjectHandlesInkReply()"></A>
        <H1 CLASS="refHeading">VisObjectHandlesInkReply()</H1>
<PRE CLASS="syntax">void VisObjectHandlesInkReply(void)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="R_a1.htm_IX_Bitmaps:VisTextGraphicCompressGraphic()"></A>
          <A NAME="R_a1.htm_IX_VisTextGraphicCompressGraphic()"></A>
        <H1 CLASS="refHeading">VisTextGraphicCompressGraphic()</H1>
<PRE CLASS="syntax">extern VMChain VisTextGraphicCompressGraphic(VisTextGraphic*グラフィック,FileHandle sourceFile, FileHandle destFile, BMFormat形式,word xRes, word yRes);</PRE>
<P>このルーチンは、ビットマップをVisTextGraphicに圧縮します。</P>
</DIV>
<DIV>
          <A NAME="R_a1.htm_IX_VMAlloc()"></A>
        <H1 CLASS="refHeading">VMAlloc()[VMAlloc]</H1>
<PRE CLASS="syntax">VMBlockHandle VMAlloc(VMFileHandleファイル、ワードサイズ、/*バイト単位のファイルサイズ*/ワードユーザID);/*ブロックに関連付けるID番号*/</PRE>
<P>このルーチンは、VMブロックを作成します。 ブロックが初期化されていません。 ブロックを使用する前に、でロックする必要があります。<CODE><A HREF="../../CRef/Routines/R_a3.htm#IX_VMLock()">VMLock()</A></CODE>ゼロバイトのサイズを渡すと、VMブロックにはVMハンドルテーブル内のエントリが与えられますが、メモリやファイル内の領域は使用されません。<CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAttach()">VMAttach()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAllocLMem()">VMAllocLMem()</A></CODE><CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAttach()">VMAttach()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_a1.htm_IX_VMAllocLMem()"></A>
        <H1 CLASS="refHeading">VMAllocLMem()</H1>
<PRE CLASS="syntax">VMBlockHandle VMAllocLmem(VMFileHandleファイル、LMemType)ltype, /*作成するLMemヒープのタイプ*/word headerSize);/*LMemヘッダーに残すサイズ. *標準ヘッダーにはゼロを渡す*/</PRE>
<P>このルーチンは、VMブロックを割り当て、LMemヒープを含むように初期化します。 作成するLMemヒープのタイプを渡す必要があります。 固定データ・スペースが必要な場合は、ヘッダーに残す合計サイズを渡す必要があります(<CODE>LMemBlockHeader</CODE>そうでない場合は、ヘッダサイズとしてゼロを渡します。<CODE>LMemBlockHeader</CODE>左にする必要があります。 ヒープはチャンクの割り当てに合わせて自動的に拡張されるため、ブロックサイズを指定する必要はありません。</P>
<P>ブロックのユーザID番号が定義されていません。 でブロックをロックする必要があります。<CODE><A HREF="../../CRef/Routines/R_a3.htm#IX_VMLock()">VMLock()</A></CODE>その後、チャンクにアクセスします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
<P CLASS="refField"><STRONG><STRONG>警告:</STRONG></STRONG>チャンクにアクセスするときは、ブロックの<EM>グローバルメモリ</EM>LMemルーチンへのハンドル(ブロックのVMハンドルではない)。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE><CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAlloc()">VMAlloc()[VMAlloc]</A></CODE><CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAttach()">VMAttach()</A></CODE>ボタンをクリックし</P>
</DIV>



<DIV>
          <A NAME="R_a1.htm_IX_VMAttach()"></A>
        <H1 CLASS="refHeading">VMAttach()</H1>
<PRE CLASS="syntax">VMBlockHandle VMAttach(VMFileHandleファイル、VMBlockHandle vmBlock、MemHandle mh);</PRE>
<P>このルーチンは、既存のグローバル・メモリー・ブロックをVMブロックに付加します。 次の引数が渡されます。</P>
<DL>
<DT>
          <CODE>やすり</CODE>
        </DT><DD>ファイルの<CODE>VMFileHandle</CODE>ボタンをクリックし</DD>
<DT>
          <CODE>vmBlock</CODE>
        </DT><DD>メモリー・ブロックを接続するVMブロックのハンドル。 そのブロックに関連付けられているデータはすべて失われます。 ヌルを渡した場合<CODE>VMBlockHandle</CODE>新しいVMブロックが割り当てられます。</DD>
<DT>
          <CODE>モデム</CODE>
        </DT><DD>アタッチするグローバルメモリブロックのハンドル。</DD>
</DL>
<P>このルーチンは、メモリー・ブロックが付加されたVMブロックのハンドルを返します。</P>
<P>既存のVMブロックにアタッチする場合、そのユーザIDは保持されます。 新しいブロックを作成する場合(nullを渡して<CODE>vmBlock</CODE>引き数)、ユーザーIDは未定義となる。</P>
<P>ブロックは自動的にダーティとマークされます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a1.htm_IX_VMCheckForModifications()"></A>
        <H1 CLASS="refHeading">VMCheckForModifications()</H1>
<PRE CLASS="syntax">ブーリアンVMCheckForModifications(VMFileHandleファイル);</PRE>
<P>このルーチンは<EM>真</EM>最後のフル・セーブ以降にVMファイルが破損または更新された場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_a2.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMClose()"></A>
        <H1 CLASS="refHeading">VMClose()</H1>
<PRE CLASS="syntax">word VMClose(VMFileHandleファイル、Boolean noErrorFlag);</PRE>
<P>このルーチンは、VMファイルを更新して閉じます。 成功した場合は、を返します。<EM>偽の</EM>失敗した場合は、メンバーaが戻されます。<CODE>VMStatus</CODE>エラーコード。 このルーチンは、ファイルを正常に更新できなかった場合でもファイルを閉じることに注意してください。この場合、最後の更新以降の変更はすべて失われます。 このため、電話をかけるのが最も安全です<CODE><A HREF="../../CRef/Routines/R_a4.htm#IX_VMUpdate()">VMUpdate()を実行します。</A></CODE>最初に、次に(ファイルが正常に更新された後に)呼び出します。<CODE>VMClose()</CODE>ボタンをクリックし</P>
<P>次の場合<EM>noErrorFlag</EM>はFILE_NO_ERRORS<CODE>VMClose()</CODE>ファイルを正常に更新して閉じることができなかった場合、致命的なエラーが発生します。 次の場合<EM>noErrorFlag</EM>がFILE_NO_ERRORSでも0でもない場合<CODE>VMClose()</CODE>クラッシュします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMCompareVMChains()"></A>
        <H1 CLASS="refHeading">VMCompareVMChains()</H1>
<PRE CLASS="syntax">ブールVMCompareVMChains(VMFileHandleソースファイル、VMChain sourceChain、VMFileHandleデスファイル、VMChain destChain);</PRE>
<P>このルーチンは、2つのVMチェーンまたはDB項目を比較します。 戻ります<EM>真</EM>2つが同一である場合。それ以外の場合は<EM>偽の</EM>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMCopyVMBlock()"></A>
        <H1 CLASS="refHeading">VMCopyVMBlock()</H1>
<PRE CLASS="syntax">VMBlockHandle VMCopyVMBlock(VMFileHandle sourceFile、VMBlockHandle sourceBlock、VMFileHandle destFile);</PRE>
<P>このルーチンは、指定されたデスティネーションファイル(ソースファイルと同じ場合があります)にVMブロックの複製を作成します。 重複するブロックのハンドルを返します。 複製のユーザIDは、元のブロックと同じになります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMCopyVMChain()"></A>
        <H1 CLASS="refHeading">VMCopyVMChain()</H1>
<PRE CLASS="syntax">VMChain VMCopyVMChain(VMFileHandle sourceFile、VMChain sourceChain、VMFileHandle destFile);</PRE>
<P>このルーチンは、指定されたデスティネーション・ファイル(ソース・ファイルと同じ場合がある)にVMチェーン(またはDBアイテム)の複製を作成します。 重複した<CODE>VMChain</CODE>構造。 複製内のすべてのブロックは、対応する元のブロックと同じユーザID番号を持ちます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMDetach()"></A>
        <H1 CLASS="refHeading">VMDetach()</H1>
<PRE CLASS="syntax">MemHandle VMDetach(VMFileHandleファイル、VMBlockHandleブロック、GeodeHandleオーナー);/*ブロックを*現在のスレッドのオーナー*に所有させるには、0を渡します*/</PRE>
<P>このルーチンは、VMブロックからグローバル・メモリー・ブロックを切り離します。 VMブロックが現在メモリー内にない場合は<CODE>VMDetach()</CODE>はメモリブロックを割り当て、そこにVMブロックをコピーします。 VMブロックがダーティであれば<CODE>VMDetach()</CODE>は、アタッチ解除する前に、ブロックをファイルに更新します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMDirty()"></A>
        <H1 CLASS="refHeading">VMDirty()</H1>
<PRE CLASS="syntax">空隙VMDirty(MemHandle mh)</PRE>
<P>このルーチンは、ロックされたVMブロックをダーティとしてマークします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMFind()"></A>
        <H1 CLASS="refHeading">VMFind()</H1>
<PRE CLASS="syntax">VMBlockHandle VMFind(VMFileHandleファイル、VMBlockHandle語startBlock、単語userID);</PRE>
<P>このルーチンは、指定されたユーザーID番号を持つVMブロックを検出します。 2番目の引数が<CODE>NullHandle</CODE>ルーチンは一番下のハンドルを持つブロックを返します。 2番目の引数がNULLでない場合、渡されたハンドルよりも大きいハンドルを持つ最初の一致ブロックを(番号順に)返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMFree()"></A>
        <H1 CLASS="refHeading">VMFree()</H1>
<PRE CLASS="syntax">空のVMFree(VMFileHandleファイル、VMBlockHandleブロック)</PRE>
<P>このルーチンは、指定されたVMブロックを解放します。 グローバル・メモリー・ブロックが現在VMブロックに接続されている場合は、それも解放されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMFreeVMChain()"></A>
        <H1 CLASS="refHeading">VMFreeVMChain()</H1>
<PRE CLASS="syntax">空のVMFreeVMChain(VMFileHandleファイル、VMChainチェーン)</PRE>
<P>このルーチンは、指定されたVMチェーンまたはDB項目を解放します。 チェーンが指定されている場合、チェーン内のすべてのブロックが解放されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMGetAttributes()"></A>
        <H1 CLASS="refHeading">VMGetAttributes()</H1>
<PRE CLASS="syntax">ワードVMGetAttributes(VMFileHandleファイル)</PRE>
<P>各VMファイルには、以下のセットが含まれます。<CODE>VMAttributes</CODE>フラグ。 これらは、VMマネージャがファイルを処理する方法を決定します。 このルーチンは現在のフラグを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>Document Controlオブジェクトがファイルを作成すると、属性が適切に自動的に初期化されます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a4.htm#IX_VMSetAttributes()">VMSetAttributes()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_a2.htm_IX_VMGetDirtyState()"></A>
        <H1 CLASS="refHeading">VMGetDirtyState()</H1>
<PRE CLASS="syntax">ワードVMGetDirtyState(VMFileHandleファイル)</PRE>
<P>このルーチンは、ファイルが破損しているかどうかを検出します。 ワードサイズの値を返します。 最後の保存、自動保存、または更新以降にファイルがdirtieされていない場合、戻り値の上位バイトは0以外になります。最後の保存以降にファイルがdirtieされていない場合、下位バイトは0以外になります。 したがって、戻り値がゼロの場合は、ファイルを更新する必要があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG><CODE><A HREF="../../CRef/Routines/R_a4.htm#IX_VMUpdate()">VMUpdate()を実行します。</A></CODE>は、クリーンファイルの更新用に最適化されています。 このため<CODE><A HREF="../../CRef/Routines/R_a4.htm#IX_VMUpdate()">VMUpdate()を実行します。</A></CODE>最初にダーティ状態をチェックし、次に<CODE><A HREF="../../CRef/Routines/R_a4.htm#IX_VMUpdate()">VMUpdate()を実行します。</A></CODE>ファイルがダーティな場合に限ります。</P>
</DIV>
<HR>
          <A NAME="R_a3.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_a3.htm_IX_VMGetMapBlock()"></A>
        <H1 CLASS="refHeading">VMGetMapBlock()</H1>
<PRE CLASS="syntax">VMBlockHandle VMGetMapBlock(VMFIleHandleファイル)</PRE>
<P>このルーチンは、ファイルのマップブロックのVMブロックハンドルを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a3.htm_IX_VMGrabExclusive()"></A>
        <H1 CLASS="refHeading">VMGrabExclusive()</H1>
<PRE CLASS="syntax">VMStartExclusiveReturnValue VMGrabExclusive(VMFileHandleファイル、ワードタイムアウト、VMOperation操作、VMOperation*currentOperation);</PRE>
<P>このルーチンは、このスレッドのVMファイルへの排他的アクセスを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a3.htm_IX_VMInfo()"></A>
        <H1 CLASS="refHeading">VMInfo()を実行します。</H1>
<PRE CLASS="syntax">Boolean VMInfo(VMFileHandleファイル、VMBlockHandleブロック、VMInfoStruct*情報)</PRE>
<P>このルーチンは、メモリハンドル、ブロックサイズ、およびブロックのユーザID番号を書き込みます。 戻ります<EM>非ゼロ</EM>ハンドルが無効またはフリーの場合。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a3.htm_IX_VMLock()"></A>
        <H1 CLASS="refHeading">VMLock()</H1>
<PRE CLASS="syntax">void*VMLock(VMFileHandleファイル、VMBlockHandleブロック、MemHandle*mh);</PRE>
<P>このルーチンは、VMブロックをグローバルヒープにロックします。 ブロックのベースアドレスを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a3.htm_IX_VMMemBlockToVMBlock()"></A>
        <H1 CLASS="refHeading">VMMemBlockToVMBlock()</H1>
<PRE CLASS="syntax">VMBlockHandle VMMemBlockToVMBlock(MemHandle mh、VMFileHandle*ファイル);</PRE>
<P>このルーチンは、指定したメモリブロックのVMブロックとファイルハンドルを取得します。 VMブロックハンドルを返し、VMファイルハンドルを<CODE>*ファイル</CODE>ボタンをクリックし</P>
<P>渡されるメモリハンドルは、VMファイルにアタッチされたブロックのハンドルである必要があります。 そうでない場合、結果は定義されません。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a3.htm_IX_VMModifyUserID()"></A>
        <H1 CLASS="refHeading">VMModifyUserID()</H1>
<PRE CLASS="syntax">void VMModifyUserID(VMFileHandleファイル、VMBlockHandleブロック、wordユーザーID)</PRE>
<P>このルーチンは、VMブロックのユーザーID番号を変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a3.htm_IX_VMOpen()"></A>
          <A NAME="R_a3.htm_IX_VM_&ldots;"></A>
        <H1 CLASS="refHeading">VMを開く()</H1>
<PRE CLASS="syntax">VMFileHandle VMOpen(char*name, /*開く/作成するファイルの名前*/VMAccessFlagsフラグ、VMOpenTypeモード、ワード圧縮);/*圧縮しきい値の割合*を整数で渡します*/</PRE>
<P>このルーチンは、VMファイルを開くか、作成します。 開かれたファイルのハンドルを返します。 ファイルを開くことができない場合は、nullを返します。<CODE>VMFileHandle</CODE>を設定し<CODE>VMStatus</CODE>で取得できるエラーコード<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>ボタンをクリックし<CODE>VMを開く()</CODE>は、スレッドの作業ディレクトリでファイルを検索します(後述するように、一時ファイルが作成されていない場合)。 このルーチンは次の4つの引数を取ります。</P>
<DL>
<DT><CODE>人名</DT><DD></CODE>開くファイルの名前を含む文字列へのポインタ。 ファイルは、スレッドの現在の作業ディレクトリで開かれます。 一時ファイルが開かれている場合、このバッファには、ファイルを作成するディレクトリのフルパスが含まれ、その後に14個のNULLバイトが続きます(文字列の末尾のNULLもカウントされます)。<CODE>VMを開く()</CODE>は、これらの後続ヌルに一時ファイルの名前を書き込みます。</DD>
<DT><CODE>フラグふらぐ</DT><DD></CODE>これは、必要なファイルへのアクセスの種類を指定します。 フラグについて説明します。<A HREF="../../CRef/Structs/S_43.htm#IX_VMAccessFlags">『C Structures Reference』の</A>ボタンをクリックし</DD>
<DT><CODE>モード(mode)</DT><DD></CODE>ファイルを開く方法を指定します。 タイプについて説明します。<A HREF="../../CRef/Structs/S_44.htm#IX_VMO_&ldots; (VMOpenType type)">『C Structures Reference』の</A>ボタンをクリックし</DD>
<DT>
          <CODE>コンプレッション</CODE>
        </DT><DD>圧縮のしきい値のパーセンテージ。整数で渡されます。 たとえば、圧縮のしきい値を50%に設定するには、整数50を渡します。 ファイル内の使用済み領域の割合が圧縮しきい値を下回ると、VMマネージャは自動的にファイルを圧縮します。 システムのデフォルトのしきい値を使用するには、しきい値0を渡します。 圧縮のしきい値は、ファイルの作成時にのみ設定されます。既存のファイルが開かれている場合、この引数は無視されます。</DD>
</DL>
<P>また、ファイルを開く方法も指定する必要があります。 これを行うには<CODE>VMOpenType</CODE>列挙型。</P>
<P>何らかの理由で<CODE>VMを開く()</CODE>が要求されたファイルを開けない場合は、ヌルのファイルハンドルを返します。 また、次のエラー値も設定されます。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>考えられるエラー状態は次のとおりです。</P>
<DL>
<DT>VM_FILE_EXISTS(仮想マシンファイルが存在する)</DT><DD><CODE>VMを開く()</CODE>がVMO_CREATE_ONLYを渡されましたが、ファイルはすでに存在します。</DD>
<DT>VMファイルが見つかりません</DT><DD><CODE>VMを開く()</CODE>がVMO_OPENを渡されましたが、ファイルが存在しません。</DD>
<DT>VM_SHARING_DENIED(共有が拒否されました</DT><DD>ファイルが別のgeodeによって開かれ、アクセスが拒否されました。</DD>
<DT>VM_OPEN_INVALID_VM_ファイル</DT><DD><CODE>VMを開く()</CODE>が無効なVMファイル(または非VMファイル)を開くように指示されました。</DD>
<DT>VM_CANNOT_CREATE(仮想マシンを作成できない)</DT><DD><CODE>VMを開く()</CODE>ファイルを作成できません(ただし、ファイルはまだ存在しません)。</DD>
<DT>VM_TRUNCATE_失敗しました</DT><DD><CODE>VMを開く()</CODE>がVMO_CREATE_TRUNCATEを渡されました。ファイルは存在しますが、トランケートできませんでした。</DD>
<DT>VM_WRITE_PROTECTED</DT><DD><CODE>VMを開く()</CODE>がVMAF_FORCE_READ_WRITEを渡されましたが、ファイルは書き込み保護されていました。</DD>
<DT>VM_CANNOT_OPEN_SHARED_MULTIPLE(VMを複数開くことができない)</DT><DD><CODE>VMを開く()</CODE>VMAF_DISALLOW_SHARED_MULTIPLEフラグを渡しているときに、GFHF_SHARED_MULTIPLEとマークされたファイルを開こうとしました。</DD>
<DT>VM_FILE_FORMAT_MISMATCH(VMファイル形式の不一致)</DT><DD><CODE>VMを開く()</CODE>すでにDOSファイルに属している名前を使用してVMファイルを作成しようとしました。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>ドキュメントコントロールオブジェクトを使用すると、必要に応じてファイルを開くことができます。<CODE>VMを開く()</CODE>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FileOpen()">ファイルを開く()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="R_a4.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMPreserveBlocksHandle()"></A>
        <H1 CLASS="refHeading">VMPreserveBlocksHandle()</H1>
<PRE CLASS="syntax">空のVMPreserveBlocksHandle(VMFileHandleファイル、VMBlockHandleブロック)</PRE>
<P>ブロックが明示的にデタッチされるか、VMブロックが解放されるまで、このVMブロックと同じグローバルメモリブロックを保持します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMReleaseExclusive()"></A>
        <H1 CLASS="refHeading">VMReleaseExclusive()</H1>
<PRE CLASS="syntax">空のVMReleaseExclusive(VMFileHandleファイル)</PRE>
<P>このルーチンは、スレッドによるVMファイルへの排他的アクセスを解放します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMRevert()"></A>
        <H1 CLASS="refHeading">VMRevert()</H1>
<PRE CLASS="syntax">空のVMRevert(VMFileHandleファイル、)</PRE>
<P>このルーチンは、ファイルを最後に保存した状態に戻します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMSave()"></A>
        <H1 CLASS="refHeading">VMSave()</H1>
<PRE CLASS="syntax">ブーリアンVMSave(VMFileHandleファイル);</PRE>
<P>このルーチンは、ファイルを更新して保存し、すべてのバックアップブロックを解放します。 保存操作でエラーが発生した場合は<EM>非ゼロ</EM>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMSaveAs()"></A>
        <H1 CLASS="refHeading">VMSaveAs()</H1>
<PRE CLASS="syntax">VMFileHandle VMSaveAs(VMFileHandleファイル、const char*name、VMAccessFlagsの旗。 VMOpenTypeモード、ワード圧縮);/*圧縮のしきい値*/</PRE>
<P>このルーチンは、ファイルを新しい名前で保存します。 古いファイルは、最後に保存した状態に戻ります。 保存操作でエラーが発生した場合は、ヌルが返されます。<CODE>VMFileHandle</CODE>を選択し<CODE>VMStatus</CODE>エラーコード<CODE></CODE>これは以下で取得できます。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMSetAttributes()"></A>
        <H1 CLASS="refHeading">VMSetAttributes()</H1>
<PRE CLASS="syntax">ワードVMSetAttributes(VMFileHandleファイル、VMAttributes attrToSet、/*これらのフラグをオンにする.*/VMAttributes attrToClear);/*これらのフラグをオフにした後*/</PRE>
<P>このルーチンは、VMファイルの<CODE>VMAttributes</CODE>見出しページを開きます。 ルーチンは、新しいアトリビュート設定を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG>Document Controlオブジェクトがファイルを作成すると、属性が適切に自動的に初期化されます。</P>
<P CLASS="refField"><STRONG>警告:</STRONG>VMA_BACKUPをオフにする場合は、保存または復元の直後(バックアップブロックがないとき)に必ずオフにしてください。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_a2.htm#IX_VMGetAttributes()">VMGetAttributes()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMSetExecThread()"></A>
        <H1 CLASS="refHeading">VMSetExecThread()</H1>
<PRE CLASS="syntax">空のVMSetExecThread(VMFileHandleファイル、ThreadHandleスレッド)</PRE>
<P>ファイル内のすべてのオブジェクトのメソッドを実行するスレッドを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMSetMapBlock()"></A>
        <H1 CLASS="refHeading">VMSetMapBlock()</H1>
<PRE CLASS="syntax">空のVMSetMapBlock(VMFileHandleファイル、VMBlockHandleブロック)</PRE>
<P>このルーチンは、VMファイルのマップブロックを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMSetReloc()"></A>
        <H1 CLASS="refHeading">VMSetReloc()</H1>
<PRE CLASS="syntax">void VMSetReloc(VMFileHandleファイル、void(*reloc)(VMFileHandleファイル、VMBlockHandleブロック、MemHandle mh、void*データ、VMRelocTypesタイプ));</PRE>
<P>このルーチンは、VMファイルのデータ再配置ルーチンを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMUnlock()"></A>
        <H1 CLASS="refHeading">VMUnlock()</H1>
<PRE CLASS="syntax">空隙VMUnlock(MemHandle mh)</PRE>
<P>このルーチンは、ロックされたVMブロックのロックを解除します。 ブロックの<EM>グローバルメモリハンドル</EM>が渡されます(VMハンドルではありません)。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMUpdate()"></A>
        <H1 CLASS="refHeading">VMUpdate()を実行します。</H1>
<PRE CLASS="syntax">word VMUpdate(VMFileHandleファイル);</PRE>
<P>このルーチンは、ディスクのダーティ・ブロックを更新します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>ヒントとコツ:</STRONG><CODE>VMUpdate()を実行します。</CODE>は、クリーンファイルをディスクに更新するために最適化されています。 そのため<CODE>VMUpdate()を実行します。</CODE>必要だと思ったときには、ダーティ状態をチェックして<CODE>VMUpdate()を実行します。</CODE>ファイルが実際にダーティである場合に限ります。</P>
</DIV>
<DIV>
          <A NAME="R_a4.htm_IX_VMVMBlockToMemBlock()"></A>
        <H1 CLASS="refHeading">VMVMBlockToMemBlock()</H1>
<PRE CLASS="syntax">MemHandle VMVMBlockToMemBlock(VMFileHandleファイル、VmBlockHandleブロック);</PRE>
<P>このルーチンは、指定されたVMブロックにアタッチされているメモリブロックのグローバルハンドルを返します。 現在アタッチされているグローバルブロックがない場合は、1つを割り当ててアタッチします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">仮想マシン.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_a5.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinAckUpdate()"></A>
        <H1 CLASS="refHeading">WinAckUpdate()</H1>
<PRE CLASS="syntax">void WinAckUpdate(WindowHandle win);</PRE>
<P>このルーチンは、アプリケーションが指定されたウィンドウのMSG_META_EXPOSEDを受信したことを確認しますが、更新を行わないことを選択します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinApplyRotation()"></A>
        <H1 CLASS="refHeading">WinApplyRotation()</H1>
<PRE CLASS="syntax">void flag(WindowHandle win, WWFixedAsDWordアングル,WinInvalFlag WinApplyRotation);</PRE>
<P>このルーチンは、指定された回転をウィンドウの変換行列に適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinApplyScale()"></A>
        <H1 CLASS="refHeading">WinApplyScale()</H1>
<PRE CLASS="syntax">void flag(WindowHandle win, WWFixedAsDWord xScale, WWFixedAsDWord yScale, WinInvalFlag WinApplyScale);</PRE>
<P>このルーチンは、指定されたスケール係数をウィンドウの変換行列に適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinApplyTransform()"></A>
        <H1 CLASS="refHeading">WinApplyTransform()</H1>
<PRE CLASS="syntax">void flag(WindowHandle win, const TransMatrix*tm, WinInvalFlag WinApplyTransform);</PRE>
<P>このルーチンは、渡された変換行列をウィンドウの変換行列に連結します。 結果は、ウィンドウの新しい変換行列になります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinApplyTranslation()"></A>
        <H1 CLASS="refHeading">WinApplyTranslation()</H1>
<PRE CLASS="syntax">void flag(WindowHandle win, WWFixedAsDWord xTrans, WWFixedAsDWord yTrans, WinInvalFlag WinApplyTranslation);</PRE>
<P>このルーチンは、指定された変換をウィンドウの変換行列に適用します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinApplyTranslationDWord()"></A>
        <H1 CLASS="refHeading">WinApplyTranslationDWord()</H1>
<PRE CLASS="syntax">void flag(WindowHandle win, sdword xTrans, sdword yTrans, WinInvalFlag WinApplyExtTranslation);</PRE>
<P>このルーチンは、指定された変換をウィンドウの変換行列に適用します。 変換は32ビット整数として指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinChangeAck()"></A>
        <H1 CLASS="refHeading">WinChangeAck()</H1>
<PRE CLASS="syntax">WindowHandle WinChangeAck(WindowHandle win, sword x, sword y, optr*winOD);</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinChangePriority()"></A>
        <H1 CLASS="refHeading">WinChangePriority()</H1>
<PRE CLASS="syntax">void WinChangePriority(WindowHandle win, WinPassFlagsフラグ,word layerID);</PRE>
<P>このルーチンは、指定したウィンドウの優先度を変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinClose()"></A>
        <H1 CLASS="refHeading">WinClose()</H1>
<PRE CLASS="syntax">void WinClose(WindowHandle win);</PRE>
<P>このルーチンは、指定されたウィンドウを閉じて解放します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinDecRefCount()"></A>
        <H1 CLASS="refHeading">WinDecRefCount()</H1>
<PRE CLASS="syntax">void WinDecRefCount(WindowHandle win);</PRE>
<P>このルーチンは、ウィンドウを閉じるメカニズムの一部です。</P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinEnsureChangeNotification()"></A>
        <H1 CLASS="refHeading">WinEnsureChangeNotification()</H1>
<PRE CLASS="syntax">void WinEnsureChangeNotification(void)</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinGeodeGetInputObj()"></A>
        <H1 CLASS="refHeading">WinGeodeGetInputObj()</H1>
<PRE CLASS="syntax">optr WinGeodeGetInputObj(GeodeHandle obj)</PRE>
<P>このルーチンは、指定されたgeodeの入力オブジェクトのoptrを取得します。 該当するオブジェクトがない場合は、null optrを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinGeodeGetParentObj()"></A>
        <H1 CLASS="refHeading">WinGeodeGetParentObj()</H1>
<PRE CLASS="syntax">optr WinGeodeGetParentObj(GeodeHandle obj)</PRE>
<P>このルーチンは、指定されたgeodeの親オブジェクトのoptrを取得します。 該当するオブジェクトがない場合は、null optrを返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a5.htm_IX_WinGeodeSetActiveWin()"></A>
        <H1 CLASS="refHeading">WinGeodeSetActiveWin()</H1>
<PRE CLASS="syntax">void WinGeodeSetActiveWin(GeodeHandle gh, WindowHandle win);</PRE>
<P>このルーチンは、指定されたgeodeのアクティブウィンドウを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_a6.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinGeodeSetInputObj()"></A>
        <H1 CLASS="refHeading">WinGeodeSetInputObj()</H1>
<PRE CLASS="syntax">void WinGeodeSetInputObj(GeodeHandle gh, optr iObj)</PRE>
<P>このルーチンは、指定したgeodeの入力オブジェクトを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinGeodeSetParentObj()"></A>
        <H1 CLASS="refHeading">WinGeodeSetParentObj()</H1>
<PRE CLASS="syntax">void WinGeodeSetParentObj(GeodeHandle gh, optr pObj)</PRE>
<P>このルーチンは、指定したgeodeの親オブジェクトを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinGeodeSetPtrImage()"></A>
        <H1 CLASS="refHeading">WinGeodeSetPtrImage()</H1>
<PRE CLASS="syntax">void WinGeodeSetPtrImage(GeodeHandle gh, optr ptrCh)</PRE>
<P>このルーチンは、指定したジオードのポインタイメージを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinGetInfo()"></A>
        <H1 CLASS="refHeading">WinGetInfo()</H1>
<PRE CLASS="syntax">dワードWinGetInfo(WindowHandle win, WinInfoTypesタイプ,void*data);</PRE>
<P>このルーチンは、GStateからプライベート・データを取得します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinGetTransform()"></A>
        <H1 CLASS="refHeading">WinGetTransform()</H1>
<PRE CLASS="syntax">void WinGetTransform(WindowHandle win、TransMatrix*tm);</PRE>
<P>このルーチンは、指定されたウィンドウの変換行列を取得します。 行列を書き込む<CODE>*商標</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinGetWinScreenBounds()"></A>
        <H1 CLASS="refHeading">WinGetWinScreenBounds()</H1>
<PRE CLASS="syntax">void WinGetWinScreenBounds(WindowHandle win, Rectangle*bounds);</PRE>
<P>このルーチンは、ウィンドウの画面上の部分(画面座標で指定)の境界を返します。 境界を書き込む<EM>*範囲</EM>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinGrabChange()"></A>
        <H1 CLASS="refHeading">WinGrabChange()</H1>
<PRE CLASS="syntax">ブーリアンWinGrabChange(WindowHandle win, optr newObj);</PRE>
<P>このルーチンは、オブジェクトがポインタイベントを取得できるようにします。 成功した場合は0を返し、それ以外の場合は0以外の値を返します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinInvalReg()"></A>
        <H1 CLASS="refHeading">WinInvalReg()</H1>
<PRE CLASS="syntax">void region(WindowHandle win, const WinInvalReg*reg, 単語axParam, 単語bxParam, 単語cxParam, 単語dxParam);</PRE>
<P>このルーチンは、指定された領域または長方形を無効にします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinMove()"></A>
        <H1 CLASS="refHeading">WinMove()</H1>
<PRE CLASS="syntax">void flag(WindowHandle win, sword xMove, sword yMove, WinPassFlags WinMove);</PRE>
<P>このルーチンは、ウィンドウを移動します。 のWPF_ABSビットが<CODE>フラグふらぐ</CODE>が設定されている場合、ウィンドウの新しい位置は親の位置を基準にして指定される。 選択されていない場合、ウィンドウの新しい位置は現在の位置を基準にして指定されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinOpen()"></A>
        <H1 CLASS="refHeading">WinOpen()[Winを開く]</H1>
<PRE CLASS="syntax">WindowHandle WinOpen(Handle parentWinOrVidDr, optr inputRecipient, optr exposureRecipient, WinColorFlags colorFlags, word owner, word green, word blue, word flags, word layerID, GeodeHandle redOrIndex, const Region*winReg, word axParam, word bxParam, word cxParam, word dxParam);</PRE>
<P>このルーチンは、ウィンドウと(オプションで)関連するGStateを割り当て、初期化します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinReleaseChange()"></A>
        <H1 CLASS="refHeading">WinReleaseChange()</H1>
<PRE CLASS="syntax">void WinReleaseChange(WindowHandle win, optr obj);</PRE>
<P>このルーチンは、ODの変更時にオブジェクトのグラブを解放します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a6.htm_IX_WinResize()"></A>
        <H1 CLASS="refHeading">WinResize()</H1>
<PRE CLASS="syntax">void region(WindowHandle win, const WinResize*reg, 単語axParam, 単語bxParam, 単語cxParam, WinPassFlagsフラグ);</PRE>
<P>このルーチンは、ウィンドウのサイズを変更します。 動かすこともできます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="R_a7.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinScroll()"></A>
        <H1 CLASS="refHeading">WinScroll()</H1>
<PRE CLASS="syntax">void WinScroll(WindowHandle win、WWFixedAsDWord xMove、WWFixedAsSWord yMove、PointWWFixed*scrollAmt);</PRE>
<P>このルーチンはウィンドウをスクロールします。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinSetInfo()"></A>
        <H1 CLASS="refHeading">WinSetInfo()</H1>
<PRE CLASS="syntax">void win(WindowHandle WinSetInfo、WinInfoTypeタイプ、dwordデータ);</PRE>
<P>このルーチンは、指定されたウィンドウのデータを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinSetNullTransform()"></A>
        <H1 CLASS="refHeading">WinSetNullTransform()</H1>
<PRE CLASS="syntax">void flag(WindowHandle win, WinInvalFlag WinSetNullTransform);</PRE>
<P>このルーチンは、ウィンドウの変換行列をヌル(または恒等)行列に変更します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_Mouse:WinSetPtrImage()"></A>
          <A NAME="R_a7.htm_IX_WinSetPtrImage()"></A>
        <H1 CLASS="refHeading">WinSetPtrImage()</H1>
<PRE CLASS="syntax">void WinSetPtrImage(WindowHandle win、WinSetPtrImageLevel ptrLevel、optr ptrCh);</PRE>
<P>このルーチンは、指定されたウィンドウで処理される範囲内にポインタイメージを設定します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinSetTransform()"></A>
        <H1 CLASS="refHeading">WinSetTransform()</H1>
<PRE CLASS="syntax">void flag(WindowHandle win, const TransMatrix*tm, WinInvalFlag WinSetTransform);</PRE>
<P>このルーチンは、ウィンドウの変換行列を渡された行列に置き換えます。<EM>*商標</EM>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinSuspendUpdate()"></A>
        <H1 CLASS="refHeading">WinSuspendUpdate()</H1>
<PRE CLASS="syntax">void WinSuspendUpdate(WindowHandle win);</PRE>
<P>このルーチンは、ウィンドウへの更新メッセージの送信を中断します。 メッセージは次の場合に送信されます。<CODE><A HREF="../../CRef/Routines/R_a7.htm#IX_WinUnSuspendUpdate()">WinUnSuspendUpdate()</A></CODE>が呼び出されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinTransform()"></A>
        <H1 CLASS="refHeading">WinTransform()</H1>
<PRE CLASS="syntax">XYValueAsDWord WinTransform(WindowHandle win, sword x, sword y);</PRE>
<P>このルーチンは、渡されたドキュメント座標を画面座標に変換します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinTransformDWord()"></A>
        <H1 CLASS="refHeading">WinTransformDWord()</H1>
<PRE CLASS="syntax">void WinTransformDWord(WindowHandle win、sdword xCoord、sdword yCoord、PointDWord*screenCoordinates);</PRE>
<P>このルーチンは、渡されたドキュメント座標を画面座標に変換します。 変換された座標は<CODE>*スクリーン座標</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinUnSuspendUpdate()"></A>
        <H1 CLASS="refHeading">WinUnSuspendUpdate()</H1>
<PRE CLASS="syntax">void WinUnSuspendUpdate(WindowHandle win);</PRE>
<P>このルーチンは、直前の<CODE><A HREF="../../CRef/Routines/R_a7.htm#IX_WinSuspendUpdate()">WinSuspendUpdate()</A></CODE>を呼び出します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinUntransform()"></A>
        <H1 CLASS="refHeading">WinUntransform</H1>
<PRE CLASS="syntax">XYValueAsDWord WinUntransform(WindowHandle win, sword x, sword y);</PRE>
<P>このルーチンは、渡された画面座標をドキュメント座標に変換します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WinUntransformDWord()"></A>
        <H1 CLASS="refHeading">WinUntransformDWord()</H1>
<PRE CLASS="syntax">void WinUntransformDWord(WindowHandle win、sdword xCoord、sdword yCoord、PointDWord*documentCoordinates);</PRE>
<P>このルーチンは、渡された画面座標をドキュメント座標に変換します。 変換された座標は<CODE>*documentCoordinates</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">win.hと入力します。</STRONG>
        </P>
</DIV>
<DIV>
<H1 CLASS="refHeading">WWFixedToFrac</H1>
<PRE CLASS="syntax">ワードWWFixedToFrac(WWFixed WWF)</PRE>
<P>このマクロを使用すると<CODE>WWFixed</CODE>値を入力します。 これを使用して分数表記に値を割り当てることができます。つまり</P>
<PRE>WWFixedToFrac(myWWFixed)=5</PRE>
<P>完全に合法なのです</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geos.hを入力します。</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="R_a7.htm_IX_WWFixedToInt"></A>
        <H1 CLASS="refHeading">WWFixedToInt</H1>
<PRE CLASS="syntax">ワードWWFixedToInt(WWFixed WWF)</PRE>
<P>このマクロを使用すると、オブジェクトのintetgral部分を<CODE>WWFixed</CODE>値を入力します。 これを使用して積分項に値を割り当てることができます。</P>
<PRE>WWFixedToInt(myWWFixed)=5</PRE>
<P>完全に合法なのです</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">geos.hを入力します。</STRONG>
        </P>
</DIV>
<HR>このドキュメントは<A HREF="index.htm">複数ページのドキュメント</A>簡単な印刷に適しています。</BODY>
</HTML>
