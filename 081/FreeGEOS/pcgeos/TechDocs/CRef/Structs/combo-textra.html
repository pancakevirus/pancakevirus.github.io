<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><meta http-equiv="Content-Type" content="text/html; charset=utf8">
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>GEOS C構造リファレンス</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">このドキュメントは<A HREF="index.htm">複数ページのドキュメント</A>簡単な印刷に適しています。<A NAME="index.htm"></A><DIV>
</DIV>
<H1>GEOS C構造リファレンス</H1>
<P>このマニュアルには、ほとんどのGEOSシステム構造に関する参照情報が記載されています。 このドキュメントおよびその他のGEOS SDKドキュメントの情報は、次のサイトで参照できます。<A HREF="../../docIndexes/bigIndex/indexA.htm">インデックス</A>このリファレンスを参照したい場合は、以下のリンクのいずれかを選択してください。各テキストは、このドキュメントのページに記載されている最初の構造体の名前です。</P>

<P CLASS="sectionlinks">
          <STRONG>
            <A HREF="#S_1.htm">AccessPointStandardProperty…</A>
            <BR>
            <A HREF="#S_2.htm">AppLaunchFlags…</A>
            <BR>
            <A HREF="#S_3.htm">ビットマップモード.</A>
            <BR>
            <A HREF="#S_4.htm">CellFunctionParameterFlags…</A>
            <BR>
            <A HREF="#S_5.htm">文字.</A>
            <BR>
            <A HREF="#S_6.htm">ChunkArrayHeader…</A>
            <BR>
            <A HREF="#S_7.htm">ClipboardItemHeader…</A>
            <BR>
            <A HREF="#S_8.htm">色.</A>
            <BR>
            <A HREF="#S_9.htm">カラーフラグ.</A>
            <BR>
            <A HREF="#S_a.htm">CompSizeHintArgs…</A>
            <BR>
            <A HREF="#S_b.htm">CustomDialogBoxFlags…</A>
            <BR>
            <A HREF="#S_c.htm">DataStoreIndexCallbackParams…</A>
            <BR>
            <A HREF="#S_d.htm">DateTimeFormat形式.</A>
            <BR>
            <A HREF="#S_e.htm">DiskFindResult…</A>
            <BR>
            <A HREF="#S_f.htm">DosNoDotFileName…</A>
            <BR>
            <A HREF="#S_10.htm">EndOfSongFlags…</A>
            <BR>
            <A HREF="#S_11.htm">EvalErrorData…</A>
            <BR>
            <A HREF="#S_12.htm">嘘…</A>
            <BR>
            <A HREF="#S_13.htm">FileAttrs…</A>
            <BR>
            <A HREF="#S_14.htm">FileDateAndTime…</A>
            <BR>
            <A HREF="#S_15.htm">FileFromTransferBlockID…</A>
            <BR>
            <A HREF="#S_16.htm">フォントファミリ.</A>
            <BR>
            <A HREF="#S_17.htm">フォントID.</A>
            <BR>
            <A HREF="#S_18.htm">フォントメーカー.</A>
            <BR>
            <A HREF="#S_19.htm">GCM情報(_I).</A>
            <BR>
            <A HREF="#S_1a.htm">GCNStandardListType…</A>
            <BR>
            <A HREF="#S_1b.htm">GeodeToken…</A>
            <BR>
            <A HREF="#S_1c.htm">GeoworksMediumID…</A>
            <BR>
            <A HREF="#S_1d.htm">GeoWorksVisContentGCNListType…</A>
            <BR>
            <A HREF="#S_1e.htm">GStringElement…</A>
            <BR>
            <A HREF="#S_1f.htm">GStringErrorType…</A>
            <BR>
            <A HREF="#S_20.htm">HeapCongestion…</A>
            <BR>
            <A HREF="#S_21.htm">IMCFeatures…</A>
            <BR>
            <A HREF="#S_22.htm">InkControlFeatures…</A>
            <BR>
            <A HREF="#S_23.htm">InstrumentPatch…</A>
            <BR>
            <A HREF="#S_24.htm">InstrumentTable…</A>
            <BR>
            <A HREF="#S_25.htm">言語.</A>
            <BR>
            <A HREF="#S_26.htm">LMemType…</A>
            <BR>
            <A HREF="#S_27.htm">LocalNumericFormat…</A>
            <BR>
            <A HREF="#S_28.htm">MediumUnitType…</A>
            <BR>
            <A HREF="#S_29.htm">MixMode…</A>
            <BR>
            <A HREF="#S_2a.htm">特殊.</A>
            <BR>
            <A HREF="#S_2b.htm">OperatorType…</A>
            <BR>
            <A HREF="#S_2c.htm">ParserFlags…</A>
            <BR>
            <A HREF="#S_2d.htm">ParserTokenData…</A>
            <BR>
            <A HREF="#S_2e.htm">点.</A>
            <BR>
            <A HREF="#S_2f.htm">プロトコル番号.</A>
            <BR>
            <A HREF="#S_30.htm">RangeSortFlags…</A>
            <BR>
            <A HREF="#S_31.htm">リリース番号.</A>
            <BR>
            <A HREF="#S_32.htm">ScannerTokenCellData…</A>
            <BR>
            <A HREF="#S_33.htm">SerialBaud…</A>
            <BR>
            <A HREF="#S_34.htm">ソケット.</A>
            <BR>
            <A HREF="#S_35.htm">SocketError…</A>
            <BR>
            <A HREF="#S_36.htm">SocketLoadType…</A>
            <BR>
            <A HREF="#S_37.htm">SoundPlayFlags…</A>
            <BR>
            <A HREF="#S_38.htm">SpecWidth…</A>
            <BR>
            <A HREF="#S_39.htm">SpoolInfoType…</A>
            <BR>
            <A HREF="#S_3a.htm">標準ダイアログ4 ResponseTriggerTable.</A>
            <BR>
            <A HREF="#S_3b.htm">StyleElementFlags…</A>
            <BR>
            <A HREF="#S_3c.htm">SystemDrawMask…</A>
            <BR>
            <A HREF="#S_3d.htm">テキストモード.</A>
            <BR>
            <A HREF="#S_3e.htm">TextReferenceType…</A>
            <BR>
            <A HREF="#S_3f.htm">TimerHandle…</A>
            <BR>
            <A HREF="#S_40.htm">TravelOption…</A>
            <BR>
            <A HREF="#S_41.htm">UndoActionStruct…</A>
            <BR>
            <A HREF="#S_42.htm">ベクトル文字.</A>
            <BR>
            <A HREF="#S_43.htm">VisRulerType…</A>
            <BR>
            <A HREF="#S_44.htm">VMOpenType…</A>
            <BR>
          </STRONG>
        </P> <!-- end of sectionlinks blob -->
<HR>
          <A NAME="S_1.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_1.htm_IX_AccessPointStandardProperty"></A>
        <H1 CLASS="refHeading">AccessPointStandardProperty</H1>
<PRE CLASS="syntax">typedef enum{APSP_NAME=0x0, APSP_PHONE=0x2, APSP_USER=0x4, APSP_SECRET=0x6, APSP_ADDRESS=0x8, APSP_MASK=0 xa,APSP_GATEWAY=0 xc,APSP_DNS1=0 xe,APSP_DNS2=0x10, APSP_DATA_BITS=0x12, APSP_STOP_BITS=0x14, APSP_PARITY=0x16, APSP_DUPLEX=0x18, APSP_MODEM_INIT=0x1a, APSP_BS=0x1c, APSP_HOSTNAME=0x1e, APSP_INTERNET_ACCPNT=0x20, APSP_PROMPT_SECRET=0x22, /*このプロパティは整数です*/APSP_AUTOMATIC=0x4000, APSP_UNDEFINED=0 xffff,/*次のものは、Nokia 9000i Communicatorのビルド4以降でのみ使用できます。 */APSP_USE_LOGIN_APP=0x24, APSP_LOGIN_APP_NAME=0x26, APSP_SCRIPT_NAME=0x28, APSP_CCARD_NAME=0x2a, APSP_CCARD_ACCESS=0x2c, APSP_CCARD_ID=0x2e, APSP_CCARD_PREFIX=0x30, APSP_CCARD_SEQUENCE=0x32, APSP_COMPRESSION=0x34, }AccessPointStandardProperty;</PRE>
<P>これらの標準プロパティに関連付けられているプロパティデータは、特に明記されていない限り、すべて文字列です。</P>
<P>任意<CODE>AccessPointStandardProperty</CODE>値をAPSP_AUTOMATICと組み合わせて(ビット単位のORで)、別の形式の名前を作成することができます。 このライブラリは自動設定された名前に特別な解釈を与えませんが、ユーザからではなく自動設定から得られた値を表すことを意図しています。</P>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
</DIV>
<DIV>
          <A NAME="S_1.htm_IX_AccessPointType"></A>
        <H1 CLASS="refHeading">AccessPointType</H1>
<PRE CLASS="syntax">typedef enum{APT_INTERNET=0x1, APT_TERMINAL, APT_TELNET, APT_APP_LOCAL, }AccessPointType;#define APT_ALL(0)</PRE>
<P CLASS="refField"><STRONG>次を含む:</STRONG>accpnt・ゴー</P>
</DIV>
<DIV>
          <A NAME="S_1.htm_IX_AUAF_&ldots;"></A>
          <A NAME="S_1.htm_IX_AddUndoActionFlags"></A>
        <H1 CLASS="refHeading">AddUndoActionFlags</H1>
<PRE CLASS="syntax">typedef WordFlags AddUndoActionFlags;#define AUAF_NOTIFY_BEFORE_FREEDING 0x8000#define AUAF_NOTIFY_IF_FREEDD_WITHOUT_BEING_PLAYED_BACK 0x4000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1.htm_IX_AUAS_&ldots;"></A>
          <A NAME="S_1.htm_IX_AddUndoActionStruct"></A>
        <H1 CLASS="refHeading">AddUndoActionStruct</H1>
<PRE CLASS="syntax">typedef struct{UndoActionStruct AUAS_data;optr AUAS_output;AddUndoActionFlags AUAS_flags;}AddUndoActionStruct;</PRE>
<P>「undo」構造は連携して動作し、undoイベントを処理するプロセスに不可欠な情報を提供します。</P>
</DIV>
<DIV>
          <A NAME="S_1.htm_IX_AppAttachFlags"></A>
          <A NAME="S_1.htm_IX_AAF_&ldots;"></A>
        <H1 CLASS="refHeading">AppAttachFlags</H1>
<PRE CLASS="syntax">typedef WordFlags AppAttachFlags;#define AAF_RESTORING_FROM_STATE 0x8000#define AAF_STATE_FILE_PASSED 0x4000#define AAF_DATA_FILE_PASSED 0x2000</PRE>
<P>これらのフラグは、アプリケーションが起動するとき、または状態ファイルから復元されるときにプロセスに渡されます。 フラグは、アプリケーションが状態ファイルから起動されているか、状態ファイルを持っているか、データファイルを持っているかを示します。</P>
<P>AAF_RESTORING_FROM_STATEが設定されている場合、AAF_STATE_FILE_PASSEDも設定されることに注意してください。</P>
</DIV>
<DIV>
          <A NAME="S_1.htm_IX_AppInstanceReference"></A>
          <A NAME="S_1.htm_IX_AIR_&ldots;"></A>
        <H1 CLASS="refHeading">AppInstanceReference</H1>
<PRE CLASS="syntax">typedef struct{/*AIR_fileName:*アプリケーションが起動されています。 pathnameはapplication*ディレクトリからの相対パスです(もちろん、アプリケーションへの直接パス*で上書きすることもできます)。 */パス名AIR_fileName;</PRE>
<PRE CLASS="syntax">/*AIR_stateFile:*状態ファイル名。 ファイルは、*GEOS状態ファイルの標準ディレクトリにあると想定されます。 最初のバイトが「0」の場合、このアプリケーションには*状態ファイルがありません。 この構造体は、アプリケーションの再起動を支援するために*フィールドにコピーされ、このバイトが0である*oneに遭遇した場合、再起動は行われません。 */FileLongName AIR_stateファイル;</PRE>
<PRE CLASS="syntax">/*AIR_diskHandle:*アプリケーションのディスクハンドル(渡された)IF 0の場合はシステムディスクを使用し、-1の場合は*AIR_diskNameを使用します。 フィールドでは、これがプレースホルダ構造である場合、この*wordはデタッチを待機しているアプリケーションオブジェクトのハンドルです。 */diskHandle AIR_diskHandle;</PRE>
<PRE CLASS="syntax">/*AIR_savedDiskData:*インスタンスが状態ファイルに保存されるときにDiskSaveによって保存されるデータの開始。 */バイトAIR_savedDiskData[1];</PRE>
<PRE CLASS="syntax">}AppInstanceReference;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1.htm_IX_AppLaunchBlock"></A>
          <A NAME="S_1.htm_IX_ALB_&ldots;"></A>
        <H1 CLASS="refHeading">AppLaunchBlock</H1>
<PRE CLASS="syntax">typedef struct{/*ALB_appRef:*インスタンス参照。 アプリケーションへの完全なパス名(*はアプリケーションディレクトリから参照される)と、状態ファイルの名前が含まれます。 *アプリケーションを再起動するのに十分な情報があります。復元されました。 (状態ファイル*はGeodeLoadに渡す必要はありません)*/AppInstanceReference ALB_appRef;</PRE>
<PRE CLASS="syntax">/*ALB_appMode:*アプリケーション接続モードの方法。 次のいずれかになります。 *MSG_GEN_PROCESS_RESTORE_FROM_STATE:*状態ファイルを渡す必要があります。データファイルを渡す必要はありません。 *MSG_GEN_PROCESS_OPEN_APPLICATION:*状態ファイルは通常渡されるべきではありませんが、*uiテンプレートを完成させることはできます。 データファイルを*アプリケーションに渡すこともできます。 *MSG_GEN_PROCESS_OPEN_ENGINE:*通常、状態ファイルは渡されません。 *エンジンが動作するデータファイルを渡す必要があります。 0の場合、デフォルトのデータファイル*を使用する必要があります(GenProcessClassではなくアプリケーションによって強制されます)。*/Message ALB_appMode;</PRE>
<PRE CLASS="syntax">/*ALB_launchFlags:*必要なアプリケーション起動タイプを指定するためのその他のフラグ。 */AppLaunchFlags ALB_launchFlags;</PRE>
<PRE CLASS="syntax">/*ALB_diskHandle:*データパスのディスクハンドル。 (*GenProcess&#39;MSG_META_ATTACHハンドラでアプリケーションの現在のパスとして設定されます。)*/MemHandle ALB_diskHandle;</PRE>
<PRE CLASS="syntax">/*ALB_path:*アプリケーションが初期パスとして使用するデータ・パス。 (通常、これは渡されたデータファイルの*ディレクトリです。)(GenProcessのMSG_META_ATTACHハンドラでアプリケーションの現在の*パスとして設定されます。) char ALB_path[PATH_BUFFER_SIZE];&lt;パス></PRE>
<PRE CLASS="syntax">/*ALB_dataFile:*開くために渡されたデータファイルの名前(ない場合は0)。 パス名は*上記のパスからの相対パス名です。 */char ALB_dataFile[PATH_BUFFER_SIZE];&lt;パス></PRE>
<PRE CLASS="syntax">/*ALB_genParent:*新しいアプリケーションの一般的な親(デフォルトフィールドに設定するには0)。 (MSG_GEN_FIELD_LAUNCH_APPLICATIONには*NULLを渡す必要があります)。 optr ALB_genParent;</PRE>
<PRE CLASS="syntax">/*ALB_userLoadAckOutput、ALB_userLoadAckMessage:*これらが一緒になって、アプリケーションが起動されたときに*アクティブになるアクション記述子を形成します(*ALF_SEND_LAUNCH_REQUEST_TO_UI_TO_HANDLEと一緒に使用されます)。 (何も送信しない場合は*NULL/0に設定します)。 *受信確認には3つの引数があります。GeodeHandle*(成功した場合はNULL以外)、*エラーが発生した場合に0となる単語値、およびALB_userLoackAckID(下記)に設定された単語値です。*/optr ALB_userLoadAckOutput;</PRE>
<PRE CLASS="syntax">メッセージALB_userLoadAckMessage;/*ALB_userLoadAckID:*上記のアクション記述子を介して送信されたID(存在する場合)。 */単語ALB_userLoadAckID;</PRE>
<PRE CLASS="syntax">/*ALB_extraData:*プロセスに送信する追加データ(引数を含む*ブロックへのハンドル)。 */単語ALB_extraData;</PRE>
<PRE CLASS="syntax">}AppLaunchBlock;</PRE>
<P>この構造体は、アプリケーションが最初に起動するときに使用されます。 これは、システムクラスによってインターセプトされるさまざまなメッセージの引数です。 最初のフィールド(<CODE>ALB_appRef</CODE><CODE>ALB_appMode</CODE><CODE>ALB_launchFlags</CODE>、および<CODE>ALB_uiLevel</CODE>)はアプリケーションの状態ファイルに保存されます。 その他の情報は、起動時に正しく設定する必要があります。</P>
</DIV>
<HR>
          <A NAME="S_2.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_2.htm_IX_AppLaunchFlags"></A>
          <A NAME="S_2.htm_IX_ALF_&ldots;"></A>
        <H1 CLASS="refHeading">AppLaunchFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags AppLaunchFlags;#define ALF_SEND_LAUNCH_REQUEST_TO_UI_TO_HANDLE 0x80#define ALF_OPEN_IN_BACK 0x40</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2.htm_IX_ApplicationStates"></A>
          <A NAME="S_2.htm_IX_AS_&ldots;"></A>
        <H1 CLASS="refHeading">ApplicationStates</H1>
<PRE CLASS="syntax">typedef ByteFlags ApplicationStates;#define AS_QUOTING 0x80#define AS_DETACHING 0x40#define AS_FOCUSABLE 0x20#define AS_MODELABLE 0x10#define AS_NOT_USER_INTERACTABLE 0x08#define AS_RECEIVED_APP_OBJECT_DETACH 0x04#define AS_ATTACHED_TO_STATE_FILE 0x02#define AS_ATTACHING 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2.htm_IX_ArcCloseType"></A>
          <A NAME="S_2.htm_IX_ACT_&ldots;"></A>
        <H1 CLASS="refHeading">ArcCloseType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{ACT_OPEN, ACT_CHORD, ACT_PIE}ArcCloseType;</PRE>
<P>この構造は、円弧を塗り潰すときに使用されます。</P>
</DIV>
<DIV>
          <A NAME="S_2.htm_IX_AreaAttr"></A>
          <A NAME="S_2.htm_IX_AA_&ldots;"></A>
        <H1 CLASS="refHeading">AreaAttr</H1>
<PRE CLASS="syntax">typedef struct{byte AA_colorFlag;RGBValue AA_color;SysDrawMask AA_mask;ColorMapMode AA_mapMode;}AreaAttr;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2.htm_IX_ArgumentStackElement"></A>
          <A NAME="S_2.htm_IX_ASE_&ldots;"></A>
        <H1 CLASS="refHeading">ArgumentStackElement</H1>
<PRE CLASS="syntax">typedef struct{EvalStackArgumentType ASE_type;EvalStackArgumentData ASE_data;}ArgumentStackElement;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2.htm_IX_BBFixed"></A>
          <A NAME="S_2.htm_IX_BBF_&ldots;"></A>
        <H1 CLASS="refHeading">BBFixed</H1>
<PRE CLASS="syntax">typedef struct{byte BBF_frac;byte BBF_int;}BBFixed;</PRE>
<P>この構造体は、8.8の固定小数点数を表します。</P>
</DIV>
<DIV>
          <A NAME="S_2.htm_IX_BBFixedAsWord"></A>
        <H1 CLASS="refHeading">BBFixedAsWord</H1>
<PRE CLASS="syntax">typedef word BBFixedAsWord;</PRE>
<P>この構造体は、8.8の固定小数点数を表します。</P>
</DIV>
<DIV>
          <A NAME="S_2.htm_IX_Bitmap"></A>
          <A NAME="S_2.htm_IX_B_&ldots;"></A>
          <A NAME="S_2.htm_IX_BMT_MASK:bitmaps with masks"></A>
          <A NAME="S_2.htm_IX_BMC_PACKBITS:uncompressing"></A>
          <A NAME="S_2.htm_IX_PackBits compression"></A>
        <H1 CLASS="refHeading"><A NAME="S_2.htm_72157"></A>ビットマップ(Bitmap)</H1>
<PRE CLASS="syntax">typedef struct{word B_width;/*ビットマップピクセル内*/word B_height;/*ビットマップピクセル内*/byte B_compact;/*BMCompact値*/byte B_type;/*BMFormat BMType値*/}Bitmap;</PRE>
<P>このデータ構造体は、単純なグラフィックスビットマップに関する情報を提供します。 通常は、ビットマップデータセットのヘッダーとして機能します。</P>
<P>ビットマップデータ自体は、スキャンラインに編成されます。 ビットマップにマスクがある場合(BMT_MASKビットが<CODE>Bタイプ</CODE>フィールド)、スキャンラインの最初の情報がそのマスク情報になります。 走査ライン内の各ピクセルに対して1ビットのマスク情報が存在する(すなわち、ビットマップ幅に等しいビット数)。 スキャンラインの実際のビットマップデータは、次のバイト境界から始まります。 各ピクセルに対して、カラーデータのビット数があります。この数は<CODE>BMFormat</CODE>の<CODE>Bタイプ</CODE>見出しページを開きます。 次のスキャンラインのデータは、次のバイト境界から始まります。</P>
<P>したがって、「x」の逆数を表す7x7のビットマップが表示されます。</P>
<PRE>(ビットマップ){7, 7, BMC_UNCOMPACTED, BMF_MONO};(バイト)[]{0x82, /*10000010*/0x44, /*01000100*/0x28, /*00101000*/0x10, /*00010000*/0x28, /*00101000*/0x44, /*01000100*/0x82};/*10000010*/</PRE>
<P>3x3カラーの「-」シェイプと「+」シェイプのマスクが表示される場合があります。</P>
<PRE>(ビットマップ){3, 3, BMC_UNCOMPACTED, (BMF_4 BIT BMT_MASK)};(バイト)[]{/*スキャンライン1:*/0x40, /*マスク:010*/0, 0/*データ:000*//*スキャンライン2:*/0xE0, /*マスク:111*/0x43, 0x20, /*データ:432*//*スキャンライン3:*/0x40, /*マスク:010*/0, 0};/*データ:000*/</PRE>
<P>標準のBMC_PackBits圧縮を使用する場合、ビットマップのマスク(存在する場合)とカラーデータは、Macintosh PackBits標準を使用して圧縮されます。 このシステムでは、スキャンラインのデータを解凍するには、次のループに従います。</P>
<OL>
<LI>バイトを読み込みます。</LI>
<LI FIXME_NumListOther>手順(1)で読み込んだバイトが-1から-127の間であれば<EM>次の</EM>バイトをコピーし、ターゲットバッファに+2から+128回コピーします。</LI>
<LI FIXME_NumListOther>(1)で読み込んだバイトが+1~+127バイトの場合は、次の1~127バイトを読み込み、ターゲットバッファにコピーします。</LI>
<LI FIXME_NumListOther>手順(1)で読み込んだバイトが-128の場合は無視します。</LI>
<LI FIXME_NumListOther>次のバッチのデータを読み込む準備ができました。手順(1)に戻ります。</LI>
</OL>
<P>したがって、一致するマスクを持つ16x4カラーの「=」が表示されます。</P>
<PRE>(ビットマップ){15, 3, BMC_PACKBITS, BMF_4 BIT BMT_MASK};(バイト)[]{/*スキャンライン1:*//*マスク:0 xffを2回繰り返し*/0 xff,0 xff,/*データ:0x14を16回繰り返し*/0xf0, 0x14, /*スキャンライン2:*//*マスク:0x00を2回繰り返し*//*データ:0x00を16回繰り返し*//*合計:0x00を18回繰り返し*/0 xee,0x00, /*スキャンライン3:*//*マスク:0x00を2回繰り返し*//*データ:0x00を16回繰り返し*//*合計:0x00を18回繰り返し*/0 xee,0x00, /*スキャンライン4:*/</PRE>
<PRE>/*マスク:0 xffを2回繰り返す*/</PRE>
<PRE>0 xff、0 xff</PRE>
<PRE>/*データ:0x14を16回繰り返し*/</PRE>
<PRE>0xf0, 0x14}と入力します。</PRE>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_3.htm#IX_CBitmap">Cビットマップ</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="S_3.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_BitmapMode"></A>
          <A NAME="S_3.htm_IX_BM_&ldots;"></A>
        <H1 CLASS="refHeading">ビットマップモード</H1>
<PRE CLASS="syntax">typedef WordFlags BitmapMode;#define BM_EDIT_MASK 0x0002#define BM_CLUSTERED_DITHER 0x0001</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_BlockFromTransferBlockID() macro"></A>
        <H1 CLASS="refHeading">BlockFromTransferBlockID</H1>
<PRE CLASS="syntax">VMBlockHandle BlockFromTransferBlockID(id);TransferBlockID id;</PRE>
<P>このマクロは、指定した<CODE>TransferBlockID</CODE>値を入力します。</P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_BlockIDFromFileAndBlock() macro"></A>
        <H1 CLASS="refHeading">BlockIDFromFileAndBlock</H1>
<PRE CLASS="syntax">TransferBlockID BlockIDFromFileAndBlock(f、b);VMFileHandle f;VMBlockHandle b;</PRE>
<P>このマクロは<CODE>TransferBlockID</CODE>値を返します。</P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_BLTMode"></A>
        <H1 CLASS="refHeading">BLTMode</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_37.htm#IX_GrBitBlt()">GrBitBlt()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_BMCompact"></A>
          <A NAME="S_3.htm_IX_BMC_&ldots;"></A>
        <H1 CLASS="refHeading">BMCompact</H1>
<PRE CLASS="syntax">typedef ByteEnum ByteCompact;#define BMC_UNCOMPACTED 0#define BMC_PACKBITS 1#define BMC_USER_DEFINED 0x80</PRE>
<P>このデータ構造は、グラフィックスビットマップの保存に使用される圧縮の種類を指定するために使用されます。</P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_BMDestroy"></A>
        <H1 CLASS="refHeading">BMDestroy</H1>
<P>のエントリを参照してください<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyBitmap()">GrDestroyBitmap()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_BMFormat"></A>
          <A NAME="S_3.htm_IX_BMF_&ldots;"></A>
        <H1 CLASS="refHeading">BMFormat</H1>
<PRE CLASS="syntax">typedef ByteEnum BMFormat#define BMF_MONO 0#define BMF_4 BIT 1#define BMF_8 BIT 2#define BMF_24 BIT 3#define BMF_4 CMYK 4</PRE>
<P>この列挙型は、グラフィックスビットマップの深さを決定します。</P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_BMType"></A>
          <A NAME="S_3.htm_IX_BMT_&ldots;"></A>
        <H1 CLASS="refHeading">BMタイプ</H1>
<PRE CLASS="syntax">typedef ByteFlags BMType;#define BMT_PALETTE 0x40#define BMT_HUGE 0x20#define BMT_MASK 0x10#define BMT_COMPLEX 0x08#define BMT_FORMAT 0x07</PRE>
<P>この構造体は、グラフィックスビットマップに関するさまざまな情報を格納するために使用されます。</P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_Boolean"></A>
        <H1 CLASS="refHeading">ブール型(Boolean)</H1>
<PRE CLASS="syntax">typedef wordブール値;</PRE>
<P>ブール値はtrue/falseの値を表します。 ブール値が<EM>偽の</EM>の場合は0と評価され、それ以外の場合は0以外と評価されます。</P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_Button"></A>
          <A NAME="S_3.htm_IX_BUTTON_&ldots;"></A>
        <H1 CLASS="refHeading">ボタン(Button)</H1>
<PRE CLASS="syntax">typedef ByteEnumボタン;#define BUTTON_0 0#define BUTTON_1 1#define BUTTON_2 2#define BUTTON_3 3</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_ButtonInfo"></A>
          <A NAME="S_3.htm_IX_BI_&ldots;"></A>
        <H1 CLASS="refHeading">ButtonInfo</H1>
<PRE CLASS="syntax">typedef ByteFlags ButtonInfo;#define BI_PRESS 0x80#define BI_DOUBLE_PRESS 0x40#define BI_B3_DOWN 0x20#define BI_B2_DOWN 0x10#define BI_B1_DOWN 0x08#define BI_B0_DOWN 0x04#define BI_BUTTON 0x03</PRE>
<P>この構造体には、マウスのボタンの状態が含まれます。</P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_byte"></A>
        <H1 CLASS="refHeading">バイト</H1>
<PRE CLASS="syntax">typedef unsigned char byte;符号なし文字バイト</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_ByteEnum"></A>
        <H1 CLASS="refHeading">ByteEnum</H1>
<PRE CLASS="syntax">typedefバイトByteEnum;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_ByteFlags"></A>
        <H1 CLASS="refHeading">ByteFlags</H1>
<PRE CLASS="syntax">typedefバイトByteFlags;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_CallbackType"></A>
          <A NAME="S_3.htm_IX_CT_&ldots;  (CallbackType type)"></A>
        <H1 CLASS="refHeading">CallbackType</H1>
<PRE CLASS="syntax">typedef ByteEnum CallbackType;#define CT_FUNCTION_TO_TOKEN 0#define CT_NAME_TO_TOKEN 1#define CT_CHECK_NAME_EXISTS 2#define CT_CHECK_NAME_SPACE 3#define CT_EVAL_FUNCTION 4#define CT_LOCK_NAME 5#define CT_UNLOCK 6#define CT_FORMAT_FUNCTION 7#define CT_FORMAT_NAME 8#define CT_CREATE_CELL 9#define CT_EMPTY_CELL 10#define CT_NAME_TO_CELL 11#define CT_FUNCTION_TO_CELL 12#define CT_DEREF_CELL 13#define CT_SPECIAL_FUNCTION 14</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3.htm_IX_CBitmap"></A>
          <A NAME="S_3.htm_IX_CB_&ldots;"></A>
        <H1 CLASS="refHeading">Cビットマップ</H1>
<PRE CLASS="syntax">typedef struct{Bitmap CB_simple;word CB_startScan;word CB_numScans;word CB_devInfo;word CB_data;word CB_palette;word CB_xres;word CB_yres;}CBitmap;を参照してください。</PRE>
<P>CBitmap構造体には、「複雑な」ビットマップの情報が含まれています。 CBitmap構造体を使用して、解像度情報、パレット、またはマスクを追跡する必要があるビットマップを保持します。</P>
</DIV>
<HR>
          <A NAME="S_4.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_4.htm_IX_CellFunctionParameterFlags"></A>
          <A NAME="S_4.htm_IX_CFPF_&ldots;"></A>
        <H1 CLASS="refHeading">CellFunctionParameterFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags CellFunctionParameterFlags;#define CFPF_DIRTY 0x80/*アプリケーションはこれを読み込んだり変更したりできます。 */#define CFPF_NO_FREE_COUNT 0x07(CFPF_NO_FREE_COUNT 0 x 02を定義)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_4.htm_IX_CellFunctionParameters"></A>
          <A NAME="S_4.htm_IX_CFP_&ldots;"></A>
          <A NAME="S_4.htm_IX_N_ROW_BLOCKS"></A>
        <H1 CLASS="refHeading">CellFunctionParameters</H1>
<PRE CLASS="syntax">typedef struct{CellFunctionParameterFlags CFP_flags;VMFileHandle CFP_file;/*セルを含むファイル*/VMBlockHandle CFP_rowBlocks[N_ROW_BLOCKS];}CellFunctionParameters;</PRE>
<P>この構造体は、セルファイルに関する詳細をセルライブラリルーチンに渡すために使用されます。 のデータの一部<CODE>CellFunctionParameters</CODE>構造はアプリケーションに対して不透明であり、他の構造はアプリケーションによって検査または変更される可能性があります。 の<CODE>CellFunctionParameters</CODE>構造体には、次のフィールドがあります。</P>
<DL>
<DT>
          <CODE>CFPフラグ</CODE>
        </DT><DD>セル・ライブラリは、このバイトをその他のブックキーピングに使用します。 構造を作成するときに、このフィールドをゼロに初期化します。 チェックまたは変更する必要があるフラグは1つだけです。<CODE>CFPFダーティ</CODE>このビットは、セルライブラリルーチンが<CODE>CellFunctionParameters</CODE>構造体を再保存する必要があることを示します。 保存した後、このビットをクリアできます。</DD>
<DT>
          <CODE>CFPファイル</CODE>
        </DT><DD>このフィールドには、セルファイルのVMファイルハンドルが含まれている必要があります。 このフィールドは、ファイルを開くたびに設定する必要があります。</DD>
<DT><CODE>CFP_rowBlocks</DT><DD></CODE>このフィールドはVMブロックハンドルの配列であり、既存の行ブロックまたは潜在的な行ブロックごとに1つずつ存在します。 この配列の長さはN_ROW_BLOCKS(<STRONG CLASS="fileName">セル.h</STRONG>)をクリックします。 セルファイルを作成するときは、これらのハンドルをすべてゼロに初期化します。その後は、このフィールドにアクセスしたり、このフィールドを変更しないでください。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
<P CLASS="refField"><STRONG>警告:</STRONG>セルライブラリは<CODE>CellFunctionParameters</CODE>通話中に動かないようにするための構造。 したがって、セル・ファイル内でDB項目として割り当てる場合は<EM>しない</EM>構造をグループ化されていない項目にします。</P>
</DIV>
<DIV>
          <A NAME="S_4.htm_IX_CellRange"></A>
          <A NAME="S_4.htm_IX_CR_&ldots;  (CellRange structure)"></A>
        <H1 CLASS="refHeading">セル範囲</H1>
<PRE CLASS="syntax">typedef struct{CellReference CR_start;CellReference CR_end;}CellRange;と入力します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_4.htm_IX_CellReference"></A>
          <A NAME="S_4.htm_IX_CR_&ldots;  (CellReference structure)"></A>
        <H1 CLASS="refHeading">セル参照</H1>
<PRE CLASS="syntax">typedef struct{CellRowColumn CR_row;CellRowColumn CR_column;}CellReference;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_4.htm_IX_CellRowColumn"></A>
          <A NAME="S_4.htm_IX_CRC_&ldots;"></A>
        <H1 CLASS="refHeading">CellRowColumn</H1>
<PRE CLASS="syntax">typedef WordFlags CellRowColumn;#define CRC_ABSOLUTE 0x8000#define CRC_VALUE 0x7fff</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_4.htm_IX_CharacterSet"></A>
          <A NAME="S_4.htm_IX_CS_&ldots;"></A>
          <A NAME="S_4.htm_IX_VC_IS&ldots;"></A>
        <H1 CLASS="refHeading">文字セット</H1>
<PRE CLASS="syntax">typedef ByteEnum CharacterSet;#define CS_BSW 0#define CS_CONTROL 0 xff#define CS_UI_FUNCSS 0 xfe#define VC_ISANSI CS_BSW#define VC_ISCTRL CS_CONTROL#define VC_ISUI CS_UI_FUNCSS</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_4.htm_IX_CharFlags"></A>
          <A NAME="S_4.htm_IX_CF_&ldots;  (CharFlags)"></A>
        <H1 CLASS="refHeading">CharFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags CharFlags;#define CF_STATE_KEY 0x80#define CF_EXTENDED 0x10#define CF_TEMP_ACCENT 0x08#define CF_FIRST_PRESS 0x04#define CF_REPEAT_PRESS 0x02#define CF_RELEASE 0x01</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_5.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_5.htm_IX_Chars"></A>
          <A NAME="S_5.htm_IX_C_&ldots;  (Chars type)"></A>
        <H1 CLASS="refHeading">文字</H1>
<PRE CLASS="syntax">typedef ByteEnum文字;#define C_NULL 0x0/*NULL*/#define C_CTRL_A 0x1/*&lt;ctrl>-A*/#define C_CTRL_B 0x2/*&lt;ctrl>-B*/#define C_CTRL_C 0x3/*&lt;ctrl>-C*/#define C_CTRL_D 0x4/*&lt;ctrl>-D*/#define C_CTRL_E 0x5/*&lt;ctrl>-E*/#define C_CTRL_F 0x6/*&lt;ctrl>-F*/#define C_CTRL_G 0x7/*&lt;ctrl>-H*/#define C_TAB 0x9/*TAB*/#define C_LINEFEED 0 xa/*LINEFEED*/#define C_CTRL_K 0 xb/*&lt;ctrl>-K*/#define C_SHIFT_L 0 xc/*&lt;ctrl>-L*/#define C_ENTER 0 xd/*ENTER or CR*/#define C_SHIFT_OUT 0 xe/*&lt;ctrl>-N*/#define C_SHIFT_IN 0 xf/*&lt;ctrl>-O*/#define C_CTRL_Q 0x11/*&lt;ctrl>-Q*/#define C_CTRL_R 0x13/*&lt;ctrl>-U*/#define C_CTRL_V 0x16/*&lt;ctrl>-V*/#define C_CTRL_W 0x17/*&lt;ctrl>-W*/#define C_CTRL_Y 0x19/*&lt;ctrl>-Y*/#define C_CTRL_Z 0x1a/*&lt;ctrl>-Z*/#define C_ESCAPE 0x1b/*ESC*/#define C_NULL_WIDTH 0x19/*null width character*/#define C_GRAPHIC 0x1a/*テキスト内のグラフィック。 */#define C_THINSPACE 0x1b/*1/4 width space*/#define C_ENSPACE 0x1c/*En-space, fixed width*/#define C_EMSPACE 0x1d/*Em-space, fixed width. */#define C_NONBRKHYPHEN 0x1e/*改行しないハイフン。 */#define C_OPTHYPHEN 0x1f/*オプションのハイフンで、末尾にのみ描画されます*/#define C_SPACE`&#39;#define C_感嘆符`!&#39;#define C_QUOTE`&quot;&#39;#define C_NUMBER_SIGN`#&#39;#define C_DOLLAR_SIGN`$&#39;#define C_PERCENT`%&#39;#define C_AMPERSAND`&amp;&#39;#define C_SNG_QUOTE 0x27#define C_LEFT_PAREN`(&#39;#define C_RIGHT_PAREN`)&#39;#define C_ASTERISK`*&#39;#define C_PLUS`+&#39;#define C_COMMA`,&#39;#define C_MINUS`-&#39;#define C_PERIOD&#39;</PRE>
<PRE CLASS="syntax">#define C_NUL C_NULL#define C_STX C_CTRL_B#define C_ETX C_CTRL_C#define C_BEL C_CTRL_G#define C_BS C_CTRL_H#define C_HT C_CTRL_I#define C_VT C_CTRL_K#define C_FF C_CTRL_L#define C_SO C_CTRL_N#define C_SI C_CTRL_O#define C_DC1 C_CTRL_Q#define C_DC2 C_CTRL_R#define C_DC3 C_CTRL_S#define C_DC4 C_CTRL_T#define C_CAN C_CTRL_X#define C_EM C_CTRL_Y#define C_ESC C_ESCAPE/**代替名*/</PRE>
<PRE CLASS="syntax">#define C_CR C_ENTER#define C_CTRL_M C_ENTER#define C_CTRL_I C_TAB#define C_CTRL_J C_LINEFEED#define C_LF C_LINEFEED#define C_CTRL_N C_SHIFT_OUT#define C_CTRL_O C_SHIFT_IN#define C_FS C_ENSPACE#define C_FIELD_SEP C_FS#define C_HYPHEN C_MINUS#define C_GRAVE C_BACKQUOTE#define C_PARTIAL_DIFF C_L_DELTA#define C_SUM C_U_SIGMA#define C_PRODUCT C_U_PI#define C_RADICAL C_ROOT#define C_LOZENGE C_DIAMONDBULLET</PRE>
<P>テキスト文字は、標準のCタイプの文字またはGEOSタイプの文字で表すことができます。 その違いはデバッグに現れます。 文字列の値をcharとして出力する場合、デバッガはASCIIテキストを出力します。 文字列がCharsとして扱われる場合、デバッガは定数名を出力します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">文字h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="S_6.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_6.htm_IX_ChunkArrayHeader"></A>
        <H1 CLASS="refHeading">ChunkArrayHeader</H1>
<PRE CLASS="syntax">typedef struct{word CAH_count;/*チャンク配列内の要素数*/word CAH_elementSize;/*各要素のサイズ(バイト単位)*/word CAH_curOffset;/*内部使用のみ*/word CAH_offset;/*チャンクの先頭から最初の要素までのオフセット*/}ChunkArrayHeader;</PRE>
<P>すべてのチャンク配列は<CODE>ChunkArrayHeader</CODE>この構造体には、チャンク配列に関する情報が含まれています。 アプリケーションは<CODE>ChunkArrayHeader</CODE>;チャンク配列ルーチンだけがこれを行うべきである。 ただし、アプリケーションは必要に応じてヘッダーを調べることができます。</P>
<P CLASS="refField"><STRONG>内容:</STRONG>には、4つの単語長フィールドがあります。<CODE>ChunkArrayHeader</CODE>キーを押します</P>
<DL>
<DT>キャー<CODE>カウント(_C)</DT><DD></CODE>このワードには、チャンク配列内の要素の数が含まれます。</DD>
<DT>キャー<CODE>エレメントサイズ(_E)</DT><DD></CODE>このワードには、各要素のサイズ(バイト単位)が含まれます。 エレメントのサイズが可変の場合<CODE>CAHエレメントサイズ</CODE>は0になります。</DD>
<DT>キャー<CODE>_curOffset</DT><DD></CODE>この単語は<CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnum()">ChunkArrayEnum()</A></CODE>簿記のためです</DD>
<DT>キャー<CODE>おふせっとオフセット</DT><DD></CODE>これは、チャンクの先頭から配列の最初の要素までのオフセットです。</DD>
</DIV>
<DIV>チャンクハンドルは、ローカルメモリヒープへのオフセットである。 現在のを見つけるには<A NAME="S_6.htm_IX_ChunkHandle"></A></DL>
<H1 CLASS="refHeading">ChunkHandle</H1>
<PRE CLASS="syntax">typedef word ChunkHandle;</PRE>
<P>LMemヒープ内のチャンクの場所、ヒープのセグメントアドレスとチャンクハンドルを結合します。 この場所から、チャンク自体の現在のオフセットを読み取ることができます。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_2b.htm#IX_optr">オプション</A></CODE><CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_6.htm_IX_ChunkMapList"></A>
        <H1 CLASS="refHeading">ChunkMapList</H1>
<PRE CLASS="syntax">typedef struct{word CML_source;word CML_dest;}ChunkMapList;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_6.htm_IX_ClassFlags"></A>
          <A NAME="S_6.htm_IX_CLASSF_&ldots;"></A>
        <H1 CLASS="refHeading">ClassFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ClassFlags;#define CL SF_HAS_DEFAULT 0x80#define CL SF_MASTER_CLASS 0x40#define CL SF_VARIANT_CLASS 0x20#define CL SF_DISCARD_ON_SAVE 0x10#define CL SF_NEVER_SAVED 0x08#define CL SF_HAS_RELOC 0x04#define CL SF_C_HANDLERS 0x02</PRE>
<P>このレコードは<CODE>ClassStruct</CODE>構造の<CODE>クラスフラグ</CODE>見出しページを開きます。 これらのフラグは内部的なもので、直接設定したり取得したりすることはできません。<CODE>@クラス</CODE>」を参照してください。</P>
</DIV>
<DIV>
          <A NAME="S_6.htm_IX_ClassStruct"></A>
          <A NAME="S_6.htm_IX_Class_&ldots;"></A>
        <H1 CLASS="refHeading">ClassStruct</H1>
<PRE CLASS="syntax">typedef struct_ClassStruct{struct_ClassStruct*Class_superClass;/*スーパークラスポインタ*/word Class_masterOffset;/*チャンク内のマスターオフセットへのオフセット*/word Class_methodCount;/*このクラス内のメソッドの数*/word Class_instanceSize;/*マスターグループ全体のサイズ*/word Class_vdRelocTable;/*vardata再配置テーブルへのオフセット*/word Class_relocTable;/*再配置テーブルへのオフセット*/ClassFlags Class_flags;/*ClassFlagsのレコード*/byte Class_masterMessages;/*最適化のための内部フラグ*/}ClassStruct;</PRE>
<P>これはクラスを定義する構造体です。 これは内部的なものであり、カーネルとUI以外ではほとんど使用されません。</P>
</DIV>
<DIV>
          <A NAME="S_6.htm_IX_ClipboardItemFlags"></A>
          <A NAME="S_6.htm_IX_CIF_QUICK"></A>
          <A NAME="S_6.htm_IX_TIF_NORMAL"></A>
        <H1 CLASS="refHeading">ClipboardItemFlags</H1>
<PRE CLASS="syntax">typedef WordFlags ClipboardItemFlags;#define CIF_QUICK 0x4000#define TIF_NORMAL 0x0000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_6.htm_IX_ClipboardItemFormat"></A>
          <A NAME="S_6.htm_IX_CIF_&ldots;"></A>
        <H1 CLASS="refHeading">ClipboardItemFormat</H1>
<PRE CLASS="syntax">typedef enum/*word*/{CIF_TEXT, CIF_GRAPHICS_STRING, CIF_FILES, CIF_SPREADSHEET, CIF_INK, CIF_GROBJ, CIF_GEODEX, CIF_BITMAP, CIF_SOUND_SYNTH, CIF_SOUND_SAMPLE}ClipboardItemFormat;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_6.htm_IX_ClipboardItemFormatID"></A>
        <H1 CLASS="refHeading">ClipboardItemFormatID</H1>
<PRE CLASS="syntax">typedef dword ClipboardItemFormatID;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_6.htm_IX_ClipboardItemFormatInfo"></A>
          <A NAME="S_6.htm_IX_CIFI_&ldots;"></A>
        <H1 CLASS="refHeading">ClipboardItemFormatInfo</H1>
<PRE CLASS="syntax">typedef struct{ClipboardItemFormatID CIFI_format;word CIFI_extra1;word CIFI_extra2;vmChain CIFI_vmChain;GeodeToken CIFI_renderer;}ClipboardItemFormatInfo;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_7.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_7.htm_IX_ClipboardItemHeader"></A>
          <A NAME="S_7.htm_IX_CIH_&ldots;"></A>
        <H1 CLASS="refHeading">ClipboardItemHeader</H1>
<PRE CLASS="syntax">typedef struct{optr CIH_owner;ClipboardItemFlags CIH_flags;ClipboardItemNameBuffer CIH_name;word CIH_formatCount;optr CIH_sourceID;FormatArray CIH_formats;dword CIH_reserved;}ClipboardItemHeader;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_7.htm_IX_ClipboardItemNameBuffer"></A>
          <A NAME="S_7.htm_IX_CLIPBOARD_ITEM_NAME_LENGTH"></A>
        <H1 CLASS="refHeading">ClipboardItemNameBuffer</H1>
<PRE CLASS="syntax">typedef char length[CLIPBOARD_ITEM_NAME_ClipboardItemNameBuffer+1];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_7.htm_IX_ClipboardQueryArgs"></A>
        <H1 CLASS="refHeading">ClipboardQueryArgs</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_7.htm_IX_ClipboardQuickNotifyFlags"></A>
          <A NAME="S_7.htm_IX_CQNF_&ldots;"></A>
        <H1 CLASS="refHeading">ClipboardQuickNotifyFlags</H1>
<PRE CLASS="syntax">typedef WordFlags ClipboardQuickNotifyFlags;#define CQNF_ERROR 0x8000#define CQNF_SOURCE_EQUAL_DEST 0x4000#define CQNF_MOVE 0x2000#define CQNF_COPY 0x1000#define CQNF_NO_OPERATION 0x0800#define CQNF_UNUSED 0x04ff</PRE>
<P>これらのフラグは、クイック転送操作の成功または失敗に関する情報を提供します。</P>
</DIV>
<DIV>
          <A NAME="S_7.htm_IX_ClipboardQuickTransferFeedback"></A>
          <A NAME="S_7.htm_IX_CQTF_&ldots;"></A>
        <H1 CLASS="refHeading">ClipboardQuickTransferFeedback</H1>
<PRE CLASS="syntax">typedef enum{CQTF_SET_DEFAULT, CQTF_CLEAR_DEFAULT, CQTF_MOVE, CQTF_COPY, CQTF_CLEAR}ClipboardQuickTransferFeedback;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_7.htm_IX_ClipboardQuickTransferFlags"></A>
        <H1 CLASS="refHeading">ClipboardQuickTransferFlags</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardStartQuickTransfer()">ClipboardStartQuickTransfer()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_7.htm_IX_ClipboardQuickTransferRegionInfo"></A>
        <H1 CLASS="refHeading">ClipboardQuickTransferRegionInfo</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardStartQuickTransfer()">ClipboardStartQuickTransfer()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_7.htm_IX_ClipboardRequestArgs"></A>
        <H1 CLASS="refHeading">ClipboardRequestArgs</H1>
<P>のエントリを参照してください<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRequestItemFormat()">ClipboardRequestItemFormat()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_7.htm_IX_CMYKTransfer"></A>
          <A NAME="S_7.htm_IX_CMYKT_&ldots;"></A>
        <H1 CLASS="refHeading">CMYKTransfer</H1>
<PRE CLASS="syntax">typedef struct{byte CMYKT_cyan[256];byte CMYKT_magenta[256];byte CMYKT_yellow[256];byte CMYKT_black[256];}CMYKTransfer;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_8.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_8.htm_IX_C_&ldots;  (Color type)"></A>
          <A NAME="S_8.htm_IX_Color"></A>
        <H1 CLASS="refHeading">カラー(Color)</H1>
<PRE CLASS="syntax"> </PRE>
<P>の<CODE>カラー(Color)</CODE>列挙型は、カラーインデックス値のエンコードに使用されます。 通常、定数名はカラーの構成に関するヒントを提供します。 しかし、アプリケーションが洗練されたパレット操作を実行した場合、C_REDは実際には例えば緑の色合いに対応することがある。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">色.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="S_9.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_9.htm_IX_CF_&ldots;  (ColorFlag type)"></A>
          <A NAME="S_9.htm_IX_ColorFlag"></A>
        <H1 CLASS="refHeading">カラーフラグ</H1>
<PRE CLASS="syntax">typedef ByteEnum ColorFlag;#define CF_INDEX 0#define CF_GRAY 1#define CF_SAME 2#define CF_RGB 0x80</PRE>
<P>色に関連するいくつかのコマンドでは、さまざまな形式の色を使用できます。 の<CODE>カラーフラグ</CODE>列挙型は、色の記述方法を指定するために使用されます。 の<CODE>カラーフラグ</CODE>は通常<CODE>カラークアッド</CODE>を参照してください。<CODE>カラークアッド</CODE>を使用して色指定を解釈する方法については<CODE>カラーフラグ</CODE>秒</P>
</DIV>
<DIV>
          <A NAME="S_9.htm_IX_ColorMapMode"></A>
          <A NAME="S_9.htm_IX_CMM_&ldots;"></A>
          <A NAME="S_9.htm_IX_LAST_MAP_MODE"></A>
        <H1 CLASS="refHeading">ColorMapMode</H1>
<PRE CLASS="syntax">typedef ByteFlags ColorMapMode;#define CMM_ON_BLACK 0x04/*黒で描画する場合はこのビットを設定*/#define CMM_MAP_TYPE 0x01/*CMT_CLOSESTまたはCMT_DITHER)*/#define LAST_MAP_MODE(CMM_MAP_TYPE CMM_ON_BLACK)</PRE>
<P>この構造体は、システムがパレットにないカラーをシミュレートする方法を定義します。 マップタイプがCMT_CLOSESTの場合、使用可能な最も近いカラーが使用されます。 マップタイプがCMT_DITHERの場合、システムはディザリングされたパターンで2つ以上の近似カラーを混合します。 黒い背景に対して描画する場合は、CMM_ON_BLACKフラグを設定できます。</P>
</DIV>
<DIV>
          <A NAME="S_9.htm_IX_ColorQuad"></A>
          <A NAME="S_9.htm_IX_CQ_&ldots;"></A>
        <H1 CLASS="refHeading">カラークアッド</H1>
<PRE CLASS="syntax">typedef struct{byte CQ_redOrIndex;ColorFlag CQ_info;byte CQ_green;byte CQ_blue;}ColorQuad;と入力します。</PRE>
<P>この構造は色を表します。 の<CODE>CQ情報</CODE>フィールドは、カラーの記述方法を決定します。</P>
<P>infoフィールドがCF_INDEXの場合、カラーはインデックス(ウィンドウのパレット内の位置)によって指定されます。 インデックスは<CODE>CQ_redOrIndex</CODE>フィールド<CODE>CQ_緑</CODE>および<CODE>CQ_青</CODE>フィールドはこの仕様では意味がありません。</P>
<P>infoフィールドがCF_RGBの場合、カラーはRGB(赤、緑、青)コンポーネントで指定されます。<CODE>CQ_redOrIndex</CODE>カラーの赤コンポーネント(0～255の数値)を格納します。 の<CODE>CQ_緑</CODE>および<CODE>CQ_青</CODE>フィールドには、それぞれカラーの緑と青の成分が含まれます。</P>
<P>infoフィールドがCF_GRAYの場合、カラーはグレースケールで表されます。 これは基本的に、赤、緑、青のコンポーネントが等しいRGBカラーを記述するための最適化された方法です。 の<CODE>CQ_redOrIndex</CODE>フィールドには、明るさ(0～255の数値)が入ります。 の<CODE>CQ_緑</CODE>および<CODE>CQ_青</CODE>フィールドは無視されます。</P>
<P>ハッチングパターンを定義するときに、CF_SAME情報フィールドを使用できます。 これは、作図時にハッチング線に「同じ」色を使用する必要があることを意味します。 つまり、テキストをハッチングする場合はテキストの色が使用され、領域を塗りつぶす場合は領域の色が使用されます。 の<CODE>CQ_redOrIndex</CODE><CODE>CQ_緑</CODE>、および<CODE>CQ_青</CODE>フィールドはすべて無視されます。</P>
</DIV>
<DIV>
          <A NAME="S_9.htm_IX_ColorQuadAsDWord"></A>
        <H1 CLASS="refHeading">ColorQuadAsDWord</H1>
<PRE CLASS="syntax">typedef dword ColorQuadAsDWord;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_9.htm_IX_ColorTransfer"></A>
          <A NAME="S_9.htm_IX_CT_data[]"></A>
        <H1 CLASS="refHeading">ColorTransfer</H1>
<PRE CLASS="syntax">typedef struct{RGBDelta CT_data[125];}ColorTransfer;</PRE>
<P>この構造は、次の5x5x5マトリックスで構成されています。<CODE>RGBDelta</CODE>構造。 これは、特定のデバイスに表示するときに色に対して行う調整の種類を指定するために使用されます。 たとえば、一部のカラープリンタでは、生のRGB値によって提示された量のインクを使用しようとすると、特定の色が消去されます。 の<CODE>ColorTransfer</CODE>したがって、構造は、「ファッジ係数」の配列を保持して、生のRGB値が示すよりも多くのまたは少ないインクを使用するようにプリンタに指示するのに役立つ。</P>
</DIV>
<DIV>
          <A NAME="S_9.htm_IX_ColorTransferData"></A>
          <A NAME="S_9.htm_IX_CTD_&ldots;"></A>
        <H1 CLASS="refHeading">ColorTransferData</H1>
<PRE CLASS="syntax">typedef union{MonoTransfer CTD_mono;RGBTransfer CTD_rgb;CMYKTransfer CTD_cmyk;}ColorTransferData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_9.htm_IX_ColorTransferType"></A>
          <A NAME="S_9.htm_IX_CTT_&ldots;"></A>
        <H1 CLASS="refHeading">ColorTransferType</H1>
<PRE CLASS="syntax">typedef ByteEnum ColorTransferType;#define CTT_MONO 0#define CTT_RGB 1#define CTT_CMYK 2</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_9.htm_IX_CommonParameters"></A>
          <A NAME="S_9.htm_IX_CP_&ldots;"></A>
        <H1 CLASS="refHeading">共通パラメータ</H1>
<PRE CLASS="syntax">typedef struct{word CP_row;word CP_column;word CP_maxRow;word CP_maxColumn;void*CP_callback;void*CP_cellParams;/*SpreadsheetClassのインスタンスへのptr*/}CommonParameters;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_9.htm_IX_CompChildFlags"></A>
          <A NAME="S_9.htm_IX_CCF_&ldots;"></A>
          <A NAME="S_9.htm_IX_CCO_&ldots;"></A>
        <H1 CLASS="refHeading">CompChildFlags</H1>
<PRE CLASS="syntax">typedef WordFlags CompChildFlags;#define CCF_MARK_DIRTY 0x8000#define CCF_REFERENCE 0x7fff#define CCO_FIRST 0x0000#define CCO_LAST 0x7fff#define CCF_REFERENCE_OFFSET 0</PRE>
<P>オブジェクトツリーで子を追加、移動、または削除するときに使用されるレコード。 レコードには、次のように1つのフラグと1つの値があります。</P>
<DL>
<DT>CCFマークダーティ</DT><DD>操作の最後にオブジェクトをダーティとしてマークするかどうかを示すフラグ。</DD>
<DT>CCF参照</DT><DD>子番号。子を追加または移動する場合、これは新しいオブジェクトが挿入される前の子番号です。 32768未満の任意の数値、または上記の2つの定数(CCO_FIRSTまたはCCO_LAST)のいずれかを指定できます。</DD>
</DIV>
</DL>
<HR>
          <A NAME="S_a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_a.htm_IX_CompSizeHintArgs"></A>
        <H1 CLASS="refHeading">CompSizeHintArgs</H1>
<PRE CLASS="syntax">typedef struct{SpecWidth CSHA_width;SpecHeight CSHA_height;剣CSHA_count;}CompSizeHintArgs;typedef WordFlags SpecWidth;#define SW_TYPE 0x8c00#define SW_DATA 0x03ff typedef WordFlags SpecHeight;#define SH_TYPE 0x8c00#define SH_DATA 0x03ff typedef ByteEnum SpecSizeType;#define SST_PIXELS 0x0000#define SST_COUNT 0x0400#define SST_PCT_OF_FIELD_WIDTH 0x0800#define SST_PCT_OF_FIELD_HEIGHT 0x0c00#define SST_AVG_CHAR_WIDTHS 0x1000#define SST_WIDE_CHAR_WIDTHS 0x1400#define SST_LINES_OF_TEXT 0x1800#define PCT_0 0x000#define PCT_5 0x033#define PCT_10 0x066#define PCT_15 0x099#define PCT_20 0x0cc#define PCT_25 0x100#define PCT_30 0x166#define PCT_40 0x199#define PCT_45 0x1cc#define PCT_50 0x200#define PCT_55 0x233#define PCT_60 0x266#define PCT_70 0x2cc#define PCT_75 0x300#define PCT_80 0x333#define PCT_85 0x366#define PCT_90 0x399#define PCT_95 0x3cc#define PCT_100 0x3ff 133 299</PRE>
<P>この構造体は、さまざまなUIガジェットのサイズを定義するために使用されます。<CODE>CSHA幅</CODE>ガジェットの幅の計算方法を決定します。<CODE>CSHA高さ</CODE>高さの計算方法を決定します。<CODE>CSHA数</CODE>は、複合オブジェクトの特定の行の子の数です(そのオブジェクトが子をラップしている場合)。</P>
<P>次の使用例は、コンポジットの初期サイズ(通常はGenPrimary)を画面の縦半分、横半分に設定します。</P>
<PRE>HINT_INITIAL_SIZE={SST_PCT_OF_FIELD_WIDTH PCT_50, SST_PCT_OF_FIELD_HEIGHT PCT_50, 0};のように指定します。</PRE>
<P>次の使用例は、コンポジットのサイズを高さ100ピクセル、幅200ピクセルに設定します。</P>
<PRE>HINT_FIXED_SIZE={SST_PIXELS 200, SST_PIXELS 100, 0};に設定します。</PRE>
<P>次の使用例は、コンポジットの最小サイズを、幅が平均10文字、高さが画面の高さの20%に設定します。</P>
<PRE>HINT_MINIMUM_SIZE={SST_AVG_CHAR_WIDTHS 10, SST_PCT_OF_FIELD_HEIGHT PCT_20, 0};(ヒント:最小サイズ={SST_AVG_CHAR_WIDTHS 10, SST_PCT_OF_FIELD_HEIGHT PCT_20, 0}</PRE>
</DIV>
<DIV>
          <A NAME="S_a.htm_IX_CountryType"></A>
          <A NAME="S_a.htm_IX_CT_&ldots;  (CountryType type)"></A>
        <H1 CLASS="refHeading">CountryType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{CT_UNITED_STATES=1, CT_CANADA, CT_UNITED_KINGH,CT_GERMANY, CT_FRANCE, CT_SPAIN, CT_ITALY, CT_DENMARK, CT_NETHERLANDS, }CountryType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_a.htm_IX_CRangeEnumParams"></A>
          <A NAME="S_a.htm_IX_CREP_&ldots;"></A>
        <H1 CLASS="refHeading">CRangeEnumParams</H1>
<PRE CLASS="syntax">typedef struct{RangeEnumParams CREP_params;void*CREP_locals;PCB(RANGE_ENUM_CALLBACK_RETURN_TYPE, CREP_callback, (RangeEnumCallbackParams));</PRE>
<PRE CLASS="syntax">}CRangeEnumParams;</PRE>
<P>の<CODE>CREP_コールバック</CODE>ルーチンは_pascalと宣言する必要があります。</P>
</DIV>
<DIV>
          <A NAME="S_a.htm_IX_CurrencyFormatFlags"></A>
          <A NAME="S_a.htm_IX_CFF_&ldots;"></A>
        <H1 CLASS="refHeading">CurrencyFormatFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags CurrencyFormatFlags;#define CFF_LEADING_ZERO 0x20#define CFF_SPACE_AROUND_SYMBOL 0x10#define CFF_USE_NEGATIVE_SIGN 0x08#define CFF_SYMBOL_BEFORE_NUMBER 0x04#define CFF_NEGATIVE_SIGN_BEFORE_NUMBER 0x02#define CFF_NEGATIVE_SIGN_BEFORE_SYMBOL 0x01</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_b.htm_IX_CustomDialogBoxFlags"></A>
          <A NAME="S_b.htm_IX_CDBF_&ldots;"></A>
        <H1 CLASS="refHeading">CustomDialogBoxFlags</H1>
<PRE CLASS="syntax">typedef WordFlags CustomDialogBoxFlags;#define CDBF_SYSTEM_MODAL 0x8000#define CDBF_DIALOG_TYPE 0x6000#define CDBF_INTERACTION_TYPE 0x1e00#define CDBF_DESTRUCTIVE_ACTION 0x0100#define CDBF_DIALOG_TYPE_OFFSET 13#define CDBF_INTERACTION_TYPE_OFFSET 9</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_b.htm_IX_CustomDialogType"></A>
          <A NAME="S_b.htm_IX_CDT_&ldots;"></A>
        <H1 CLASS="refHeading">CustomDialogType</H1>
<PRE CLASS="syntax">typedef ByteEnum CustomDialogType;#define CDT_QUESTION 0#define CDT_WARNING 1#define CDT_NOTIFICATION 2#define CDT_ERROR 3</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_b.htm_IX_DACPlayFlags"></A>
          <A NAME="S_b.htm_IX_DACPF_CATENATE"></A>
        <H1 CLASS="refHeading">DACPlayFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags DACPlayFlags;#define DACPF_CATENATE 0x80</PRE>
</DIV>
<DIV>
          <A NAME="S_b.htm_IX_DACReferenceByte"></A>
          <A NAME="S_b.htm_IX_DACRB_&ldots;"></A>
        <H1 CLASS="refHeading">DACReferenceByte</H1>
<PRE CLASS="syntax">typedef enum{DACRB_NO_REFERENCE_BYTE, DACRB_WITH_REFERENCE_BYTE}DACReferenceByte;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_b.htm_IX_DACSampleFormat"></A>
          <A NAME="S_b.htm_IX_DACSF_&ldots;"></A>
        <H1 CLASS="refHeading">DACSampleFormat</H1>
<PRE CLASS="syntax">typedef enum{DACSF_8_BIT_PCM, DACSF_2_TO_1_ADPCM, DACSF_3_TO_1_ADPCM, DACSF_4_TO_1_ADPCM}DACSampleFormat;</PRE>
<P>この構造体は、サンプリングされたサウンドを録音または再生するときに使用するサンプリングの種類を指定します。</P>
</DIV>
<DIV>
          <A NAME="S_b.htm_IX_DashPairArray"></A>
        <H1 CLASS="refHeading">DashPairArray</H1>
<P CLASS="refField">
          <STRONG>
            <STRONG>以下を参照してください。</STRONG>
          </STRONG>
          <CODE>線スタイル</CODE>
        </P>
</DIV>
<DIV>
          <A NAME="S_b.htm_IX_DACSF_&ldots;"></A>
        <H1 CLASS="refHeading">DataStoreCreateParams</H1>
<PRE CLASS="syntax">typedef struct{TCHAR*DSCP_name;DataStoreFlags DSCP_flags;FieldDescriptor*DSCP_keyList;word DSCP_keyCount;optr DSCP_notifObject;DataStoreOpenFlags DSCP_openFlags;}DataStoreCreateParams;</PRE>
<P>新しいデータストアを作成するときに指定する属性。</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">DatatStoreDataError</H1>
<PRE CLASS="syntax">typedef enum{DSDE_NO_ERROR, DSDE_INVALID_TOKEN, DSDE_DATASTORE_LOCKED, DSDE_ACCESS_DENIED, DSDE_WRITE_ERROR, DSDE_MEMORY_FULL, DSDE_INVALID_RECORD_ID, DSDE_INVALID_FIELD_ID, DSDE_INVALID_FIELD_NAME, DSDE_INVALID_FIELD_TYPE, DSDE_INVALID_FIELD_CATEGORY, DSDE_INVALID_FIELD_FLAGS, DSDE_RECORD_BUFFER_NOT_EMPTY, DSDE_RECORD_BUFFER_EMPTY, DSDE_INVALID_FIELD_DATA, DSDE_DATASTORE_READ_ONLY, DSDE_INVALID_RECORD_NUMBER, DSDE_INVALID_DATA_SIZE, DSDE_FIELD_DOES_NOT_EXIST, DSDE_RECORD_READ_ONLY, DSDE_RECORD_NOT_FOUND, DSDE_READ_ERROR, DSDE_EXCEEDS_BUFFER_SIZE, DSDE_TOO_MANY_FIELDS, DSDE_RECORD_IN_USE, DSDE_INVALID_BLOCK_HANDLE, DSDE_INVALID_CHUNK_HANDLE, DSDE_RECORD_LOCKED, }DataStoreDataError;</PRE>
<P>さまざまなDataStoreルーチンによって返されるエラー値。</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">DatatStoreError</H1>
<PRE CLASS="syntax">typedef enum{DSE_NO_ERROR, DSE_INVALID_TOKEN, DSE_DATASTORE_LOCKED, DSE_ACCESS_DENIED, DSE_WRITE_ERROR, DSE_MEMORY_FULL, DSE_INVALID_RECORD_ID, DSE_INVALID_NAME, DSE_INVALID_KEY_LIST, DSE_INVALID_FLAGS, DSE_DUPLICATE_FIELD_NAME, /*create params内の重複フィールド*/DSE_CREATE_ERROR, DSE_OPEN_ERROR, DSE_CLOSE_ERROR, DSE_UPDATE_ERROR, DSE_DATASTORE_EXISTS, DSE_DATASTORE_NOT_FOUND, DSE_DATASTORE_ALREADY_OPEN, DSE_PROTOCOL_ERROR, DSE_CLOSE_WITH_LOCKED_RECORD, DSE_INVALID_DATASTORE_FILE, DSE_PRIVATE_DATASTORE, DSE_BAD_SEARCH_PARAMS, DSE_CANNOT_SET_NEXT_RECORD_ID_SMALLER, DSE_NO_MATCH_FOUND, DSE_NO_MORE_RECORDS, /*last record reached*/}DataStoreError;</PRE>
<P>さまざまなDataStoreルーチンによって返されるエラー値。</P>
</DIV>
<HR>
          <A NAME="S_c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_c.htm_IX_DataStoreIndexCallbackParams"></A>
        <H1 CLASS="refHeading">DataStoreIndexCallbackParams</H1>
<PRE CLASS="syntax">typedef struct{FieldID DSICP_indexField;sortOrder DSICP_sortOrder;void*DSICP_cbData;RecordHeader*DSICP_rec1;RecordHeader*DSICP_rec2;}DataStoreIndexCallbackParams;</PRE>
<P>呼び出し側がコールバックに渡すパラメータのセット<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_DataStoreBuildIndex()">DataStoreBuildIndex()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_c.htm_IX_DatatStoreStructureError"></A>
        <H1 CLASS="refHeading">DatatStoreStructureError</H1>
<PRE CLASS="syntax">typedef enum{DSSE_NO_ERROR, DSSE_INVALID_TOKEN, DSSE_DATASTORE_LOCKED, DSSE_ACCESS_DENIED, DSSE_WRITE_ERROR, DSSE_MEMORY_FULL, DSSE_TOO_MANY_FIELDS, DSSE_INVALID_FIELD_ID, DSSE_INVALID_FIELD_NAME, DSSE_INVALID_FIELD_TYPE, DSSE_INVALID_FIELD_CATEGORY, DSSE_INVALID_FIELD_FLAGS, DSSE_RECORD_BUFFER_NOT_EMPTY, DSSE_FIELD_NAME_TOO_LONG, DSSE_FIELD_NAME_EXISTS, DSSE_FIELD_NOT_FOUND, DSSE_TIME_STAMP_CANNOT_BE_ADDED, DSSE_TIME_STAMP_CANNOT_BE_DELETED, DSSE_INVALID_SORT_ORDER, DSSE_NO_RECORDS_IN_DATASTORE, DSSE_PARTIAL_INDEX_RETURNED, DSSE_DELETE_PRIMARY_KEY, DSSE_INDEX_RECORD_NUMBER_LIMIT_EXCEEDED, }DataStoreStructureError;</PRE>
<P>さまざまなDataStoreルーチンによって返されるエラー値。</P>
</DIV>
<DIV>
          <A NAME="S_c.htm_IX_DataStoreFlags"></A>
        <H1 CLASS="refHeading">DataStoreFlags</H1>
<PRE CLASS="syntax">typedef WordFlags DataStoreFlags;#define DSF_PRIVATE 0x8000#define DSF_TIMESTAMP 0x4000#define DSF_BACKUP 0x2000#define DSF_ARCHIVE 0x1000#define DSF_NO_PRIMARY_KEY 0x1000</PRE>
<P>データストアの作成時に渡されるフラグです。</P>
</DIV>
<DIV>
          <A NAME="S_c.htm_IX_DataStoreChangeNotification"></A>
        <H1 CLASS="refHeading">DataStoreChangeNotification</H1>
<PRE CLASS="syntax">typedef struct{TCHAR DSCN_name[FILE_LONGNAME_BUFFER_SIZE];DataStoreChangeType DSCN_action;RecordID DSCN_record;FieldID DSCN_field;}DataStoreChangeNotification;</PRE>
<P>データストアが変更されたときにMSG_META_NOTIFY_WITH_DATA_BLOCKとともに送信される構造体。</P>
</DIV>
<DIV>
          <A NAME="S_c.htm_IX_DataStoreChangeType"></A>
        <H1 CLASS="refHeading">DataStoreChangeType</H1>
<PRE CLASS="syntax">typedef enum{DSCT_RECORD_ADDED, DSCT_RECORD_CHANGED, DSCT_RECORD_DELETED, DSCT_FIELD_ADDED, DSCT_FIELD_RENAMED, DSCT_FIELD_DELETED, DSCT_DATASTORE_CHANGED, DSCT_NAME_CHANGED, DSCT_NEXT_RECORD_ID_CHANGED, }DataStoreChangeType;</PRE>
<P>データストア変更通知。を参照してください。<CODE>DataStoreChangeNotification</CODE>上記</P>
</DIV>
<DIV>
          <A NAME="S_c.htm_IX_DataStoreDate"></A>
        <H1 CLASS="refHeading">DataStoreDate</H1>
<PRE CLASS="syntax">typedef struct{word DSD_year;byte DSD_month;byte DSD_day;}DataStoreDate;</PRE>
<P>データストア内の日付フィールドのデータを取得および設定するために使用される構造体。</P>
</DIV>
<DIV>
          <A NAME="S_c.htm_IX_DataStoreOpenFlags"></A>
        <H1 CLASS="refHeading">DataStoreOpenFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags DataStoreOpenFlags;#define DSOF_EXCLUSIVE 0x80</PRE>
<P>データストアを開くときに渡されるフラグ。呼び出し元に排他的なアクセス権を与えます。</P>
</DIV>
<DIV>
          <A NAME="S_c.htm_IX_DataStoreRecordEnumFlags"></A>
        <H1 CLASS="refHeading">DataStoreRecordEnumFlags</H1>
<PRE CLASS="syntax">typedef WordFlags DataStoreRecordEnumFlags;#define DSREF_BACKWARDS 0x8000#define DSREF_START_AT_END 0x4000</PRE>
<P>渡されたフラグ<CODE><A HREF="../../CRef/Routines/R_14.htm#IX_DataStoreRecordEnum()">DataStoreRecordEnum()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_c.htm_IX_DataStoreTime"></A>
        <H1 CLASS="refHeading">DataStoreTime</H1>
<PRE CLASS="syntax">typedef struct{byte DST_hour;byte DST_minute;byte DST_second;}DataStoreTime;</PRE>
<P>データストア内の時間フィールドのデータを取得および設定するために使用される構造体。</P>
</DIV>
<HR>
          <A NAME="S_d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DateTimeFormat"></A>
        <H1 CLASS="refHeading">DateTimeFormat/日付の形式</H1>
<PRE CLASS="syntax">typedef enum/*word*/{DTF_LONG, /*Thursday, 7 th August, 1997*/DTF_LONG_CONDENSED, /*Thu, 7 Aug, 1997*/DTF_LONG_NO_WEEKDAY, /*7 th August, 1997*/DTF_LONG_NO_WEEKDAY_CONDENSED, /*7 Aug, 1997*/DTF_SHORT, /*7.8.97*/DTF_ZERO_PADDED_SHORT, /*07.08.97*/DTF_MD_LONG, /*Thursday, 7 th August*/DTF_MD_LONG_WEEKDAY, /*7 th August*/DTF_MD_SHORT, /*7.8*/DTF_MY_LONG, /*August 1997*/DTF_MY_SHORT, /*8.97*/DTF_MONTH, /*August*/DTF_WEEKDAY, /*Thursday*/DTF_HMS, /*02:05:06*/DTF_HM, /*02:05*/DTF_H, /*02*/DTF_MS, /*5:06*/DTF_HMS_24 HOUR,/*14:05:06*/DTF_HM_24 HOUR,/*14:05*/}DateTimeFormat;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DayOfTheWeek"></A>
          <A NAME="S_d.htm_IX_DOTW_&ldots;"></A>
          <A NAME="S_d.htm_IX_Sunday"></A>
          <A NAME="S_d.htm_IX_Monday"></A>
          <A NAME="S_d.htm_IX_Tuesday"></A>
          <A NAME="S_d.htm_IX_Wednesday"></A>
          <A NAME="S_d.htm_IX_Thursday"></A>
          <A NAME="S_d.htm_IX_Friday"></A>
          <A NAME="S_d.htm_IX_Saturday"></A>
        <H1 CLASS="refHeading">曜日</H1>
<PRE CLASS="syntax">typedef enum{DOTW_SUNDAY, DOTW_MONDAY, DOTW_TUESAY, DOTW_WEDNESDAY, DOTW_THURSDAY, DOTW_FRIDAY, DOTW_SATURDAY}DayOfTheWeek;&lt;日付></PRE>
<P>この列挙型は<CODE>TimerDateAndTime</CODE>構造。</P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DBGroup"></A>
        <H1 CLASS="refHeading">DBGroup</H1>
<PRE CLASS="syntax">typedef word DBGroup;</PRE>
<P>DBグループのハンドルです。 DBグループブロックのVMハンドルです。 DBグループハンドルは、ファイルがコピーされたとき、またはファイルが閉じられて再度開かれたときには変更されません。</P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DBGroupAndItem"></A>
        <H1 CLASS="refHeading">DBGroupAndItem</H1>
<PRE CLASS="syntax">typedef dword DBGroupAndItem;</PRE>
<P>データベース項目のグループハンドルと項目ハンドルを含むdワードです。 上位ワードは項目のグループハンドルで、下位ワードは項目の項目ハンドルです。<DIV>
          <IMG SRC="DBGroupAndItem.gif">
        </DIV>
</P>
<P>マクロは<CODE>DBGroupAndItem</CODE>キーを押します</P>
<DL>
<DT><CODE>DBCombineGroupAndItem()</DT><DD></CODE>を作成します。<CODE>DBGroupAndItem</CODE>指定されたグループハンドルと項目ハンドルから</DD>
<PRE>DBCombineGroupAndItem(グループ,項目);</PRE>
<DT><CODE>DBExtractGroupFromGroupAndItem()</DT><DD></CODE>次のものを抽出します。<CODE>DBGroup</CODE>与えられた<CODE>DBGroupAndItem</CODE>ボタンをクリックし</DD>
<PRE><CODE>DBExtractGroupFromGroupAndItem(groupAndItem)</CODE></PRE>
<DT><CODE>DBExtractItemFromGroupAndItem()</DT><DD></CODE>次のものを抽出します。<CODE>DBItem</CODE>与えられた<CODE>DBGroupAndItem</CODE>ボタンをクリックし</DD>
<PRE>DBExtractItemFromGroupAndItem(groupAndItem)</PRE>
</DL>
<P CLASS="refField"><STRONG>次を含む:</STRONG>geos.hを入力します。</P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DBItem"></A>
        <H1 CLASS="refHeading">DBItem</H1>
<PRE CLASS="syntax">typedef word DBItem;</PRE>
<P>これはDB項目のハンドルです。 の<CODE>DBItem</CODE>および<CODE>DBGroup</CODE>指定したファイル内のDB項目を一意に識別します。</P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DBReturn"></A>
          <A NAME="S_d.htm_IX_DBR_&ldots;"></A>
        <H1 CLASS="refHeading">DBReturn</H1>
<PRE CLASS="syntax">typedef struct{word DBR_group;word DBR_item;word unused1;word unused2;}DBReturn;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DefaultPrintSizes"></A>
          <A NAME="S_d.htm_IX_paper&ldots;"></A>
          <A NAME="S_d.htm_IX_document&ldots;"></A>
        <H1 CLASS="refHeading">DefaultPrintSizes</H1>
<PRE CLASS="syntax">typedef struct{word paperWidth;word paperHeight;word documentWidth;word documentHeight;}DefaultPrintSizes;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DevicePresent"></A>
          <A NAME="S_d.htm_IX_DP_&ldots;"></A>
        <H1 CLASS="refHeading">DevicePresent</H1>
<PRE CLASS="syntax">typedef enum/*word*/{DP_NOT_PRESENT=0 xffff,DP_CANT_TELL=0, DP_PRESENT=1, DP_INVALID_DEVICE=0 xfffe}DevicePresent;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DirPathInfo"></A>
        <H1 CLASS="refHeading">DirPathInfo</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DiskCopyCallback"></A>
        <H1 CLASS="refHeading">DiskCopyCallback</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy(コマンド)</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_d.htm_IX_DiskCopyError"></A>
          <A NAME="S_d.htm_IX_ERR_&ldots;"></A>
        <H1 CLASS="refHeading">DiskCopyError</H1>
<PRE CLASS="syntax">typedef enum/*word*/{ERR_DISKCOPY_INSUFFICIENT_MEM=0xd0, ERR_CANT_COPY_FIXED_DISKS, ERR_CANT_READ_FROM_SOURCE, ERR_CANT_WRITE_TO_DEST, ERR_INCOMPATIBLE_FORMATS, ERR_OPERATION_CANCELLED, ERR_CANT_FORMAT_DEST, }DiskCopyError;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DiskFindResult"></A>
        <H1 CLASS="refHeading">DiskFindResult</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_19.htm#IX_DiskFind()">DiskFind()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DiskHandle"></A>
        <H1 CLASS="refHeading">DiskHandle</H1>
<PRE CLASS="syntax">typedefハンドルDiskHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DiskInfoStruct"></A>
          <A NAME="S_e.htm_IX_DIS_&ldots;  (DiskInfoStruct structure)"></A>
        <H1 CLASS="refHeading">DiskInfoStruct</H1>
<PRE CLASS="syntax">typedef struct{word DIS_blockSize;sdword DIS_freeSpace;sdword DIS_totalSpace;VolumeName DIS_name;}DiskInfoStruct;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DiskRestoreError"></A>
        <H1 CLASS="refHeading">DiskRestoreError</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRestore()">DiskRestore()を実行します。</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DisplayAspectRatio"></A>
          <A NAME="S_e.htm_IX_DAR_&ldots;"></A>
        <H1 CLASS="refHeading">アスペクト比の表示</H1>
<PRE CLASS="syntax">typedef ByteEnum DisplayAspectRatio;#define DAR_NORMAL 0#define DAR_SQUISHED 1#define DAR_VERY_SQUISHED 2</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DisplayClass"></A>
          <A NAME="S_e.htm_IX_DC_&ldots;"></A>
        <H1 CLASS="refHeading">表示クラス</H1>
<PRE CLASS="syntax">typedef ByteEnum DisplayClass;#define DC_TEXT 0#define DC_GRAY_1 1#define DC_GRAY_2 2#define DC_GRAY_4 3#define DC_GRAY_8 4#define DC_COLOR_2 5#define DC_COLOR_4 6#define DC_COLOR_8 7#define DC_CF_RGB 8</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DisplaySize"></A>
          <A NAME="S_e.htm_IX_DS_&ldots;  (DisplaySize type)"></A>
        <H1 CLASS="refHeading">表示サイズ</H1>
<PRE CLASS="syntax">typedef ByteEnum DisplaySize;#define DS_TINY 0#define DS_STANDARD 1#define DS_LARGE 2#define DS_HUGE 3</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DisplayType"></A>
          <A NAME="S_e.htm_IX_DT_&ldots;"></A>
        <H1 CLASS="refHeading">表示タイプ</H1>
<PRE CLASS="syntax">typedef ByteFlags DisplayType;#define DT_DISP_SIZE 0xc0#define DT_DISP_ASPECT_RATIO 0x30#define DT_DISP_CLASS 0x0f</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DistanceUnit"></A>
          <A NAME="S_e.htm_IX_DU_&ldots;"></A>
          <A NAME="S_e.htm_IX_LOCAL_DISTANCE_BUFFER_SIZE"></A>
        <H1 CLASS="refHeading">距離単位(DistanceUnit)</H1>
<PRE CLASS="syntax">typedef ByteEnum DistanceUnit;#define DU_POINTS 0#define DU_INCHES 1#define DU_CENTIMETERS 2#define DU_MILLIMETERS 3#define DU_PICAS 4#define DU_EUR_POINTS 5#define DU_CICEROS 6#define DU_POINTS_OR_MILLIMETERS 7#define DU_INCHES_OR_CENTIMETERS 8#define LOCAL_DISTANCE_BUFFER_SIZE 32</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DocQuitStatus"></A>
          <A NAME="S_e.htm_IX_DQS_&ldots;"></A>
        <H1 CLASS="refHeading">DocQuitStatus</H1>
<PRE CLASS="syntax">typedef enum/*word*/{DQS_OK, DQS_CANCEL, DQS_DELAYED, DQS_SAVE_ERROR}DocQuitStatus;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DocumentSize"></A>
          <A NAME="S_e.htm_IX_leftMargin (DocumentSize structure)"></A>
          <A NAME="S_e.htm_IX_topMargin (DocumentSize structure)"></A>
          <A NAME="S_e.htm_IX_width (DocumentSize structure)"></A>
          <A NAME="S_e.htm_IX_height (DocumentSize structure)"></A>
        <H1 CLASS="refHeading">ドキュメントサイズ</H1>
<PRE CLASS="syntax">typedef struct{int leftMargin;int topMargin;int width;int height;}ドキュメントサイズ;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DosCodePage"></A>
          <A NAME="S_e.htm_IX_CODE_PAGE_&ldots;"></A>
        <H1 CLASS="refHeading">DosCodePage</H1>
<PRE CLASS="syntax">typedef enum/*word*/{CODE_PAGE_US=437, CODE_PAGE_MULTILINGUAL=850, CODE_PAGE_PORTUGUES=860, CODE_PAGE_CANADIAN_FRENCH=863, CODE_PAGE_NORD=865}DosCodePage;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DosDotFileName"></A>
          <A NAME="S_e.htm_IX_DOS_DOT_DOS_FILE_NAME_SIZE"></A>
        <H1 CLASS="refHeading">DosDotFileName</H1>
<PRE CLASS="syntax">typedef char DosDotFileName[DOS_DOT_DOS_FILE_NAME_SIZE];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DosExecFlags"></A>
          <A NAME="S_e.htm_IX_DEF_&ldots;"></A>
        <H1 CLASS="refHeading">DosExecFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags DosExecFlags;#define DEF_PROMPT 0x80/*GEOSに戻るようユーザにプロンプトを出す*/#define DEF_FORCED_SHUTDOWN 0x40/*強制シャットダウン;中止しない*/#define DEF_INTERACTIVE 0x20/*プログラムはインタラクティブシェル*/</PRE>
<P>で使用されるフラグ<CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DosExec()">DosExec()関数</A></CODE>ボタンをクリックし<CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DosExec()">DosExec()関数</A></CODE>はこれらのフラグに基づいてDOSプログラムを実行します。</P>
</DIV>
<DIV>
          <A NAME="S_e.htm_IX_DOS_DOT_FILE_NAME_LENGTH_ZT"></A>
          <A NAME="S_e.htm_IX_DosFileInfoStruct"></A>
          <A NAME="S_e.htm_IX_DFIS_&ldots;"></A>
        <H1 CLASS="refHeading">DosFileInfoStruct</H1>
<PRE CLASS="syntax">typedef struct{byte DFIS_attributes;dword DFIS_modTimeDate;dword DFIS_fileSize;char DFIS_name[DOS_DOT_FILE_NAME_LENGTH_ZT];word DFIS_pathInfo;}DosFileInfoStruct;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DosNoDotFileName"></A>
          <A NAME="S_f.htm_IX_DOS_NO_DOT_DOS_FILE_NAME_SIZE"></A>
        <H1 CLASS="refHeading">DosNoDotFileName</H1>
<PRE CLASS="syntax">typedef char DosNoDotFileName[DOS_NO_DOT_DOS_FILE_NAME_SIZE];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DrawMask"></A>
        <H1 CLASS="refHeading">DrawMask</H1>
<PRE CLASS="syntax">typedefバイトDrawMask[8];</PRE>
<P>グラフィックスシステムは、この構造を使用してカスタム描画マスクを定義します。</P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DriveType"></A>
          <A NAME="S_f.htm_IX_DRIVE_&ldots;"></A>
        <H1 CLASS="refHeading">ドライブタイプ</H1>
<PRE CLASS="syntax">typedef ByteEnum DriveType;#define DRIVE_5_25 0#define DRIVE_3_5 1#define DRIVE_FIXED 2#define DRIVE_RAM 3#define DRIVE_CD_ROM 4#define DRIVE_8 5#define DRIVE_UNKNOWN 0 xf}DriveType;</PRE>
<P>いくつかのルーチン(特に<CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>)は、GEOSを実行しているコンピュータで使用されているドライブに関する情報を提供します。 これらのルーチンは<CODE>DriveTypes</CODE>列挙型。 型はバイト長ですが、すべての値は4ビットに収まることが保証されていることに注意してください。<CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>は<CODE>DriveTypes</CODE>値を1バイトの下位4ビットに、その他のフラグを上位4ビットに格納します。</P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DriverAttrs"></A>
          <A NAME="S_f.htm_IX_DA_&ldots;"></A>
        <H1 CLASS="refHeading">DriverAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags DriverAttrs;#define DA_FILE_SYSTEM 0x8000#define DA_CHARACTER 0x4000#define DA_HAS_EXTENDED_INFO 0x2000</PRE>
<P>このレコードには、特定のドライバの属性を示すフラグが含まれています。 このレコードは、ドライバの<CODE>DriverInfoStruct</CODE>構造。</P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DriverExtendedInfoStruct"></A>
          <A NAME="S_f.htm_IX_DEIS_&ldots;"></A>
        <H1 CLASS="refHeading">DriverExtendedInfoStruct</H1>
<PRE CLASS="syntax">typedef struct{DriverInfoStruct DEIS_common;/*The base driver info structure*/MemHandle DEIS_resource;/*Handle of driver&#39;s DriverExtendedInfo*table. */}DriverExtendedInfoStruct</PRE>
<P>この構造体は、特定のドライバでサポートされているデバイスの名前を見つけるために、環境設定で使用されます。</P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DriverExtendedInfoTable"></A>
          <A NAME="S_f.htm_IX_DEIT_&ldots;"></A>
        <H1 CLASS="refHeading">DriverExtendedInfoTable</H1>
<PRE CLASS="syntax">typedef struct{LMemBlockHeader DEIT_common;word DEIT_numDevices;ChunkHandle DEIT_ChunkHandle;word DEIT_infoTable;}DriverExtendedInfoTable;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DriverInfoStruct"></A>
          <A NAME="S_f.htm_IX_DIS_&ldots;  (DriverInfoStruct structure)"></A>
        <H1 CLASS="refHeading">DriverInfoStruct</H1>
<PRE CLASS="syntax">typedef struct{void(*DIS_strategy)();/*ストラテジルーチンへのポインタ*/DriverAttrs DIS_driverAttributes;/*ドライバの属性フラグ*/DriverType DIS_DriverType;/*ドライバのタイプ*/}DriverInfoStruct;</PRE>
<P>この構造体は、特定のドライバの特性を定義します。 一般に、アプリケーションはドライバを直接使用しない限り、この構造体にアクセスする必要はありません。</P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DriverType"></A>
          <A NAME="S_f.htm_IX_DRIVER_TYPE_&ldots;"></A>
        <H1 CLASS="refHeading">ドライバの種類</H1>
<PRE CLASS="syntax">typedef enum{DRIVER_TYPE_VIDEO=1, /*Video drivers*/DRIVER_TYPE_INPUT, /*Input(keyboard, mouse)drivers*/DRIVER_TYPE_MASS_STORAGE, /*Disk/Drive drivers*/DRIVER_TYPE_STREAM, /*Stream and port drivers*/DRIVER_TYPE_FONT, /*Font drivers*/DRIVER_TYPE_OUTPUT, /*Output(not not video and printer)drivers*/DRIVER_TYPE_LOCALIZATION, /*Localization drivers*/DRIVER_TYPE_FILE_SYSTEM, /*File system drivers*/DRIVER_TYPE_PRINTER, /*Printer drivers*/DRIVER_TYPE_SWAP, /*Swap drivers*/DRIVER_TYPE_POWER_MANAGEMENT, /*Power management drivers*/DRIVER_TYPE_TASK_SWITCH, /*Task switch drivers*/DRIVER_TYPE_NETWORK/*Network file system drivers*/}DriverType;(英語)</PRE>
<P>この列挙型は、システム内のドライバの種類ごとに1つの値を持ちます。 主に次のものと共に使用します。<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseDriver()">GeodeUseDriver()</A></CODE>とそれに関連付けられたルーチンです。 各ドライバは、そのタイプを<CODE>DriverInfoStruct</CODE>構造。</P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DWFixed"></A>
        <H1 CLASS="refHeading">DWFixed</H1>
<PRE CLASS="syntax">typedef struct{word WWF_frac;dword WWF_int;}DWFixed;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_dword"></A>
        <H1 CLASS="refHeading">dワード</H1>
<PRE CLASS="syntax">typedef unsigned long dword;符号なしlong dword;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_DWordFlags"></A>
        <H1 CLASS="refHeading">DWordFlags</H1>
<PRE CLASS="syntax">typedef dword DWordFlags;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_f.htm_IX_ElementArrayHeader"></A>
          <A NAME="S_f.htm_IX_EAH_&ldots;"></A>
        <H1 CLASS="refHeading">ElementArrayHeader</H1>
<PRE CLASS="syntax">typedef struct{ChunkArrayHeader EAH_meta;/*チャンク配列ヘッダ構造体*/word EAH_freePtr;/*最初の空き要素*/}ElementArrayHeader;</PRE>
<P>すべての要素配列は<CODE>ElementArrayHeader</CODE>要素配列は特殊なチャンク配列であるため<CODE>ElementArrayHeader</CODE>で始まる必要があります。<CODE>ChunkArrayHeader</CODE>構造体には、追加フィールドEAHが1つ含まれています。<CODE>_freePtr</CODE>これは、要素配列内の解放された要素を追跡するために使用されます。 アプリケーションでは、このフィールドを確認または変更しないでください。</P>
</DIV>
<HR>
          <A NAME="S_10.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_10.htm_IX_EOSF_&ldots;"></A>
          <A NAME="S_10.htm_IX_UNLOCK_ON_EOS (EndOfSongFlags flag)"></A>
          <A NAME="S_10.htm_IX_DESTROY_ON_EOS (EndOfSongFlags flag)"></A>
        <H1 CLASS="refHeading">EndOfSongFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags EndOfSongFlags;#define EOSF_UNLOCK 0x0080/*EOSでブロックをロック解除しますか?*/#define EOSF_DESTROY 0x0040/*EOSでブロックを破棄しますか?*/#define UNLOCK_ON_EOS EOSF_UNLOCK#define DESTROY_ON_EOS EOSF_DESTROY</PRE>
<P>これらのフラグは、曲の再生が終了した後に、曲構造を格納するメモリブロックで何をすべきかを決定する。</P>
</DIV>
<DIV>
          <A NAME="S_10.htm_IX_EntryPointRelocation"></A>
          <A NAME="S_10.htm_IX_EPR_&ldots;"></A>
        <H1 CLASS="refHeading">EntryPointRelocation</H1>
<PRE CLASS="syntax">typedef struct{char EPR_geodeName[GEODE_NAME_SIZE];word EPR_entryNumber;}EntryPointRelocation;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_10.htm_IX_EnvelopeOrientation"></A>
          <A NAME="S_10.htm_IX_EO_&ldots;"></A>
        <H1 CLASS="refHeading">EnvelopeOrientation</H1>
<PRE CLASS="syntax">typedef ByteEnum EnvelopeOrientation;#define EO_PORTAIT_LEFT 0x00#define EO_PORTAIT_RIGHT 0x01#define EO_LANDSCAPE_UP 0x02#define EO_LANDSCAPE_DOWN 0x03</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_10.htm_IX_EnvelopePath"></A>
          <A NAME="S_10.htm_IX_EP_&ldots;  (EnvelopePath type)"></A>
        <H1 CLASS="refHeading">EnvelopePath</H1>
<PRE CLASS="syntax">typedef ByteEnum EnvelopePath;#define EP_LEFT 0x00#define EP_CENTER 0x01#define EP_RIGHT 0x02</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_10.htm_IX_Errors"></A>
          <A NAME="S_10.htm_IX_ERROR_&ldots;"></A>
        <H1 CLASS="refHeading">エラー</H1>
<PRE CLASS="syntax">#define ERROR_UNSUPPORTED_FUNCTION 1#define ERROR_FILE_NOT_FOUND 2#define ERROR_PATH_NOT_FOUND 3#define ERROR_TOO_MANY_OPEN_FILES 4#define ERROR_ACCESS_DENIED 5#define ERROR_INSUFFICIENT_MEMORY 8#define ERROR_INVALID_VOLUME 15#define ERROR_IS_CURRENT_DIRECTORY 16#define ERROR_DIFFERENT_DEVICE 17#define ERROR_NO_MORE_FILES 18#define ERROR_WRITE_PROTECTED 19#define ERROR_CRC_ERROR 23#define ERROR_SEEK_ERROR 25#define ERROR_SECTOR_NOT_FOUND 27#define ERROR_WRITE_FAULT 29#define ERROR_READ_FAULT 30#define ERROR_GENERAL_FAILURE 31#define ERROR_INVALID_LONGNAME 129#define ERROR_ALREADY_LOCKED 33#define ERROR_SHARING_OVERFLOW 36#define ERROR_SHORT_READ_WRITE 128#define ERROR_INVALID_LONGNAME#define ERROR_FILE_IN_PROGRESS 131#define ERROR_ARGS_TOO_LONG 133#define ERROR_DISK_UNAVAILABLE 134#define ERROR_DISK_STALE 135#define ERROR_FILE_FORMAT_MISMATCH 136#define ERROR_CANNOT_MAP_NAME 140#define ERROR_CANNOT_BE_SET 142#define ERROR_CANNOT_MOVE_DIRECTORY 143#define ERROR_ARGS_INVALID 145#define ERROR_CANNOT_FIND_COMMAND_INTERPRETER 146#define ERROR_NO_TASK_DRIVER_LOADED 147 137 138 139 141 144 130 132</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_10.htm_IX_ErrorCheckingFlags"></A>
          <A NAME="S_10.htm_IX_ECF_&ldots;"></A>
        <H1 CLASS="refHeading">ErrorCheckingFlags</H1>
<PRE CLASS="syntax">typedef WordFlags ErrorCheckingFlags;#define ECF_REGION 0x8000#define ECF_HEAP_FREE_BLOCKS 0x4000#define ECF_LMEM_INTERNAL 0x2000#define ECF_LMEM_FREE_AREAS 0x1000#define ECF_LMEM_OBJECT 0x0800#define ECF_BLOCK_CHECKSUM 0x0400#define ECF_GRAPHICS 0x0200#define ECF_SEGMENT 0x0100#define ECF_NORMAL 0x0080#define ECF_VMEM 0x0040#define ECF_APP 0x0020#define ECF_LMEM_MOVE 0x0010#define ECF_UNLOCK_MOVE 0x0008#define ECF_VMEM_DISCARD 0x0004</PRE>
<P>エラーチェックフラグは、システムのエラーチェックレベルを<CODE><A HREF="../../CRef/Routines/R_93.htm#IX_SysSetECLevel()">SysSetECLevel()</A></CODE>上記のフラグは、個別に設定またはクリアできます。 デバッグ時にはエラー・チェックを使用することが重要です。エラー・チェックを使用しないと、製品が出荷されるまで気づかれない可能性のある不明瞭なバグを検出するのに役立ちます。</P>
</DIV>
<HR>
          <A NAME="S_11.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalErrorData"></A>
          <A NAME="S_11.htm_IX_EED_&ldots;"></A>
        <H1 CLASS="refHeading">EvalErrorData</H1>
<PRE CLASS="syntax">typedef struct{byte EED_errorCode;/*ParserScannerEvaluatorError*/}EvalErrorData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalFlags"></A>
          <A NAME="S_11.htm_IX_EF_&ldots;  (EvalFlags)"></A>
          <A NAME="S_11.htm_IX_EVAL_MAX_NESTED_LEVELS"></A>
        <H1 CLASS="refHeading">EvalFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags EvalFlags;#define EF_MAKE_DEPENDENCIES 0x80#define EF_ONLY_NAMES 0x40#define EF_KEEP_LAST_CELL 0x20#define EF_NO_NAMES 0x10#define EF_ERROR_PUSHEd 0x08#define EVAL_MAX_NESTED_LEVELS 32</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalFunctionData"></A>
          <A NAME="S_11.htm_IX_EFD_&ldots;"></A>
        <H1 CLASS="refHeading">EvalFunctionData</H1>
<PRE CLASS="syntax">typedef struct{FunctionID EFD_FunctionID;word EFD_nArgs;}EvalFunctionData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalNameData"></A>
          <A NAME="S_11.htm_IX_END_&ldots;"></A>
        <H1 CLASS="refHeading">EvalNameData</H1>
<PRE CLASS="syntax">typedef struct{word END_name;}EvalNameData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalOperatorData"></A>
          <A NAME="S_11.htm_IX_EOD_&ldots;"></A>
        <H1 CLASS="refHeading">EvalOperatorData</H1>
<PRE CLASS="syntax">typedef struct{OperatorType EOD_opType;}EvalOperatorData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EP_&ldots;  (EvalParameters structure)"></A>
          <A NAME="S_11.htm_IX_EvalParameters"></A>
        <H1 CLASS="refHeading">EvalParameters</H1>
<PRE CLASS="syntax">typedef struct{CommonParameters EP_common;EvalFlags EP_flags;word EP_fpStack;word EP_depHandle;word EP_nestedLevel;dword EP_nestedAddresses[EVAL_MAX_NESTED_LEVELS];}EvalParameters;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalRangeData"></A>
          <A NAME="S_11.htm_IX_ERD_&ldots;"></A>
        <H1 CLASS="refHeading">EvalRangeData</H1>
<PRE CLASS="syntax">typedef struct{CellReference ERD_firstCell;CellReference ERD_lastCell;}EvalRangeData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalStackArgumentData"></A>
          <A NAME="S_11.htm_IX_ESAD_&ldots;"></A>
        <H1 CLASS="refHeading">EvalStackArgumentData</H1>
<PRE CLASS="syntax">typedef union{EvalStringData ESAD_string;EvalRangeData ESAD_range;EvalErrorData ESAD_error;}EvalStackArgumentData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalStackArgumentType"></A>
          <A NAME="S_11.htm_IX_ESAT_&ldots;"></A>
        <H1 CLASS="refHeading">EvalStackArgumentType</H1>
<PRE CLASS="syntax">typedef ByteFlags EvalStackArgumentType;#define ESAT_EMPTY 0x80#define ESAT_ERROR 0x40#define ESAT_RANGE 0x20#define ESAT_STRING 0x10#define ESAT_NUMBER 0x08#define ESAT_NUM_TYPE 0x03#define ESAT_TOP_OF_STACK 0#define ESAT_NAME(ESAT_RANGE ESAT_STRING) #define ESAT_FUNCTION(ESAT_NUMBER ESAT_STRING)#define ESAT_FUNCTION(ESAT_NUMBER ESAT_STRING)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalStackOperatorData"></A>
          <A NAME="S_11.htm_IX_ESOD_&ldots;"></A>
        <H1 CLASS="refHeading">EvalStackOperatorData</H1>
<PRE CLASS="syntax">typedef union{EvalOperatorData ESOD_operator;EvalFunctionData ESOD_function;}EvalStackOperatorData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalStackOperatorType"></A>
          <A NAME="S_11.htm_IX_ESOT_&ldots;"></A>
        <H1 CLASS="refHeading">EvalStackOperatorType</H1>
<PRE CLASS="syntax">typedef ByteEnum EvalStackOperatorType;#define ESOT_OPERATOR 0#define ESOT_FUNCTION 1#define ESOT_OPEN_PAREN 2#define ESOT_TOP_OF_STACK 3</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EvalStringData"></A>
          <A NAME="S_11.htm_IX_ESD_&ldots;"></A>
        <H1 CLASS="refHeading">EvalStringData</H1>
<PRE CLASS="syntax">typedef struct{word ESD_length;}EvalStringData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_EventHandle"></A>
        <H1 CLASS="refHeading">EventHandle</H1>
<PRE CLASS="syntax">typedefハンドルEventHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_ExitFlags"></A>
          <A NAME="S_11.htm_IX_EF_&ldots;  (ExitFlags)"></A>
        <H1 CLASS="refHeading">ExitFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ExitFlags;#define EF_PANIC 0x80#define EF_RUN_DOS 0x40#define EF_OLD_EXIT 0x20#define EF_RESET 0x10#define EF_RESTART 0x08</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_ExportControlFeatures"></A>
          <A NAME="S_11.htm_IX_EXPORTCF_BASIC"></A>
        <H1 CLASS="refHeading">ExportControlFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags ExportControlFeatures;#define EXPORTCF_BASIC 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_11.htm_IX_ExportControlToolboxFeatures"></A>
          <A NAME="S_11.htm_IX_EXPORTCTF_DIALOG_BOX"></A>
        <H1 CLASS="refHeading">ExportControlToolboxFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags ExportControlToolboxFeatures;#define EXPORTCTF_DIALOG_BOX 0x01</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_12.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FALSE"></A>
        <H1 CLASS="refHeading">偽</H1>
<PRE CLASS="syntax">#define FALSE 0#define TRUE(~0)/*比較ではなく、戻り値として使用*/</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FileAccess"></A>
        <H1 CLASS="refHeading">フィールドの分類</H1>
<PRE CLASS="syntax">typedef ByteEnum FieldType#define FC_NONE 0x0#define FC_NAME 0x1#define FC_DATE 0x2#define FC_TELEPHONE 0x3#define FC_ADDRESS 0x4#define FC_EMAIL 0x5</PRE>
<P>フィールドをdatatstoreに追加するときは<CODE>フィールドの分類</CODE>ボタンをクリックし<CODE>フィールドの分類</CODE>は、データが表す情報のタイプです(と混同しないでください<CODE>フィールドタイプ</CODE>(下記参照)。</P>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FieldData"></A>
        <H1 CLASS="refHeading">フィールドデータ</H1>
<PRE CLASS="syntax">typedef struct{FieldType FD_type;FieldCategory FD_category;FieldFlags FD_flags;}FieldData;と入力します。</PRE>
<P>フィールド情報の取得と設定に使用される構造体(<CODE>FieldDescriptor</CODE>(下記参照)。</P>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FieldDescriptor"></A>
        <H1 CLASS="refHeading">FieldDescriptor</H1>
<PRE CLASS="syntax">typedef struct{FieldData FD_data;TCHAR*FD_name;}FieldDescriptor;</PRE>
<P>フィールド情報の取得と設定に使用される構造体(<CODE>フィールドデータ</CODE>上記参照)。</P>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FieldHeader"></A>
        <H1 CLASS="refHeading">FieldHeader</H1>
<PRE CLASS="syntax">typedef struct{FieldID FH_id;word FH_size;}FieldHeader;</PRE>
<P>可変サイズのフィールド(文字列フィールドなど)に関するメタデータを含む構造。フィールドデータはこのヘッダーの後に続きます。</P>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FieldHeaderFixed"></A>
        <H1 CLASS="refHeading">FieldHeaderFixed</H1>
<PRE CLASS="syntax">typedef struct{FieldID FHF_id;}フィールド;FieldHeaderFixed;</PRE>
<P>固定サイズのフィールドに関するメタデータを含む構造体。フィールドデータはこのヘッダーの後に続きます。</P>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FileAccess"></A>
          <A NAME="S_12.htm_IX_FA_&ldots;  (FileAccess type)"></A>
        <H1 CLASS="refHeading">フィールドタイプ</H1>
<PRE CLASS="syntax">typedef ByteEnum FieldType#define DSFT_FLOAT 0x0#define DSFT_SHORT 0x1#define DSFT_LONG 0x2#define DSFT_TIMESTAMP 0x3#define DSFT_DATE 0x4#define DSFT_TIME 0x5#define DSFT_STRING 0x6#define DSFT_BINARY 0x7#define DSFT_GRAPHICS 0x8#define DSFT_INK 0x9</PRE>
<P>フィールドをdatatstoreに追加するときは<CODE>フィールドタイプ</CODE>ボタンをクリックし<CODE>フィールドタイプ</CODE>は、フィールドに含まれるデータのタイプです(と混同しないでください<CODE>フィールドの分類</CODE>上記参照)。 DSFT_FLOAT型のフィールドは<CODE>FloatNum</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FileAccess"></A>
          <A NAME="S_12.htm_IX_FA_&ldots;  (FileAccess type)"></A>
        <H1 CLASS="refHeading">ファイルアクセス</H1>
<PRE CLASS="syntax">typedef ByteEnum FileAccess#define FA_READ_ONLY 0#define FA_WRITE_ONLY 1#define FA_READ_WRITE 2を定義します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FileAccessFlags"></A>
          <A NAME="S_12.htm_IX_FILE_&ldots;"></A>
        <H1 CLASS="refHeading">FileAccessFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags FileAccessFlags;#define FILE_DENY_RW 0x10#define FILE_DENY_W 0x20#define FILE_DENY_R 0x30#define FILE_DENY_NONE 0x40#define FILE_ACCESS_R 0x00#define FILE_ACCESS_W 0x01#define FILE_ACCESS_RW 0x02#define FILE_NO_ERRORS 0x80</PRE>
<P>バイト単位のアクセス用にファイルを開くときには<CODE>FileAccessFlags</CODE>である。<CODE>FileAccessFlags</CODE>recordは、呼び出し側が必要とするアクセスの種類と、他の測地に許可されるアクセスの種類の2つを指定します。 のセット<CODE>FileAccessFlags</CODE>つまり、2つの異なる値のビット単位の「or」です。 1つ目は、呼び出し元のgeodeが必要とするアクセスの種類を指定し、次の値を持ちます。</P>
<DL>
<DT>ファイルアクセス権</DT><DD>geodeはファイルからの読み込みだけを行います。</DD>
<DT>ファイルアクセス権</DT><DD>geodeはファイルに書き込みますが、ファイルからの読み取りは行いません。</DD>
<DT>FILE_ACCESS_RW(ファイルアクセスRW)</DT><DD>geodeはファイルの読み書きを行います。</DD>
</DL>
<P>2番目の部分では、他の測地が持つことができるアクセスの種類を指定します。 他のgeodeにすでに与えられているパーミッションを拒否しようとすると(例えば、他のgeodeが書き込みアクセス用にファイルを開いているときにFILE_DENY_Wでファイルを開こうとすると)、呼び出しは失敗することに注意してください。 次の値があります。</P>
<DL>
<DT>ファイル拒否(FILE_DENY_RW)</DT><DD>geodeは、読み取り、書き込み、読み取り/書き込みのいずれであっても、ファイルを開いてアクセスすることはできません。</DD>
<DT>FILE_DENY_R(ファイル拒否)</DT><DD>geodeは、読み取りまたは読み取り/書き込みアクセスのためにファイルを開くことはできません。</DD>
<DT>ファイル_拒否_W</DT><DD>geodeは、書き込みまたは読み取り/書き込みアクセスのためにファイルを開くことはできません。</DD>
<DT>FILE_DENY_NONE(ファイル拒否なし)</DT><DD>その他の測地は、あらゆる種類のアクセス用にファイルを開くことができます。</DD>
</DL>
<P>これらの値の各セットから1つずつの2つのフラグが結合されて、適切な<CODE></CODE><CODE>FileAccessFlags</CODE><CODE></CODE>値を入力します。 たとえば、他の測地によるファイルへの書き込みを禁止しながら、読み取り専用アクセス用にファイルを開くには、フラグ&quot;(FILE_ACCESS_R FILE_DENY_W)&quot;を渡します。</P>
</DIV>
<DIV>
          <A NAME="S_12.htm_IX_FileAccessRights"></A>
          <A NAME="S_12.htm_IX_FILE_RIGHTS_SIZE"></A>
        <H1 CLASS="refHeading">FileAccessRights</H1>
<PRE CLASS="syntax">typedef char FileAccessRights[FILE_RIGHTS_SIZE];</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_13.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_13.htm_IX_FileAttrs"></A>
          <A NAME="S_13.htm_IX_FA_&ldots;  (FileAttrs)"></A>
          <A NAME="S_13.htm_IX_FILE_ATTR_&ldots;"></A>
        <H1 CLASS="refHeading">FileAttrs</H1>
<PRE CLASS="syntax">typedef ByteFlags FileAttrs;#define FA_ARCHIVE 0x20#define FA_SUBDIR 0x10#define FA_VOLUME 0x8#define FA_SYSTEM 0x4#define FA_HIDDEN 0x2#define FA_RDONLY 0x1#define FILE_ATTR_NORMAL 0#define FILE_ATTR_READ_ONLY FA_RDONLY#define FILE_ATTR_HIDDEN FA_HIDDEN#define FILE_ATTR_SYSTEM FA_SYSTEM#define FILE_ATTR_VOLUME_LABEL FA_VOLUME</PRE>
<P>すべてのDOSファイルまたはGEOSファイルには、特定の属性があります。 これらの属性は、ファイルが読み取り専用かどうかを示します。 GEOSファイルでは、拡張属性FEA_FILE_ATTRを使用して属性にアクセスできます。 次のルーチンを使用して、任意のファイルの標準属性にアクセスすることもできます。<CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileGetAttributes()">FileGetAttributes()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_2b.htm#IX_FileSetAttributes()">FileSetAttributes()</A></CODE>これらのルーチンはGEOSファイルと普通のDOSファイルの両方で動作します。</P>
<P>の<CODE>FileAttrs</CODE>フィールドには、次のビットが含まれます。</P>
<DL>
<DT>FA_アーカイブ</DT><DD>このフラグは、ファイルのバックアップが必要な場合に設定されます。 通常、バックアッププログラムはこのビットをクリアします。</DD>
<DT>FA_サブディレクトリ</DT><DD>このフラグは、「ファイル」が実際にディレクトリである場合に設定されます。 測地でこのフラグを変更することはできません。</DD>
<DT>FAボリューム</DT><DD>このフラグは、「ファイル」が実際にボリュームラベルである場合に設定されます。 このフラグは次のようになります<EM>オフ</EM>すべてのファイルを表示します。 測地でこのフラグを変更することはできません。</DD>
<DT>FAシステム</DT><DD>このフラグは、ファイルがシステムファイルの場合に設定されます。 測地はこのビットを変更しません。</DD>
<DT>FA_非表示</DT><DD>このフラグは、ファイルが非表示の場合に設定されます。</DD>
<DT>FAレコードのみ</DT><DD>このフラグは、ファイルが読み取り専用の場合に設定されます。</DD>
</DL>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileGetAttributes()">FileGetAttributes()</A></CODE><CODE><A HREF="../../CRef/Routines/R_2b.htm#IX_FileSetAttributes()">FileSetAttributes()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_13.htm_IX_FileChangeNotificationData"></A>
          <A NAME="S_13.htm_IX_FCND_&ldots;"></A>
        <H1 CLASS="refHeading">FileChangeNotificationData</H1>
<PRE CLASS="syntax">typedef struct{PathName FCND_PathName;diskHandle FCND_diskHandle;FileChangeType FCND_changeType;}FileChangeNotificationData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_13.htm_IX_FileChangeType"></A>
          <A NAME="S_13.htm_IX_FCT_&ldots;"></A>
        <H1 CLASS="refHeading">FileChangeType</H1>
<PRE CLASS="syntax">typedef ByteEnum FileChangeType;#define FCT_CREATE 0#define FCT_DELETE 1#define FCT_RENAME 2#define FCT_CONTENTS 3#define FCT_DISK_FORMAT 4</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_13.htm_IX_FileCopyrightNotice"></A>
          <A NAME="S_13.htm_IX_GFH_NOTICE_SIZE"></A>
        <H1 CLASS="refHeading">FileCopyrightNotice</H1>
<PRE CLASS="syntax">typedef char FileCopyrightNotice[GFH_NOTICE_SIZE];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_13.htm_IX_FILE_CREATE_&ldots;  constants"></A>
          <A NAME="S_13.htm_IX_FileCreateFlags"></A>
          <A NAME="S_13.htm_IX_FCF_&ldots;"></A>
        <H1 CLASS="refHeading">FileCreateFlags</H1>
<PRE CLASS="syntax">typedef WordFlags FileCreateFlags;#define FCF_NATIVE 0x8000#define FCF_MODE 0x0300/*Filled with FILE_CREATE_*constant*/#define FCF_ACCESS 0x00ff/*Filled with FileAccessFlags*/</PRE>
<P>このフィールドの下位バイトは<CODE>FileAccessFlags</CODE>レコード。 ファイルのアクセス権と除外を指定します。 ファイルを作成するときは、書き込みアクセス権または読み取り/書き込みアクセス権を要求する必要があります。 上位バイトは、ファイルの作成方法を指定します。 これには、次の値があります。</P>
<DL>
<DT>FILE_CREATE_TRUNCATE&lt;ファイル名></DT><DD>指定された名前のファイルが存在する場合は、そのファイルを開いて切り詰めます。つまり、すべてのデータを削除します。</DD>
<DT>FILE_CREATE_NO_TRUNCATE[ファイル作成]</DT><DD>ファイルが存在する場合は、トランケートせずに開く必要があります。</DD>
<DT>FILE_CREATE_ONLY(ファイル作成のみ)</DT><DD>ファイルが存在する場合、ルーチンは失敗し、スレッドのエラー値をERROR_FILE_EXISTSに設定します。</DD>
<DT>FCF_ネイティブ</DT><DD>ファイルをデバイスのネイティブフォーマットで作成する必要がある場合、このフラグは上記のフラグのいずれかと組み合わされます。たとえば、GEOSファイルではなくDOSファイルである必要がある場合などです。 渡される名前は、受け入れ可能なネイティブファイル名である必要があります。 指定した名前のGEOSファイルが既に存在する場合は<CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreate()">FileCreate()関数</A></CODE>はエラー条件ERROR_FILE_FORMAT_MISMATCHで失敗します。 同様に、フラグが設定されておらず、この名前の非GE OSファイルが存在する場合は<CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreate()">FileCreate()関数</A></CODE>は失敗し、このエラーを返します。</DD>
</DIV>
</DL>
<HR>
          <A NAME="S_14.htm"></A>
        <DIV>
</DIV>


<DIV>
          <A NAME="S_14.htm_IX_FileDate"></A>
        <H1 CLASS="refHeading">ファイル日付</H1>
<PRE CLASS="syntax">typedef WordFlags FileDate;#define FD_YEAR 0xfe00#define FD_MONTH 0x01e0#define FD_DAY 0x001f#define FD_YEAR_OFFSET 9#define FD_MONTH_OFFSET 5#define FD_DAY_OFFSET 0</PRE>
<P>ファイルの日付スタンプは、16ビットのビットフィールドに格納されます。 このフィールドには、年、月、および日のエントリが含まれます。 各フィールドは、マスクとオフセットによって識別されます。 フィールドにアクセスするには、マスク内のビット以外のすべてのビットをクリアし、オフセットの数だけビットを右にシフトします。 (これを行うためのマクロが用意されています。以下で説明します。)<CODE>ファイル日付</CODE>には、マスクで識別される次のフィールドがあります。</P>

<DL>
<DT>
          <STRONG>FD_年</STRONG>
        </DT><DD>このフィールドには、基準年である1980年から数えた年が記録されます。 オフセット<CODE>FD_YEAR_OFFSET(年オフセット)</CODE>ビット。</DD>
<DT>
          <STRONG>月(FD_MONTH)</STRONG>
        </DT><DD>このフィールドには、1月を1として、月が整数で記録されます。<CODE>FD_MONTH_OFFSET(月オフセット)</CODE>ビット。</DD>
<DT>
          <STRONG>FD日</STRONG>
        </DT><DD>このフィールドには、月の日付が記録されます。 オフセット<CODE>FD_DAY_OFFSET(日オフセット)</CODE>ビット。</DD>
</DL>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <A HREF = "S_15.htm#IX_FileTime">ファイル時間</A>
        </P>
</DIV>






<DIV>
          <A NAME="S_14.htm_IX_FileDateAndTime"></A>
          <A NAME="S_14.htm_IX_FDAT_&ldots;"></A>
          <A NAME="S_14.htm_IX_FDATExtract&ldots; () macros"></A>
        <H1 CLASS="refHeading">FileDateAndTime</H1>
<PRE CLASS="syntax">typedef DWordFlags FileDateAndTime;#define FDAT_HOUR 0xf8000000#define FDAT_MINUTE 0x07e00000#define FDAT_2 SECOND 0x001f0000#define FDAT_YEAR 0x0000fe00#define FDAT_MONTH 0x000001e0#define FDAT_DAY 0x0000001f#define FDAT_HOUR_OFFSET 27#define FDAT_MINUTE_OFFSET 21#define FDAT_2 SECOND_OFFSET 16#define FDAT_YEAR_OFFSET 9#define FDAT_MONTH_OFFSET 5#define FDAT_DAY_OFFSET 0#define FDAT_BASE_YEAR 1980</PRE>
<P>各GEOSファイルには、2つの日付とタイムスタンプがあります。 1つはファイルが作成された時刻を記録し、もう1つはファイルが最後に変更された時刻を記録します。 これらのスタンプはファイルの拡張属性とともに記録され、それぞれFEA_CREATIONおよびFEA_MODIFICATIONというラベルが付けられます。 非GE OSファイルには、ファイルが最後に修正された時刻を記録する単一の日付/時刻スタンプがあります。</P>
<P>日付/タイムスタンプは、32ビットのビットフィールドに格納されます。 このフィールドには、年、月、日、時、分、および秒のエントリが含まれます。 各フィールドは、マスクとオフセットによって識別されます。 フィールドにアクセスするには、マスク内のビット以外のすべてのビットをクリアし、オフセットの数だけビットを右にシフトします。 (これを行うためのマクロが用意されています。以下で説明します。)<CODE>FileDateAndTime</CODE>には、マスクで識別される次のフィールドがあります。</P>
<DL>
<DT>FDAT年</DT><DD>このフィールドには、基準年の1980年から数えた年が記録されます。 (定数FDAT_BASE_YEARは1980として定義されています)。 このフィールドは、値の下限からFDAT_YEAR_OFFSETビットのオフセットにあります。</DD>
<DT>FDAT月</DT><DD>このフィールドには、1月を1として月が整数で記録されます。 これは、FDAT_MONTH_OFFSETのオフセットに配置されます。</DD>
<DT>FDAT日</DT><DD>このフィールドには、月の日付が記録されます。 これは、FDAT_DAY_OFFSETのオフセットに配置されます。</DD>
<DT>FDAT時間</DT><DD>このフィールドは24時間制で時間を記録します。0は深夜0時以降の時間を表します。 これは、FDAT_HOUR_OFFSETのオフセットにあります。</DD>
<DT>FDAT_分</DT><DD>このフィールドには分が記録されます。 これは、FDAT_MINUTE_OFFSETのオフセットにあります。</DD>
<DT>FDAT_2秒</DT><DD>このフィールドには、秒を2で割った値が記録されます。つまり、フィールド値15は30秒目を示します。 (これは、2番目のビットを5ビットに適合させ、値全体を32ビットに適合させるためにこのように表されます。) これは、FDAT_2 SECOND_OFFSETのオフセットに配置されます。</DD>
</DL>
<P>マクロが用意されており<CODE>FileDateAndTime</CODE>構造。 マクロは次のとおりです。</P>
<PRE CLASS="syntax">バイトFDATExtractYear(/*1980から数えた年フィールドを返します*/FileDateAndTime fdat);ワードFDATExtractYearAD(/*年フィールド+基準年を返します*/FileDateAndTime fdat);バイトFDATExtractMonth(/*月フィールド(1=1月など)を返します*/FileDateAndTime fdat);バイトFDATExtractDay(/*日フィールドを返します*/FileDateAndTime fdat);バイトFDATExtractHour(/*時間フィールドを返します*/FileDateAndTime fdat);バイトFDATExtractMinute(/*分フィールドを返します*/FileDateAndTime fdat);バイトFDATExtract 2秒(/*2秒フィールドを返します*/FileDateAndTime fdat);バイトFDATExtractSecond(/*秒数(2*2秒)を返します*/FileDateAndTime fdat);</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_14.htm_IX_FileDesktopInfo"></A>
          <A NAME="S_14.htm_IX_FILE_DESKTOP_INFO_SIZE"></A>
        <H1 CLASS="refHeading">FileDesktopInfo</H1>
<PRE CLASS="syntax">typedef char FileDesktopInfo[FILE_DESKTOP_INFO_SIZE];</PRE>
</DIV>
<DIV>
          <A NAME="S_14.htm_IX_FileDirID"></A>
        <H1 CLASS="refHeading">FileDirID</H1>
<PRE CLASS="syntax">typedef dword FileDirID;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_14.htm_IX_FileFileID"></A>
        <H1 CLASS="refHeading">FileFileID</H1>
<PRE CLASS="syntax">typedef dword FileFileID;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_14.htm_IX_FileExclude"></A>
          <A NAME="S_14.htm_IX_FE_&ldots;  (FileExclude)"></A>
        <H1 CLASS="refHeading">FileExclude</H1>
<PRE CLASS="syntax">typedef ByteEnum FileExclude;#define FE_EXCLUSIVE 1#define FE_DENY_WRITE 2#define FE_DENY_READ 3#define FE_NONE 4</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_14.htm_IX_FileExtAttrDesc"></A>
          <A NAME="S_14.htm_IX_FEAD_&ldots;"></A>
        <H1 CLASS="refHeading">FileExtAttrDesc</H1>
<PRE CLASS="syntax">typedef struct{FileExtendedAttribute FEAD_attr;/*取得または設定する属性*/void*FEAD_value;/*バッファへのポインタ/新しい値*/word FEAD_size;/*バッファの長さ/新しい値*/chr*FEAD_name;/*FEAD_attr==FEA_CUSTOMの場合、*これは*属性名を持つnull*終端のASCII文字列を指します。それ以外の場合、*これは無視されます。*/</PRE>
<PRE CLASS="syntax">}FileExtendedAttrDesc;</PRE>
<P>拡張属性を取得および設定するルーチンには、属性FEA_MULTIPLEを渡すことができます。 この場合、配列のアドレスも渡されます。<CODE>FileExtAttrDesc</CODE>構造体と配列の要素数。 アレイを経由して、適切な情報の読み取りまたは書き込みを行います。</P>
<P><CODE><A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>の配列を渡すこともできます。<CODE>FileExtAttrDesc</CODE>構造。 この場合、配列内の要素数は渡されません。 代わりに、各配列の末尾に<CODE>FileExtAttrDesc</CODE>FEADで<CODE>属性(_A)</CODE>フィールドをFEA_END_OF_LISTに設定します。</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_14.htm#IX_FileExtendedAttribute">FileExtendedAttribute</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_14.htm_IX_FileExtendedAttribute"></A>
          <A NAME="S_14.htm_IX_FEA_&ldots;"></A>
        <H1 CLASS="refHeading">FileExtendedAttribute</H1>
<PRE CLASS="syntax">typedef enum/*word*/{FEA_MODIFICATION, FEA_FILE_ATTR, FEA_SIZE, FEA_FILE_TYPE, FEA_FLAGS, FEA_RELEASE, FEA_PROTOCOL, FEA_TOKEN, FEA_CREATOR, FEA_USER_NOTES, FEA_NOTICE, FEA_CREATION, FEA_PASSWORD, FEA_CUSTOM, FEA_NAME, FEA_GEODE_ATTR, FEA_PATH_INFO, FEA_FILE_ID, FEA_DESKTOP_INFO, FEA_DRIVE_STATUS, FEA_DOS_NAME, FEA_OWNER, FEA_RIGHTS, FEA_MULTIPLE=0 xfffe,FEA_END_OF_LIST=0 xffff,}FileExtendedAttribute;</PRE>
<P>すべてのGEOSファイルには、一連の拡張属性があります。 これらの属性は、次のコマンドで復元できます。<CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileGetPathExtAttributes()">FileGetPathExtAttributes()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileGetHandleExtAttributes()">FileGetHandleExtAttributes()</A></CODE>を使用することもできます。<CODE><A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>指定した拡張属性を持つファイルをディレクトリから検索します。</P>
<P>上記の拡張属性が実装されました。 GEOSの将来のリリースでは、さらに追加される可能性があります。 属性の詳細については、を参照してください。<A HREF="../../Files/FileSys/FileSys_d.htm#49785">「ファイルシステム」の章</A>ボタンをクリックし</P><P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_14.htm#IX_FileExtAttrDesc">FileExtAttrDesc</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="S_15.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FileFromTransferBlockID() macro"></A>
        <H1 CLASS="refHeading">FileFromTransferBlockID</H1>
<PRE CLASS="syntax">VMFileHandle FileFromTransferBlockID(id);TransferBlockID id;</PRE>
<P>このマクロは、指定された<CODE>TransferBlockID</CODE>値を入力します。</P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FileHandle"></A>
        <H1 CLASS="refHeading">ファイルハンドル</H1>
<PRE CLASS="syntax">typedefハンドルファイルハンドル;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FILE_LONGNAME_BUFFER_SIZE"></A>
          <A NAME="S_15.htm_IX_FileLongName"></A>
        <H1 CLASS="refHeading">FileLongName</H1>
<PRE CLASS="syntax">typedef char FileLongName[FILE_LONGNAME_BUFFER_SIZE];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FILE_OWNER_NAME_SIZE"></A>
          <A NAME="S_15.htm_IX_FileOwnerName"></A>
        <H1 CLASS="refHeading">FileOwnerName</H1>
<PRE CLASS="syntax">typedef char FileOwnerName[FILE_OWNER_NAME_SIZE];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FilePassword"></A>
          <A NAME="S_15.htm_IX_FILE_PASSWORD_SIZE"></A>
        <H1 CLASS="refHeading">FilePassword</H1>
<PRE CLASS="syntax">typedef char FilePassword[FILE_PASSWORD_SIZE];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FilePosMode"></A>
          <A NAME="S_15.htm_IX_FILE_POS_&ldots;"></A>
        <H1 CLASS="refHeading">FilePosMode</H1>
<PRE CLASS="syntax">typedef ByteEnum FilePosMode;#define FILE_POS_START 0#define FILE_POS_RELATIVE 1#define FILE_POS_END 2</PRE>
<P> </P>
</DIV>

<DIV>
          <A NAME="S_15.htm_IX_FileTime"></A>
        <H1 CLASS="refHeading">ファイル時間</H1>
<PRE CLASS="syntax">typedef WordFlags FileTime;#define FT_HOUR 0xf800#define FT_MINUTE 0x07e0#define FT_2 SECOND 0x001f#define FT_HOUR_OFFSET 11#define FT_MINUTE_OFFSET 5#define FT_2 SECOND_OFFSET 0</PRE>
<P>ファイルのタイムスタンプは16ビットのビットフィールドに格納されます。 このフィールドには、時、分、および秒のエントリが含まれます。 各フィールドは、マスクとオフセットによって識別されます。 フィールドにアクセスするには、マスク内のビット以外のすべてのビットをクリアし、オフセットの数だけビットを右にシフトします。<CODE>ファイル時間</CODE>には、マスクで識別される次のフィールドがあります。</P>

<DL>
<DT>
          <STRONG>FT_時間</STRONG>
        </DT><DD>このフィールドは24時間制で時間を記録します。0は深夜0時以降の時間を表します。 オフセット<CODE>「時間オフセット」(FT_HOUR_OFFSET)</CODE>ビット。</DD>
<DT>
          <STRONG>フィート分</STRONG>
        </DT><DD>このフィールドは分を示します。 オフセット<CODE>「フィート分オフセット」(FT_MINUTE_OFFSET)</CODE>ビット。</DD>
<DT>
          <STRONG>FT_2秒</STRONG>
        </DT><DD>このフィールドには、秒を2で割った値が記録されます。つまり、フィールド値15は30秒目を示します。 (2番目のビットを5ビットに合わせるために、このように表されています。) 次のオフセットに配置されます。<CODE>「フィート2秒オフセット」(FT_2 SECOND_OFFSET)</CODE>ビット。</DD>
</DL>

<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ファイル.h</STRONG>
        </P>
<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <A HREF = "S_14.htm#IX_FileDate">ファイル日付</A>
        </P>
</DIV>


<DIV>
          <A NAME="S_15.htm_IX_FileUserNotes"></A>
          <A NAME="S_15.htm_IX_GFH_USER_NOTES_BUFFER_SIZE"></A>
        <H1 CLASS="refHeading">FileUserNotes</H1>
<PRE CLASS="syntax">typedef char FileUserNotes[GFH_USER_NOTES_BUFFER_SIZE];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FindNoteHeader"></A>
          <A NAME="S_15.htm_IX_FNH_&ldots;"></A>
        <H1 CLASS="refHeading">FindNoteHeader</H1>
<PRE CLASS="syntax">typedef struct{word FNH_count;/*見つかった一致するノートの数*/}FindNoteHeader;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FloatExponent"></A>
          <A NAME="S_15.htm_IX_FE_&ldots;  (FloatExponent)"></A>
        <H1 CLASS="refHeading">FloatExponent</H1>
<PRE CLASS="syntax">typedef WordFlags FloatExponent;#define FE_SIGN 0x8000#define FE_EXPONENT 0x7fff</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FloatNum"></A>
          <A NAME="S_15.htm_IX_F_&ldots;"></A>
        <H1 CLASS="refHeading">FloatNum</H1>
<PRE CLASS="syntax">typedef struct{word F_mantissa_wd0;word F_mantissa_wd1;word F_mantissa_wd2;word F_mantissa_wd3;FloatExponent F_exponent;}FloatNum;</PRE>
<P> </P>
</DIV>




<DIV>
          <A NAME="S_15.htm_IX_FontAttrs"></A>
          <A NAME="S_15.htm_IX_FA_&ldots;  (FontAttrs)"></A>
        <H1 CLASS="refHeading">FontAttrs</H1>
<PRE CLASS="syntax">typedef ByteFlags FontAttrs;#define FA_FIXED_WIDTH 0x40#define FA_ORIENT 0x20#define FA_OUTLINE 0x10#define FA_FAMILY 0x0f#define FA_FAMILY_OFFSET 0</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FEF_&ldots;"></A>
          <A NAME="S_15.htm_IX_FontEnumFlags"></A>
        <H1 CLASS="refHeading">FontEnumFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags FontEnumFlags;#define FEF_ALPHABETIZE 0x80/*返されたフォントのリストをアルファベット順にする*/#define FEF_FIXED_WIDTH 0x20/*固定幅フォントのみを返す*/#define FEF_FAMILY 0x10#define FEF_STRING 0x08#define FEF_DOWNCASE 0x04/*返されるフォント名は小文字になる*/#define FEF_BITMAPS 0x02/*ビットマップフォントに興味がある*/#define FEF_OUTLINES 0x01/*アウトラインフォントに興味がある*/</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_15.htm_IX_FontEnumStruct"></A>
          <A NAME="S_15.htm_IX_FES_&ldots;"></A>
          <A NAME="S_15.htm_IX_FID_NAME_LEN"></A>
        <H1 CLASS="refHeading">FontEnumStruct</H1>
<PRE CLASS="syntax">typedef struct{FontIDs FES_ID;char FES_name[FID_NAME_LEN];}FontEnumStruct;</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="S_16.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_16.htm_IX_FontFamily"></A>
          <A NAME="S_16.htm_IX_FF_&ldots;"></A>
        <H1 CLASS="refHeading">フォントファミリ</H1>
<PRE CLASS="syntax">typedefバイトFontFamily;#define FF_NON_PORTABLE 0x0007#define FF_SPECIAL 0x0006#define FF_MONO 0x0005#define FF_SYMBOL 0x0004#define FF_ORNAMENT 0x0003#define FF_SCRIPT 0x0002#define FF_SANS_SERIF 0x0001#define FF_SERIF 0x0000</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォントID.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_16.htm_IX_FontGroup"></A>
          <A NAME="S_16.htm_IX_FG_&ldots;"></A>
        <H1 CLASS="refHeading">FontGroup</H1>
<PRE CLASS="syntax">typedef enum/*word*/{#define FG_NON_PORTABLE 0x0e00#define FG_SPECIAL 0x0c00#define FG_MONO 0x0a00#define FG_SYMBOL 0x0800#define FG_ORNAMENT 0x0600#define FG_SCRIPT 0x0400#define FG_SANS_SERIF 0x0200#define FG_SERIF 0x0000}FontGroup;</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォントID.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_16.htm_IX_FontIDRecord"></A>
          <A NAME="S_16.htm_IX_FIDR_&ldots;"></A>
        <H1 CLASS="refHeading">FontIDRecord</H1>
<PRE CLASS="syntax">typedef WordFlags FontIDRecord;#define FIDR_maker 0xf000#define FIDR_ID 0x0fff#define FIDR_maker_OFFSET 12#define FIDR_ID_OFFSET 0</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="S_17.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_17.htm_IX_FontID"></A>
          <A NAME="S_17.htm_IX_FID_&ldots;"></A>
        <H1 CLASS="refHeading">フォントID</H1>
<PRE CLASS="syntax"> </PRE>
<P>フォントは通常、FontIDによって参照されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォントID.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="S_18.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_18.htm_IX_FontMaker"></A>
          <A NAME="S_18.htm_IX_FM_&ldots;  (FontMaker)"></A>
        <H1 CLASS="refHeading">フォントメーカー</H1>
<PRE CLASS="syntax">typedef word FontMaker;#define FM_PRINTER 0xf000#define FM_MICROLOGIC 0xe000#define FM_ATECH 0xd000#define FM_PUBLIC 0xc000#define FM_AGFA 0x4000#define FM_BITSTREAM 0x3000#define FM_ADOBE 0x2000#define FM_NIMBUSQ 0x1000#define FM_BITMAP 0x0000</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォントID.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_18.htm_IX_FontMap"></A>
          <A NAME="S_18.htm_IX_FM_&ldots;  (FontMap)"></A>
        <H1 CLASS="refHeading">フォントマップ</H1>
<PRE CLASS="syntax">typedef byte FontMap;#define FM_DONT_USE 0x00ff#define FM_EXACT 0x0000</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォントID.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_18.htm_IX_FontWeight"></A>
          <A NAME="S_18.htm_IX_FW_&ldots;"></A>
        <H1 CLASS="refHeading">フォントの太さ</H1>
<PRE CLASS="syntax">typedef ByteEnum FontWeight;#define FW_ULTRA_LIGHT 0#define FW_EXTRA_LIGHT 1#define FW_LIGHT 2#define FW_BOOK 3#define FW_NORMAL 4#define FW_DEMI 5#define FW_BOLD 6#define FW_EXTRA_BOLD 7#define FW_ULTRA_BOLD 8#define FW_BLACK 9</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_18.htm_IX_FontWidth"></A>
          <A NAME="S_18.htm_IX_FWI_&ldots;"></A>
        <H1 CLASS="refHeading">フォントの幅</H1>
<PRE CLASS="syntax">typedef ByteEnum FontWidth;#define FWI_NARROW 0#define FWI_CONDENSED 1#define FWI_MEDIUM 2#define FWI_WIDE 3#define FWI_EXPANDED 4</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">フォント.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_18.htm_IX_FormatArray"></A>
          <A NAME="S_18.htm_IX_CLIPBOARD_MAX_FORMATS"></A>
        <H1 CLASS="refHeading">FormatArray</H1>
<PRE CLASS="syntax">typedef ClipboardItemFormatInfo FormatArray[CLIPBOARD_MAX_FORMATS];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_18.htm_IX_FormatError"></A>
        <H1 CLASS="refHeading">フォーマットエラー</H1>
<PRE CLASS="syntax">typedef ByteEnum FormatError;#define FMT_DONE 0#define FMT_READY 1#define FMT_RUNNING 2#define FMT_DRIVE_NOT_READY 3#define FMT_ERR_WRITING_BOOT 4#define FMT_ERR_WRITING_ROOT_DIR 5#define FMT_ERR_WRITING_FAT 6#define FMT_ABORTED 7#define FMT_SET_VOLUME_NAME_ERR 8#define FMT_CANNOT_FORMAT_FIXED_DISKS_IN_CUR_RELEASE 9#define FMT_BAD_PARTITION_TABLE 10#define FMT_ERR_READING_PARTITION_TABLE 11#define FMT_ERR_NO_PARTITION_FOUND 12#define FMT_ERR_NO_EXTENDED_PARTITION_FOUND 14#define FMT_ERR_CAN_ALLOC_SECTOR_BUFFER 16#define FMT_ERR_WRITE_PROTECTED 17#define FMT_ERR_DRIVE_CANNOT_SUPPORT_GIVEN_FORMAT 18#define FMT_ERR_INVALID_DRIVE_SPECIFIED 19#define FMT_ERR_DRIVE_CANNOT_BE_FORMATTED 20#define FMT_ERR_DISK_UNAVAILABLE 21</PRE>
</DIV>
<DIV>
          <A NAME="S_18.htm_IX_FormatIDFromManufacturerAndType() macro"></A>
        <H1 CLASS="refHeading">FormatIDFromManufacturerAndType</H1>
<PRE CLASS="syntax">ClipboardItemFormatID FormatIDFromManufacturerAndType(man, typ)ManufacturerID man;word typ;</PRE>
<P>このマクロは<CODE>ClipboardItemFormatID</CODE>指定された製造元IDと形式IDからのdword値。</P>
</DIV>
<DIV>
          <A NAME="S_18.htm_IX_FunctionID"></A>
          <A NAME="S_18.htm_IX_FUNCTION_ID_&ldots;"></A>
        <H1 CLASS="refHeading">FunctionID</H1>
<PRE CLASS="syntax">typedef enum/*word*/{FUNCTION_ID_ABS, FUNCTION_ID_ACOS, FUNCTION_ID_ACOSH, FUNCTION_ID_AND, FUNCTION_ID_ASIN, FUNCTION_ID_ASINH, FUNCTION_ID_ATAN, FUNCTION_ID_ATAN2, FUNCTION_ID_ATANH, FUNCTION_ID_AVG, FUNCTION_ID_CHAR, FUNCTION_ID_CHOOSE, FUNCTION_ID_CLEAN, FUNCTION_ID_CODE, FUNCTION_ID_COLS, FUNCTION_ID_COS, FUNCTION_ID_COSH, FUNCTION_ID_COUNT, FUNCTION_ID_CTERM, FUNCTION_ID_DATE, FUNCTION_ID_DATEVALUE, FUNCTION_ID_DAY, FUNCTION_ID_DDB, FUNCTION_ID_EXACT, FUNCTION_ID_EXP, FUNCTION_ID_FACT, FUNCTION_ID_FALSE, FUNCTION_ID_FIND, FUNCTION_ID_FV, FUNCTION_ID_HLOOKUP, FUNCTION_ID_HOUR, FUNCTION_ID_IF, FUNCTION_ID_INDEX, FUNCTION_ID_INT, FUNCTION_ID_IRR, FUNCTION_ID_ISERR, FUNCTION_ID_ISNUMBER, FUNCTION_ID_ISSTRING, FUNCTION_ID_LEFT, FUNCTION_ID_LENGTH, FUNCTION_ID_LN, FUNCTION_ID_LOG, FUNCTION_ID_LOWER, FUNCTION_ID_MAX, FUNCTION_ID_MID, FUNCTION_ID_MIN, FUNCTION_ID_MINUTE, FUNCTION_ID_MOD, FUNCTION_ID_MONTH, FUNCTION_ID_N, FUNCTION_ID_NA, FUNCTION_ID_NOW, FUNCTION_ID_NPV, FUNCTION_ID_OR, FUNCTION_ID_PI, FUNCTION_ID_PMT, FUNCTION_ID_PRODUCT, FUNCTION_ID_PROPER, FUNCTION_ID_PV, FUNCTION_ID_RANDOM_N, FUNCTION_ID_RANDOM, FUNCTION_ID_RATE, FUNCTION_ID_REPEAT, FUNCTION_ID_REPLACE, FUNCTION_ID_RIGHT, FUNCTION_ID_ROUND, FUNCTION_ID_ROWS, FUNCTION_ID_SECOND, FUNCTION_ID_SIN, FUNCTION_ID_SINH, FUNCTION_ID_SLN, FUNCTION_ID_SQRT, FUNCTION_ID_STD, FUNCTION_ID_STDP, FUNCTION_ID_STRING, FUNCTION_ID_SUM, FUNCTION_ID_SYD, FUNCTION_ID_TAN, FUNCTION_ID_TANH, FUNCTION_ID_TERM, FUNCTION_ID_TIME, FUNCTION_ID_TIMEVALUE, FUNCTION_ID_TODAY, FUNCTION_ID_TRIM, FUNCTION_ID_TRUE, FUNCTION_ID_TRUNC, FUNCTION_ID_UPPER, FUNCTION_ID_VALUE, FUNCTION_ID_VAR, FUNCTION_ID_VARP, FUNCTION_ID_VLOOKUP, FUNCTION_ID_WEEKDAY, FUNCTION_ID_YEAR, FUNCTION_ID_FILENAME, FUNCTION_ID_PAGE, FUNCTION_ID_PAGES, FUNCTION_ID_FIRST_EXTERNAL_FUNCTION=FUNCTION_ID_FIRST_EXTERNAL_FUNCTION_BASE}FunctionID;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_19.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCM_info"></A>
          <A NAME="S_19.htm_IX_GCMI_&ldots;"></A>
        <H1 CLASS="refHeading">GCM情報</H1>
<PRE CLASS="syntax">typedef enum/*word*/{GCMI_MIN_X, GCMI_MIN_X_ROUNDED, GCMI_MIN_Y, GCMI_MIN_Y_ROUNDED, GCMI_MAX_X, GCMI_MAX_X_ROUNDED, GCMI_MAX_Y, GCMI_MAX_Y_ROUNDED, }GCM_info;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNDriveChangeNotificationType"></A>
          <A NAME="S_19.htm_IX_GCNDCNT_&ldots;"></A>
        <H1 CLASS="refHeading">GCNDriveChangeNotificationType</H1>
<PRE CLASS="syntax">typedef enum{GCNDCNT_CREATED, GCNDCNT_DESTROYED}GCNDriveChangeNotificationType;という文字列を返します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNExpressMenuNotificationType"></A>
          <A NAME="S_19.htm_IX_GCNEMNT_&ldots;"></A>
        <H1 CLASS="refHeading">GCNExpressMenuNotificationType</H1>
<PRE CLASS="syntax">typedef enum{GCNEMNT_CREATED, GCNEMNT_DESTROYED}GCNExpressMenuNotificationType;という文字列を返します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNListBlockHeader"></A>
          <A NAME="S_19.htm_IX_GCNLBH_&ldots;"></A>
        <H1 CLASS="refHeading">GCNListBlockHeader</H1>
<PRE CLASS="syntax">typedef struct{LMemBlockHeader GCNLBH_lmemHeader;ChunkHandle GCNLBH_listOfLists;}GCNListBlockHeader;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNListElement"></A>
          <A NAME="S_19.htm_IX_GCNLE_item[]"></A>
        <H1 CLASS="refHeading">GCNListElement</H1>
<PRE CLASS="syntax">typedef struct{optr GCNLE_item;}GCNListElement;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNListHeader"></A>
          <A NAME="S_19.htm_IX_GCNLH_&ldots;"></A>
        <H1 CLASS="refHeading">GCNListHeader</H1>
<PRE CLASS="syntax">typedef struct{ChunkArrayHeader GCNLH_meta;word GCNLH_statusEvent;MemHandle GCNLH_statusData;word GCNLH_statusCount;/*GCNListOfListElementsの開始*/}GCNListHeader;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNListOfListsElement"></A>
          <A NAME="S_19.htm_IX_GCNLOLE_&ldots;"></A>
        <H1 CLASS="refHeading">GCNListOfListsElement</H1>
<PRE CLASS="syntax">typedef struct{GCNListType GCNLOLE_ID;ChunkHandle GCNLOLE_list;}GCNListOfListsElement;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNListOfListsHeader"></A>
          <A NAME="S_19.htm_IX_GCNLOL_meta"></A>
        <H1 CLASS="refHeading">GCNListOfListsHeader</H1>
<PRE CLASS="syntax">typedef struct{ChunkArrayHeader GCNLOL_meta;/*GCNListOfListsElementのスタート*/}GCNListOfListsHeader;</PRE>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNListParams"></A>
          <A NAME="S_19.htm_IX_GCNLP_&ldots;"></A>
        <H1 CLASS="refHeading">GCNListParams</H1>
<PRE CLASS="syntax">typedef struct{GCNListType GCNLP_ID;optr GCNLP_optr;}GCNListParams;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNListSendFlags"></A>
          <A NAME="S_19.htm_IX_GCNLSF_&ldots;"></A>
        <H1 CLASS="refHeading">GCNListSendFlags</H1>
<PRE CLASS="syntax">typedef WordFlags GCNListSendFlags;#define GCNLSF_SET_STATUS 0x8000#define GCNLSF_IGNORE_IF_STATUS_TRANSITIONING 0x4000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNListType"></A>
          <A NAME="S_19.htm_IX_GCNLT_&ldots;"></A>
        <H1 CLASS="refHeading">GCNListType</H1>
<PRE CLASS="syntax">typedef struct{word GCNLT_manuf;word GCNLT_type;}GCNListType;と入力します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNListTypeFlags"></A>
          <A NAME="S_19.htm_IX_GCNLTF_&ldots;"></A>
        <H1 CLASS="refHeading">GCNListTypeFlags</H1>
<PRE CLASS="syntax">typedef WordFlags GCNListTypeFlags;#define GCNLTF_SAVE_TO_STATE 0x8000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_19.htm_IX_GCNShutdownControlType"></A>
          <A NAME="S_19.htm_IX_GCNSCT_&ldots;"></A>
        <H1 CLASS="refHeading">GCNShutdownControlType</H1>
<PRE CLASS="syntax">typedef enum{GCNSCT_SUSPEND, GCNSCT_SHUTDOWN, GCNSCT_UNSUSPEND}GCNShutdownControlType;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_1a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GCNStandardListType"></A>
          <A NAME="S_1a.htm_IX_GCNSLT_&ldots;"></A>
        <H1 CLASS="refHeading">GCNStandardListType</H1>
<PRE CLASS="syntax">typedef enum{GCNSLT_FILE_SYSTEM, GCNSLT_APPLICATION, GCNSLT_DATE_TIME, GCNSLT_DICTIONARY, GCNSLT_EXPRESS_MENU, GCNSLT_SHUTDOWN_CONTROL}GCNStandardListType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GenAppGCNListTypes"></A>
        <H1 CLASS="refHeading">GenAppGCNListTypes</H1>
<P>Gocでは、GenAppGCNListTypes値は別の名前で別の構造に維持されます。 標準GEOSリストタイプは、GeoWorksGenAppGCNListType列挙タイプの一部です。</P>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GeneralEvent"></A>
          <A NAME="S_1a.htm_IX_GE_&ldots;"></A>
        <H1 CLASS="refHeading">GeneralEvent</H1>
<PRE CLASS="syntax">typedef enum{GE_NO_EVENT=0, /*ダミーイベント(NOP)*/GE_END_OF_SONG=2, /*曲の終わりをマークする*/GE_SET_PRIORITY=4, /*サウンドの優先度を変更する*/GE_SET_TEMPO=6, /*サウンドのテンポを変更する*/GE_SEND_NOTIFICATION=8, /*エンコードされたメッセージを送信する*/GE_V_SEMAPHORE=10/*V&#39;s a specified semaphore*/}GeneralEvent;</PRE>
<P>これらは、音楽バッファを構成するさまざまなイベントの一部を表します。</P>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GenTravelOption"></A>
        <H1 CLASS="refHeading">GenTravelOption</H1>
<P>の<CODE>生成クラス</CODE>は<CODE>TravelOption</CODE>列挙値。 詳細については<CODE>TravelOption</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GeodeAttrs"></A>
          <A NAME="S_1a.htm_IX_GA_&ldots;  (GeodeAttrs)"></A>
        <H1 CLASS="refHeading">GeodeAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags GeodeAttrs;#define GA_PROCESS 0x8000#define GA_LIBRARY 0x4000#define GA_DRIVER 0x2000#define GA_KEEP_FILE_OPEN 0x1000#define GA_SYSTEM 0x0800#define GA_MULTI_LAUNCHABLE 0x0400#define GA_APPLICATION 0x0200#define GA_DRIVER_INITIALIZED 0x0100#define GA_LIBRARY_INITIALIZED 0x0080#define GA_GEODE_INITIALIZED 0x0040#define GA_USES_COPROC 0x0020#define GA_REQUIRES_COPROC 0x0010#define GA_HAS_GENERAL_CONSUMER_MODE 0x0008#define GA_ENTRY_POINTS_IN_C 0x0004</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GeodeDefaultDriverType"></A>
          <A NAME="S_1a.htm_IX_GDDT_&ldots;"></A>
        <H1 CLASS="refHeading">GeodeDefaultDriverType</H1>
<PRE CLASS="syntax">typedef enum{GDDT_FILE_SYSTEM=0, /*ファイルシステムドライバ*/GDDT_KEYBOARD=2, /*キーボードドライバ*/GDDT_MOUSE=4, /*マウスドライバ*/GDDT_VIDEO=6, /*ビデオドライバ*/GDDT_MEMORY_VIDEO=8, /*Vidmemドライバ*/GDDT_POWER_MANAGEMENT=10/*電源管理ドライバ*/GDDT_TASK=12/*タスクドライバ*/}GeodeDefaultDriverType;</PRE>
<P>デフォルトのドライバタイプには、GEOSのデフォルトのドライバタイプごとに1つの値があります。 このタイプは<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeGetDefaultDriver()">GeodeGetDefaultDriver()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodeSetDefaultDriver()">GeodeSetDefaultDriver()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GeodeGetInfoType"></A>
        <H1 CLASS="refHeading">GeodeGetInfoType</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeGetInfo()">GeodeGetInfo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GeodeHandle"></A>
        <H1 CLASS="refHeading">GeodeHandle</H1>
<PRE CLASS="syntax">typedefハンドルGeodeHandle;</PRE>
<P>ロードされたジオードに関する情報を含む標準ハンドル。 ジオードがロードされると、そのハンドルによって参照されます。</P>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GeodeHeapVars"></A>
          <A NAME="S_1a.htm_IX_GHV_&ldots;"></A>
        <H1 CLASS="refHeading">GeodeHeapVars</H1>
<PRE CLASS="syntax">typedef struct{word GHV_heapSpace;}GeodeHeapVars;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1a.htm_IX_GeodeLoadError"></A>
          <A NAME="S_1a.htm_IX_GLE_&ldots;"></A>
        <H1 CLASS="refHeading">GeodeLoadError</H1>
<PRE CLASS="syntax">typedef enum{GLE_PROTOCOL_IMPORTER_TOO_RECENT, GLE_PROTOCOL_IMPORTER_TOO_OLD, GLE_FILE_NOT_FOUND, GLE_LIBRARY_NOT_FOUND, GLE_FILE_READ_ERROR, GLE_NOT_GEOS_FILE, GLE_NOT_GEOS_EXECUTABLE_FILE, GLE_ATTRIBUTE_MISMATCH, GLE_MEMORY_ALLOCATION_ERROR, GLE_NOT_MULTI_LAUNCHABLE, GLE_LIBRARY_PROTOCOL_ERROR, GLE_LIBRARY_LOAD_ERROR, GLE_DRIVER_INIT_ERROR, GLE_LIBRARY_INIT_ERROR, GLE_DISK_TOO_FULL, GLE_FIELD_DETACHING, }フィールド;GeodeLoadError</PRE>
<P>これらのエラーは、次のような測地をロードするルーチンによって返される場合があります。<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE><CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseLibrary()">GeodeUseLibrary()</A></CODE><CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseDriver()">GeodeUseDriver()</A></CODE>、および<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="S_1b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_1b.htm_IX_GeodeToken"></A>
          <A NAME="S_1b.htm_IX_GT_&ldots;"></A>
        <H1 CLASS="refHeading">GeodeToken</H1>
<PRE CLASS="syntax">typedef struct{TokenChars GT_chars;ManufacturerID GT_manufID;}GeodeToken;</PRE>
<P>トークン識別子を定義します。 の<CODE>GT文字</CODE>fieldはトークンを識別する4文字です。<CODE>GT_manufID</CODE>は、参照されるアイテムの製造元の識別番号です。</P>
</DIV>
<DIV>
          <A NAME="S_1b.htm_IX_GeosFileHeaderFlags"></A>
          <A NAME="S_1b.htm_IX_GFHF_&ldots;"></A>
        <H1 CLASS="refHeading">GeosFileHeaderFlags</H1>
<PRE CLASS="syntax">typedef WordFlags GeosFileHeaderFlags;#define GFHF_TEMPLATE 0x8000#define GFHF_SHARED_MULTIPLE 0x4000#define GFHF_SHARED_SINGLE 0x2000</PRE>
<P> </P>
</DIV>
<DIV>ジオス<A NAME="S_1b.htm_IX_GeosFileType"></A><A NAME="S_1b.htm_IX_GFT_&ldots;"></A><H1 CLASS="refHeading">GeosFileType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{GFT_NOT_GEOS_FILE, GFT_EXECUTABLE, GFT_VM, GFT_DATA, GFT_DIRECTORY, GFT_LINK}GeosFileType;</PRE>
<P>ファイルは、いくつかの大きなカテゴリに分けられます。 FEA_FILE_TYPE拡張属性を取得することで、ファイルのカテゴリを調べることができます。 この属性は<CODE>GeosFileType</CODE>列挙型。 このタイプには次の値があります。</P>
<DL>
<DT>GFT_NOT_GEOS_FILE(GFT_NOT_GEOS_ファイル)</DT><DD>ファイルはGEOSファイルではありません。 この定数は、ゼロに等しいことが保証されています。</DD>
<DT>GFT_実行可能ファイル</DT><DD>このファイルは実行可能です。つまり、ある種のgeodeです。</DD>
<DT>GFT仮想マシン</DT><DD>このファイルはVMファイルです。</DD>
<DT>GFTデータ</DT><DD>このファイルはGEOSバイトファイルです(下記参照)。</DD>
<DT>GFTディレクトリ</DT><DD>ファイルはGEOSディレクトリです(まだ実装されていません)。</DD>
<DT>リンク(GFT_LINK)</DT><DD>このファイルはシンボリックリンクです(まだ実装されていません)。</DD>
</DIV>
<DIV>
          <A NAME="S_1b.htm_IX_GAGCNLT_&ldots;"></A>
          <A NAME="S_1b.htm_IX_GeoWorksGenAppGCNListType"></A>
        </DL>
<H1 CLASS="refHeading">GeoWorksGenAppGCNListType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{GAGCNLT_SELF_LOAD_OPTIONS=0x6800, GAGCNLT_GEN_CONTROL_NOTIFY_STATUS_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_SELECT_STATE_CHANGE, GAGCNLT_EDIT_CONTROL_NOTIFY_UNDO_STATE_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_TEXT_CHAR_ATTR_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_TEXT_PARA_ATTR_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_TEXT_TYPE_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_TEXT_SELECTION_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_TEXT_COUNT_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_STYLE_TEXT_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_STYLE_SHEET_TEXT_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_TEXT_STYLE_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_FONT_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_POINT_SIZE_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_FONT_ATTR_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_JUSTIFICATION_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_TEXT_FG_COLOR_CHANGE, GAGCNLT_APP_TARGET_NOTIFY_TEXT_BG_COLOR_CHANGE, GAGCNLT_APP_TARGET_変更、GAGCNLT_APP_TARGET_NOTIFY_STYLE_GROBJ_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_STYLE_SHEET_GROBJ_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_GROBJ_BODY_INSTRUCTION_FLAGS_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_GROBJ_GRADIENT_ATTR_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_RULER_TYPE_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_RULER_GRID_CHANGE、GAGCNLT_TEXT_RULER_OBJECTS、GAGCNLT_APP_TARGET_NOTIFY_BITMAP_CURRENT_TOOL_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_BITMAP_CURRENT_FORMAT_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_FIELD_PROPERTIES_STATUS_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_FIELD_LIST_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_RCP_STATUS_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_FIELD_APPEARANCE_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_DUMMY_CHANGE_2、GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_DUMMY_CHANGE_3、GAGCNLT_APP_NOTIFY_DOC_SIZE_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_EDIT_BAR_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_SELECTION_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_CELL_WIDTH_HEIGHT_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_DOC_ATTR_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_CELL_ATTR_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_CELL_NOTES_CHANGE、_APP_TARGET_NOTIFY_SPREADSHEET_DATA_RANGE_CHANGE、_APP_TARGET_NOTIFY_TEXT_NAME_CHANGE、_FLOAT_FORMAT_CHANGE、GAGCNLT_DISPLAY_OBJECTS_WITH_RULERs、GAGCNLT_APP_TARGET_NOTIFY_APP_CHANGE、GAGCNLT_APP_TARGET_NOTIFY_LIBRARY_CHANGE、GAGCNLT_WINDOWS、GAGCNLT_STARTUP_LOAD_OPTIONS}GeoWorksGenAppGCNListType;GAGCNLT GROBJ GAGCNLT GAGCNLT GAGCNLT GAGCNLT GROBJ GAGCNLT GROBJ GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GROBJ GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GAGCNLT GROBJ GAGCNLT</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_1c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_1c.htm_IX_GMID_&ldots;"></A>
          <A NAME="S_1c.htm_IX_GeoworksMediumID"></A>
        <H1 CLASS="refHeading">GeoworksMediumID</H1>
<PRE CLASS="syntax">typedef enum{GMID_INVALID=0x0, GMID_SERIAL_CABLE, /*unit is SerialPortNum*/GMID_INFRARED, /*unit is SerialPortNum*/GMID_DATA_MODEM, /*unit is SerialPortNum*/GMID_FAX_MODEM, /*unit is SerialPortNum*/GMID_PRINTER, /*unit is printer name in mem block*/GMID_PARALLEL_PORT, /*unit is ParallelPortNum*/GMID_NETWORK, /*unit is NetID*/GMID_LOOPBACK, /*no units*/GMID_SM/*Small Message--no units*/}GeoworksMediumID;</PRE>
<P>これらの値は、MANUFACTURER_ID_GEOWORKSとともに、次の形式になります。<CODE>メディアタイプ</CODE>特定の標準通信メディアを表す値。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ミディアム.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_1c.htm_IX_GeoWorksMetaGCNListType"></A>
          <A NAME="S_1c.htm_IX_MGCNLT_&ldots;"></A>
        <H1 CLASS="refHeading">GeoWorksMetaGCNListType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{MGCNLT_ACTIVE_LIST=0x00, MGCNLT_APP_STARTUP=0x02}GeoWorksMetaGCNListType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1c.htm_IX_GeoWorksNotificationType"></A>
          <A NAME="S_1c.htm_IX_GWNT_&ldots;"></A>
        <H1 CLASS="refHeading">GeoWorksNotificationType</H1>
<PRE CLASS="syntax">typedef enum{GWNT_INK, GWNT_GEN_CONTROL_NOTIFY_STATUS_CHANGE, GWNT_SELECT_STATE_CHANGE, GWNT_UNDO_STATE_CHANGE, GWNT_STYLE_CHANGE, GWNT_STYLE_SHEET_CHANGE, GWNT_TEXT_CHAR_ATTR_CHANGE, GWNT_TEXT_PARA_ATTR_CHANGE, GWNT_TEXT_TYPE_CHANGE, GWNT_TEXT_SELECTION_CHANGE, GWNT_TEXT_COUNT_CHANGE, GWNT_TEXT_STYLE_CHANGE, GWNT_FONT_CHANGE, GWNT_POINT_SIZE_CHANGE, GWNT_FONT_ATTR_CHANGE, GWNT_JUSTIFICATION_CHANGE, GWNT_TEXT_FG_COLOR_CHANGE, GWNT_TEXT_BG_COLOR_CHANGE, GWNT_TEXT_PARA_COLOR_CHANGE, GWNT_TEXT_BORDER_COLOR_CHANGE, GWNT_SEARCH_REPLACE_ENABLE_CHANGE, GWNT_SPELL_ENABLE_CHANGE, GWNT_CHART_TYPE_CHANGE, GWNT_CHART_GROUP_FLAGS, GWNT_CHART_AXIS_ATTRIBUTES, GWNT_GROBJ_CURRENT_TOOL_CHANGE, GWNT_GROBJ_BODY_SELECTION_STATE_CHANGE, GWNT_GROBJ_AREA_ATTR_CHANGE, GWNT_GROBJ_LINE_ATTR_CHANGE, GWNT_GROBJ_TEXT_ATTR_CHANGE, GWNT_GROBJ_BODY_INSTRUCTION_FLAGS_CHANGE, GWNT_GROBJ_GRADIENT_ATTR_CHANGE, GWNT_RULER_TYPE_CHANGE, GWNT_RULER_GRID_CHANGE, GWNT_RULER_GUIDE_CHANGE, GWNT_BITMAP_CURRENT_TOOL_CHANGE, GWNT_BITMAP_CURRENT_FORMAT_CHANGE, GWNT_FLAT_FILE_FIELD_PROPERTIES_STATUS_CHANGE, GWNT_FLAT_FILE_RCP_STATUS_CHANGE, GWNT_FLAT_FIELD_APPEARANCE_CHANGE, GWNT_FLAT_FILE_DUMMY_CHANGE_2, GWNT_FLAT_FILE_DUMMY_CHANGE_3, GWNT_SPOOL_DOC_OR_PAPER_SIZE, GWNT_VIEW_STATE_CHANGE, GWNT_INK_HAS_TARGET, GWNT_PAGE_STATE_CHANGE, GWNT_DOCUMENT_CHANGE, GWNT_DISPLAY spline_POINT、GWNT_SPLINE_POLYLINE、GWNT_SPLINE_SMOOTHNESS、GWNT_SPLINE_OPEN_CLOSE_CHANGE、GWNT_UNUSED_1、GWNT_SPREADSHEET_ACTIVE_CELL_CHANGE、GWNT_SPREADSHEET_EDIT_BAR_CHANGE、GWNT_SPREADSHEET_SELECTION_CHANGE、GWNT_SPREADSHEET_CELL_WIDTH_HEIGHT_CHANGE、_SPREADSHEET_DOC_ATTR_CHANGE、GWNT_SPREADSHEET_CELL_ATTR_CHANGE、_SPREADSHEET_CELL_NOTES_CHANGE、GWNT_SPREADSHEET_DATA_RANGE_CHANGE、GWNT_FLOAT_FORMAT_CHANGE、GWNT_MAP_APP_CHANGE、GWNT_MAP_LIBRARY_CHANGE、GWNT_TEXT_NAME_CHANGE、GWNT_CARD_BACK_CHANGE、GWNT_TEXT_OBJECT_HAS_FOCUS、_TEXT_CONTEXT、_TEXT_REPLACE_WITH_HWR、_HELP_CONTEXT_CHANGE、GWNT_FLOAT_FORMAT_INIT、GWNT_HARD_ICON_BAR_FUNCTION、GWNT_STARTUP_INDEXED_APP、GWNT_SPOOL_PRINTING_COMPLETE、GWNT_MODAL_WIN_CHANGE、GWNT_SPREADSHEET_NAME_CHANGE、GWNT_DOCUMENT_OPEN_COMPLETE、_EMAIL_SCAN_INBOX、_FOCUS_WINDOW_KBD_STATUS、_TAB_DOUBLE_CLICK、GWNT_PAGE_INFO_STATE_CHANGE、GWNT_CURSOR_POSITION_CHANGE、GWNT_FAX_NEW_JOB_CREATED、GWNT_FAX_NEW_JOB_COMPLETED、GWNT_EMAIL_DATABASE_CHANGE、GWNT_EMAIL_STATUS_CHANGE、GWNT_EMAIL_PAGE_PANEL_UPDATE、__DISPLAY_CHAR、_PCCOM_DISPLAY_STRING、_PCCOM_EXIT GWNT GWNT GWNT GWNT GWNT GWNT GWNT GWNT GWNT PCCOM GWNT GWNT GWNT GWNT GWNT GWNT</PRE>
<PRE CLASS="syntax">}GeoWorksNotificationType;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_1d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GeoWorksvisContentGCNListType"></A>
          <A NAME="S_1d.htm_IX_VCGCNLT_TARGET_NOTIFY_TEXT_PARA_ATTR_CHANGE"></A>
        <H1 CLASS="refHeading">GeoWorksVisContentGCNListType</H1>
<PRE CLASS="syntax">typedef enum{VCGCNLT_TARGET_NOTIFY_TEXT_PARA_ATTR_CHANGE=0x4a00, PADDING_VCGCNLT_INVALID_ITEM_000}GeoWorksVisContentGCNListType;のように指定します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GetMaskType"></A>
          <A NAME="S_1d.htm_IX_GMT_&ldots;"></A>
        <H1 CLASS="refHeading">GetMaskType</H1>
<PRE CLASS="syntax">typedef ByteEnum GetMaskType;#define GMT_ENUM 0#define GMT_BUFFER 1</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GetPalType"></A>
          <A NAME="S_1d.htm_IX_GPT_&ldots;"></A>
        <H1 CLASS="refHeading">GetPalType</H1>
<PRE CLASS="syntax">typedef ByteEnum GetPalType;#define GPT_ACTIVE 0#define GPT_CUSTOM 1#define GPT_DEFAULT 2</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GFM_info"></A>
        <H1 CLASS="refHeading">GFM情報</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_3f.htm#IX_GrFontMetrics()">GrFontMetrics()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GOC_POINT macro"></A>
        <H1 CLASS="refHeading">GOC_POINTマクロ</H1>
<PRE CLASS="syntax">#define GOC_POINT(x,y)GOC_SW(x),GOC_SW(y)</PRE>
<P>このマクロは、GStringsを静的に宣言する場合に便利です。 GStringは基本的にバイトの配列です。このマクロは2つの単語長の値を取り、それらをカンマで区切られた4つのバイトに分割します。 したがって、可変数の点データを持つGStringコマンドを読みやすくするのに役立つ。 次に例を示します。</P>
<PRE>GSDrawPolyline(3)、GOC_POINT(0,6)、GOC_POINT(106)、GOC_POINT(101)、GSFillPolygon(4,ODD_EVEN)、GOC_POINT(5,1)、GOC_POINT(9,0)、GOC_POINT(9,5)、GOC_POINT(5,6)</PRE>
<PRE>……………………</PRE>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GOC_SW(), GOC_WORD() macros"></A>
        <H1 CLASS="refHeading">GOC_SW(),GOC_WORD()マクロ</H1>
<PRE CLASS="syntax">#define GOC_SW(a)GOC_WORD(a)#define GOC_WORD(a)((a)&amp;0 xff),(((a)&amp;0xff00)>>8)</PRE>
<P>これらのマクロは、ワード長の値を含むバイト配列を静的に定義する場合に便利です。 各マクロは、ワード長の値をカンマで区切って2バイトに分割します。</P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GraphicPattern"></A>
          <A NAME="S_1d.htm_IX_HP_&ldots;  (GraphicPattern structure)"></A>
        <H1 CLASS="refHeading">GraphicPattern</H1>
<PRE CLASS="syntax">typedef struct{PatternType HP_type;byte HP_data;}GraphicPattern;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GSControl"></A>
          <A NAME="S_1d.htm_IX_GSC_&ldots;"></A>
        <H1 CLASS="refHeading">GSControl</H1>
<PRE CLASS="syntax">typedef WordFlags GSControl;#define GSC_PARTIAL 0x0200#define GSC_ONE 0x0100#define GSC_MISC 0x0080#define GSC_LABEL 0x0040#define GSC_ESCAPE 0x0020#define GSC_NEW_PAGE 0x0010#define GSC_XFORM 0x0008#define GSC_OUTPUT 0x0004#define GSC_ATTR 0x0002#define GSC_PATH 0x0001</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GSRetType"></A>
          <A NAME="S_1d.htm_IX_GSRT_&ldots;"></A>
        <H1 CLASS="refHeading">GSRetType</H1>
<PRE CLASS="syntax">typedef ByteEnum GSRetType;#define GSRT_COMPLETE 0#define GSRT_FORM_FEED 1#define GSRT_ONE 2#define GSRT_ESCAPE 3#define GSRT_OUTPUT 4#define GSRT_ELEMENT 5#define GSRT_FAULT 0 xff</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GState"></A>
        <H1 CLASS="refHeading">G状態</H1>
<P>GStatesは常にGStateHandlesによって参照され、そこに記録されている。</P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GStateHandle"></A>
        <H1 CLASS="refHeading">GStateHandle</H1>
<PRE CLASS="syntax">typedefハンドルGStateHandle;</PRE>
<P>GStates、つまりグラフィックス状態は、グラフィックスコマンドを解釈するために使用されます。 何かを描画するグラフィックスコマンドは、引数としてGStateHandleを取ります。 各GStateはウィンドウに関連付けられており、グラフィックスシステムはGStateを使用して、コマンドが影響を与えるウィンドウを決定します。</P>
<P>GStateには、描画コマンドの実行方法を決定する重要な情報も保持されています。 たとえば、線の色を保持します。 緑の線を描くには、最初のルーチンでGStateの線の色を緑に設定します。 それ以降(または線の色が再び変更されるまで)、そのGStateを使用して描画されるすべての線は緑色になります。 したがって、色、パターン、またはその他の図面属性を設定するすべてのコマンドは、GStateHandle引数を取ります。</P>
<P>GStateHandlesは、ビットマップやグラフィックス文字列を作成するときにも使用されます。 この場合、関連付けられたウィンドウは偽物です。ビットマップまたはグラフィックス文字列を表すGStateHandleに渡されたすべての描画コマンドは、画面に描画されるのではなく、データ構造に影響を与えます。</P>
</DIV>
<DIV>
          <A NAME="S_1d.htm_IX_GStrings:GString type"></A>
        <H1 CLASS="refHeading">G文字列</H1>
<PRE CLASS="syntax">typedef void GString;と入力します。</PRE>
<P>GString(&quot;Graphics Strings&quot;の省略形)は、グラフィックスコマンドの文字列を表します。 各GStringは1つ以上のGString要素で構成され、各要素は標準のグラフィックコマンドに対応しています。</P>
<P>GStringsは、次のように返されるGStateHandleに描画することで作成できます。<CODE><A HREF="../../CRef/Routines/R_38.htm#IX_GrCreateState()">GrCreateState()</A></CODE>しかし多くの場合、GStringは明示的に宣言されています。 GStringのデータは、しばしば以下のようなマクロを使って設定されます。<CODE><A HREF="../../CRef/Routines/R_4e.htm#IX_GSDrawLine() macro">GSDrawLine()</A></CODE>これらのマクロはオペコード(<CODE>GStringElement</CODE>)、マクロ引数をopcodeで期待されるデータにフォーマットします。</P>
<P>例えば</P>
<PRE>GSDrawLine(72、144、216、288);</PRE>
<P>は次のデータに展開されます。</P>
<PRE>(GStringElement)GR_DRAW_LINE</PRE>
<PRE>GOC_SW(72)、GOC_SW(144)、GOC_SW(216)、GOC_SW(288)</PRE>
<P>GOC_SW()は、ワード長の値を2バイトに分割するマクロです。 基本的に、GStringは単なるバイトの配列です。</P>
<P>したがって、これらのマクロは、通常のカーネルのグラフィックスコマンドのように見えますが、データを表すだけです。</P>
</DIV>
<HR>
          <A NAME="S_1e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_1e.htm_IX_GR_&ldots;"></A>
          <A NAME="S_1e.htm_IX_GStringElement"></A>
        <H1 CLASS="refHeading">GStringElement</H1>
<PRE CLASS="syntax">typedef ByteEnum GStringElement;/*次の要素が定義されています:(Miscellaneous GString opcodes:)GR_END_STRING</PRE>
<PRE CLASS="syntax">GR_COMMENT, (data:variable(word(length of code),code))GR_NULL_OP, GR_SET_GSTRING_BOUNDS, (data:8 byte(4 swords))GR_LABEL, (data:2 byte(word))GR_ESCAPE, (data:variable(word(size of code),code))GR_NEW_PAGE, (Coordinate Transformオペコード:)GR_APPLY_ROTATION, (data:4 byte(WWFixed))</PRE>
<PRE CLASS="syntax">GR_APPLY_SCALE, (data:8バイト(2 WWFixed))GR_APPLY_TRANSLATION, (data:8バイト(2 WWFixed))GR_APPLY_TRANSFORM, (data:26バイト(4 WWFixed, 2 DWFixed))GR_APPLY_TRANSLATION_DWORD, (data:8バイト(2 sdwords))GR_SET_TRANSFORM, (data:26バイト(4 WWFixed, 2 DWFixed))GR_SET_NULL_TRANSFORM, GR_SET_DEFAULT_TRANSFORM, GR_INIT_DEFAULT_TRANSFORM, GR_SAVE_TRANSFORM, GR_RESTORE_TRANSFORM, (Outputオペコード:)GR_DRAW_LINE, (data:8バイト(4剣))GR_DRAW_LINE_TO, (data:4バイト(2剣))GR_DRAW_REL_LINE_TO(data:8バイト(2 WWFixed))GR_DRAW_HLINE, (data:6バイト(3剣))GR_DRAW_HLINE_TO, (data:2バイト(剣))GR_DRAW_VLINE, (data:6バイト(3剣))GR_DRAW_VLINE_TO, (data:2バイト(剣))GR_DRAW_POLYLINE, (data:variable(word(#of points),points)GR_DRAW_ARC, (data:14バイト(ArcCloseType, 6剣))GR_DRAW_ARC_ARC_3 POINT, (data:14バイト(,6剣))GR_DRAW_REL_ARC_3 POINT_TO, (data:10バイト(ArcCloseType, 4剣))GR_DRAW_RECT, (data:8バイト(4剣))GR_DRAW_ROUND_RECT, (data:10バイト(word, 4剣))GR_DRAW_ROUND_RECT_TO, (data:6バイト(word, 2剣))GR_DRAW_SPLINE, (data:variable(word(#of points),points))GR_DRAW_SPLINE_TO, (data:variable(word(#of points),points))GR_DRAW_CURVE, (data:16バイト(8剣))GR_DRAW_CURVE_TO, (data:12バイト(6剣))GR_DRAW_CURVE, (data:12バイト(6剣))REL_CURVE_TO, (data:24バイト(6 WWFixed))GR_DRAW_ELLIPSE, (data:8バイト(4剣))GR_DRAW_POLYGON, (data:variable(word(#of points),points))GR_DRAW_POINT, (data:4バイト(2ワード))GR_DRAW_POINT_CP, GR_BRUSH_POLYLINE, (data:variable(word(#of points),2バイト,points))ArcCloseType ArcCloseType WWFixed</PRE>
<PRE CLASS="syntax">GR_DRAW_CHAR, (データ:5バイト)(Chars, 2 swords))GR_DRAW_CHAR_CP, (データ:1バイト)(Chars))GR_DRAW_TEXT, (データ:variable(sword, sword, word(length of string),string(not null terminated)))</PRE>
<PRE CLASS="syntax">GR_DRAW_TEXT_CP, (データ:変数(ワード(文字列の長さ),文字列(NULL終端でない)))</PRE>
<PRE CLASS="syntax">GR_DRAW_TEXT_PTR, (data:6 byte(2 swords, (char*)))GR_DRAW_TEXT_OPTR, (data:6 byte(2 swords, optr))GR_DRAW_PATH, GR_FILL_RECT, (data:8 byte(4 swords))GR_FILL_RECT_TO, (data:4 byte(2 swords))GR_FILL_ROUND_RECT, (data:10 byte(4 swords, word))GR_FILL_ROUND_RECT_TO, (data:6 byte(2 swords, word))GR_FILL_ARC, (data:14 byte(ArcCloseType, 6 swords))GR_FILL_POLYGON, (data:variable(word(#of points),RegionFillRule, points))</PRE>
<PRE CLASS="syntax">GR_FILL_ELLIPSE, (data:8 byte(2 swords))GR_FILL_PATH, (data:1 byte(RegionFillRule))GR_FILL_ARC_3 POINT,(data:14 byte(ArcCloseType, 6 swords))GR_FILL_ARC_3 POINT_TO(data:10 byte(ArcCloseType, 4 swords))GR_FILL_BITMAP, (data:6 byte(2 swords, word))GR_FILL_BITMAP_CP, (data:2 byte(word))GR_FILL_BITMAP_OPTR, GR_DRAW_BITMAP, (data:6 byte(2 swords, word))GR_DRAW_BITMAP_CP, (data:2 byte(word))GR_DRAW_BITMAP_OPTR, (data:6 byte(2 swords, optr))GR_DRAW_BITMAP_PTR, (data:6 byte(2 swords, *))GSE_BITMAP_SLICE, (data:variable)(Drawing Attribute Opcodes:)GR_SAVE_STATE, GR_RESTORE_STATE, GR_SET_MIX_MODE, (data:1 byte(MixMode))GR_MOVE_TO, (data:4 byte(2 swords, 3 bytes))GR_REL_MOVE_TO, (data:8 byte(2 WWFixed))GR_CREATE_PALETTE, GR_DESTROY_PALETTE, GR_SET_PALETTE_ENTRY, (data:4 byte(Color, 3 bytes))GR_SET_PALETTE, (data:variable(word(#of entries),entries(each 3 bytes)))</PRE>
<PRE CLASS="syntax">GR_SET_LINE_COLOR, (data:3バイト(3バイト))GR_SET_LINE_MASK, (data:1バイト(SysDrawMask))GR_SET_LINE_COLOR_MAP, (data:1バイト(ColorMapMode))GR_SET_LINE_WIDTH, (data:4バイト(WWFixed))GR_SET_LINE_JOIN, (data:1バイト(LineJoin))GR_SET_LINE_END, (data:1バイト(LineEnd))GR_SET_LINE_ATTR, (data:9バイト(CF_RGB, 3バイト,SysDrawMask, ColorMapMode, LineEnd, LineJoin, LineStyle)</PRE>
<PRE CLASS="syntax">GR_SET_MITER_LIMIT, (data:4 bytes(WWFixed))GR_SET_LINE_STYLE, (data:2 bytes(LineStyle, index))GR_SET_LINE_COLOR_INDEX, (data:1 byte(Color))GR_SET_CUSTOM_LINE_MASK, (data:8 bytes(8 bytes))GR_SET_CUSTOM_LINE_STYLE, (data:variable(word(index),word(#of on-off dash pairs))</PRE>
<PRE CLASS="syntax">ペア(各ペアは2バイト)))GR_SET_AREA_COLOR、(データ:3バイト(3バイト)GR_SET_AREA_MASK、(データ:1バイト(SysDrawMask))GR_SET_AREA_COLOR_MAP、(データ:1バイト(ColorMapMode))GR_SET_AREA_ATTR、(データ:6バイト(CF_RGB、3バイト、SysDrawMask、ColorMapMode))</PRE>
<PRE CLASS="syntax">GR_SET_AREA_COLOR_INDEX, (data:1 byte(Color))GR_SET_CUSTOM_AREA_MASK, (data:8 byte(8 byte))GR_SET_AREA_PATTERN, (data:2 byte(GraphicPattern))GR_SET_CUSTOM_AREA_PATTERN, (data:variable(GraphicPattern, word(size of data)pattern data))</PRE>
<PRE CLASS="syntax">GR_SET_TEXT_COLOR, (data:3バイト(3バイト))GR_SET_TEXT_MASK, (data:1バイト(SysDrawMask))GR_SET_TEXT_COLOR_MAP, (data:1バイト(ColorMapMode))GR_SET_TEXT_STYLE, (data:2バイト(2 TextStyles))GR_SET_TEXT_MODE, (data:2バイト(2 TextModes))GR_SET_TEXT_SPACE_PAD, (data:3バイト(WBFixed))GR_SET_TEXT_ATTR, (data:20バイト(CF_RGB, 3バイト,SysDrawMask, ColorMapMode, 2 TextStyles, 2 TextModes, WBFixed, FontID, word))</PRE>
<PRE CLASS="syntax">GR_SET_FONT, (data:5 byte(WBFixed, FontID))GR_SET_TEXT_COLOR_INDEX, (data:1 byte(Color))GR_SET_CUSTOM_TEXT_MASK, (data:8 byte()GR_SET_TRACK_KERN, (data:2 byte(sword))GR_SET_FONT_WEIGHT, (data:2 byte(FontWeight))GR_SET_FONT_WIDTH, (data:2 byte(FontWidth))GR_SET_SUPERSCRIPT_ATTR, (data:2 byte(position, scale))GR_SET_SUBSCRIPT_ATTR, (data:2 byte(position, scale))GR_SET_TEXT_PATTERN, (data:2 byte(GraphicPattern))GR_SET_CUSTOM_TEXT_PATTERN, (data:variable(GraphicPattern, word(size of data),pattern data))</PRE>
<PRE CLASS="syntax">(パスオペコード:)GR_BEGIN_PATH, (データ:1バイト(PathCombineParam))GR_END_PATH, GR_SET_CLIP_RECT, (データ:8バイト(4剣))GR_SET_WIN_CLIP_RECT, (データ:8バイト(4剣))GR_CLOSE_SUB_PATH, GR_SET_CLIP_PATH, (データ:1バイト(フラグ))GR_SET_WIN_CLIP_PATH, (データ:1バイト(フラグ))GR_SET_STROKE_PATH*/</PRE>
<P>各グラフィックス文字列要素は<CODE>GStringElement</CODE>要素のタイプと、要素の操作に関連付けられたデータを指定する値。 例えば、GR_DRAW_CHAR操作には6バイトのデータが必要です。<CODE>文字</CODE>描画する文字の値、および描画座標を指定する2つの符号付きワード。</P>
<P>特定のに関連付けられたデータについて調べるのに適した場所<CODE>GStringElement</CODE>typeは<CODE>GS.()社</CODE>マクロ定義{{まくろ:てい<STRONG CLASS="fileName">「文字列」</STRONG>ボタンをクリックし</P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Structs/S_1d.htm#IX_GOC_POINT macro">「GOC点」(GOC_POINT)</A></CODE><CODE><A HREF="../../CRef/Structs/S_1d.htm#IX_GOC_SW(), GOC_WORD() macros">GOC_SW(GOC_SW)</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="S_1f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_1f.htm_IX_GStringErrorType"></A>
          <A NAME="S_1f.htm_IX_GSET_&ldots;"></A>
        <H1 CLASS="refHeading">GStringErrorType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{GSET_NO_ERROR, GSET_DISK_FULL}GStringErrorType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1f.htm_IX_GStringKillType"></A>
        <H1 CLASS="refHeading">GStringKillType</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_1f.htm_IX_GStringSetPosType"></A>
        <H1 CLASS="refHeading">GStringSetPosType</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_47.htm#IX_GrSetGStringPos()">GrSetGStringPos()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_1f.htm_IX_GStringType"></A>
          <A NAME="S_1f.htm_IX_GST_&ldots;"></A>
        <H1 CLASS="refHeading">GStringType</H1>
<PRE CLASS="syntax">typedef ByteEnum GStringType;#define GST_CHUNK 0#define GST_STREAM 1#define GST_VMEM 2#define GST_PTR 3#define GST_PATH 4</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1f.htm_IX_Handle"></A>
        <H1 CLASS="refHeading">ハンドル(Handle)</H1>
<PRE CLASS="syntax">typedef wordハンドル;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1f.htm_IX_HatchDash"></A>
          <A NAME="S_1f.htm_IX_HD_o&ldots;"></A>
        <H1 CLASS="refHeading">HatchDash</H1>
<PRE CLASS="syntax">typedef struct{WWFixed HD_on;WWFixed HD_off;}HatchDash;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1f.htm_IX_HatchLine"></A>
          <A NAME="S_1f.htm_IX_HL_&ldots;"></A>
        <H1 CLASS="refHeading">HatchLine</H1>
<PRE CLASS="syntax">typedef struct{PointWWFixed HL_origin;WWFixed HL_deltaX;WWFixed HL_deltaY;WWFixed HL_angle;ColorQuad HL_color;単語HL_numDashes;/*HatchDash構造体の配列がここに続きます*/}HatchLine;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1f.htm_IX_HatchPattern"></A>
          <A NAME="S_1f.htm_IX_HP_numLines"></A>
        <H1 CLASS="refHeading">HatchPattern</H1>
<PRE CLASS="syntax">typedef struct{word HP_numLines;/*HatchLine構造体の配列がここに続きます*/}HatchPattern;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_1f.htm_IX_HAF_&ldots;"></A>
          <A NAME="S_1f.htm_IX_HeapAllocFlags:with HeapAlloc()"></A>
        <H1 CLASS="refHeading">HeapAllocFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags HeapAllocFlags;#define HAF_ZERO_INIT 0x80#define HAF_LOCK 0x40#define HAF_NO_ERR 0x20#define HAF_UI 0x10#define HAF_READ_ONLY 0x08#define HAF_OBJECT_RESOURCE 0x04#define HAF_CODE 0x02#define HAF_CONFORMING 0x01#define HAF_STANDARD(0)#define HAF_STANDARD_NO_ERR(HAF_NO_ERR)#define HAF_STANDARD_LOCK(HAF_LOCK)#define HAF_STANDARD_NO_ERR_LOCK(HAF_NO_ERR HAF_LOCK)</PRE>
<P><CODE>HeapAllocFlags</CODE>ブロックの割り当てと初期化の方法を示します。 これらは保存されず、取得することもできません。 で渡すことができるフラグは一部のみです。<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>これらを以下に示します。 次のフラグを使用できます。</P>
<DL>
<DT>HAF_ZERO_INIT(ゼロ初期化)</DT><DD>メモリマネージャは、ブロックをヌルバイトに初期化する必要があります。 このフラグは<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>新しいメモリがゼロ初期化されます。</DD>
<DT>HAF_LOCK[ハーフロック]</DT><DD>メモリマネージャは、割り当て後にブロックをロックする必要があります。 ブロックのアドレスを取得するには<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>このフラグは<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>ボタンをクリックし</DD>
<DT>HAF_NO_ERRエラー</DT><DD>メモリマネージャはエラーを返さないはずです。 ブロックを割り当てることができない場合、GEOSは使用可能なメモリがないことをユーザに通知し、クラッシュします。 このフラグの使用は強く推奨されません。 このフラグは<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>ボタンをクリックし</DD>
<DT>HAF_UI[ユーザインタフェース]</DT><DD>HAF_OBJECT_RESOURCEとHAF_UIの両方が設定されている場合、このブロックはアプリケーションのUIスレッドによって実行されます。</DD>
<DT>HAF読み込み専用</DT><DD>ブロックのデータは変更されません。 デバッガに便利です。</DD>
<DT>HAF_OBJECT_RESOURCEオブジェクトリソース</DT><DD>このブロックはオブジェクトブロックになります。</DD>
<DT>HAFコード</DT><DD>このブロックには、実行可能コードが含まれています。</DD>
<DT>HAF準拠</DT><DD>ブロックにコードが含まれている場合、そのコードは権限の低いエンティティによって実行される可能性があります。 ブロックにデータが含まれている場合、データは権限の低いエンティティによってアクセスまたは変更される可能性があります。</DD>
</DIV>
</DL>
<HR>
          <A NAME="S_20.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_20.htm_IX_HC_&ldots;"></A>
          <A NAME="S_20.htm_IX_HeapCongestion"></A>
        <H1 CLASS="refHeading">HeapCongestion</H1>
<PRE CLASS="syntax">typedef enum/*word*/{HC_SCRUBBING, HC_CONGESTED, HC_DESPERATE}HeapCongestion;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_20.htm_IX_HeapFlags"></A>
          <A NAME="S_20.htm_IX_HF_&ldots;"></A>
        <H1 CLASS="refHeading">HeapFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags HeapFlags;#define HF_FIXED 0x80#define HF_SHARABLE 0x40#define HF_DISCARDABLE 0x20#define HF_SWAPABLE 0x10#define HF_LMEM 0x08#define HF_DISCARDED 0x02#define HF_SWAPPED 0x01#define HF_STATIC(HF_DISCARDABLE HF_SWAPABLE)#define HF_DYNAMIC HF_SWAPABLE</PRE>
<P>次のフラグを使用できます。</P>
<DL>
<DT>HF_FIXED[固定]</DT><DD>ブロックは、解放されるまで、グローバルヒープ内のその場所から移動しません。 このフラグがオフの場合、メモリマネージャはロックが解除されている間にブロックを移動できます。 フラグがオンの場合、ブロックはロックされていない可能性があり、HF_DISCARDABLEとHF_SWAPABLEはオフである必要があります。</DD>
<DT>HF_共有可能</DT><DD>ブロックは、ブロックの所有者以外の測地に属するスレッドによってロックされる場合があります。</DD>
<DT>HF_DISCARDABLE[破棄可能]</DT><DD>ロックが解除されると、ブロックは破棄されます。</DD>
<DT>HF_SWAPABLE[スワップ可能]</DT><DD>ロックが解除されると、ブロックは拡張/拡張メモリまたはディスクスワップ領域にスワップされます。</DD>
<DT>HF_LMEM(英語の可能性あり)</DT><DD>ブロックにはローカルメモリヒープが含まれています。 このフラグは<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAllocLMem()">VMAllocLMem()</A></CODE>;アプリケーションはこのフラグを設定する必要はありません。</DD>
<DT>HF_DISCARDED(破棄され</DT><DD>メモリマネージャは、ブロックを破棄すると、このビットをオンにします。 ブロックが再割り当てされると、このビットはオフになります。</DD>
<DT>HF_スワップ</DT><DD>メモリマネージャは、ブロックを拡張メモリまたはディスクスワップ領域にスワップするときに、このビットをオンにします。 ブロックをグローバルヒープにスワップバックするときに、ビットをオフにします。</DD>
</DIV>
<DIV>
          <A NAME="S_20.htm_IX_HugeArrayDirectory"></A>
          <A NAME="S_20.htm_IX_HAD_&ldots;"></A>
        </DL>
<H1 CLASS="refHeading">HugeArrayDirectory</H1>
<PRE CLASS="syntax">typedef struct{LMemBlockHeader HAD_header;VMBlockHandle HAD_data;ChunkHandle HAD_dir;VMBlockHandle HAD_xdir;VMBlockHandle HAD_self;ワードHAD_size;}HugeArrayDirectory;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_20.htm_IX_IACPCF_&ldots;"></A>
          <A NAME="S_20.htm_IX_IACPConnectFlags"></A>
        <H1 CLASS="refHeading">IACPConnectFlags</H1>
<PRE CLASS="syntax">typedef WordFlags IACPConnectFlags;#define IACPCF_OBEY_LAUNCH_MODEL 0x0020#define IACPCF_CLIENT_OD_SPECIFIED 0x0010#define IACPCF_FIRST_ONLY 0x0008#define IACPCF_SERVER_MODE 0x0007</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">イアーク・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_20.htm_IX_IACPServerFlags"></A>
          <A NAME="S_20.htm_IX_IACPSF_&ldots;"></A>
        <H1 CLASS="refHeading">IACPServerFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags IACPServerFlags;#define IACPSF_MULTIPLE_INSTANCES 0x80</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">イアーク・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_20.htm_IX_IACPServerMode"></A>
          <A NAME="S_20.htm_IX_IACPSM_&ldots;"></A>
        <H1 CLASS="refHeading">IACPServerMode</H1>
<PRE CLASS="syntax">IACPServerMode;#define IACPSM_NOT_USER_INTERACTIBLE 0#define IACPSM_IN_FLUX 1#define IACPSM_USER_INTERACTIBLE 2</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">イアーク・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_20.htm_IX_IACPSide"></A>
          <A NAME="S_20.htm_IX_IACPS_&ldots;"></A>
        <H1 CLASS="refHeading">IACPSide</H1>
<PRE CLASS="syntax">typedef enum{IACPS_CLIENT, IACPS_SERVER}IACPSide;と入力します。</PRE>
<P> </P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">イアーク・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_20.htm_IX_ImageFlags"></A>
          <A NAME="S_20.htm_IX_ImageBitSize"></A>
          <A NAME="S_20.htm_IX_IBS_&ldots;"></A>
          <A NAME="S_20.htm_IX_IF_&ldots;  (ImageFlags)"></A>
        <H1 CLASS="refHeading">ImageFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ImageFlags;#define IF_IGNORE_MASK 0x10#define IF_BORDER 0x08#define IF_BITSIZE 0x07/*ImageBitSizeを保持する必要がある*/#define IBS_1 0#define IBS_2 1#define IBS_4 2#define IBS_8 3#define IBS_16 4</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_21.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_IMCFeatures"></A>
          <A NAME="S_21.htm_IX_IMC_&ldots;"></A>
        <H1 CLASS="refHeading">IMCFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags IMCFeatures;#define IMCF_MAP 0x01#define IMC_DEFAULT_FEATURES IMCF_MAP#define IMC_DEFAULT_TOOLBOX_FEATURES 0#define IMC_MAP_MONIKER_SIZE 1024</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_ImpexDataClasses"></A>
          <A NAME="S_21.htm_IX_IDC_&ldots;"></A>
        <H1 CLASS="refHeading">ImpexDataClasses</H1>
<PRE CLASS="syntax">typedef WordFlags ImpexDataClasses;#define IDC_TEXT 0x8000#define IDC_GRAPHICS 0x4000#define IDC_SPREADSHEET 0x2000#define IDC_FONT 0x1000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_ImpexFileSelectionData"></A>
          <A NAME="S_21.htm_IX_IFSD_&ldots;"></A>
        <H1 CLASS="refHeading">ImpexFileSelectionData</H1>
<PRE CLASS="syntax">typedef struct{FileLongName IFSD_selection;パス名IFSD_path;ワードIFSD_disk;GenFileSelectorEntryFlags IFSD_type;}ImpexFileSelectionData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_ImpexMapFlags"></A>
          <A NAME="S_21.htm_IX_IMF_&ldots;"></A>
        <H1 CLASS="refHeading">ImpexMapFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ImpexMapFlags;#define IMF_IMPORT 0x80#define IMF_EXPORT 0x40</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_ImpexMapFileInfoHeader"></A>
          <A NAME="S_21.htm_IX_IMFIH_&ldots;"></A>
        <H1 CLASS="refHeading">ImpexMapFileInfoHeader</H1>
<PRE CLASS="syntax">typedef struct{LMemBlockHeader IMFIH_base;word IMFIH_fieldChunk;word IMFIH_numFields;}ImpexMapFileInfoHeader;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_ImpexTranslationParams"></A>
          <A NAME="S_21.htm_IX_ITP_&ldots;"></A>
        <H1 CLASS="refHeading">ImpexTranslationParams</H1>
<PRE CLASS="syntax">typedef struct{optr ITP_impexOD;Message ITP_returnMsg;word ITP_dataClass;FileHandle ITP_transferVMFile;VMChain ITP_transferVMChain;dword ITP_internal;}ImpexTranslationParams;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_ImportControlAttrs"></A>
          <A NAME="S_21.htm_IX_ICA_IGNORE_INPUT"></A>
        <H1 CLASS="refHeading">ImportControlAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags ImportControlAttrs;#define ICA_IGNORE_INPUT 0x8000/*インポート時に入力を無視する*/</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_ImportControlToolboxFeatures"></A>
          <A NAME="S_21.htm_IX_IMPORTCF_DIALOG_BOX"></A>
        <H1 CLASS="refHeading">ImportControlToolboxFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags ImportControlToolboxFeatures;#define IMPORTCTF_DIALOG_BOX 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_IndexArrayBlockHeader"></A>
        <H1 CLASS="refHeading">IndexArrayBlockHeader</H1>
<PRE CLASS="syntax">typedef struct{word IALMBH_recCount;word IALMBH_array;word IALMBH_indexField;word IALMBH_sortOrder;}IndexArrayBlockHeader;</PRE>
<P>のデータストアインデックスを含むブロックの形式<CODE>RecordNum</CODE>s(下位ワードのみ)、参照<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_DataStoreBuildIndex()">DataStoreBuildIndex()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_InitFileCharConvert"></A>
          <A NAME="S_21.htm_IX_IFCC_&ldots;"></A>
        <H1 CLASS="refHeading">InitFileCharConvert</H1>
<PRE CLASS="syntax">typedef ByteEnum InitFileCharConvert;#define IFCC_INTACT 0/*すべての文字を変更せずに残します。 */#define IFCC_UPCASE 1/*すべての文字を大文字にします。 */#define IFCC_DOWNCASE 2/*すべての文字を小文字にします。 (注)</PRE>
<P>この列挙型は、次の方法を説明します。<CODE>InitFileRead…………………………………</CODE>ルーチンは入力文字列を処理する必要があります。</P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_InitFileReadFlags"></A>
          <A NAME="S_21.htm_IX_IFRF_&ldots;"></A>
        <H1 CLASS="refHeading">InitFileReadFlags</H1>
<PRE CLASS="syntax">typedef WordFlags InitFileReadFlags;#define IFLF_CHAR_CONVERT 0xc000/*2ビット: InitFileCharConvertタイプ*/#define IFRF_READ_ALL 0x2000#define IFRF_FIRST_ONLY 0x1000#define IFRF_SIZE 0x0fff</PRE>
<P>このレコードは<CODE>InitFileRead…………………………………</CODE>ルーチン。 IFRF_CHAR_CONVERTフィールドは、読み込まれる文字列を大文字にするか、小文字にするか、変更しないかを指定するために使用されます。<CODE>InitFileCharConvert</CODE>IFRF_SIZEフィールドは、渡されたバッファを受け取るルーチンで使用されます。このフィールドは、バッファのサイズ(ルーチンが返すことができる最大バイト数)を示します。</P>
<P>このレコードを設定するときは、必ずIFLF_CHAR_CONVERT値をIFLF_CHAR_CONVERT_OFFSETのオフセットだけ左にシフトしてください。</P>
</DIV>
<DIV>
          <A NAME="S_21.htm_IX_InkBackgroundType"></A>
          <A NAME="S_21.htm_IX_IBT_&ldots;"></A>
        <H1 CLASS="refHeading">InkBackgroundType</H1>
<PRE CLASS="syntax">typedef enum{IBT_NO_BACKGROUND=0, IBT_NARROW_LINED_PAPER=2, IBT_MEDIUM_LINED_PAPER=4, IBT_WIDE_LINED_PAPER=6, IBT_NARROW_STENO_PAPER=8, IBT_MEDIUM_STENO_PAPER=10, IBT_WIDE_STENO_PAPER=12, IBT_SMALL_GRID=14, IBT_MEDIUM_GRID=16, IBT_LARGE_GRID=18, IBT_SMALL_CROSS_SECTION=20, IBT_MEDIUM_CROSS_SECTION=22, IBT_LARGE_CROSS_SECTION=24, IBT_TO_DO_LIST=26, IBT_PHONE_MESSAGE=28, IBT_CUSTOM_BACKGROUND=30}InkBackgrountType;</PRE>
<P>この列挙型は、インクデータベースルーチンで使用する標準の背景画像のセットです。</P>
</DIV>
<HR>
          <A NAME="S_22.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_22.htm_IX_InkControlFeatures"></A>
          <A NAME="S_22.htm_IX_ICF_&ldots;  (InkControlFeatures)"></A>
        <H1 CLASS="refHeading">InkControlFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags InkControlFeatures;#define ICF_PENCIL_TOOL 0x02#define ICF_ERASER_TOOL 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_22.htm_IX_InkControlToolboxFeatures"></A>
          <A NAME="S_22.htm_IX_ICTF_&ldots;"></A>
        <H1 CLASS="refHeading">InkControlToolboxFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags InkControlToolboxFeatures;#define ICTF_PENCIL_TOOL 0x02#define ICTF_ERASER_TOOL 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_22.htm_IX_InkDBDisplayInfo"></A>
        <H1 CLASS="refHeading">InkDBDisplayInfo</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_5e.htm#IX_InkDBGetDisplayInfo()">InkDBGetDisplayInfo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_22.htm_IX_InkDBFrame"></A>
          <A NAME="S_22.htm_IX_IDBF_&ldots;"></A>
        <H1 CLASS="refHeading">InkDBFrame</H1>
<PRE CLASS="syntax">typedef struct{Rectangle IDBF_bounds;/*保存するデータの範囲、または*データをロードする場所*/</PRE>
<PRE CLASS="syntax">VMFileHandle IDBF_VMFile;/*VMFile to write to/read from*/DBGroupAndItem IDBF_DBGroupAndItem;/*DB item to save to/load from*/word IDBF_DBExtra;/*space to skip at start of block*/}InkDBFrame;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_22.htm_IX_InkFlags"></A>
          <A NAME="S_22.htm_IX_IF_&ldots;  (InkFlags)"></A>
        <H1 CLASS="refHeading">InkFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags InkFlags;#define IF_HAS_TARGET 0x20#define IF_DIRTY 0x10#define IF_ONLY_CHILD_OF_CONTENT 0x08#define IF_CONTROLLED 0x04#define IF_INVALIDATE_ERASECTS 0x02#define IF_HAS_UNDO 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_22.htm_IX_InkReturnValue"></A>
          <A NAME="S_22.htm_IX_IRV_&ldots;"></A>
        <H1 CLASS="refHeading">InkReturnValue</H1>
<PRE CLASS="syntax">typedef enum{IRV_NO_REPLY, /*VisCompオブジェクトはVisCallChildUnderPointを使用して*MSG_META_QUERY_IF_PRESS_IS_INKをその子に送信し、*VisCallChildUnderPointはポイントの下に子*がなかった場合にこの値(0)を返します。 オブジェクトが実際にこの値を返すことはありません。*/</PRE>
<PRE CLASS="syntax">IRV_NO_INK, /*オブジェクトが着信イベントをマウスデータとして扱う場合にこれを返します。*/</PRE>
<PRE CLASS="syntax">IRV_INK_WITH_STANDARD_OVERRIDE, /*オブジェクトが通常インクを必要とする場合にこれを返します(テキストオブジェクトがこれを行います)。*ただし、ユーザーはペンを押して*ユーザーが調整可能な時間保持することで、マウスイベントを強制できます。 (注)</PRE>
<PRE CLASS="syntax">IRV_WAIT/*ポイントの下のオブジェクトが別の*スレッドによって実行されていて、入力を保留したい場合は、この値を返します(*MSG_META_START_SELECTを受信しても何もしないでください)。objがMSG_GEN_APPLICATION_INK_QUERY_REPLY*をアプリケーションオブジェクトに送信するまで。*/</PRE>
<PRE CLASS="syntax">}InkReturnValue;</PRE>
<P>この列挙型はオブジェクトによって使用され、着信ポインタイベントをマウスデータまたはペンデータとして解釈する必要があるかどうかをシステムに通知します。</P>
</DIV>
<DIV>
          <A NAME="S_22.htm_IX_InsertChildFlags"></A>
          <A NAME="S_22.htm_IX_ICF_&ldots;  (InsertChildFlags)"></A>
        <H1 CLASS="refHeading">InsertChildFlags</H1>
<PRE CLASS="syntax">typedef WordFlags InsertChildFlags#define ICF_MARK_DIRTY 0x8000#define ICF_OPTIONS 0x0003</PRE>
<P>このレコードは、子をオブジェクトツリーに追加する方法を指定します。</P>
</DIV>
<DIV>
          <A NAME="S_22.htm_IX_InsertChildOption"></A>
          <A NAME="S_22.htm_IX_ICO_&ldots;"></A>
        <H1 CLASS="refHeading">InsertChildOption</H1>
<PRE CLASS="syntax">typedef ByteEnum InsertChildOption#define ICO_FIRST 0#define ICO_LAST 1#define ICO_BEFORE_REFERENCE 2#define ICO_AFTER_REFERENCE 3</PRE>
<P>この列挙型は、子の追加方法を決定し<CODE>InsertChildFlags</CODE>レコード。 上に示すように、4つの列挙があります。</P>
</DIV>
<HR>
          <A NAME="S_23.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_23.htm_IX_Glockenspiel"></A>
          <A NAME="S_23.htm_IX_Ocarina"></A>
          <A NAME="S_23.htm_IX_Tinkle bell"></A>
          <A NAME="S_23.htm_IX_Melodic tom"></A>
          <A NAME="S_23.htm_IX_Hi tom"></A>
          <A NAME="S_23.htm_IX_InstrumentPatch"></A>
          <A NAME="S_23.htm_IX_IP_&ldots;"></A>
        <H1 CLASS="refHeading">InstrumentPatch</H1>
<PRE CLASS="syntax"> </PRE>
<P>これらは標準的な模擬楽器です。</P>
</DIV>
<HR>
          <A NAME="S_24.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_24.htm_IX_IT_STANDARD_TABLE"></A>
          <A NAME="S_24.htm_IX_InstrumentTable"></A>
        <H1 CLASS="refHeading">InstrumentTable</H1>
<PRE CLASS="syntax">typedef enum{IT_STANDARD_TABLE=0/*デフォルトテーブル*/}InstrumentTable;</PRE>
<P>サウンドライブラリは、この列挙型を使用して、使用するシミュレートされた楽器のテーブルを追跡します。</P>
</DIV>
<DIV>
          <A NAME="S_24.htm_IX_JobStatus"></A>
          <A NAME="S_24.htm_IX_JS_&ldots;"></A>
        <H1 CLASS="refHeading">ジョブの状態</H1>
<PRE CLASS="syntax">typedef struct{char JS_fname[13];/*std DOS(8.3)spool filename*/char JS_parent[FILE_LONGNAME_LENGTH+1];/*親アプリケーションの名前*/</PRE>
<PRE CLASS="syntax">char JS_documentName[FILE_LONGNAME_LENGTH+1];/*ドキュメント名*/</PRE>
<PRE CLASS="syntax">word JS_numPages;/*ドキュメント内の#ページ*/SpoolTimeStruct JS_time;/*スプールされた時間*/byte JS_printing;/*印刷する場合はTRUE/FALSE*/}JobStatus;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_24.htm_IX_Justification"></A>
          <A NAME="S_24.htm_IX_J_&ldots;"></A>
        <H1 CLASS="refHeading">位置合わせ</H1>
<PRE CLASS="syntax">typedef ByteEnum位置合わせ;#define J_LEFT 0#define J_RIGHT 1#define J_CENTER 2#define J_FULL 3</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_24.htm_IX_KeyboardShortcut"></A>
          <A NAME="S_24.htm_IX_KS_&ldots;"></A>
        <H1 CLASS="refHeading">KeyboardShortcut</H1>
<PRE CLASS="syntax">typedef ByteFlags KeyboardShortcut;#define KS_PHYSICAL 0x80/*TRUE:マッチキー、文字ではありません*/#define KS_ALT 0x40/*TRUE:&lt;ALT>を押す必要があります*/#define KS_CTRL 0x20/*TRUE:&lt;CTRL>を押す必要があります*/#define KS_SHIFT 0x10/*TRUE:&lt;SHIFT>を押す必要があります*/#define KS_CHAR_SET_PRINTABLE(CS_BSW&amp;0x0f)#define KS_CHAR_SET_CONTROL(CS_CONTROL&amp;0x0f)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_24.htm_IX_KeyboardType"></A>
          <A NAME="S_24.htm_IX_KT_&ldots;"></A>
        <H1 CLASS="refHeading">KeyboardType</H1>
<PRE CLASS="syntax">typedef ByteEnum KeyboardType;#define KT_NOT_EXTD 1#define KT_EXTD 2#define KT_BOTH 3</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_24.htm_IX_KeyMapType"></A>
          <A NAME="S_24.htm_IX_KEYMAP_&ldots;"></A>
        <H1 CLASS="refHeading">KeyMapType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{KEYMAP_US_EXTD=1, KEYMAP_US, KEYMAP_UK_EXTD, KEYMAP_UK, KEYMAP_GERMANY_EXTD, KEYMAP_GERMANY, KEYMAP_SPAIN_EXTD, KEYMAP_SPAIN, KEYMAP_DENMARK_EXTD, KEYMAP_DENMARK, KEYMAP_BELGIUM_EXTD, KEYMAP_BELGIUM, KEYMAP_CANADA_EXTD, KEYMAP_CANADA, KEYMAP_ITALY_EXTD, KEYMAP_ITALY, KEYMAP_LATIN_AMERICA, KEYMAP_NETHERLANDS, KEYMAP_NETHERLANDS_EXTD, KEYMAP_NORWAY_EXTD, KEYMAP_NORWAY, KEYMAP_PORTUGAL_EXTD, KEYMAP_PORTUGAL, KEYMAP_SWEDEN_EXTD, KEYMAP_SWEDEN, KEYMAP_SWISS_FRENCH_EXTD, KEYMAP_SWISS_FRENCH, KEYMAP_SWISS_GERMAN_EXTD, KEYMAP_SWISS_GERMAN, KEYMAP_FRANCE_EXTD, KEYMAP_FRANCE, }KeyMapType;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_25.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_25.htm_IX_Language type"></A>
          <A NAME="S_25.htm_IX_L_&ldots;"></A>
        <H1 CLASS="refHeading">言語</H1>
<PRE CLASS="syntax">typedef ByteEnum言語;#define L_DEFAULT 0#define L_GRAPHIC 0#define L_ENGLISH 1#define L_GERMAN 2#define L_FRENCH 3#define L_SPANISH 4#define L_ITALIAN 5#define L_DANISH 6#define L_DUTCH 7</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_25.htm_IX_LargeMouseData"></A>
          <A NAME="S_25.htm_IX_LMD_&ldots;"></A>
        <H1 CLASS="refHeading">LargeMouseData</H1>
<PRE CLASS="syntax">typedef struct{PointDWFixed LMD_location;バイトLMD_buttonInfo;UIFunctionsActive LMD_UIFunctionsActive;}LargeMouseData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_25.htm_IX_LayerPriority"></A>
          <A NAME="S_25.htm_IX_LAYER_PRIO_&ldots;"></A>
        <H1 CLASS="refHeading">LayerPriority</H1>
<PRE CLASS="syntax">typedef ByteEnum LayerPriority;#define LAYER_PRIO_MODAL 6#define LAYER_PRIO_ON_TOP 8#define LAYER_PRIO_STD 12#define LAYER_PRIO_ON_BOTTOM 14</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_25.htm_IX_LibraryCallType"></A>
          <A NAME="S_25.htm_IX_LCT_&ldots;"></A>
        <H1 CLASS="refHeading">LibraryCallType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{LCT_ATTACH, /*ライブラリがロードされました。 */LCT_DETACH, /*ライブラリをアンロードしようとしています。 */LCT_NEW_CLIENT, /*ライブラリの新しいクライアントがロードされました。 */LCT_NEW_CLIENT_THREAD, /*ライブラリの*現在のクライアント用に新しいスレッドが作成されました。 */LCT_CLIENT_THREAD_EXIT, /*ライブラリの現在の*クライアントのスレッドが終了しました。 */LCT_CLIENT_EXIT, /*ライブラリのクライアントがアンロードされようとしています。 */}LibraryCallType</PRE>
<P>この型は、ライブラリのエントリポイントルーチンで使用されます。 ライブラリのエントリポイントルーチンは、この列挙型の値を使用して、何を行うかを決定します。</P>
</DIV>
<DIV>
          <A NAME="S_25.htm_IX_LineAttr"></A>
          <A NAME="S_25.htm_IX_LA_&ldots;"></A>
        <H1 CLASS="refHeading">線属性</H1>
<PRE CLASS="syntax">typedef struct{byte LA_colorFlag;RGBValue LA_color;SysDrawMask LA_mask;ColorMapMode LA_mapMode;LineEnd LA_end;LineJoin LA_join;LineStyle LA_style;WWFixed LA_width;}LineAttr;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_25.htm_IX_LineEnd"></A>
          <A NAME="S_25.htm_IX_LE_&ldots;"></A>
          <A NAME="S_25.htm_IX_LAST_LINE_END_TYPE"></A>
        <H1 CLASS="refHeading">線の終点</H1>
<PRE CLASS="syntax">typedef ByteEnum LineEnd;#define LE_BUTTCAP 0#define LE_ROUNDCAP 1#define LE_SQUARECAP 2#define LAST_LINE_END_TYPE LE_SQUARECAP</PRE>
<P>線分の終点は、グラフィックスシステムが線分セグメントの終点を描画する方法を決定します。</P>
</DIV>
<DIV>
          <A NAME="S_25.htm_IX_LineJoin"></A>
          <A NAME="S_25.htm_IX_LJ_&ldots;"></A>
          <A NAME="S_25.htm_IX_LAST_LINE_JOIN_TYPE"></A>
        <H1 CLASS="refHeading">ライン結合</H1>
<PRE CLASS="syntax">typedef ByteEnum LineJoin;#define LJ_MITERED 0#define LJ_ROUND 1#define LJ_BEV EL 2#define LAST_LINE_JOIN_TYPE LJ_BEV EL</PRE>
<P>この列挙型は、グラフィックスシステムが長方形とポリラインのコーナーを描画する方法を決定します。</P>
</DIV>
<DIV>
          <A NAME="S_25.htm_IX_MAX_DASH_ARRAY_PAIRS"></A>
          <A NAME="S_25.htm_IX_DashPairArray"></A>
          <A NAME="S_25.htm_IX_LineStyle"></A>
          <A NAME="S_25.htm_IX_LS_&ldots;"></A>
        <H1 CLASS="refHeading">線スタイル</H1>
<PRE CLASS="syntax">typedef ByteEnum LineStyle;#define LS_SOLID 0#define LS_DASHED 1#define LS_DOTTED 2#define LS_DASHDOT 3#define LS_DASHDDOT 4#define LS_CUSTOM 5#define MAX_DASH_ARRAY_PAIRS 5</PRE>
<P>の<CODE>線スタイル</CODE>typeは、行の「dottedness」を示します。 カスタムダッシュを使用した線は<CODE>DashPairArray</CODE>構造:</P>
<PRE>typedef word DashPairArray[MAX_DASH_ARRAY_PAIRS*2];</PRE>
</DIV>
<DIV>
          <A NAME="S_25.htm_IX_LMemBlockHeader"></A>
          <A NAME="S_25.htm_IX_LMBH_&ldots;"></A>
        <H1 CLASS="refHeading">LMemBlockHeader</H1>
<PRE CLASS="syntax">typedef struct{MemHandle LMBH_handle;word LMBH_offset;word LMBH_flags;LMemTypes LMBH_lmemType;word LMBH_blockSize;word LMBH_nHandles;word LMBH_freeList;word LMBH_totalFree;}LMemBlockHeader;</PRE>
<P>この構造体は、LMemヒープを含むすべてのブロックの先頭にあります。 ブロックをロックし、そのアドレスを<CODE>*LMemBlockHeader</CODE>ただし、フィールドはLMemルーチンによって管理されているため、自分で変更しないでください。</P>
<P CLASS="refField"><STRONG>内容:</STRONG>ヘッダーには、次のフィールドがあります。</P>
<DL>
<DT>LMBH<CODE>はんどるハンドル</DT><DD></CODE>このブロックのハンドル。</DD>
<DT>LMBH<CODE>おふせっとオフセット</DT><DD></CODE>ブロックの先頭からヒープの先頭までのオフセット。</DD>
<DT>LMBH<CODE>ふらぐ</DT><DD></CODE>の<CODE>LocalMemoryFlags</CODE>ブロックに現在設定されている。 フラグについては<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>ボタンをクリックし</DD>
<DT>LMBH<CODE>_lmemType</DT><DD></CODE>このブロック内のLMemヒープのタイプ。 このフィールドは<CODE>LMemType</CODE>のエントリで説明されている列挙型<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>ボタンをクリックし</DD>
<DT>LMBH<CODE>ブロックサイズ(_B)</DT><DD></CODE>このブロックの合計サイズ。 このサイズは、チャンク割り当てとヒープ圧縮の結果として、どちらの方向にも変化する可能性があります。</DD>
<DT>LMBH<CODE>_nHandles</DT><DD></CODE>チャンクハンドルテーブルで使用可能なハンドルの数。 これらのチャンクのすべてが、必ずしも所有チャンクまたは空きチャンクとして割り当てられるわけではありません。 テーブルは必要に応じて自動的に拡大されます。</DD>
<DT>LMBH<CODE>_freeList[フリーリスト]</DT><DD></CODE>空きチャンクのリンク・リスト内の最初の空きチャンクのチャンク・ハンドル。</DD>
<DT>LMBH<CODE>_totalFree</DT><DD></CODE>LMemヒープ内の空き領域の合計。</DD>
</DL>
<P CLASS="refField"><STRONG>警告:</STRONG>の設定は変更しないでください。<CODE>LMemBlockHeader</CODE>これらはLMemルーチンによって自動的に維持されます。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
<P CLASS="refField"><STRONG>関連項目:</STRONG><CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>ボタンをクリックし</P>
</DIV>
<HR>
          <A NAME="S_26.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_26.htm_IX_LMemType"></A>
          <A NAME="S_26.htm_IX_LMEM_TYPE_&ldots;"></A>
        <H1 CLASS="refHeading">LMemType</H1>
<PRE CLASS="syntax">typdef enum{LMEM_TYPE_GENERAL, LMEM_TYPE_WINDOW, LMEM_TYPE_OBJ_BLOCK, LMEM_TYPE_GSTATE, LMEM_TYPE_FONT_BLK, LMEM_TYPE_GSTRING, LMEM_TYPE_DB_ITEMS}LMemType;</PRE>
<P>LMemヒープは、さまざまな目的のために作成される。 これらの目的の中には、ヒープが特別な機能を持つことを必要とするものもあります。 このため、LMemヒープを作成する場合は、そのヒープの用途を指定する必要があります。 次のタイプを使用できます。</P>
<DL>
<DT>一般LMEM_TYPE_GENERAL</DT><DD>LMemヒープは、チャンク、名前、または要素配列を含む一般的なデータストレージに使用されます。 アプリケーションがLMemヒープを作成する場合、ほとんどの場合、そのタイプは「General」または「Object」です。</DD>
<DT>LMEM_TYPE_OBJ_BLOCK[オブジェクトタイプブロック]</DT><DD>オブジェクトは、LMemヒープであるオブジェクトブロックに格納されます。 オブジェクトブロックにはいくつかの余分なヘッダー情報があり、フラグだけを含む1つのチャンクが含まれます。 ブロック内のすべてのオブジェクトは、チャンクとしてヒープに格納されます。 アプリケーションは、オブジェクトブロックを直接作成できます。</DD>
<DT>ウィンドウの種類</DT><DD>ウィンドウはLMemヒープとしてメモリに格納されます。 ヘッダーにはウィンドウに関する情報が含まれており、ウィンドウ内の各領域はチャンクとして保存されます。 アプリケーションは、Windowヒープを直接作成しません。</DD>
<DT>LMEM_TYPE_GSTATE(タイプGステート)</DT><DD>GStateはLMemヒープです。 GState情報はヘッダーにあり、アプリケーションのクリップ矩形はチャンクに格納されます。 アプリケーションはGStateブロックを直接作成するのではなく、GState作成ルーチンを呼び出してブロックを作成します。</DD>
<DT>LMEM_TYPE_FONT_BLOCK[線種フォントブロック]</DT><DD>フォントブロックはLMemヒープとして保存されます。 アプリケーションは、フォントブロックを直接作成しません。</DD>
<DT>LMEM_TYPE_GSTRING(文字列の種類)</DT><DD>GStringが作成されるかロードされると、GString LMemヒープが作成され、要素がチャンクとして追加されます。 ヒープはGStringルーチンによって自動的に作成されるので、アプリケーションはGStringブロックを作成してはなりません。</DD>
<DT>LMEM_TYPE_DB_ITEMS[項目]</DT><DD>仮想メモリメカニズムは、データベース項目、つまり動的に割り当てられ、VMファイルとともに保存される短いデータを作成および管理するためのルーチンを提供します。 アプリケーションはDBブロックを直接割り当てるのではなく、DBルーチンを呼び出して、ブロックが作成されるようにします。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_26.htm_IX_LocalDistanceFlags"></A>
          <A NAME="S_26.htm_IX_LDF_&ldots;"></A>
        <H1 CLASS="refHeading">LocalDistanceFlags</H1>
<PRE CLASS="syntax">typedef WordFlags LocalDistanceFlags;#define LDF_FULL_NAMES 0x8000#define LDF_PRINT_PLURAL_IF_NEEDED 0x4000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_26.htm_IX_LocalCmpStringsDosToGeosFlags"></A>
        <H1 CLASS="refHeading">LocalCmpStringsDosToGeosFlags</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_66.htm#IX_LocalCmpStringsDosToGeos()">LocalCmpStringsDosToGeos()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_26.htm_IX_currencyFormatFlags (LocalCurrencyFormat structure field)"></A>
          <A NAME="S_26.htm_IX_currencyDigits (LocalCurrencyFormat structure format)"></A>
          <A NAME="S_26.htm_IX_thousandsSeperator (LocalCurrencyFormat structure field)"></A>
          <A NAME="S_26.htm_IX_decimalSeperator (LocalCurrencyFormat structure field)"></A>
          <A NAME="S_26.htm_IX_LocalCurrencyFormat"></A>
          <A NAME="S_26.htm_IX_listSeperator (LocalCurrencyFormat structure field)"></A>
        <H1 CLASS="refHeading">LocalCurrencyFormat</H1>
<PRE CLASS="syntax">typedef struct{byte currencyFormatFlags;byte currencyDigits;word thousandsSeparator;word decimalSeparator;word listSeparator;}LocalCurrencyFormat;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_26.htm_IX_LocalMemoryFlags"></A>
          <A NAME="S_26.htm_IX_LMF_&ldots;"></A>
          <A NAME="S_26.htm_IX_STD_LMEM_OBJECT_FLAGS"></A>
        <H1 CLASS="refHeading">LocalMemoryFlags</H1>
<PRE CLASS="syntax">typedef WordFlags LocalMemoryFlags;#define LMF_HAS_FLAGS 0x8000#define LMF_IN_RESOURCE 0x4000#define LMF_DETACHABLE 0x2000#define LMF_DUPLICATED 0x1000#define LMF_RELOCATED 0x0800#define LMF_AUTO_FREE 0x0400#define LMF_IN_LMEM_ALLOC 0x0200#define LMF_IS_VM 0x0100#define LMF_NO_HANDLES 0x0080#define LMF_NO_ENSIZE 0x0040#define LMF_RETURN_ERRORS 0x0020#define LMF_DEATH_COUNT 0x0007#define STD_LMEM_OBJECT_FLAGS(LMF_HAS_FLAGS LMF_RELOCATED)</PRE>
<P>LMemヒープが割り当てられると、ヒープが持つべきプロパティを示すために特定のフラグが渡されます。 一部のフラグは、システムが作成したヒープに対してのみ渡されます。 フラグはワード長のレコード(<CODE>LocalMemoryFlags</CODE>レコードには、ヒープの現在の状態を示すフラグも含まれます。 の<CODE>LocalMemoryFlags</CODE>以下にリストします。</P>
<DL>
<DT>フラグ付きLMF</DT><DD>ブロックにフラグのみを含むチャンクがある場合に設定されます。 このフラグは、オブジェクトブロックに対して設定されます。通常、一般的なLMemヒープではクリアされます。</DD>
<DT>リソースのLMF_IN_RESOURCE</DT><DD>ブロックがリソースからロードされたばかりで、ロード後に変更されていない場合に設定されます。 このフラグは、コンパイラによって作成されたオブジェクトブロックに対してのみ設定されます。</DD>
<DT>LMF_DETACHABLE[着脱可能]</DT><DD>ブロックが状態ファイルに保存できるオブジェクトブロックである場合に設定されます。</DD>
<DT>LMF_DUPLICATED(重複したL</DT><DD>ブロックが<CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjDuplicateResource()">ObjDuplicateResource()</A></CODE>ルーチン。 このフラグは、アプリケーションで設定しないでください。</DD>
<DT>LMF_RELOCATED(再配置された)</DT><DD>ブロック内のすべてのオブジェクトが再配置された場合に設定されます。 オブジェクトシステムは、ブロック内のすべてのオブジェクトを再配置したときに、これを設定します。</DD>
<DT>LMF_自動フリー</DT><DD>このフラグは、いくつかのオブジェクトルーチンで使用されます。 これは、ブロックの使用中カウントがゼロになった場合、ブロックが解放される可能性があることを示します。 このフラグは、アプリケーションで設定しないでください。</DD>
<DT>LMF_IN_MEM_ALLOC(メモリ割り当て)</DT><DD>このフラグはエラー・チェック・コードで使用され、チャンクの割り当て中にヒープが検証されないようにします。 内部使用のみ--変更しない<EM>ボタンをクリックし</EM></DD>
<DT>LMF_IS_仮想マシン</DT><DD>LMemヒープがVMブロック内にあり、チャンクがダーティとマークされるたびにブロックがダーティとマークされる場合に設定されます。 このフラグは、LMemヒープがVMファイルに作成またはアタッチされたときに、VMコードによって自動的に設定されます。 このフラグは、アプリケーションで設定しないでください。</DD>
<DT>LMFハンドルなし</DT><DD>ブロックがチャンクハンドルを使用しない場合に設定します。 Cをシミュレートするようにブロックを設定できます。<CODE>関数malloc()</CODE>この場合、チャンクは作成後に再配置されないため、チャンク・ハンドルは必要ありません。 通常、これらのブロックは<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">関数malloc()</A></CODE>アプリケーションによってではなく、ルーチンによって実行されます</DD>
<DT>LMF拡大しない</DT><DD>ローカルメモリルーチンがチャンク要求を満たすためにこのブロックを拡大しないことを示します。 これにより、チャンク割り当て要求によってブロックが移動されないことが保証されますが、これらの要求が失敗する可能性が高くなります。</DD>
<DT>LMF_RETURN_ERRORS(LMFリターンエラー)</DT><DD>割り当て要求が満たされない場合に、ローカルメモリルーチンがエラーを返すかどうかを設定します。 フラグが設定されていない場合、割り当てルーチンが要求に対応できないと、致命的なエラーが発生します。 このフラグは、拡張可能なLMemブロックでは一般にクリアされます。<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>)は、LMem割り当てエラーを処理できないように最適化されます。</DD>
<DT>LMF_DEATH_COUNT(死亡カウント)</DT><DD>このフィールドはフラグフィールドの下位3ビットを占有する。 値が0の場合は何も意味しません。 ゼロ以外の場合は、ブロック削除メッセージの残りの数を示します。<CODE>BlockDeathCommon</CODE>ブロックが解放されます。 このフラグは、カーネル内のエラーチェックコードで使用されます。</DD>
<DT>STD_LMEM_OBJ_フラグ</DT><DD>これはLMF_HAS_FLAGSとLMF_RELOCATEDフラグを組み合わせた定数です。 これらのフラグは、すべてのオブジェクトブロックに対して設定する必要があります。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">メモリh</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="S_27.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_LocalNumericFormat"></A>
          <A NAME="S_27.htm_IX_numberFormatFlags (LocalNumericFormat structure field)"></A>
          <A NAME="S_27.htm_IX_decimalDigits (LocalNumericFormat structure field)"></A>
          <A NAME="S_27.htm_IX_thousandsSeparator (LocalNumericFormat structure field)"></A>
          <A NAME="S_27.htm_IX_decimalSeperator (LocalNumericFormat structure field)"></A>
          <A NAME="S_27.htm_IX_listSeparator (LocalNumericFormat structure field)"></A>
        <H1 CLASS="refHeading">LocalNumericFormat</H1>
<PRE CLASS="syntax">typedef struct{byte numberFormatFlags;byte decimalDigits;word thousandsSeparator;word decimalSeparator;word listSeparator;}LocalNumericFormat;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_endDouble (LocalQuotes structure field)"></A>
          <A NAME="S_27.htm_IX_LocalQuotes"></A>
          <A NAME="S_27.htm_IX_frontSingle (LocalQuotes structure field)"></A>
          <A NAME="S_27.htm_IX_endSingle (LocalQuotes structure field)"></A>
          <A NAME="S_27.htm_IX_frontDouble (LocalQuotes structure field)"></A>
        <H1 CLASS="refHeading">LocalQuotes</H1>
<PRE CLASS="syntax">typedef struct{word frontSingle;word endSingle;word frontDouble;word endDouble;}LocalQuotes;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_ManufacturerFromFormatID() macro"></A>
        <H1 CLASS="refHeading">ManufacturerFromFormatID</H1>
<PRE CLASS="syntax">メーカーID ManufacturerFromFormatID(種類);ClipboardItemFormatIDの種類;</PRE>
<P>このマクロは、指定されたクリップボード形式IDと製造元の値から製造元IDを抽出します。</P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_ManufacturerID"></A>
          <A NAME="S_27.htm_IX_MANUFACTURER_ID_&ldots;"></A>
        <H1 CLASS="refHeading">製造者ID</H1>
<PRE CLASS="syntax">typedefワードManufacturerID#define MANUFACTURER_ID_GEOWORKS 0#define MANUFACTURER_ID_APP_LOCAL 1#define MANUFACTURER_ID_DOS_LAUNCHER 5#define MANUFACTURER_ID_SDK 8#define MANUFACTURER_ID_GENERIC 10</PRE>
<P>一方<CODE>geode.hと入力します</CODE>他の多くの定義<CODE>製造者ID</CODE>特定の開発者の場合、Nokia 9000iコミュニケータ用に開発するときに知っておくと便利なのは、次のうちの1つだけです。<CODE>製造元ID_NOKIA</CODE>ボタンをクリックし</P>
<P>各企業は、その企業に固有の独自の製造元IDを持つ必要があり、そのアプリケーションのGeodeTokensが他の製造元の地域と競合しないようにする必要があります。 もしあなたがメーカーIDを持っていないが、持っているべきだと思うなら<A HREF = "mailto:orders@geoworks.com">接触</A>Geoworks開発者サポート。</P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_MapColorToMono"></A>
          <A NAME="S_27.htm_IX_CMT_&ldots;  (MapColorToMono types)"></A>
        <H1 CLASS="refHeading">MapColorToMono</H1>
<PRE CLASS="syntax">typedef ByteEnum MapColorToMono;#define CMT_CLOSEST 0#define CMT_DITHER 1</PRE>
<P>このタイプは、使用できない色で描画しようとしたときにグラフィックスシステムが実行する内容を決定します。 最も近いカラーで描画するか、2つ以上の近いカラーを混合して全体をできるだけ近づけます。</P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_MapListBlockHeader"></A>
          <A NAME="S_27.htm_IX_MLBH_&ldots;"></A>
        <H1 CLASS="refHeading">MapListBlockHeader</H1>
<PRE CLASS="syntax">typedef struct{LMemBlockHeader MLBH_base;word MLBH_numDestFields;word MLBH_chunk1;}MapListBlockHeader;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_leftMargin (MarginDimensions structure field)"></A>
          <A NAME="S_27.htm_IX_topMargin (MarginDimensions structure field)"></A>
          <A NAME="S_27.htm_IX_rightMargin (MarginDimensions structure field)"></A>
          <A NAME="S_27.htm_IX_bottomMargin (MarginDimensions structure field)"></A>
        <H1 CLASS="refHeading">MarginDimensions</H1>
<PRE CLASS="syntax">typedef struct{int leftMargin;int topMargin;int rightMargin;int bottomMargin;}MarginDimensions;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_MAX_FIELD_NAME_LENGTH"></A>
        <H1 CLASS="refHeading">最大フィールド名長さ</H1>
<PRE CLASS="syntax">#define MAX_FIELD_NAME_LENGTH 40を入力します。</PRE>
<P>データストア内のフィールド名の最大サイズ。 詳細については<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_DataStoreAddField()">DataStoreAddField()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_MeasurementType"></A>
          <A NAME="S_27.htm_IX_MEASURE_&ldots;"></A>
        <H1 CLASS="refHeading">MeasurementType</H1>
<PRE CLASS="syntax">typedef ByteEnum MeasurementType;#define MEASURE_US 0#define MEASURE_METRIC 1</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_MediaType"></A>
          <A NAME="S_27.htm_IX_MEDIA_&ldots;"></A>
        <H1 CLASS="refHeading">メディアの種類</H1>
<PRE CLASS="syntax">typedef enum/*byte*/{#define MEDIA_UNEXISTN 0#define MEDIA_160K 1#define MEDIA_180K 2#define MEDIA_320K 3#define MEDIA_360K 4#define MEDIA_720K 5#define MEDIA_1M2 6#define MEDIA_1M44 7#define MEDIA_2M88 8#define MEDIA_FIXED_DISK 9#define MEDIA_CUSTOM 10}MediaType;と入力します。</PRE>
<P>の<CODE>メディアの種類</CODE>列挙型は、ディスクのフォーマット方法を示します。 この列挙型のメンバは、いくつかのディスク情報ルーチンによって返される(例えば<CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetDefaultMedia()">DriveGetDefaultMedia()</A></CODE>).A<CODE>メディアの種類</CODE>値も<CODE><A HREF="../../CRef/Routines/R_1a.htm#IX_DiskFormat()">DiskFormat()関数</A></CODE>ディスクのフォーマット方法を指定します。</P>
</DIV>
<DIV>
          <A NAME="S_27.htm_IX_MediumAndUnit"></A>
        <H1 CLASS="refHeading">MediumAndUnit</H1>
<PRE CLASS="syntax">typedef struct{MediumType MU_medium;MediumUnitType MU_unitType;word MU_unit;}MediumAndUnit;</PRE>
<P>この構造体は、何らかの通信媒体のインスタンスを表します。一般に、これは何らかのハードウェアポートまたは周辺機器に対応します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ミディアム.h</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="S_28.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MediumUnitType"></A>
        <H1 CLASS="refHeading">MediumUnitType</H1>
<PRE CLASS="syntax">typedef ByteEnum MediumUnitType;#define MUT_NONE 0x0#define MUT_INT 0x1#define MUT_MEM_BLOCK 0x2#define MUT_ANY 0x3</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ミディアム.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MediumType"></A>
        <H1 CLASS="refHeading">メディアタイプ</H1>
<PRE CLASS="syntax">typedef struct{word MET_id;ManufacturerID MET_manuf;}MediumType;と入力します。</PRE>
<P>この構造は、通信媒体を表す。 いくつかの標準メディアは<CODE>MET_手動</CODE>MANUFACTURER_ID_GEOWORKSと<CODE>GeoworksMediumID</CODE>の<CODE>MET_ID(MET_</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ミディアム.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MemGetInfoType"></A>
        <H1 CLASS="refHeading">MemGetInfoType</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MemHandle"></A>
        <H1 CLASS="refHeading">MemHandle</H1>
<PRE CLASS="syntax">typedefハンドルMemHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_Message"></A>
          <A NAME="S_28.htm_IX_MSG_&ldots;"></A>
        <H1 CLASS="refHeading">メッセージ(Message)</H1>
<PRE CLASS="syntax">typedef wordメッセージ;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MessageError"></A>
          <A NAME="S_28.htm_IX_MESSAGE_NO_&ldots;"></A>
        <H1 CLASS="refHeading">メッセージエラー</H1>
<PRE CLASS="syntax">typedef enum/*word*/{MESSAGE_NO_ERROR, /*エラーは発生しませんでした*/MESSAGE_NO_HANDLES/*ハンドルを割り当てられませんでした*そしてMF_CAN_DISCARD_IF_DESPARATE*が渡されました*/</PRE>
<PRE CLASS="syntax">}MessageErrors;</PRE>
<P>ア<CODE>メッセージエラー</CODE>は、アセンブリルーチンによって返されます。<CODE>ObjMessage()</CODE>メッセージが正常に送信されたかどうかを示します。 これはCアプリケーションでは発生しません。</P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MessageFlags"></A>
          <A NAME="S_28.htm_IX_MF_&ldots;"></A>
        <H1 CLASS="refHeading">MessageFlags</H1>
<PRE CLASS="syntax">typedef WordFlags MessageFlags;#define MF_CALL 0x8000/*@call*/#define MF_FORCE_QUEUE 0x4000#define MF_STACK 0x2000/*@stack*/#define MF_CHECK_DUPLICATE 0x0800#define MF_CHECK_LAST_ONLY 0x0400#define MF_REPLACE 0x0200#define MF_CUSTOM 0x0100#define MF_FIXUP_DS 0x0080#define MF_FIXUP_ES 0x0040#define MF_DISCARD_IF_NO_MATCH 0x0020#define MF_MATCH_ALL 0x0010#define MF_INSERT_AT_FRONT 0x0008/*キューの先頭に配置*/#define MF_CAN_DISCARD_IF_DESPERATE 0x0004#define MF_RECORD 0x0002/*@record*/#define MF_DISPATCH_DONT_FREE 0x0002</PRE>
<P><CODE>MessageFlags</CODE>アセンブリルーチンで指定されている<CODE>ObjMessage()</CODE>これらのフラグのほとんどは、GocとCのカーネルによって適切に設定されています。Gocキーワードのリファレンスエントリを参照してください。<CODE>@呼び出し</CODE>および<CODE>@送信</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MessageHandle"></A>
        <H1 CLASS="refHeading">メッセージハンドル</H1>
<PRE CLASS="syntax">typedefハンドルMessageHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MessageMethod()"></A>
        <H1 CLASS="refHeading">MessageMethod</H1>
<PRE CLASS="syntax">typedef void MessageMethod();</PRE>
<P>Gocは、クラスのメソッド・テーブルを構築するときにこの型を使用します。</P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MinIncrementType"></A>
          <A NAME="S_28.htm_IX_MIT_&ldots;"></A>
        <H1 CLASS="refHeading">MinIncrementType</H1>
<PRE CLASS="syntax">typedef union{MinUSMeasure MIT_US;MinMetricMeasure MIT_METRIC;MinPointMeasure MIT_POINT;MinPicaMeasure MIT_PICA;}MinIncrementType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MinMetricMeasure"></A>
          <A NAME="S_28.htm_IX_MMM_&ldots;"></A>
        <H1 CLASS="refHeading">MinMetricMeasure</H1>
<PRE CLASS="syntax">typedef ByteEnum MinMetricMeasure;#define MMM_MILLIMETERS 0#define MMM_HALF_CENTIMETERS 1#define MMM_CENTIMETERS 2</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MinPicaMeasure"></A>
          <A NAME="S_28.htm_IX_MPM (MinPicaMeasure type)"></A>
        <H1 CLASS="refHeading">MinPicaMeasure</H1>
<PRE CLASS="syntax">typedef ByteEnum MinPicaMeasure;#define MPM_PICA 0#define MPM_INCH 1</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MinPointMeasure"></A>
        <H1 CLASS="refHeading">MinPointMeasure</H1>
<PRE CLASS="syntax">typedef ByteEnum MinPointMeasure;#define MPM_25_POINT 0#define MPM_50_POINT 1#define MPM_100_POINT 2</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_28.htm_IX_MinUSMeasure"></A>
          <A NAME="S_28.htm_IX_MUSM_&ldots;"></A>
        <H1 CLASS="refHeading">MinUSMeasure</H1>
<PRE CLASS="syntax">typedef ByteEnum MinUSMeasure;#define MUSM_EIGHTH_INCH 0#define MUSM_QUARTER_INCH 1#define MUSM_HALF_INCH 2#define MUSM_ONE_INCH 3</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_29.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_MixMode"></A>
          <A NAME="S_29.htm_IX_MM_&ldots;"></A>
        <H1 CLASS="refHeading">MixMode</H1>
<PRE CLASS="syntax">typedef ByteEnum MixMode;#define MM_CLEAR 0/*clear destination*/#define MM_COPY 1/*新しい図面は不透明*/#define MM_NOP 2/*図面がありません*/#define MM_AND 3/*新しい色と古い色の論理AND*/#define MM_INVERT 4/*古い色の反転*/#define MM_XOR 5/*新しい色と古い色のXOR*/#define MM_SET 6/*set destination black*/#define MM_OR 7/*新しい色と古い色の論理OR*/</PRE>
<P>の<CODE>MixMode</CODE>は、あるものを別のものの上に描画するときに、グラフィックスシステムが何を行うかを決定します。</P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_ModemResultCode"></A>
        <H1 CLASS="refHeading">ModemResultCode</H1>
<PRE CLASS="syntax">typedef enum{MRC_NOT_SUPPORTED=1, MRC_DRIVER_IN_USE, MRC_TIMEOUT, MRC_UNKNOWN_RESPONSE, MRC_OK, RC_ERROR, MRC_BUSY, MRC_NO_DIALTONE, MRC_NO_ANSWER, MRC_NO_CARRIER, MRC_CONNECT, MRC_CONNECT_1200, MRC_CONNECT_2400, MRC_CONNECT_4800, MRC_CONNECT_9600, MRC_BLACKLISTED, MRC_DELAYED, }ModemResultCode;</PRE>
<P>モデムルーチンから返されるエラーコード。</P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_MonoTransfer"></A>
          <A NAME="S_29.htm_IX_MT_gray[]"></A>
        <H1 CLASS="refHeading">MonoTransfer</H1>
<PRE CLASS="syntax">typedef struct{byte MT_gray[256];}MonoTransfer;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_MouseReturnFlags"></A>
          <A NAME="S_29.htm_IX_MRF_&ldots;"></A>
        <H1 CLASS="refHeading">MouseReturnFlags</H1>
<PRE CLASS="syntax">typedef WordFlags MouseReturnFlags;#define MRF_PROCESSED 0x8000#define MRF_REPLAY 0x4000#define MRF_PREVENT_PASS_THROUGH 0x2000#define MRF_SET_POINTER_IMAGE 0x1000#define MRF_CLEAR_POINTER_IMAGE 0x0800</PRE>
<P>これらのフラグは、マウス入力で動作するシステムのさまざまな部分で使用されます。 どの値を渡すのが適切かは、コンテキストによって異なります。</P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_MouseReturnParams"></A>
        <H1 CLASS="refHeading">MouseReturnParams</H1>
<PRE CLASS="syntax">typedef struct{word unused;MouseReturnFlagsフラグ;optr ptrImage;}MouseReturnParams;</PRE>
<P>この構造は、マウス入力で動作するシステムの特定の領域で使用されます。</P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_NameArrayAddFlags"></A>
          <A NAME="S_29.htm_IX_NAAF_SET_DATA_ON_REPLACE"></A>
        <H1 CLASS="refHeading">NameArrayAddFlags</H1>
<PRE CLASS="syntax">typedef WordFlags NameArrayAddFlags;#define NAAF_SET_DATA_ON_REPLACE 0x8000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_NameArrayElement"></A>
          <A NAME="S_29.htm_IX_NAE_meta"></A>
        <H1 CLASS="refHeading">NameArrayElement</H1>
<PRE CLASS="syntax">typedef struct{RefElementHeader NAE_meta;}NameArrayElement;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_NameArrayHeader"></A>
          <A NAME="S_29.htm_IX_NAH_&ldots;"></A>
        <H1 CLASS="refHeading">NameArrayHeader</H1>
<PRE CLASS="syntax">typedef struct{ElementArrayHeader NAH_meta;word NAH_dataSize;/*各要素*/のデータセクションのサイズ</PRE>
<PRE CLASS="syntax">}NameArrayHeader;</PRE>
<P>すべてのname配列は<CODE>NameArrayHeader</CODE>name配列は特殊な要素配列であるため<CODE>NameArrayHeader</CODE>で始まる必要があります。<CODE>ElementArrayHeader</CODE>構造体には追加のフィールドが1つあります。<CODE>NAH_データサイズ</CODE>このフィールドは、各要素のデータセクションの長さを指定します。 アプリケーションはこのフィールドを調べることができますが、変更してはなりません。</P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_NameArrayMaxElement"></A>
          <A NAME="S_29.htm_IX_NAME_&ldots;"></A>
          <A NAME="S_29.htm_IX_NAME_ARRAY_MAX_DATA_SIZE"></A>
          <A NAME="S_29.htm_IX_NAME_ARRAY_MAX_NAME_SIZE"></A>
        <H1 CLASS="refHeading">NameArrayMaxElement</H1>
<PRE CLASS="syntax">typedef struct{RefElementHeader NAME_meta;byte NAME_data[NAME_ARRAY_MAX_DATA_SIZE];char NAME_name[NAME_ARRAY_MAX_NAME_SIZE];}NameArrayMaxElement;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_NO_ERROR_RETURNED"></A>
        <H1 CLASS="refHeading">NO_ERROR_RETURNED(返されたエラーなし)</H1>
<PRE CLASS="syntax">#define NO_ERROR_RETURNED 0(0が返されました)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_NoteType"></A>
          <A NAME="S_29.htm_IX_NT_&ldots;  (NoteType type)"></A>
        <H1 CLASS="refHeading">メモの種類</H1>
<PRE CLASS="syntax">typedef ByteEnum NoteType;#define NT_INK 0#define NT_TEXT 1</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_NotificationType"></A>
          <A NAME="S_29.htm_IX_NT_&ldots;  (NotificationType structure)"></A>
        <H1 CLASS="refHeading">通知の種類</H1>
<PRE CLASS="syntax">typedef struct{ManufacturerID NT_manuf;word NT_type;}通知タイプ;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_29.htm_IX_NotifyInkHasTarget"></A>
          <A NAME="S_29.htm_IX_NIHT_&ldots;"></A>
        <H1 CLASS="refHeading">NotifyInkHasTarget</H1>
<PRE CLASS="syntax">typedef struct{optr NIHT_optr;}NotifyInkHasTarget;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_2a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_NULL"></A>
        <H1 CLASS="refHeading">特殊文字</H1>
<PRE CLASS="syntax">#undef NULL#define NULL 0</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_NullChunk"></A>
        <H1 CLASS="refHeading">NullChunk</H1>
<PRE CLASS="syntax">#define NullChunk((ChunkHandle)0)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_NullClass"></A>
        <H1 CLASS="refHeading">NullClass</H1>
<PRE CLASS="syntax">#define NullClass((ClassStruct*)0)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_NullHandle"></A>
        <H1 CLASS="refHeading">NullHandle</H1>
<PRE CLASS="syntax">#define NullHandle((ハンドル)0)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_NullOptr"></A>
        <H1 CLASS="refHeading">NullOptr</H1>
<PRE CLASS="syntax">#define NullOptr((optr)0)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_NumberFormatFlags"></A>
          <A NAME="S_2a.htm_IX_NFF_LEADING_ZERO"></A>
        <H1 CLASS="refHeading">NumberFormatFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags NumberFormatFlags;#define NFF_LEADING_ZERO 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_NumberType"></A>
          <A NAME="S_2a.htm_IX_NT_&ldots;  (NumberType type)"></A>
        <H1 CLASS="refHeading">番号の種類</H1>
<PRE CLASS="syntax">typedef ByteEnum NumberType;#define NT_VALUE 0#define NT_BOOLEAN 1#define NT_DATE_TIME 2</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_ObjChunkFlags"></A>
          <A NAME="S_2a.htm_IX_OCF_&ldots;"></A>
        <H1 CLASS="refHeading">ObjChunkFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ObjChunkFlags;#define OCF_VARDATA_RELOC 0x10#define OCF_DIRTY 0x08#define OCF_IGNORE_DIRTY 0x04#define OCF_IN_RESOURCE 0x02#define OCF_IS_OBJECT 0x01</PRE>
<P>このレコードは各チャンクの先頭に格納され、チャンクに関する特定の情報を提供します。 フラグは内部にあります。</P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_ObjLMemBlockHeader"></A>
          <A NAME="S_2a.htm_IX_OLMBH_&ldots;"></A>
        <H1 CLASS="refHeading">ObjLMemBlockHeader</H1>
<PRE CLASS="syntax">typedef struct{LMemBlockHeader OLMBH_header;/*標準LMemブロックヘッダ*/word OLMBH_inUseCount;word OLMBH interactibleCount;optr OLMBH_output;word OLMBH resourceSize;}ObjLMemBlockHeader;</PRE>
<P>これは、すべてのオブジェクトブロックを開始する標準のObject Blockヘッダーです。<CODE>@ヘッダー</CODE>Gocキーワード。 この構造体のフィールドは次のとおりです。</P>
<DL>
<DT><CODE>OLMBH_ヘッダ</DT><DD></CODE>標準LMemブロックヘッダ。 詳細については<CODE>LMemBlockHeader</CODE>構造タイプ。</DD>
<DT><CODE>OLMBH_inUseCount</DT><DD></CODE>ブロックの「使用中」カウント。 ゼロでない場合、ブロックは安全に解放されない可能性があります。</DD>
<DT><CODE>OLMBH_interactibleCount</DT><DD></CODE>ブロックの「対話可能な」カウント。 ゼロでない場合、ブロック内の1つまたは複数のオブジェクトがユーザに表示されるか、ユーザによって(キーボードショートカットなどを介して)アクティブにされようとしています。 interactibleカウントがゼロ以外のブロックはスワップできません。</DD>
<DT><CODE>OLMBH_出力</DT><DD></CODE>使用中カウントのゼロへの変更やゼロからの変更など、リソースステータスの変更について通知されるオブジェクトのoptr。 この出力オブジェクトには<CODE>TravelOption</CODE>TO_OBJ_BLOCK_OUTPUTを参照してください。</DD>
<DT><CODE>OLMBH_resourceSize</DT><DD></CODE>オブジェクトブロック(リソース)のサイズ。</DD>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_ObjRelocation"></A>
          <A NAME="S_2a.htm_IX_OR_&ldots;"></A>
        </DL>
<H1 CLASS="refHeading">ObjRelocation</H1>
<PRE CLASS="syntax">typedef struct{ObjRelocationType OR_type;word OR_offset;}ObjRelocation;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_ObjRelocationSource"></A>
          <A NAME="S_2a.htm_IX_ORS_&ldots;"></A>
          <A NAME="S_2a.htm_IX_RID_SOURCE_OFFSET"></A>
        <H1 CLASS="refHeading">ObjRelocationSource</H1>
<PRE CLASS="syntax">typedef ByteEnum ObjRelocationSource;#define ORS_NULL 0#define ORS_OWNING_GEODE 1#define ORS_KERNEL 2#define ORS_LIBRARY 3#define ORS_CURRENT_BLOCK 4#define ORS_VM_HANDLE 5#define ORS_OWNING_GEODE_ENTRY_POINT 6#define ORS_NON_STATE_VM 7#define ORS_UNKNOWN_BLOCK 8#define ORS_EXTERNAL 9#define RID_SOURCE_OFFSET 12</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_ObjRelocationType"></A>
          <A NAME="S_2a.htm_IX_RELOC_&ldots;"></A>
        <H1 CLASS="refHeading">ObjRelocationType</H1>
<PRE CLASS="syntax">typedef ByteEnum ObjRelocationType;#define RELOC_END_OF_LIST 0#define RELOC_RELOC_HANDLE 1#define RELOC_RELOC_SEGMENT 2#define RELOC_RELOC_ENTRY_POINT 3</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2a.htm_IX_OperatorStackElement"></A>
          <A NAME="S_2a.htm_IX_OSE_&ldots;"></A>
        <H1 CLASS="refHeading">OperatorStackElement</H1>
<PRE CLASS="syntax">typedef struct{EvalStackOperatorType OSE_type;EvalStackOperatorType OSE_data;}OperatorStackElement;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_2b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_OperatorType"></A>
          <A NAME="S_2b.htm_IX_OP_&ldots;  (OperatorType)"></A>
        <H1 CLASS="refHeading">OperatorType</H1>
<PRE CLASS="syntax">typedef ByteEnum OperatorType;#define OP_RANGE_SEPARATOR 0#define OP_NEGATION 1#define OP_PERCENT 2#define OP_EXPONATION 3#define OP_DIVISION 5#define OP_MODULO 6#define OP_ADDITION 7#define OP_SUBTRACTION 8#define OP_EQUAL 9#define OP_NOT_EQUAL 10#define OP_LESS_THAN 11#define OP_GREATER_THAN 12#define OP_LESS_THAN_OR_EQUAL 13#define OP_GREATER_THAN_OR_EQUAL 14#define OP_STRING_CONCAT 15#define OP_RANGE_INTERSECTION 16#define OP_NOT_EQUAL_GRAPHIC 17#define OP_DIVISION_GRAPHIC 18#define OP_LESS_THAN_OR_EQUAL_GRAPHIC 19#define OP_GREATER_THAN_OR_EQUAL_GRAPHIC 20#define OP_PERCENT_MODULO 21#define OP_SUBTRACTION_NEGATION 22</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_optr"></A>
        <H1 CLASS="refHeading">オプション</H1>
<PRE CLASS="syntax">typedef dword optr;と入力します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PageEndCommand"></A>
          <A NAME="S_2b.htm_IX_PEC_&ldots;"></A>
        <H1 CLASS="refHeading">PageEndCommand</H1>
<PRE CLASS="syntax">typedef ByteEnum PageEndCommand;#define PEC_FORM_FEED 0#define PEC_NO_FORM_FEED 1</PRE>
<P>この列挙型は、ページの最後にフォームフィードが必要かどうかを指定するために使用されます。 ほとんどの場合、フォームフィードが必要ですが、バナープリンタなどのプログラムでは、フォームフィードが抑制される場合があります。</P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PageLayout"></A>
          <A NAME="S_2b.htm_IX_PL_&ldots;"></A>
        <H1 CLASS="refHeading">ページレイアウト</H1>
<PRE CLASS="syntax">typedef union{PageLayoutPaper PL_paper;PageLayoutEnvelope PL_envelope;PageLayoutLabel PL_label;}PageLayout;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PageLayoutEnvelope"></A>
          <A NAME="S_2b.htm_IX_PLE_&ldots;"></A>
        <H1 CLASS="refHeading">PageLayoutEnvelope</H1>
<PRE CLASS="syntax">typedef WordFlags PageLayoutEnvelope;#define PLE_PATH 0x0040#define PLE_ORIENTATION 0x0010#define PLE_TYPE 0x0004</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PageLayoutLabel"></A>
          <A NAME="S_2b.htm_IX_PLL_&ldots;"></A>
        <H1 CLASS="refHeading">PageLayoutLabel</H1>
<PRE CLASS="syntax">typedef WordFlags PageLayoutLabel;#define PLL_ROWS 0x7e00/*ラベルダウン*/#define PLL_COLUMNS 0x01f8/*ラベルアクロス*/#define PLL_TYPE 0x0004/*PT_LABEL*/</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PageLayoutPaper"></A>
          <A NAME="S_2b.htm_IX_PLP_&ldots;"></A>
        <H1 CLASS="refHeading">PageLayoutPaper</H1>
<PRE CLASS="syntax">typedef WordFlags PageLayoutPaper;#define PLP_ORIENTATION 0x0008#define PLP_TYPE 0x0004</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PageSize"></A>
          <A NAME="S_2b.htm_IX_PS_&ldots;"></A>
        <H1 CLASS="refHeading">ページサイズ</H1>
<PRE CLASS="syntax">typedef struct{word unused;word PS_width;word PS_height;PageLayout PS_layout;}ページサイズ;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PageSizeCtrlAttrs"></A>
          <A NAME="S_2b.htm_IX_PSCA_&ldots;"></A>
        <H1 CLASS="refHeading">PageSizeCtrlAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags PageSizeCtrlAttrs;#define PZCA_ACT_LIKE_GADGET 0x8000#define PZCA_PAPER_SIZE 0x4000#define PZCA_INITIALIZE 0x2000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PSIZECF_&ldots;"></A>
          <A NAME="S_2b.htm_IX_PageSizeCtrlFeatures"></A>
        <H1 CLASS="refHeading">PageSizeCtrlFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags PageSizeControlFeatures;#define PSIZECF_MARGINS 0x04#define PSIZECF_ALL 0x02#define PSIZECF_PAGE_TYPE 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PageSizeReport"></A>
          <A NAME="S_2b.htm_IX_PSR_&ldots;"></A>
        <H1 CLASS="refHeading">PageSizeReport</H1>
<PRE CLASS="syntax">typedef struct{dword PSR_width;dword PSR_height;PageLayout PSR_layout;PCMarginParams PSR_margins;}PageSizeReport:</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PageType"></A>
          <A NAME="S_2b.htm_IX_PT_&ldots;  (PageType type)"></A>
        <H1 CLASS="refHeading">ページの種類</H1>
<PRE CLASS="syntax">typedef enum{PT_PAPER, PT_ENVELOPE, PT_LABEL}PageType;(PT_PAPER、PT_ENVELOPE、PT_LABELの</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_PaperOrientation"></A>
          <A NAME="S_2b.htm_IX_PO_&ldots;"></A>
        <H1 CLASS="refHeading">用紙の向き</H1>
<PRE CLASS="syntax">typedef ByteEnum PaperOrientation;#define PO_PORTRAIT 0x00#define PO_LANDSCAPE 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2b.htm_IX_ParallelUnit"></A>
          <A NAME="S_2b.htm_IX_PARALLEL_LPT&ldots;"></A>
        <H1 CLASS="refHeading">ParallelUnit</H1>
<PRE CLASS="syntax">typedef enum{PARALLEL_LPT1=0, PARALLEL_LPT2=2, PARALLEL_LPT3=4, PARALLEL_LPT4=6, }ParallelUnit;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_2c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_2c.htm_IX_ParserFlags"></A>
          <A NAME="S_2c.htm_IX_PF_&ldots;  (ParserFlags)"></A>
        <H1 CLASS="refHeading">ParserFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ParserFlags;#define PF_HAS_LOOKAHEAD 0x80#define PF_CONTAINS_DISPLAY_FUNC 0x40#define PF_OPERATORS 0x20#define PF_NUMBERS 0x10#define PF_CELLS 0x08#define PF_FUNCTIONS 0x04#define PF_NAMES 0x02#define PF_NEW_NAMES 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2c.htm_IX_ParserParameters"></A>
          <A NAME="S_2c.htm_IX_PP_&ldots;"></A>
        <H1 CLASS="refHeading">ParserParameters</H1>
<PRE CLASS="syntax">typedef struct{CommonParameters PP_common;word PP_parserBufferSize;ParserFlags PP_flags;dword PP_textPtr;ScannerToken PP_currentToken;ScannerToken PP_lookAheadToken;byte PP_error;/*ParserScannerEvaluatorError*/word PP_tokenStart;word PP_tokenEnd;}ParserParameters;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2c.htm_IX_ParserScannerEvaluatorError"></A>
          <A NAME="S_2c.htm_IX_PSEE_&ldots;"></A>
        <H1 CLASS="refHeading">ParserScannerEvaluatorError</H1>
<PRE CLASS="syntax">typedef ByteEnum ParserScannerEvaluatorError;/**スキャナエラー*/#define PSEE_BAD_NUMBER 0#define PSEE_BAD_CELL_REFERENCE 1#define PSEE_NO_CLOSE_QUOTE 2#define PSEE_COLUMN_TOO_LARGE 3#define PSEE_ROW_TOO_LARGE 4#define PSEE_ILLEGAL_TOKEN 5/**パーサーエラー*/#define PSEE_GENERAL 6#define PSEE_TOO_MANY_TOKENS 7#define PSEE_EXPECTED_OPEN_PA LA 8#define PSEE_EXPECTED_CLOSE_PA LA 9#define PSEE_BAD_EXPRESSION 10#define PSEE_EXPECTED_END_OF_EXPRESSION 11#define PSEE_MISSING_CLOSE_PA LA 12#define PSEE_UNKNOWN_IDENTIFIER 13#define PSEE_NOT_ENOUGH_NAME_SPACE 14/**重大な評価者エラー*/#define PSEE_OUT_OF_STACK_SPACE 15#define PSEE_NESTING_TOO_DEEP 16/**式の結果として返される評価者エラー。 *これらは引数スタックに返されます。 */#define PSEE_ROW_OUT_OF_RANGE 17#define PSEE_COLUMN_OUT_OF_RANGE 18#define PSEE_FUNCTION_NO_LONGER_EXISTS 19#define PSEE_BAD_ARG_COUNT 20#define PSEE_WRONG_TYPE 21#define PSEE_DIVIDE_BY_ZERO 22#define PSEE_UNDEFINED_NAME 23#define PSEE_CIRCULAR_REF 24#define PSEE_CIRCULAR_DEP 25#define PSEE_CIRC_NAME_REF 26#define PSEE_NUMBER_OUT_OF_RANGE 27#define PSEE_GEN_ERR 28#define PSEE_NA 29/**依存関係エラー*/#define PSEE_TOO_MANY_DEPENDENCIES 30#define PSEE_SSHEET_BASE 0xc0#define PSEE_FLOAT_BASE 250#define PSEE_APP_BASE 230#define PSEE_FLOAT_POS_INFINITY PSEE_FLOAT_BASE#define PSEE_FLOAT_NEG_INFINITY(PSEE_FLOAT_BASE+1)#define PSEE_FLOAT_GEN_ERR(PSEE_FLOAT_BASE+2)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2c.htm_IX_ParserToken"></A>
          <A NAME="S_2c.htm_IX_PT_&ldots;  (ParserToken structure)"></A>
        <H1 CLASS="refHeading">ParserToken</H1>
<PRE CLASS="syntax">typedef struct{ParserTokenType PT_type;ParserTokenData PT_data;}ParserToken;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2c.htm_IX_ParserTokenCellData"></A>
          <A NAME="S_2c.htm_IX_PTCD_&ldots;"></A>
        <H1 CLASS="refHeading">ParserTokenCellData</H1>
<PRE CLASS="syntax">typedef struct{CellReference PTCD_cellRef;}ParserTokenCellData;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_2d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_ParserTokenData"></A>
          <A NAME="S_2d.htm_IX_PTD_&ldots;"></A>
        <H1 CLASS="refHeading">ParserTokenData</H1>
<PRE CLASS="syntax">typedef union{ParserTokenNumberData PTD_number;ParserTokenStringData PTD_string;ParserTokenNameData PTD_name;ParserTokenCellData PTD_cell;ParserTokenFunctionData PTD_function;ParserTokenOperatorData PTD_operator;}ParserTokenData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_ParserTokenFunctionData"></A>
          <A NAME="S_2d.htm_IX_PTFD_functionID"></A>
        <H1 CLASS="refHeading">ParserTokenFunctionData</H1>
<PRE CLASS="syntax">typedef struct{word PTFD_functionID;}ParserTokenFunctionData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_ParserTokenNameData"></A>
          <A NAME="S_2d.htm_IX_PTND_name"></A>
        <H1 CLASS="refHeading">ParserTokenNameData</H1>
<PRE CLASS="syntax">typedef struct{word PTND_name;}ParserTokenNameData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_ParserTokenNumberData"></A>
          <A NAME="S_2d.htm_IX_PTND_value"></A>
        <H1 CLASS="refHeading">ParserTokenNumberData</H1>
<PRE CLASS="syntax">typedef struct{FloatNum PTND_value;}ParserTokenNumberData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_ParserTokenOperatorData"></A>
          <A NAME="S_2d.htm_IX_PTOD_operatorID"></A>
        <H1 CLASS="refHeading">ParserTokenOperatorData</H1>
<PRE CLASS="syntax">typedef struct{OperatorType PTOD_operatorID;}ParserTokenOperatorData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_ParserTokenStringData"></A>
          <A NAME="S_2d.htm_IX_PTSD_length"></A>
        <H1 CLASS="refHeading">ParserTokenStringData</H1>
<PRE CLASS="syntax">typedef struct{word PTSD_length;}ParserTokenStringData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_ParserTokenType"></A>
          <A NAME="S_2d.htm_IX_PARSER_TOKEN_&ldots;"></A>
        <H1 CLASS="refHeading">ParserTokenType</H1>
<PRE CLASS="syntax">typedef ByteEnum ParserTokenType;#define PARSER_TOKEN_NUMBER 0#define PARSER_TOKEN_STRING 1#define PARSER_TOKEN_CELL 2#define PARSER_TOKEN_END_OF_EXPRESSION 3#define PARSER_TOKEN_OPEN_PAREN 4#define PARSER_TOKEN_CLOSE_PAREN 5#define PARSER_TOKEN_NAME 6#define PARSER_TOKEN_FUNCTION 7#define PARSER_TOKEN_CLOSE_FUNCTION 8#define PARSER_TOKEN_ARG_END 9#define PARSER_TOKEN_OPERATOR 10</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_PathCombineType"></A>
          <A NAME="S_2d.htm_IX_PCT_&ldots;  (PathCombineType type)"></A>
        <H1 CLASS="refHeading">PathCombineType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{PCT_NULL, /*古いパスを消去*/PCT_REPLACE, /*古いパスを次のパスで置換*/PCT_UNION, /*古いパスを新しいパスで結合*/PCT_INTERSECTION/*古いパスを新しいパスで交差*/}PathCombineType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_PathName"></A>
          <A NAME="S_2d.htm_IX_PATH_BUFFER_SIZE"></A>
        <H1 CLASS="refHeading">パス名(PathName</H1>
<PRE CLASS="syntax">typedef charパス名[PATH_BUFFER_SIZE];</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_PT_ (PatternType type)"></A>
          <A NAME="S_2d.htm_IX_PatternType"></A>
        <H1 CLASS="refHeading">パターンタイプ</H1>
<PRE CLASS="syntax">typedef ByteEnum PatternType;#define PT_SOLID 0#define PT_SYSTEM_HATCH 1#define PT_SYSTEM_BITMAP 2#define PT_USER_HATCH 3#define PT_USER_BITMAP 4#define PT_CUSTOM_HATCH 5#define PT_CUSTOM_BITMAP 6</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_PCDocSizeParams"></A>
          <A NAME="S_2d.htm_IX_PCDSP_&ldots;"></A>
        <H1 CLASS="refHeading">PCDocSizeParams</H1>
<PRE CLASS="syntax">typedef struct{dword PCDSP_width;dword PCDSP_height;}PCDocSizeParams;と入力します。</PRE>
<P>この構造を使用して、文書サイズを印刷コントロールに伝達します。</P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_PCMarginParams"></A>
          <A NAME="S_2d.htm_IX_PCMP_&ldots;"></A>
        <H1 CLASS="refHeading">PCMarginParams</H1>
<PRE CLASS="syntax">typedef struct{word PCMP_left;/*左マージン*/word PCMP_top;/*上マージン*/word PCMP_right;/*右マージン*/word PCMP_bottom;/*下マージン*/}PCMarginParams</PRE>
<P>この構造体は、ドキュメントまたはプリンタの余白に関する情報を保持します。</P>
</DIV>
<DIV>
          <A NAME="S_2d.htm_IX_PCProgressType"></A>
          <A NAME="S_2d.htm_IX_PCPT_&ldots;"></A>
        <H1 CLASS="refHeading">PCProgressType</H1>
<PRE CLASS="syntax">typedef enum{PCPT_PAGE, PCPT_PERCENT, PCPT_TEXT}PCProgressType;</PRE>
<P> </P>
</DIV>

<DIV>
          <A NAME="S_2d.htm_IX_PDAType"></A>
          <A NAME="S_2d.htm_IX_PDAT&ldots"></A>
        <H1 CLASS="refHeading">PDAType</H1>
<PRE CLASS="syntax">typedef ByteEnum PDAType;#define PDAT_PC_EMULATOR 0x0#define PDAT_N9000 0x1#define PDAT_N9000i 0x2</PRE>

<P>これらの値は、さまざまなNokia 9000 Communicatorハードウェアプラットフォームに対応しています。 デバイスのビルド4以降でのみ使用できます(を参照)。<A HREF = "../../Nokia9000/Versions/Update_1.htm">バージョン</A>」を参照してください)。</P>

<P CLASS="refField"><STRONG>次を含む:</STRONG>respondr・ゴー</P>

<P CLASS="refField">
          <STRONG>関連項目:</STRONG>
          <CODE>RespGetPDAHardwareInfo()</CODE>
        </P>
</DIV>

<HR>
          <A NAME="S_2e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_Point"></A>
          <A NAME="S_2e.htm_IX_P_&ldots;"></A>
        <H1 CLASS="refHeading">[点]</H1>
<PRE CLASS="syntax">typedef struct{sword P_x;sword P_y;}ポイント;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PointDWord"></A>
          <A NAME="S_2e.htm_IX_PD_&ldots;  (PointDWord structure)"></A>
        <H1 CLASS="refHeading">PointDWord</H1>
<PRE CLASS="syntax">typedef struct{sdword PD_x;sdword PD_y;}PointDWord;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PointDWFixed"></A>
          <A NAME="S_2e.htm_IX_PDF_&ldots;"></A>
        <H1 CLASS="refHeading">PointDWFixed</H1>
<PRE CLASS="syntax">typedef struct{DWFixed PDF_x;DWFixed PDF_y;}PointDWFixed;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PointerDef32"></A>
          <A NAME="S_2e.htm_IX_PD_&ldots;  (PointerDef32 structure)"></A>
        <H1 CLASS="refHeading">PointerDef32</H1>
<PRE CLASS="syntax">typedef struct{sbyte PD_hotX;sbyte PD_hotY;byte PD_mask[CURSOR_IMAGE_SIZE_32];byte PD_image[CURSOR_IMAGE_SIZE_32];}PointerDef32;STANDARD_CURSOR_IMAGE_SIZE=32</PRE>
<P>この構造体はマウスポインタを定義します。</P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PointWWFixed"></A>
          <A NAME="S_2e.htm_IX_PF_&ldots;  (PointWWFixed structure)"></A>
        <H1 CLASS="refHeading">PointWWFixed</H1>
<PRE CLASS="syntax">typedef struct{WWFixed PF_x;WWFixed PF_y;}PointWWFixed;</PRE>
<P>これらの構造は、グラフィックス点の座標を指定するために使用されます。 どの点構造を使用するかは、座標空間のサイズと必要な精度によって異なります。</P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PrintControlAttrs"></A>
          <A NAME="S_2e.htm_IX_PCA_&ldots;"></A>
        <H1 CLASS="refHeading">PrintControlAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags PrintControlAttrs;#define PCA_MARK_APP_BUSY 0x2000/*印刷中にビジー状態をマーク*/#define PCA_VERIFY_PRINT 0x1000/*印刷前に確認*/#define PCA_SHOW_PROGRESS 0x0800/*印刷進捗ダイアログボックスを表示*/#define PCA_PROGRESS_PERCENT 0x0400/*進捗をパーセントで表示*/#define PCA_PROGRESS_PAGE 0x0200/*進捗をページで表示*/#define PCA_FORCE_ROTATION 0x0100/*出力の回転を強制*/#define PCA_COPY_CONTROLS 0x0080/*コピーコントロールが使用可能*/#define PCA_PAGE_CONTROLS 0x0040/*ページ範囲コントロールが使用可能*/#define PCA_QUALITY_CONTROLS 0x0020/*品質コントロールが使用可能*/#define PCA_USES_DIALOG_BOX 0x0010/*ダイアログボックスが表示されます*/#define PCA_GRAPHICS_MODE 0x0008/*グラフィックスモード出力をサポート*/#define PCA_TEXT_MODE 0x0004/*テキストモード出力をサポート*/#define PCA_DEFAULT_QUALITY 0x0002/*デフォルトの印刷品質*/</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PrintControlFeatures"></A>
          <A NAME="S_2e.htm_IX_PRINTCF_&ldots;"></A>
        <H1 CLASS="refHeading">PrintControlFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags PrintControlFeatures;#define PRINTCF_PRINT_TRIGGER 0x02/*印刷トリガが必要*/#define PRINTCF_FAX_TRIGGER 0x01/*FAXトリガが必要*/</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PrintControlStatus"></A>
          <A NAME="S_2e.htm_IX_PCS_PRINT_BOX_&ldots;"></A>
        <H1 CLASS="refHeading">PrintControlStatus</H1>
<PRE CLASS="syntax">typedef enum{PCS_PRINT_BOX_VISIBLE, PCS_PRINT_BOX_NOT_VISIBLE}PrintControlStatus;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PrintControlToolboxFeatures"></A>
          <A NAME="S_2e.htm_IX_PRINTCTF_&ldots;"></A>
        <H1 CLASS="refHeading">PrintControlToolboxFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags PrintControlToolboxFeatures;#define PRINTCTF_PRINT_TRIGGER 0x02/*印刷ツールのトリガが必要*/#define PRINTCTF_FAX_TRIGGER 0x01/*FAXツールのトリガが必要*/</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PrinterDriverType"></A>
          <A NAME="S_2e.htm_IX_PDT_&ldots;"></A>
        <H1 CLASS="refHeading">PrinterDriverType</H1>
<PRE CLASS="syntax">typedef enum PrinterDriverType;PDT_PRINTER, PDT_PLOTTER, PDT_FACSIMILE, PDT_CAMERA, PDT_OTHER, }PrinterDriverType;</PRE>
<P>この列挙型は、扱っているプリンタドライバの種類を示します。</P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PrinterOutputModes"></A>
          <A NAME="S_2e.htm_IX_POM_&ldots;"></A>
          <A NAME="S_2e.htm_IX_PRINT_GRAPHICS"></A>
          <A NAME="S_2e.htm_IX_PRINT_TEXT"></A>
        <H1 CLASS="refHeading">PrinterOutputModes</H1>
<PRE CLASS="syntax">typedef ByteFlags PrinterOutputModes;#define POM_GRAPHICS_LOW 0x10#define POM_GRAPHICS_MEDIUM 0x08#define POM_GRAPHICS_HIGH 0x04#define POM_TEXT_DRAFT 0x02#define POM_TEXT_NLQ 0x01#define PRINT_GRAPHICS=(POM_GRAPHICS_LOW POM_GRAPHICS_MEDIUM POM_GRAPHICS_HIGH)</PRE>
<PRE CLASS="syntax">#define PRINT_TEXT=(POM_TEXT_DRAFT POM_TEXT_NLQ)となります。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2e.htm_IX_PrintQualityEnum"></A>
          <A NAME="S_2e.htm_IX_PQT_&ldots;"></A>
        <H1 CLASS="refHeading">PrintQualityEnum</H1>
<PRE CLASS="syntax">typedef enum{PQT_HIGH, PQT_MEDIUM, PQT_LOW}PrintQualityEnum;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_2f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_2f.htm_IX_ProtocolNumber"></A>
          <A NAME="S_2f.htm_IX_PN_&ldots;"></A>
        <H1 CLASS="refHeading">プロトコル番号(ProtocolNumber)</H1>
<PRE CLASS="syntax">typedef struct{word PN_major;word PN_minor;}プロトコル番号;</PRE>
<P>ファイル、ジオード、またはドキュメントのプロトコルレベルを定義します。<CODE>PN_メジャー</CODE>重要な互換性の比較を表します。<CODE>PN_マイナー</CODE>有意差が少ないことを示している。 アイテム間でメジャープロトコルが異なる場合は、互換性がありません。 マイナープロトコルが異なる場合は、互換性がない場合とない場合があります。</P>
</DIV>
<DIV>
          <A NAME="S_2f.htm_IX_QueueHandle"></A>
        <H1 CLASS="refHeading">QueueHandle</H1>
<PRE CLASS="syntax">typedefハンドルQueueHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2f.htm_IX_QuickSortParameters"></A>
          <A NAME="S_2f.htm_IX_QSP_&ldots;"></A>
        <H1 CLASS="refHeading">QuickSortParameters</H1>
<PRE CLASS="syntax">typedef struct_QuickSortParameters{word_pascal(*QSP_compareCallback)(void*el1, void*el2</PRE>
<PRE CLASS="syntax">単語valueForCallback));void_pascal(*QSP_lockCallback)(void*el, 単語valueForCallback));void_pascal(*QSP_unlockCallback)(void*el, 単語valueForCallback));word QSP_insertLimit;word QSP_medianLimit;/*これらはクイックソートアルゴリズムによって内部的に設定され、*呼び出し側によって設定されるべきではありません:*/word QSP_nLesser;word QSP_nGreater;}QuickSortParameters;</PRE>
<P>この構造体は<CODE>ArrayQuickSort</CODE>各フィールドの意味は次のとおりです。</P>
<DL>
<DT><CODE>(注)</CODE>品質管理プログラム<CODE>_compareCallback</DT><DD></CODE>このルーチンは、要素を比較するために呼び出されます。 _pascalと宣言する必要があります。 次の場合は正の値を返します。<EM>*エル1</EM>前に来るべきである<EM>(注2)</EM>の場合は負の値<EM>*エル1</EM>後に来るべきである<EM>(注2)</EM>どちらが先でもよい場合は0を返します。</DD>
<DT><CODE>(注)</CODE>品質管理プログラム<CODE>_lockCallback</DT><DD></CODE>このルーチンは前に呼び出されます<CODE>ArrayQuickSort</CODE>任意の要素を検査または変更します。 _pascalと宣言する必要があります。 ロック・コールバック・ルーチンを呼び出す必要がないことを示すnull関数ポインタを渡すことができます。</DD>
<DT><CODE>(注)</CODE>品質管理プログラム<CODE>_lockCallback</DT><DD></CODE>このルーチンは<CODE>ArrayQuickSort</CODE>任意の要素を検査または変更します。 _pascalと宣言する必要があります。 ロック解除コールバックルーチンを呼び出す必要がないことを示すヌル関数ポインタを渡すことができます。</DD>
<DT>品質管理プログラム<CODE>_insertLimit</DT><DD></CODE>QSPより少ない場合<CODE>_insertLimit</CODE>サブリスト内の要素<CODE>ArrayQuickSort</CODE>は、クイックソートではなく、そのサブリストの挿入ソートを使用します。</DD>
<DT>品質管理プログラム<CODE>_medianLimit</DT><DD></CODE>QSPより少ない場合<CODE>_medianLimit</CODE>エレメントがサブリストにある場合、ArrayQuickSortはmedianエレメントを検索する代わりに、最初のエレメントをパーティションとして使用します。</DD>
</DIV>
<DIV>
          <A NAME="S_2f.htm_IX_RangeEnumCallbackParams"></A>
        </DL>
<H1 CLASS="refHeading">RangeEnumCallbackParams</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_2f.htm_IX_RangeEnumFlags"></A>
          <A NAME="S_2f.htm_IX_REF_&ldots;"></A>
        <H1 CLASS="refHeading">RangeEnumFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags RangeEnumFlags;#define REF_ALL_CELLS 0x80#define REF_NO_LOCK 0x40#define REF_COLUMN_FLAGS 0x20#define REP_MATCH_COLUMN_FLAGS 0x10#define REF_CELL_ALLOCATED 0x08#define REF_CELL_FREED 0x04#define REF_OTHER_ALLOC_OR_FREE 0x02#define REF_COLUMN_FLAGS_MODIFIED 0x01</PRE>
<P>これらのフラグは<CODE><A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_2f.htm_IX_RangeEnumParams"></A>
          <A NAME="S_2f.htm_IX_REP_&ldots;"></A>
        <H1 CLASS="refHeading">RangeEnumParams</H1>
<PRE CLASS="syntax">typedef struct{PCB(RANGE_ENUM_CALLBACK_RETURN_TYPE, REP_callback, (RangeEnumCallbackParams));</PRE>
<PRE CLASS="syntax">Rectangle REP_bounds;byte REP_columnFlags;word*REP_columnFlagsArray;CellFunctionParameters*REP_cfp;byte REP_matchFlags;word*REP_locals;}RangeEnumParams;</PRE>
<P>この構造体は、2つのルーチンで使用されます。<CODE><A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellGetExtent()">CellGetExtent()</A></CODE>によって使用される場合<CODE><A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>この構造体は<CODE><A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>が機能します。<CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellGetExtent()">CellGetExtent()</A></CODE>に空白が渡された場合<CODE>RangeEnumParams</CODE>構造体である。<CODE>REP境界</CODE>見出しページを開きます。</P>
<P>コールバックルーチンがある場合は、_pascalと宣言します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">セル.h</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_2f.htm_IX_RangeInsertParams"></A>
        <H1 CLASS="refHeading">RangeInsertParams</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_82.htm#IX_RangeInsert()">RangeInsert()</A></CODE>です。</P>
</DIV>
<DIV>
          <A NAME="S_2f.htm_IX_RangeSortError"></A>
          <A NAME="S_2f.htm_IX_RSE_&ldots;"></A>
        <H1 CLASS="refHeading">RangeSortError</H1>
<PRE CLASS="syntax">typedef enum/*word*/{RSE_NO_ERROR, RSE_UNABLE_TO_ALLOC, }RangeSortError;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_2f.htm_IX_RangeSortCellExistFlags"></A>
          <A NAME="S_2f.htm_IX_RSCEF_&ldots;"></A>
        <H1 CLASS="refHeading">RangeSortCellExistFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags RangeSortCellExistsFlags;#define RSCEF_SECOND_CELL_EXISTS 0x02#define RSCEF_FIRST_CELL_EXISTS 0x01</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_30.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_RangeSortFlags"></A>
          <A NAME="S_30.htm_IX_RSF_&ldots;"></A>
        <H1 CLASS="refHeading">RangeSortFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags RangeSortFlags;#define RSF_SORT_ROWS 0x80#define RSF_SORT_ASCENDING 0x40#define RSF_IGNORE_CASE 0x20</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_RangeSortParams"></A>
          <A NAME="S_30.htm_IX_RSP_&ldots;"></A>
        <H1 CLASS="refHeading">RangeSortParams</H1>
<PRE CLASS="syntax">typedef struct{Rectangle RSP_range;Point RSP_active;dword RSP_callback;byte RSP_flags;/*RangeSortFlags*/dword RSP_cfp;word RSP_sourceChunk;word RSP_destChunk;word RSP_base;dword RSP_lockedEntry;byte RSP_cachedFlags;}RangeSortParams;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_RecordHeader"></A>
        <H1 CLASS="refHeading">RecordHeader</H1>
<PRE CLASS="syntax">typedef struct{RecordID RH_id;word RH_size;byte RH_fieldCount;}フィールド;RecordHeader</PRE>
<P>レコードに関するメタデータを含む構造。最初<CODE>FieldHeader</CODE>が続きます。</P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_RecordID"></A>
        <H1 CLASS="refHeading">レコードID</H1>
<PRE CLASS="syntax">typedef dword RecordID;レコードID</PRE>
<P>データストア内のレコードを一意に識別します。この値は一定で、他のレコードが追加または削除されても変更されません。</P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_RecordNum"></A>
        <H1 CLASS="refHeading">RecordNum</H1>
<PRE CLASS="syntax">typedef dword RecordNum;</PRE>
<P>データストア内の相対位置を指定します。この値は、他のレコードが追加または削除されたときに変更される場合があります。</P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_Rectangle"></A>
          <A NAME="S_30.htm_IX_R_&ldots;"></A>
        <H1 CLASS="refHeading">長方形</H1>
<PRE CLASS="syntax">typedef struct{sword R_left;sword R_top;sword R_right;sword R_bottom;}長方形;</PRE>
<P>この構造は、グラフィックスの四角形を表します。</P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_RectDWord"></A>
          <A NAME="S_30.htm_IX_RD_&ldots;"></A>
        <H1 CLASS="refHeading">RectDWord</H1>
<PRE CLASS="syntax">typedef struct{sdword RD_left;sdword RD_top;sdword RD_right;sdword RD_bottom;}RectDWord;</PRE>
<P>この構造は、グラフィックスの四角形を表します。</P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_RectRegion"></A>
          <A NAME="S_30.htm_IX_RR_&ldots;"></A>
        <H1 CLASS="refHeading">RectRegion</H1>
<PRE CLASS="syntax">typedef struct{word RR_y1M1;word RR_eo1;/*EOREGREC*/word RR_y2;word RR_x1;word RR_x2;word RR_eo2;/*EOREGREC*/word RR_eo3;/*EOREGREC*/}RectRegion;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_RefElementHeader"></A>
          <A NAME="S_30.htm_IX_REH_refCount"></A>
        <H1 CLASS="refHeading">RefElementHeader</H1>
<PRE CLASS="syntax">typedef struct{WordAndAHalf REH_refCount;}RefElementHeader;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_Region"></A>
          <A NAME="S_30.htm_IX_EOREGREC"></A>
          <A NAME="S_30.htm_IX_EOREG_HIGH"></A>
        <H1 CLASS="refHeading">地域</H1>
<PRE CLASS="syntax">typedef word EOREGREC;#define region 0x8000#define EOREG_HIGH 0x80</PRE>
<P>この構造は、グラフィックス座標空間の領域を表します。</P>
<P>領域は、矩形状の配列で記述されます(したがって、ビットマップと類似しています)。 しかし、各ピクセルに対してオン/オフ値を指定する代わりに、領域は、その領域がかなり詳細ではなく、したがってデータ構造が疎な配列の方法で処理できると仮定する。 行の色の値が変化するセルのみが記録されます。 ここで注意が必要なのは、ある行が前の行と同じかどうかを判断するときには、システムは下から上に向かって作業するので、各行をその下の行と比較して、エントリが必要かどうかを判断する必要があるということです。</P>
<P>記述するのが最も簡単な領域はヌル領域で、これは値EOREGREC(名前がを表す定数)を持つ1つの単語で記述される特殊なケースです。<EM>エ</EM>次の日数<EM>レジ</EM>イオン<EM>認識</EM>ord値)。 非ヌル領域を記述するには、いくつかの数字が必要です。</P>
<P>領域記述の最初の4つの数字は、領域の境界を示します。 次に、1つまたは複数の一連の数値が表示されます。 各シリーズは行を記述し、その行のどのピクセルが領域の一部であるかを指定する。 記述する必要がある行は、下の行と異なる行だけです。 各行の説明の最初の番号は行番号です。<EM>イ</EM>座標。 各シリーズの最後の番号はEOREGRECという特別なトークンであり、これは記述の次の番号が別の行の始まりであることをカーネルに知らせます。 行番号とEOREGRECの間には、ピクセルがオンとオフを切り替える列番号があります。 行番号の後の最初の番号は、ピクセルがオンである最初の列に対応し、次の番号は、ピクセルがオフである最初の後続の列であり、以下同様である。</P>
</DIV>
<DIV>
          <A NAME="S_30.htm_IX_RegionFillRule"></A>
          <A NAME="S_30.htm_IX_ODD_EVEN (RegionFillRule type)"></A>
          <A NAME="S_30.htm_IX_WINDING (RegionFillRule type)"></A>
        <H1 CLASS="refHeading">RegionFillRule</H1>
<PRE CLASS="syntax">typedef ByteEnum RegionFillRule;#define ODD_EVEN 0#define WINDING 1</PRE>
<P>この列挙型は、パスまたは領域の塗りつぶし方法を決定します。 ワインディングフィルの方が用途は広いですが、パスまたはポリゴンのエッジが正しい方向を向いている必要があります。</P>
</DIV>
<HR>
          <A NAME="S_31.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_ReleaseNumber"></A>
          <A NAME="S_31.htm_IX_RN_&ldots;"></A>
        <H1 CLASS="refHeading">リリース番号</H1>
<PRE CLASS="syntax">typedef struct{word RN_major;word RN_minor;word RN_change;word RN_engineering;}リリース番号;</PRE>
<P>ファイル、ドキュメント、またはgeodeのバージョンを記録するために使用されます。 これはリリースレベルを表します。最も重要な数値は次のとおりです。<CODE>RN_メジャー</CODE>および<CODE>RN_マイナー</CODE>その他のフィールドは通常、製造元の内部でのみ使用されます。</P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_RGBColorAsDWord"></A>
          <A NAME="S_31.htm_IX_RGB_&ldots; () macros"></A>
        <H1 CLASS="refHeading">RGBColorAsDWord</H1>
<PRE CLASS="syntax">typedef dword RGBColorAsDWord;RGB_RED(val)(val&amp;0 xff)RGB_GREEN(val)((val>>8)&amp;0 xff)RGB_BLUE(val)((val>>16)&amp;0 xff)RGB_INDEX(val)((val>>24)&amp;0 xff)</PRE>
<P>詳細については<CODE>カラークアッド</CODE>フィールドの意味を見つけるためのデータ構造。</P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_RGBDelta"></A>
          <A NAME="S_31.htm_IX_RGBD_&ldots;"></A>
        <H1 CLASS="refHeading">RGBDelta</H1>
<PRE CLASS="syntax">typedef struct{byte RGBD_red;byte RGBD_green;byte RGBD_blue;}RGBDelta;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_RGBTransfer"></A>
          <A NAME="S_31.htm_IX_RGBT_&ldots;"></A>
        <H1 CLASS="refHeading">RGBTransfer</H1>
<PRE CLASS="syntax">typedef struct{byte RGBT_red[256];byte RGBT_green[256];byte RGBT_blue[256];}RGBTransfer;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_RGBValue"></A>
          <A NAME="S_31.htm_IX_RGB_&ldots;"></A>
        <H1 CLASS="refHeading">RGB値</H1>
<PRE CLASS="syntax">typedef struct{byte RGB_red;byte RGB_green;byte RGB_blue;}RGBValue;という文字列を返します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_SACAddress"></A>
        <H1 CLASS="refHeading">SACAddress</H1>
<PRE CLASS="syntax">typedef struct{word SACA_opaqueSize;/*label byte SACA_opaque;*//*user-readable form of address follows opaque address--*SACA_opaqueSizeを使用して、このデータへのオフセットを計算します。 */}SACAddress</PRE>
<P>SocketAddressControlは<CODE>SACAddress</CODE>構造体を使ってアドレスに関する情報を提供する。</P>
<P>ほとんどのプログラムは、この構造体の内部を見る必要はありません。<CODE><A HREF="../../CRef/Routines/R_8a.htm#IX_SocketResolve()">SocketResolve()</A></CODE>アドレスが有効であることを確認し、それをプリミティブ形式に変換します。</P>
<P>しかし、もしあなたが「生の」アドレスを構築して<CODE><A HREF="../../CRef/Routines/R_8a.htm#IX_SocketResolve()">SocketResolve()</A></CODE>不透明なアドレス情報の構造を知る必要があります。 これは<CODE>ExtendedSACAddress</CODE>バッファの後にNULLで終端されたユーザが読める接続アドレス文字列が続く。</P>
<P>の<CODE>ExtendedSACAddress</CODE>バッファは、次のもので構成され</P>
<UL>
<LI>オプションのリンク情報のサイズを示すワード(リンク情報がない場合はゼロ)。</LI>
<LI>リンク情報。<CODE>リンクの種類</CODE>値(LT_ADDR、LT_ID、またはLT_DEFAULTのいずれか)、およびリンクを識別するパラメータです。 次の場合<CODE>リンクの種類</CODE>がLT_DEFAULTの場合、それ以上のパラメータはありません。 次の場合<CODE>リンクの種類</CODE>がLT_IDの場合、単語長が存在する<CODE>リンクID(LinkID)</CODE>これは、リンクの永続的な識別子として機能します。 次の場合<CODE>リンクの種類</CODE>がLT_ADDRの場合、パラメータは、ユーザが読み取り可能な接続アドレス文字列に追加される文字列で、括弧で囲まれます。</LI>
</UL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">サックゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_SampleFormat"></A>
          <A NAME="S_31.htm_IX_SMID_&ldots;  (SampleFormat structure)"></A>
        <H1 CLASS="refHeading">SampleFormat</H1>
<PRE CLASS="syntax">typedef struct{DACSampleFormat SMID_format:15;DACReferenceByte SMID_reference:1;}SampleFormat;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_SampleFormatDescription"></A>
          <A NAME="S_31.htm_IX_SFD_&ldots;"></A>
        <H1 CLASS="refHeading">SampleFormatDescription</H1>
<PRE CLASS="syntax">typedef struct{word SFD_manufacte;word SFD_format;word SFD_rate;word SFD_playFlags;}SampleFormatDescription;</PRE>
<P>この構造体は、サンプリングされたサウンドのヘッダーとして機能し、サウンドデータを適切に解釈するために必要なフォーマット情報を提供します。</P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_SansFace"></A>
          <A NAME="S_31.htm_IX_SF_A_&ldots;"></A>
        <H1 CLASS="refHeading">SansFace</H1>
<PRE CLASS="syntax">typedefバイトSansFace;#define SF_A_CLOSED 0x0080#define SF_A_OPEN 0x0000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_sbyte"></A>
        <H1 CLASS="refHeading">sバイト</H1>
<PRE CLASS="syntax">typedef char sbyte;と入力します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_31.htm_IX_ScannerToken"></A>
          <A NAME="S_31.htm_IX_ST_&ldots;"></A>
        <H1 CLASS="refHeading">ScannerToken</H1>
<PRE CLASS="syntax">typedef struct{ScannerTokenType ST_type;ScannerTokenData ST_data;}ScannerToken;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_32.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_ScannerTokenCellData"></A>
          <A NAME="S_32.htm_IX_STCD_cellRef"></A>
        <H1 CLASS="refHeading">ScannerTokenCellData</H1>
<PRE CLASS="syntax">typedef struct{CellReference STCD_cellRef;}ScannerTokenCellData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_ScannerTokenData"></A>
          <A NAME="S_32.htm_IX_STD_&ldots;"></A>
        <H1 CLASS="refHeading">ScannerTokenData</H1>
<PRE CLASS="syntax">typedef union{ScannerTokenNumberData STD_number;ScannerTokenStringData STD_string;ScannerTokenCellData STD_cell;ScannerTokenIdentifierData STD_identifier;ScannerTokenOperatorData STD_operator;}ScannerTokenData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_ScannerTokenIdentifierData"></A>
          <A NAME="S_32.htm_IX_STID_start"></A>
        <H1 CLASS="refHeading">ScannerTokenIdentifierData</H1>
<PRE CLASS="syntax">typedef struct{word STID_start;}ScannerTokenIdentifierData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_ScannerTokenNumberData"></A>
          <A NAME="S_32.htm_IX_STND_value"></A>
        <H1 CLASS="refHeading">ScannerTokenNumberData</H1>
<PRE CLASS="syntax">typedef struct{FloatNum STND_value;}ScannerTokenNumberData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_ScannerTokenOperatorData"></A>
          <A NAME="S_32.htm_IX_STOD_operatorID"></A>
        <H1 CLASS="refHeading">ScannerTokenOperatorData</H1>
<PRE CLASS="syntax">typedef struct{OperatorType STOD_operatorID;}ScannerTokenOperatorData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_ScannerTokenStringData"></A>
          <A NAME="S_32.htm_IX_STSD_&ldots;"></A>
        <H1 CLASS="refHeading">ScannerTokenStringData</H1>
<PRE CLASS="syntax">typedef struct{word STSD_start;word STSD_length;}ScannerTokenStringData;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_ScannerTokenType"></A>
          <A NAME="S_32.htm_IX_SCANNER_TOKEN_&ldots;"></A>
        <H1 CLASS="refHeading">ScannerTokenType</H1>
<PRE CLASS="syntax">typedef ByteEnum ScannerTokenType;#define SCANNER_TOKEN_NUMBER 0#define SCANNER_TOKEN_STRING 1#define SCANNER_TOKEN_CELL 2#define SCANNER_TOKEN_END_OF_EXPRESSION 3#define SCANNER_TOKEN_OPEN_PAREN 4#define SCANNER_TOKEN_CLOSE_PAREN 5#define SCANNER_TOKEN_IDENTIFIER 6#define SCANNER_TOKEN_OPERATOR 7#define SCANNER_TOKEN_LIST_SEPARATOR 8</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_ScriptAttrAsWord"></A>
        <H1 CLASS="refHeading">ScriptAttrAsWord</H1>
<PRE CLASS="syntax">typedef word ScriptAttrAsWord;/*ハイバイトは、フォントサイズの一部としての垂直オフセットです。 下位バイトは、使用する小数点以下の桁数です。</PRE>
<PRE CLASS="syntax">したがって、添字attrを0x8020に設定すると、添字文字は1/4の標準サイズで1行下に印刷されます。 (注)</PRE>
<P>この構造体は、下付き文字と上付き文字が描画するオフセットとスケール係数を指定します。</P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_ScriptFace"></A>
          <A NAME="S_32.htm_IX_SF_&ldots;  (ScriptFace)"></A>
        <H1 CLASS="refHeading">ScriptFace</H1>
<PRE CLASS="syntax">typedefバイトScriptFace;#define SF_CURSIVE 0x0080#define SF_CALLIGRAPHIC IC 0x0000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_sdword"></A>
        <H1 CLASS="refHeading">sdword</H1>
<PRE CLASS="syntax">typedef long sdword</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_SearchFlags"></A>
        <H1 CLASS="refHeading">検索フラグ</H1>
<PRE CLASS="syntax">typedef ByteFlags SearchFlags;#define SF_BACKWARDS 0x80#define SF_START_AT_END 0x40#define SF_IGNORE_CASE 0x20#define SF_NO_WILDCARDS 0x10#define SF_PARTIAL_WORD 0x08</PRE>
<P>検索パラメータを定義するフラグ。を参照してください。<CODE>SearchParams</CODE>および<CODE><A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreStringSearch()">DataStoreStringSearch()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_SearchParams"></A>
        <H1 CLASS="refHeading">SearchParams</H1>
<PRE CLASS="syntax">typedef struct{searchType SP_searchType;dword SP_maxRecords;FieldID SP_startField;FieldCategory SP_category;TCHAR*SP_searchString;SearchFlags SP_flags;}SearchParams;</PRE>
<P>呼び出し時に検索条件を指定するための構造<CODE><A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreStringSearch()">DataStoreStringSearch()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_SearchType"></A>
          </A>
        <H1 CLASS="refHeading">検索タイプ</H1>
<PRE CLASS="syntax">typedef ST SearchType;#define ByteEnum_ALL 1/*すべての文字列フィールドを検索*/#define ST_FIELD 2/*FieldIDで検索*/#define ST_CATEGORY 3/*FieldCategoryで検索*/</PRE>
<P>検索パラメータで指定する値。を参照してください。<CODE>SearchParams</CODE>および<CODE><A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreStringSearch()">DataStoreStringSearch()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_segment"></A>
        <H1 CLASS="refHeading">分節</H1>
<PRE CLASS="syntax">typedefの単語セグメント</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_32.htm_IX_SemaphoreError"></A>
          <A NAME="S_32.htm_IX_SE_&ldots;"></A>
        <H1 CLASS="refHeading">SemaphoreError</H1>
<PRE CLASS="syntax">typedef enum{SE_NO_ERROR, /*エラーは発生しませんでした*/SE_TIMEOUT, /*セマフォが*スレッドに取り込まれる前にタイムアウトしました*/</PRE>
<PRE CLASS="syntax">SE_PREVIOUS_OWNER_DIED/*セマフォーの現在の所有者が*異常終了しました*/</PRE>
<PRE CLASS="syntax">}SemaphoreError;</PRE>
<P>セマフォーおよびスレッドロックルーチンで発生したエラーを判別します。<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE>および<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>ボタンをクリックし</P>
<DL>
<DT>SE_NO_エラー</DT><DD>エラーは発生せず、セマフォーは正しく捕捉されました。</DD>
<DT>SE_タイムアウト</DT><DD>時間が経過しましたが、セマフォは捕捉されませんでした。 この値が返された場合、スレッドは<EM>しない</EM>保護された操作が発生した場合は、それを続行します。 代わりに、もう一度セマフォーの取得を試みるか、他のタスクを続行する必要があります。</DD>
<DT>SE_PREVIOUS_OWNER_DEAD SE_PREVIOUS_OWNER_</DT><DD>セマフォーの前の所有者が異常終了しました。 例えば、現在セマフォーを保持しているスレッドが、セマフォーを解放せずに終了した場合、これが返されます。</DD>
</DIV>
</DL>
<HR>
          <A NAME="S_33.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_33.htm_IX_SerialBaud"></A>
          <A NAME="S_33.htm_IX_SERIAL_BAUD_&ldots;"></A>
        <H1 CLASS="refHeading">SerialBaud</H1>
<PRE CLASS="syntax">typedef enum{SERIAL_BAUD_115200=1, SERIAL_BAUD_57600=2, SERIAL_BAUD_38400=3, SERIAL_BAUD_19200=6, SERIAL_BAUD_14400=8, SERIAL_BAUD_9600=12, SERIAL_BAUD_7200=16, SERIAL_BAUD_4800=24, SERIAL_BAUD_3600=32, SERIAL_BAUD_2400=48, SERIAL_BAUD_2000=58, SERIAL_BAUD_1800=64, SERIAL_BAUD_1200=96, SERIAL_BAUD_600=192, SERIAL_BAUD_300=384}SerialBaud;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_33.htm_IX_SerialFormat"></A>
          <A NAME="S_33.htm_IX_SERIAL_FORMAT_&ldots;"></A>
        <H1 CLASS="refHeading">SerialFormat</H1>
<PRE CLASS="syntax">typedef ByteFlags SerialFormat;#define SERIAL_FORMAT_DLAB_OFFSET(7)#define SERIAL_FORMAT_DLAB(0x01&lt;&lt;SERIAL_FORMAT_DLAB_OFFSET)#define SERIAL_FORMAT_BREAK_OFFSET(6)#define SERIAL_FORMAT_BREAK(0x01&lt;&lt;SERIAL_FORMAT_BREAK_OFFSET)#define SERIAL_FORMAT_PARITY_OFFSET(3)#define SERIAL_FORMAT_PARITY(0x07&lt;&lt;SERIAL_FORMAT_PARITY_OFFSET)#define SERIAL_FORMAT_EXTRA_STOP_OFFSET(2)#define SERIAL_FORMAT_EXTRA_STOP(0x01&lt;&lt;\SERIAL_FORMAT_EXTRA_STOP_OFFSET)</PRE>
<PRE CLASS="syntax">#define SERIAL_FORMAT_LENGTH_OFFSET(0)#define SERIAL_FORMAT_LENGTH(0x03&lt;&lt;SERIAL_FORMAT_LENGTH_OFFSET)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_33.htm_IX_SerialMode"></A>
          <A NAME="S_33.htm_IX_SM_&ldots;"></A>
        <H1 CLASS="refHeading">SerialMode</H1>
<PRE CLASS="syntax">typedef enum{SM_RAW, SM_RARE, SM_COOKED}SerialMode;</PRE>
<P> </P>
</DIV>
<DIV>#define SERIAL_MODEM_RTS(0x01&lt;&lt;SERIAL_MODEM_RTS_OFFSET)と入力します。<A NAME="S_33.htm_IX_SerialModem"></A><A NAME="S_33.htm_IX_SMC_&ldots;"></A><A NAME="S_33.htm_IX_SERIAL_MODEM_&ldots;"></A><H1 CLASS="refHeading">SerialModem</H1>
<PRE CLASS="syntax">typedef ByteFlags SerialModem;#define SMC_RTS 0x02/*Request-To-Send(1がアサート)*/#define SMC_DTR 0x01/*Data-Terminal Ready(1がアサート)*/#define SERIAL_MODEM_RTS_OFFSET(1)#define SERIAL_MODEM_DTR_OFFSET(0)#define SERIAL_MODEM_DTR(0x01&lt;&lt;SERIAL_MODEM_DTR_OFFSET)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_33.htm_IX_SerialPortNum"></A>
          <A NAME="S_33.htm_IX_SERIAL_COM&ldots;"></A>
        <H1 CLASS="refHeading">SerialPortNum</H1>
<PRE CLASS="syntax">typedef enum{SERIAL_COM1=0, SERIAL_COM2=2, SERIAL_COM3=4, SERIAL_COM4=6, SERIAL_COM5=8, SERIAL_COM6=10, SERIAL_COM7=12, SERIAL_COM8=14}SerialPortNum;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_33.htm_IX_SemaphoreHandle"></A>
        <H1 CLASS="refHeading">SemaphoreHandle</H1>
<PRE CLASS="syntax">typedefハンドルSemaphoreHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_33.htm_IX_SerifFace"></A>
          <A NAME="S_33.htm_IX_SF_&ldots;  (SerifFace)"></A>
        <H1 CLASS="refHeading">SerifFace</H1>
<PRE CLASS="syntax">typedefバイトSerifFace;#define SF_SLAB 0x00c0#define SF_MODERN 0x0080#define SF_TRANS 0x0040#define SF_OLD 0x0000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_33.htm_IX_SetPalType"></A>
          <A NAME="S_33.htm_IX_SPT_&ldots;  (SetPalType type)"></A>
        <H1 CLASS="refHeading">SetPalType</H1>
<PRE CLASS="syntax">typedef ByteEnum SetPalType;#define SPT_DEFAULT 0#define SPT_CUSTOM 1</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_33.htm_IX_ShiftState"></A>
          <A NAME="S_33.htm_IX_SS_&ldots;  (ShiftState)"></A>
        <H1 CLASS="refHeading">ShiftState</H1>
<PRE CLASS="syntax">typedef ByteFlags ShiftState;#define SS_LALT 0x80#define SS_RALT 0x40#define SS_LCTRL 0x20#define SS_RCTRL 0x10#define SS_LSHIFT 0x08#define SS_RSHIFT 0x04#define SS_FIRE_BUTTON_1 0x02#define SS_FIRE_BUTTON_2 0x01</PRE>
<P>入力情報に組み込まれる修飾子。 Altキー、Ctrlキー、Shiftキー、または特殊なシステム修飾キーに対応します。 これらのビットは、まだ考慮されていない場合にのみ設定されることに注意してください。つまり、文字「E」が渡された場合、この構造体のシフト修飾子はマークされません。</P>
</DIV>
<HR>
          <A NAME="S_34.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_34.htm_IX_Socket"></A>
        <H1 CLASS="refHeading">ソケット</H1>
<PRE CLASS="syntax">typedef wordソケット;</PRE>
<P>ソケットは、ソケットライブラリによって管理される通信の一方の側を表します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_34.htm_IX_SocketAddress"></A>
          <A NAME="S_34.htm_IX_SA_&ldots;"></A>
        <H1 CLASS="refHeading">ソケットアドレス</H1>
<PRE CLASS="syntax">typedef struct{domain SA_port;word SA_domainSize;/*SA_domainバッファのサイズ(バイト単位)*/char*SA_domain;/*nullで終端されたSocketPort名*/word SA_addressSize;/*アドレスデータのサイズ(バイト単位)*/}SocketAddress;</PRE>
<P>アドレスは、ポート番号、ドメイン、およびアドレスデータで構成されます。</P>
<DL>
<DT>
          <STRONG>SAポート(_P)</STRONG>
        </DT><DD>ポート番号は、マシン内の特定の通信回線を識別します。 ポート番号は、ドメインに応じて32ビットまたは16ビットになります。 これらは<CODE>SocketPort</CODE>構造。</DD>
<DT><STRONG>SAドメイン</STRONG><STRONG>SA_ドメインサイズ</DT><DD></STRONG>ドメインは、アドレス指定されたマシンに到達するためのネットワークのプロトコルを識別します。 ドメインは文字列で指定します。<CODE>SAドメイン</CODE>はNULL終端されたドメイン名文字列へのポインタであり<CODE>SA_ドメインサイズ</CODE>は、ドメイン名文字列を含むバッファのサイズです。</DD>
<DT></DT><DD>一部のルーチンには空の<CODE>ソケットアドレス</CODE>構造。 これは、SA_domainに対してメモリーを割り振り<CODE>SAドメイン</CODE>および<CODE>SA_ドメインサイズ</CODE>ボタンをクリックし</DD>
<DT><STRONG>SA_addressSize</STRONG><STRONG>アドレスデータ</DT><DD></STRONG>ドメイン内のマシンを識別するために使用されるアドレスデータの形式は、そのドメインによって異なります。 の<CODE>SA_addressSize</CODE>フィールドには、アドレスデータのサイズが入ります。 アドレスデータを含むバッファは<CODE>ソケットアドレス</CODE>構造。</DD>
<DT></DT><DD>一部のルーチンには空の<CODE>ソケットアドレス</CODE>構造。 つまり、構造体の後にアドレスデータ用の領域を残し<CODE>SA_addressSize</CODE>見出しページを開きます。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_34.htm_IX_SocketBindFlags"></A>
          <A NAME="S_34.htm_IX_SBF_REUSE_PORT"></A>
        <H1 CLASS="refHeading">SocketBindFlags</H1>
<PRE CLASS="syntax">typedef WordFlags SocketBindFlags;#define SBF_REUSE_PORT(0x8000)</PRE>
<P>これらのフラグは、ソケットをポートにバインドするときにオプションを指定するために使用されます。</P>
<P>フラグはSBF_REUSE_PORTのみで、別のソケットがすでにポートにバインドされている場合でも、そのソケットをポートにバインドすることを要求します。 このフラグはデータグラムソケットでは使用できません。</P>
</DIV>
<DIV>
          <A NAME="S_34.htm_IX_SocketCheckRequest"></A>
          <A NAME="S_34.htm_IX_SocketCondition"></A>
          <A NAME="S_34.htm_IX_SCR_&ldots;"></A>
          <A NAME="S_34.htm_IX_SC_&ldots;"></A>
        <H1 CLASS="refHeading">SocketCheckRequest</H1>
<PRE CLASS="syntax">typedef struct{word SCR_socket;SocketCondition SCR_condition;byte SCR_reserved;}SocketCheckRequest;typedef ByteEnum SocketCondition;#define SC_READ 0x0/*データが到着しました*/#define SC_WRITE 0x1/*データを書き込むことができます*/#define SC_ACCEPT 0x2/*接続要求が到着しました*/#define SC_EXCEPTION 0x3/*例外が発生しました*/#define SC_URGENT 0x4/*緊急データが到着しました*/</PRE>
<P>ア<CODE>SocketCheckRequest</CODE>は、何らかの操作を実行する準備ができているかどうかをソケットに問い合わせるために使用されます。 次の2つのフィールドを設定する必要があります。</P>
<DL>
<DT>
          <STRONG>SCRソケット</STRONG>
        </DT><DD>照会するソケット。</DD>
<DT><STRONG>SCR条件</DT><DD></STRONG>照会する操作です。</DD>
</DL>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_34.htm_IX_SocketCondition"></A>
        <H1 CLASS="refHeading">SocketCondition</H1>
<P>詳細については<CODE>SocketCheckRequest</CODE>ボタンをクリックし</P>
</DIV>
<DIV>typedef ByteEnum<A NAME="S_34.htm_IX_SocketDeliveryType"></A><A NAME="S_34.htm_IX_SDT_&ldots;"></A><H1 CLASS="refHeading">SocketDeliveryType</H1>
<PRE CLASS="syntax">SocketDeliveryType;#define SDT_DATAGRAM 0x0/*信頼できないパケット*/#define SDT_SEQ_PACKET 0x1/*信頼できるパケット*/#define SDT_STREAM 0x2/*信頼できるバイト*/</PRE>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<HR>
          <A NAME="S_35.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_35.htm_IX_SocketError"></A>
        <H1 CLASS="refHeading">SocketError</H1>
<PRE CLASS="syntax">typedef enum{SE_NORMAL=0x0, /*operation completed successfully*/SE_OUT_OF_MEMORY, /**the net library was unable to allocate memory*either there no more system memory available, or a net-library*specific upper bound on memory usage has been exceeded*/SE_PORT_IN_USE, /**Another socket is already bound to this port, and the*SBF_REUSE_PORT flag was not set.(typedef enum{SE_NORMAL=0x0, /*操作が正常に完了しました*/SE_OUT_OF_MEMORY, /**ネットライブラリがメモリを */SE_PORT_ALREADY_LISTENING, /*別のソケットがすでにこのポートをリッスンしています。 */SE_SOCKET_IN_USE, /**ソケットはすでに*要求された操作と矛盾する方法で使用されています*/SE_SOCKET_ALREADY_BOUND, /*ソケットはすでにポートにバインドされています。 */SE_SOCKET_NOT_BOUND, /*要求された操作を行うには、ソケットをポートにバインドする必要があります。 */SE_SOCKET_NOT_LISTENING, /*ソケットは要求された操作のためにポートをリッスンしている必要があります。 */SE_SOCKET_LISTENING, /*リスニングソケットは発信接続に使用できません*/SE_CONNECTION_REFUSED, /*誰もリモートポートでリスニングしていません。 */SE_CONNECTION_FAILED, /*おそらくリンク障害が原因で、接続が無効になっています。 */SE_CONNECTION_CLOSED, /*接続はもう一方の端から閉じられました。 */SE_NON_UNIQUE_CONNECTION, /*同じエンドポイントアドレスとポートを持つ別の接続が存在します。 */SE_TIMED_OUT, /**操作が完了する前にタイムアウト時間が経過しました。 *場合によっては、プロトコルはユーザが指定した値よりも短いタイムアウトを強制することがあるので、*SOCKET_NO_TIMEOUTが使用されている場合でもこれは可能です。 */SE_CANT_LOAD_DRIVER, /*接続の確立に必要なドライバを*ロードできませんでした。 */SE_UNKNOWN_DOMAIN, /*要求されたドメインがライブラリーに認識されていません。 */SE_SYSTEM_SHUTDOWN, /*GEOSが終了しているため、操作は中止されました*/SE_SOCKET_NOT_CONNECTED, /*操作には接続されたソケットが必要です*/SE_SOCKET_ALREADY_CLOSED, /*ソケットの送信側はすでに閉じられています*/SE_SOCKET_BUSY, /*別のスレッドがソケット上で動作しています*/SE_IMPROPER_CONDITION, /**要求されたSocketCheckReadyの条件が*現在の状態のソケットに対して有効ではありません*/SE_INFO_NOT_AVAILABLE, /*ドライバは要求された情報を提供できません*/SE_DOMAIN_REQUIRES_16 BIT_PORTS, /**要求されたドメインには16ビットのポート番号しか使用できません *SP_manufフィールドはMANUFACTURER_ID_SOCKET_16 BIT_PORTに設定する必要があります*/SE_CONNECTION_ERROR, /**接続は何らかの理由で確立されませんでした。接続には*固有のSocketError*/SE_MEDIUM_BUSY, /*接続に必要なメディアが使用できません*/SE_DESTINATION_UNREACHABLE, /*要求された接続先が使用できません*/SE_LINK_FAILED, /**この接続に使用された低レベルリンクが失敗したか、*確立できませんでした*/SE_INTERNAL_ERROR, /**ソケットライブラリがドライバから不可能なエラーコードを受信しました。 *ライブラリまたはドライバにバグがあります。 */SE_CLOSE_SEND_NOT_SUPPORTED, /**このドメインのソケットの送信側だけを閉じることはできません*。 代わりにSocketCloseを使ってください。 */SE_BIND_CONFLICT, /**同じポートにドメイン制限ありとドメイン制限なしの両方のバインディングを設定することはできません。 */SE_ALL_PORTS_BUSY, /**SocketConnectはソケットを暗黙的にバインドしようとしましたが、*暗黙的バインドで使用された範囲内のすべてのポート番号が使用中であったために失敗しました*/SE_SOCKET_NOT_INTERRUPTIBLE, /**中断できない操作が*ソケットで進行中です*/SE_INTERRUPT, /*操作はSocketInterruptで中断されました*/SE_PORT_NOT_LISTENING, /*このポートにはリスニングソケットまたはLoadOnMsg要求が存在しません*/SE_LISTEN_QUEUE_EMPTY, /*このポートに保留中の接続はありません*/SE_SOCKET_CLOSED, /*ソケットは*SocketGetSocketNameまたはSocketGetPeerNameのいずれかを呼び出すために送信するために開いている必要があります*/SE_BUFFER_TOO_SMALL, /*解決された*アドレスのバッファが小さすぎることを意味するためにSocketResolveによって返されました*/SE_TEMPORARY_ERROR, /*アドレス解決が*外部の理由(*ネットワークのダウンまたはサーバの障害など)で一時的に利用できないことを示すためにSocketResolveによって返されました*/SE_EXCEPTION, SE_URGENT=SE_EXCEPTION, /*何らかの緊急データが*信頼できるソケットに到着したことを示すためにSocketRecvによって返されました、または*データグラムソケットに対して例外が受信されました*/SE_NOT_IMPLEMENTED, /*まだ実装されていないAPI関数によって返されました*/SE_CONNECTION_RESET/*ソケットはその所有スレッドが終了したときに解放されるためSocketCloseDomainMedium */}SocketError</PRE>
<P>特定のソケットルーチンは、特定の条件下でエラー値を生成するか、スレッドエラーを生成します。 エラー値は、ワード長の値で構成されます。<CODE>SocketError</CODE>値、そしておそらく<CODE>SpecSocketDrError</CODE>値を上位バイトに格納する。</P>
</DIV>
<HR>
          <A NAME="S_36.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_36.htm_IX_SocketLoadType"></A>
          <A NAME="S_36.htm_IX_SLT_&ldots;"></A>
        <H1 CLASS="refHeading">SocketLoadType</H1>
<PRE CLASS="syntax">typedef enum{SLT_USER_LOAD_APPLICATION=0x0, SLT_GEODE_LOAD, }SocketLoadType;</PRE>
<P>ソケットライブラリには、ポートに着信するパケットを検知したときにアプリケーションをロードする機能があります。 ここでは<CODE>SocketLoadType</CODE>を使用して、アプリケーションのロード方法を決定します。<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>または<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_36.htm_IX_SocketOption"></A>
        <H1 CLASS="refHeading">SocketOption</H1>
<PRE CLASS="syntax">typedef enum{SO_RECV_BUF=0x0, /*受信バッファサイズ*/SO_SEND_BUF=0x2, /*送信バッファサイズ*/SO_INLINE=0x4, /*インライン緊急データ*/SO_NODELAY=0x6, /*直ちにデータを送信*/SO_OWNER=0x8, /*どのアプリがソケットを所有しているか*/}SocketOption;</PRE>
<P>さまざまなオプションがあります。これらのオプションは<CODE><A HREF="../../CRef/Routines/R_8a.htm#IX_SocketSetIntSocketOption()">SocketSetIntSocketOption()</A></CODE>ルーチン。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_36.htm_IX_SocketPort"></A>
          <A NAME="S_36.htm_IX_SP_&ldots;"></A>
        <H1 CLASS="refHeading">SocketPort</H1>
<PRE CLASS="syntax">typedef struct{word SP_port;/*16ビットポート番号*/ManufacturerID SP_manuf;/*16ビット製造者ID*/}SocketPort;</PRE>
<P>ポート番号は、マシン内の特定の通信回線を識別します。 ポート番号は、ドメインに応じて32ビットまたは16ビットになります。 これらは<CODE>SocketPort</CODE>16ビットで構成される構造<CODE>製造者ID</CODE>16ビットのトークン番号です。 ドメインが16ビットのソケット番号を使用する場合は、MANUFACTURER_ID_SOCKET_16 BIT_PORTを<CODE>製造者ID</CODE>ドメインで32ビットソケット番号が許可されている場合は、MANUFACTURER_ID_SOCKET_16 BIT_PORTなどを使用できます。<CODE>製造者ID</CODE>ボタンをクリックし</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_36.htm_IX_SocketRecvFlags"></A>
          <A NAME="S_36.htm_IX_SRF_&ldots;"></A>
        <H1 CLASS="refHeading">SocketRecvFlags</H1>
<PRE CLASS="syntax">typedef WordFlags SocketRecvFlags;#define SRF_ADDRESS(0x8000)/*データの送信元アドレスを返す*/#define SRF_URGENT(0x4000)/*緊急データがある場合は返す*/#define SRF_PEEK(0x2000)/*ソケットにデータを残す*/</PRE>
<P>これらのフラグを使用して、ソケットからデータを受信するときのオプションを設定できます。 SRF_ADDRESSは、データを送信するマシンのアドレスを要求します。 SRF_URGENTは、緊急データのみを戻すように要求します(緊急データがある場合)。 SRF_PEEKは、データをソケットに残すように要求します。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_36.htm_IX_SocketSendFlags"></A>
          <A NAME="S_36.htm_IX_SSF_&ldots;"></A>
        <H1 CLASS="refHeading">SocketSendFlags</H1>
<PRE CLASS="syntax">typedef WordFlags SocketSendFlags;#define SSF_ADDRESS(0x8000)/*アドレスが指定されています*/#define SSF_URGENT(0x4000)/*これは緊急データです*/#define SSF_OPEN_LINK(0x2000)/*このデータグラムは、*リンクが閉じている場合、リンクを開く必要があります*/</PRE>
<P>この構造体を使用して、ソケット経由でデータを送信するときのオプションを指定します。 アドレスを指定していることや、送信されたパケットに緊急のマークを付ける必要があることを示す場合があります。</P>
<P CLASS="refField">
          <STRONG>次を含む:</STRONG>
          <STRONG CLASS="fileName">ソケット・ゴー</STRONG>
        </P>
</DIV>
<DIV>
          <A NAME="S_36.htm_IX_SortOrder"></A>
        <H1 CLASS="refHeading">ソート順</H1>
<PRE CLASS="syntax">typedef ByteEnum SortOrder;#define SO_ASCENDING 0#define SO_DESCENDING 1</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_36.htm_IX_SoundDriverCapability"></A>
          <A NAME="S_36.htm_IX_SDC_&ldots;"></A>
          <A NAME="S_36.htm_IX_SoundDriverNoiseCapability"></A>
          <A NAME="S_36.htm_IX_SDNC_&ldots;"></A>
          <A NAME="S_36.htm_IX_SoundDriverWaveFormCapability"></A>
          <A NAME="S_36.htm_IX_SDWFC_&ldots;"></A>
          <A NAME="S_36.htm_IX_SoundDriverTimbreCapability"></A>
          <A NAME="S_36.htm_IX_SDTC_&ldots;"></A>
          <A NAME="S_36.htm_IX_SoundDriverEnvelopeCapability"></A>
          <A NAME="S_36.htm_IX_SDEC_&ldots;"></A>
        <H1 CLASS="refHeading">SoundDriverCapability</H1>
<PRE CLASS="syntax">typedef WordFlags SoundDriverCapability;#define SDC_NOISE 0x8000#define SDC_WAVEFORM 0x6000#define SDC_TIMBRE 0x1800#define SDC_ENVELOPE 0x0600 typedef WordFlags SoundDriverNoiseCapability;#define SDNC_NO_NOISE 0x0000#define SDNC_WHITE_NOISE 0x8000 typedef WordFlags SoundDriverWaveFormCapability#define SDWFC_NONE 0x0000#define SDWFC_SELECT 0x2000#define SDWFC_GENERATE 0x4000 typedef WordFlags SoundDriverTimbreCapability;#define SDTC_TONE_GENERATOR 0x0000#define SDTC_ADDITIVE 0x0800#define SDTC_MODULATOR 0x1000#define SDTC_SELECTIVE 0x1800 typedef WordFlags SoundDriverEnvelopeCapability;#define SDEC_NONE 0x0000#define SDEC_ADSR 0x0200#define SDEC_DSP 0x0400</PRE>
<P>これらのフィールドは、サウンドドライバが音楽合成に関して何ができるかについての情報をエンコードする。</P>
</DIV>
<HR>
          <A NAME="S_37.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_37.htm_IX_SoundPlayFlags"></A>
          <A NAME="S_37.htm_IX_SPF_HIGH_PRIORITY"></A>
        <H1 CLASS="refHeading">SoundPlayFlags</H1>
<PRE CLASS="syntax">typedef WordFlags SoundPlayFlags;#define SPF_HIGH_PRIORITY 0x8000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_37.htm_IX_SoundPriority"></A>
          <A NAME="S_37.htm_IX_SP_&ldots;  (SoundPriority type)"></A>
        <H1 CLASS="refHeading">SoundPriority</H1>
<PRE CLASS="syntax">typedef enum{SP_SYSTEM_LEVEL=10, /*最も緊急性が高い*/SP_ALARM=20, SP_STANDARD=30, SP_GAME=40, SP_BACKGROUND=50/*最も緊急性が低い*/}SoundPriority;#define SP_IMMEDIATE-1#define SP_THEME+1</PRE>
<P>ユーザーのサウンドデバイスが要求されたサウンドをすべて再生できない場合は<CODE>SoundPriority</CODE>どの音が最も重要であるかを決定するための値。</P>
<P>これらの値を使用して作成できる最も優先度の高いサウンドは、(SP_SYSTME_LEVEL+SP_IMMEDIATE)です。 最も優先度の低いサウンドは、(SP_BACKGROUND+SP_THEME)です。</P>
</DIV>
<DIV>
          <A NAME="S_37.htm_IX_SoundStreamDeltaTimeType"></A>
          <A NAME="S_37.htm_IX_SSDTT_&ldots;"></A>
          <A NAME="S_37.htm_IX_Delta&ldots; () macros"></A>
        <H1 CLASS="refHeading">SoundStreamDeltaTimeType</H1>
<PRE CLASS="syntax">typedef enum{SSDTT_MSEC=8, /*Nミリ秒間待機*/SSDTT_TICKS=10, /*Nティック間待機*/SSDTT_TEMPO=12, /*N拍間待機*/}SoundStreamDeltaTimeType;/*以下のマクロは音楽バッファを構築するのに役立ちます*/#define DeltaTick(time)SSDTT_TICKS, time#define DeltaMS(time)SSDTT_MSEC, time#define DeltaTempo(time)SSDTT_TEMPO, time</PRE>
<P>サウンドの継続時間を指定する単位は、ミリ秒、タイマーの「ティック」(1/60秒ごと)、または独立して指定されたテンポです。</P>
</DIV>
<DIV>
          <A NAME="S_37.htm_IX_SoundStreamEvents"></A>
          <A NAME="S_37.htm_IX_SSE_&ldots;"></A>
        <H1 CLASS="refHeading">SoundStreamEvents</H1>
<PRE CLASS="syntax">typedef enum{SSE_VOICE_ON=0, /*音声イベントをオンにする*/SSE_VOICE_OFF=2, /*音声イベントをオフにする*/SSE_CHANGE=4, /*楽器を変更する*/SSE_GENERAL=6/*システム固有のイベント*/}SoundStreamEvents;/*次のマクロが音楽バッファの構築に役立ちます*/#define General(command)SSE_GENERAL, command#define Rest(duration)General(GE_NO_EVENT),DeltaTick(duration)#define VoiceOn(voice, freq, attack)SSE_VOICE_ON, voice, freq, attack#define VoiceOff(voice)SSE_VOICE_OFF, voice#define ChangeEnvelope(voice, instrument, table)\SSE_CHANGE, voice, instrument, table</PRE>
<PRE CLASS="syntax">#define SoundNote(voice, freq, duration,attack)\VoiceOn(voice, freq, attack),DeltaTempo(duration),VoiceOff(voice)</PRE>
<PRE CLASS="syntax">#defineスタッカート(voice, freq, duration,attack)\VoiceOn(voice, freq, attack),DeltaTempo(((duration*0x03)/0x04)),\VoiceOff(voice),DeltaTempo((duration/0x4))</PRE>
<PRE CLASS="syntax">#define Natural(voice, freq, duration,attack)\VoiceOn(voice, freq, attack),DeltaTempo(((duration*0x07)/0x08)),VoiceOff(voice),DeltaTempo((duration/0x8))</PRE>
<PRE CLASS="syntax">#define Legato(voice, freq, duration, attack)\SoundNote(voice, freq, duration, attack)</PRE>
<P>これらは、音楽バッファを構成する「イベント」です。</P>
</DIV>
<DIV>
          <A NAME="S_37.htm_IX_SoundStreamSize"></A>
          <A NAME="S_37.htm_IX_SSS_&ldots;  (SoundStreamSize type)"></A>
        <H1 CLASS="refHeading">SoundStreamSize</H1>
<PRE CLASS="syntax">typedefワードSoundStreamSize;#define SSS_ONE_SHOT 128/*128 bytes(very small)*/#define SSS_SMALL 256/*256 bytes*/#define SSS_MEDIUM 512/*512 bytes(nice size)*/#define SSS_LARGE 1024</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_37.htm_IX_SpecHeight"></A>
          <A NAME="S_37.htm_IX_SH_&ldots;  (SpecHeight flags)"></A>
        <H1 CLASS="refHeading">SpecHeight</H1>
<PRE CLASS="syntax">typedef WordFlags SpecHeight;#define SH_TYPE 0x8c00#define SH_DATA 0x03ff</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_37.htm_IX_SpecSizeSpec"></A>
          <A NAME="S_37.htm_IX_SSS_&ldots;  (SpecSizeSpec flags)"></A>
        <H1 CLASS="refHeading">SpecSizeSpec</H1>
<PRE CLASS="syntax">typedef WordFlags SpecSizeSpec;#define SSS_TYPE 0x8c00#define SSS_DATA 0x03ff</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_37.htm_IX_SST_&ldots;  (SpecSizeType type)"></A>
          <A NAME="S_37.htm_IX_PCT_&ldots;  (SpecSizeType Percent constants)"></A>
        <H1 CLASS="refHeading">SpecSizeType</H1>
<PRE CLASS="syntax">typedef ByteEnum SpecSizeType;#define SST_PIXELS 0x0000#define SST_COUNT 0x0400#define SST_PCT_OF_FIELD_WIDTH 0x0800#define SST_PCT_OF_FIELD_HEIGHT 0x0c00#define SST_AVG_CHAR_WIDTHS 0x1000#define SST_WIDE_CHAR_WIDTHS 0x1400#define SST_LINES_OF_TEXT 0x1800</PRE>
</DIV>
<DIV>
          <A NAME="S_37.htm_IX_SpecSocketDrError"></A>
        <H1 CLASS="refHeading">SpecSocketDrError</H1>
<PRE CLASS="syntax">typedef enum/*word*/{SSDE_DEVICE_BUSY=0x0100, /*シリアルポートまたはモデムドライバが使用中*/</PRE>
<PRE CLASS="syntax">SSDE_DIAL_ERROR=0x0200、SSDE_LINE_BUSY=0x0300、/*モデムがビジー信号を受信*/SSDE_NO_DIALTONE=0x0400、SSDE_NO_ANSWER=0x0500、SSDE_NO_CARRIER=0x0600、SSDE_BLACKLISTED=0x0700、/*GSMネットワークで使用*/SSDE_DELAYED=0x0800、/*GSMネットワークで使用*/SSDE_CALL_FAILED=0x0900、/*何らかの理由でダイヤルできなかった*/SSDE_NEG_FAILED=0x0a00、SSDE_AUTH_REFUSED=0x0b00、SSDE_AUTH_FAILED=0x0c00、SSDE_LQM_FAILURE=0x0d00、SSDE_LOOPED_BACK=0x0e00、SSDE_IDLE_TIMEOUT=0x0f00、SSDE_DEVICE_NOT_FOUND=0x1000、SSDE_DEVICE_TIMEOUT=0x1100、SSDE_DEVICE_ERROR=0x1200、SSDE_NO_USERNAME=0x1300、/*ユーザ名とパスワードのプロンプトが使用されていない*/</PRE>
<PRE CLASS="syntax">SSDE_CANCEL=0x1400, /*ユーザーがキャンセルしました*/SSDE_INVALID_ACCPNT=0x1500/*アクセスポイントが無効です*/}SpecSocketDrError;</PRE>
<P>特定のソケットライブラリ操作は、エラー値を<CODE>SocketError</CODE>値を入力します。 エラーの根本原因が低レベルの通信障害であった場合、返されたエラーワードの上位バイトには<CODE>SpecSocketDrError</CODE>値<CODE>SocketError</CODE>値を下位バイトに格納します。</P>
</DIV>
<HR>
          <A NAME="S_38.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_38.htm_IX_SpecWidth"></A>
          <A NAME="S_38.htm_IX_SW_&ldots;"></A>
        <H1 CLASS="refHeading">SpecWidth</H1>
<PRE CLASS="syntax">typedef WordFlags SpecWidth#define SW_TYPE 0x8c00#define SW_DATA 0x03ff</PRE>
<PRE CLASS="syntax">#define PCT_0 0x000#define PCT_5 0x033#define PCT_10 0x066#define PCT_15 0x099#define PCT_20 0x0cc#define PCT_25 0x100#define PCT_30 0x133#define PCT_35 0x166#define PCT_40 0x199#define PCT_45 0x1cc#define PCT_50 0x200#define PCT_55 0x233#define PCT_60 0x266#define PCT_65 0x299#define PCT_70 0x2cc#define PCT_75 0x300#define PCT_80 0x333#define PCT_85 0x366#define PCT_90 0x399#define PCT_95 0x3cc#define PCT_100 0x3ff</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_38.htm_IX_SpecWinSizePair"></A>
          <A NAME="S_38.htm_IX_SWSP_&ldots;"></A>
        <H1 CLASS="refHeading">SpecWinSizePair</H1>
<PRE CLASS="syntax">typedef struct{SpecWinSizeSpec SWSP_x;SpecWinSizeSpec SWSP_y;</PRE>
<PRE CLASS="syntax">}SpecWinSizePair;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_38.htm_IX_SpecWinSizeSpec"></A>
          <A NAME="S_38.htm_IX_SWSS_&ldots;"></A>
        <H1 CLASS="refHeading">SpecWinSizeSpec</H1>
<PRE CLASS="syntax">typedef WordFlags SpecWinSizeSpec;#define SWSS_RATIO 0x8000#define SWSS_SIGN 0x4000#define SWSS_MANTISSA 0x3c00#define SWSS_FRACTION 0x03ff</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_38.htm_IX_SpecialFunctions"></A>
          <A NAME="S_38.htm_IX_SF_&ldots;  (SpecialFunctions type)"></A>
        <H1 CLASS="refHeading">特殊関数</H1>
<PRE CLASS="syntax">typedef enum/*word*/{SF_FILENAME, SF_PAGE, SF_PAGES, }特殊関数;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_38.htm_IX_SpoolError"></A>
          <A NAME="S_38.htm_IX_SERROR_&ldots;"></A>
        <H1 CLASS="refHeading">SpoolError</H1>
<PRE CLASS="syntax">typedef enum/*word*/{SERROR_NO_SPOOL_FILE, SERROR_NO_PRINT_DRIVER, SERROR_NO_PORT_DRIVER, SERROR_NO_PRINTERS, SERROR_NO_MODE_AVAIL, SERROR_CANT_ALLOC_BITMAP, SERROR_NO_VIDMEM_DRIVER, SERROR_MANUAL_PAPER_FEED, SERROR_CANT_LOAD_PORT_DRIVER, SERROR_PORT_BUSY, SERROR_TEST_NO_PAPER, SERROR_TEST_OFFLINE, SERROR_TEST_PARALLEL_ERROR, SERROR_MISSING_COM_PORT, SERROR_PRINT_ON_STARTUP}SpoolError;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_38.htm_IX_SpoolFileName"></A>
          <A NAME="S_38.htm_IX_SFN_&ldots;"></A>
        <H1 CLASS="refHeading">SpoolFileName</H1>
<PRE CLASS="syntax">typedef struct{char SFN_base[5];char SFN_num[3];char SFN_ext[5];}SpoolFileName;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_39.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_SpoolInfoType"></A>
          <A NAME="S_39.htm_IX_SIT_&ldots;"></A>
        <H1 CLASS="refHeading">SpoolInfoType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{SIT_JOB_INFO, SIT_QUEUE_INFO}SpoolInfoType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_SpoolOpStatus"></A>
          <A NAME="S_39.htm_IX_SPOOL_&ldots;"></A>
        <H1 CLASS="refHeading">SpoolOpStatus</H1>
<PRE CLASS="syntax">typedef enum/*word*/{SPOOL_OPERATION_SUCCESSFUL, SPOOL_JOB_NOT_FOUND, SPOOL_QUEUE_EMPTY, SPOOL_QUEUE_NOT_EMPTY, SPOOL_QUEUE_NOT_FOUND, SPOOL_CANT_VERIFY_PORT, SPOOL_OPERATION_FAILED}SpoolOpStatus;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_SpoolTimeStruct"></A>
          <A NAME="S_39.htm_IX_STS_&ldots;"></A>
        <H1 CLASS="refHeading">SpoolTimeStruct</H1>
<PRE CLASS="syntax">typedef struct{byte STS_second;/*秒(0-59)*/byte STS_minute;/*分(0-59)*/byte STS_hour;/*時間(0-23)*/}SpoolTimeStruct;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_SpoolVerifyAction"></A>
          <A NAME="S_39.htm_IX_SVA_&ldots;"></A>
        <H1 CLASS="refHeading">SpoolVerifyAction</H1>
<PRE CLASS="syntax">typedef enum{SVA_NO_MESSAGE, SVA_WARNING, SVA_PRINTING}SpoolVerifyAction;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_StandardDialogBoxType"></A>
          <A NAME="S_39.htm_IX_SDBT_&ldots;"></A>
        <H1 CLASS="refHeading">StandardDialogBoxType</H1>
<PRE CLASS="syntax">typedef enum{SDBT_FILE_NEW_CANNOT_CREATE_TEMP_NAME, SDBT_FILE_NEW_INSUFFICIENT_DISK_SPACE, SDBT_FILE_NEW_ERROR, SDBT_FILE_NEW_WRITE_PROTECTED, SDBT_FILE_OPEN_SHARING_DENIED, SDBT_FILE_OPEN_FILE_NOT_FOUND, SDBT_FILE_OPEN_INVALID_VM_FILE, SDBT_FILE_OPEN_INSUFFICIENT_DISK_SPACE, SDBT_FILE_OPEN_ERROR, SDBT_FILE_OPEN_READ_ONLY, SDBT_FILE_OPEN_VM_DIRTY, SDBT_FILE_OPEN_DOC_MORE_RECENT_THAN_DOC, SDBT_FILE_OPEN_DOC_MORE_RECENT_THAN_APP, SDBT_FILE_SAVE_INSUFFICIENT_DISK_SPACE, SDBT_FILE_SAVE_ERROR, SDBT_FILE_SAVE_WRITE_PROTECTED, SDBT_FILE_SAVE_AS_FILE_EXISTS, SDBT_FILE_SAVE_AS_SHARING_DENIED, SDBT_FILE_CLOSE_SAVE_CHANGES, SDBT_FILE_CLOSE_ATTACH_DIRTY, SDBT_FILE_REVERT_CONFIRM, SDBT_FILE_REVERT_ERROR, SDBT_FILE_ATTACH_DISK_NOT_FOUND, SDBT_CANNOT_OPEN_VOLUME_SELECTED, SDBT_QUERY_SAVE_AS_TEMPLATE, SDBT_QUERY_SAVE_AS_EMPTY, SDBT_QUERY_SAVE_AS_DEFAULT, SDBT_QUERY_SAVE_AS_MULTI_USER, SDBT_QUERY_SAVE_AS_PUBLIC, SDBT_QUERY_RESET_EMPTY_FILE, SDBT_QUERY_RESET_DEFAULT_FILE, SDBT_CANNOT_OPEN_EMPTY_FILE}StandardDialogBoxType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_StandardDialogParams"></A>
          <A NAME="S_39.htm_IX_SDP_&ldots;"></A>
        <H1 CLASS="refHeading">StandardDialogParams</H1>
<PRE CLASS="syntax">typedef struct{word SDP_customFlags;char*SDP_customString;char*SDP_stringArg1;char*SDP_stringArg2;StandardDialogResponseTriggerTable語*SDP_customTriggers;}StandardDialogParams;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_StandardDialogOptrParams"></A>
          <A NAME="S_39.htm_IX_SDOP_&ldots;"></A>
        <H1 CLASS="refHeading">StandardDialogOptrParams</H1>
<PRE CLASS="syntax">typedef struct{word SDOP_customFlags;optr SDOP_customString;optr SDOP_stringArg1;optr SDOP_stringArg2;optr SDOP_customTriggers;}StandardDialogOptrParams;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_StandardDialogResponseTriggerEntry"></A>
          <A NAME="S_39.htm_IX_SDRTE_&ldots;"></A>
        <H1 CLASS="refHeading">StandardDialogResponseTriggerEntry</H1>
<PRE CLASS="syntax">typedef struct{optr SDRTE_moniker;word SDRTE_responseValue;}StandardDialogResponseTriggerEntry;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_StandardDialog1ResponseTriggerTable"></A>
          <A NAME="S_39.htm_IX_SD1RTT_&ldots;"></A>
        <H1 CLASS="refHeading">標準ダイアログ1(ResponseTriggerTable)</H1>
<PRE CLASS="syntax">typedef struct{word SD1RTT_numTriggers;StandardDialogResponseTriggerEntry SD1RTT_trigger1;}StandardDialog1ResponseTriggerTable;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_StandardDialog2ResponseTriggerTable"></A>
          <A NAME="S_39.htm_IX_SD2RTT_&ldots;"></A>
        <H1 CLASS="refHeading">標準ダイアログ2(ResponseTriggerTable)</H1>
<PRE CLASS="syntax">typedef struct{word SD2RTT_numTriggers;StandardDialogResponseTriggerEntry SD2RTT_trigger1;StandardDialogResponseTriggerEntry SD2RTT_trigger2;}StandardDialog2ResponseTriggerTable;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_39.htm_IX_StandardDialog3ResponseTriggerTable"></A>
          <A NAME="S_39.htm_IX_SD3RTT_&ldots;"></A>
        <H1 CLASS="refHeading">標準ダイアログ3(ResponseTriggerTable)</H1>
<PRE CLASS="syntax">typedef struct{word SD3RTT_numTriggers;StandardDialogResponseTriggerEntry SD3RTT_trigger1;StandardDialogResponseTriggerEntry SD3RTT_trigger2;StandardDialogResponseTriggerEntry SD3RTT_trigger3;}StandardDialog3ResponseTriggerTable;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_3a.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_3a.htm_IX_StandardDialog4ResponseTriggerTable"></A>
          <A NAME="S_3a.htm_IX_SD4RTT_&ldots;"></A>
        <H1 CLASS="refHeading">標準ダイアログ4(ResponseTriggerTable)</H1>
<PRE CLASS="syntax">typedef struct{word SD4RTT_numTriggers;StandardDialogResponseTriggerEntry SD4RTT_trigger1;StandardDialogResponseTriggerEntry SD4RTT_trigger2;StandardDialogResponseTriggerEntry SD4RTT_trigger3;StandardDialogResponseTriggerEntry SD4RTT_trigger4;}StandardDialog4ResponseTriggerTable;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3a.htm_IX_StandardPath"></A>
          <A NAME="S_3a.htm_IX_SP_&ldots;  (StandardPath type)"></A>
        <H1 CLASS="refHeading">StandardPath</H1>
<PRE CLASS="syntax">typedef enum/*word*/{SP_NOT_STANDARD_PATH=0, SP_TOP=1, SP_APPLICATION=3, SP_DOCUMENT=5, SP_SYSTEM=7, SP_PRIVATE_DATA=9, SP_STATE=11, SP_FONT=13, SP_SPOOL=15, SP_SYS_APPLICATION=17, SP_PUBLIC_DATA=19, SP_MOUSE_DRIVERS=21, SP_PRINTER_DRIVERS=23, SP_FILE_SYSTEM_DRIVERS=25, SP_VIDEO_DRIVERS=27, SP_SWAP_DRIVERS=29, SP_KEYBOARD_DRIVERS=31, SP_FONT_DRIVERS=33, SP_IMPORT_EXPORT_DRIVERS=35, SP_TASK_SWITCH_DRIVERS=37, SP_HELP_FILES=39, SP_TEMPLATE=41, SP_POWER_DRIVERS=43, SP_DOS_ROOM=45, SP_HWR=47, SP_WASTE_BASKET=49, SP_BACKUP=51, SP_PAGER_DRIVERS=53 SP_DUMMY=256}StandardPath;</PRE>
<P>ディスクハンドルとして渡されるほとんどのルーチンは<CODE>StandardPath</CODE>列挙型。 標準パスを使用すると、アプリケーションはディスクに依存しない方法でファイルにアクセスできます。 標準パスは通常、特定の階層に配置されます。たとえば、STATEディレクトリは通常、PRIVDATAディレクトリに属します。 ただし、これは完全にユーザの裁量に任されています。アプリケーションは、標準パスがどのように配置されているかを想定しない場合があります。</P>
</DIV>
<DIV>
          <A NAME="S_3a.htm_IX_StandardSoundType"></A>
        <H1 CLASS="refHeading">StandardSoundType</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_9f.htm#IX_UserStandardSound()">UserStandardSound()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3a.htm_IX_StreamBlocker"></A>
          <A NAME="S_3a.htm_IX_STREAM_&ldots;  (StreamBlocker type)"></A>
        <H1 CLASS="refHeading">StreamBlocker</H1>
<PRE CLASS="syntax">typedef enum{STREAM_BLOCK=2, STREAM_NO_BLOCK=0}StreamBlocker;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3a.htm_IX_StreamError"></A>
          <A NAME="S_3a.htm_IX_STREAM_&ldots;  (StreamError type)"></A>
        <H1 CLASS="refHeading">StreamError</H1>
<PRE CLASS="syntax">typedef enum{STREAM_WOULD_BLOCK, STREAM_CLOSING, STREAM_CANNOT_ALLOC, STREAM_BUFFER_TOO_LARGE, STREAM_CLOSED, STREAM_SHORT_READ_WRITE}StreamError;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3a.htm_IX_StreamOpenFlags"></A>
          <A NAME="S_3a.htm_IX_STREAM_OPEN_&ldots;"></A>
        <H1 CLASS="refHeading">StreamOpenFlags</H1>
<PRE CLASS="syntax">typedef enum{STREAM_OPEN_NO_BLOCK=0x01, STREAM_OPEN_TIMEOUT=0x02}StreamOpenFlags</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3a.htm_IX_StreamToken"></A>
        <H1 CLASS="refHeading">StreamToken</H1>
<PRE CLASS="syntax">typedef Handleword StreamToken;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3a.htm_IX_StreamRoles"></A>
          <A NAME="S_3a.htm_IX_STREAM_ROLES_&ldots;"></A>
        <H1 CLASS="refHeading">StreamRoles</H1>
<PRE CLASS="syntax">typedef enum{STREAM_ROLES_WRITER=0, STREAM_ROLES_READER=-1, STREAM_ROLES_BOTH=-2}StreamRoles;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3a.htm_IX_StyleChunkDesc"></A>
          <A NAME="S_3a.htm_IX_SCD_&ldots;"></A>
        <H1 CLASS="refHeading">StyleChunkDesc</H1>
<PRE CLASS="syntax">typedef struct{VMFileHandle SCD_vmFile;word SCD_vmBlockOrMemHandle;ChunkHandle SCD_chunk;}StyleChunkDesc;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_3b.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_StyleElementFlags"></A>
          <A NAME="S_3b.htm_IX_SEF_DISPLAY_IN_TOOLBOX"></A>
        <H1 CLASS="refHeading">StyleElementFlags</H1>
<PRE CLASS="syntax">typedef WordFlags StyleElementFlags;#define SEF_DISPLAY_IN_TOOLBOX 0x8000</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_StyleElementHeader"></A>
          <A NAME="S_3b.htm_IX_SEH_&ldots;"></A>
        <H1 CLASS="refHeading">StyleElementHeader</H1>
<PRE CLASS="syntax">typedef struct{NameArrayElement SEH_meta;word SEH_baseStyle;StyleElementFlags SEH_flags;dword SEH_privateData;}StyleElementHeader;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_StyleSheetElementHeader"></A>
          <A NAME="S_3b.htm_IX_SSEH_&ldots;"></A>
        <H1 CLASS="refHeading">StyleSheetElementHeader</H1>
<PRE CLASS="syntax">typedef struct{RefElementHeader SSEH_meta;word SSEH_style;}StyleSheetElementHeader;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SupportedEnvelopeForamt"></A>
          <A NAME="S_3b.htm_IX_SEF_&ldots;  (SupportedEnvelopeFormat type)"></A>
        <H1 CLASS="refHeading">SupportedEnvelopeFormat</H1>
<PRE CLASS="syntax">typedef enum{SEF_NO_FORMAT, SEF_SBI_FORMAT, SEF_CTI_FORMAT}SupportedEnvelopeFormat;</PRE>
<P>これらの値は、サウンドデバイスが楽器をシミュレートできるかどうかを指定します。</P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_sword"></A>
        <H1 CLASS="refHeading">太刀</H1>
<PRE CLASS="syntax">typedef signed short sword(typedef符号付き短刀</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SysConfigFlags"></A>
          <A NAME="S_3b.htm_IX_SCF_&ldots;"></A>
        <H1 CLASS="refHeading">SysConfigFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags SysConfigFlags;#define SCF_UNDER_SWAT 0x80#define SCF_2 ND_IC 0x40#define SCF_RTC 0x20#define SCF_COPROC 0x10#define SCF_RESTARTED 0x08#define SCF_CRASHED 0x04#define SCF_MCA 0x02#define SCF_LOGGING 0x01</PRE>
<P>上記のフラグは、システム設定を示します。 これらのフラグのいずれかまたはすべてを一度に設定できます。フラグが設定されている場合、説明は真になります。これらのフラグはカーネルによって使用され、次のコマンドで取得できます。<CODE><A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SysDrawMask"></A>
          <A NAME="S_3b.htm_IX_SDM_&ldots;  (SysDrawMask)"></A>
        <H1 CLASS="refHeading">SysDrawMask</H1>
<PRE CLASS="syntax">typedef ByteFlags SysDrawMask;#define SDM_INVERSE 0x80#define SDM_MASK 0x7f</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SysGetInfoType"></A>
        <H1 CLASS="refHeading">SysGetInfoType</H1>
<P CLASS="refField"><STRONG><STRONG>以下を参照してください。</STRONG></STRONG><CODE><A HREF="../../CRef/Routines/R_92.htm#IX_SysGetInfo()">SysGetInfo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SysMachineType"></A>
          <A NAME="S_3b.htm_IX_SMT_&ldots;"></A>
        <H1 CLASS="refHeading">SysMachineType</H1>
<PRE CLASS="syntax">typedef ByteEnum SysMachineType;#define SMT_UNKNOWN 0#define SMT_PC 1#define SMT_PC_CONV 2#define SMT_PC_JR 3#define SMT_PC_XT 4#define SMT_PC_XT_286 5#define SMT_PC_AT 6#define SMT_PS2_30 7#define SMT_PS2_50 8#define SMT_PS2_60 9#define SMT_PS2_80 10#define SMT_PS1 11</PRE>
<P>GEOSを実行しているマシンのタイプを示すバイトサイズの値。 この値は、次のコマンドで取得できます。<CODE><A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SysNotifyFlags"></A>
        <H1 CLASS="refHeading">SysNotifyFlags</H1>
<P CLASS="refField"><STRONG><STRONG>以下を参照してください。</STRONG></STRONG><CODE><A HREF="../../CRef/Routines/R_93.htm#IX_SysNotify()">SysNotify()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SysProcessorType"></A>
          <A NAME="S_3b.htm_IX_SPT_&ldots;  (SysProcessorType type)"></A>
        <H1 CLASS="refHeading">SysProcessorType</H1>
<PRE CLASS="syntax">typedef ByteEnum SysProcessorType;#define SPT_8088 0#define SPT_8086 0#define SPT_80186 1#define SPT_80286 2#define SPT_80386 3#define SPT_80486 4</PRE>
<P>この列挙型は、GEOSを実行するシステム上のプロセッサのタイプを示すバイトです。 次のコマンドで取得できます。<CODE><A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SysShutdownType"></A>
        <H1 CLASS="refHeading">SysShutdownType</H1>
<P CLASS="refField"><STRONG><STRONG>以下を参照してください。</STRONG></STRONG><CODE><A HREF="../../CRef/Routines/R_94.htm#IX_SysShutdown()">SysShutdown()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SysStats"></A>
          <A NAME="S_3b.htm_IX_SS_&ldots;  (SysStats struct)"></A>
        <H1 CLASS="refHeading">システム統計</H1>
<PRE CLASS="syntax">typedef struct{dword SS_idleCount;/*最後の1秒間のアイドルティック。 */SysSwapInfo SS_swapOuts;/*外向きのスワップ動作。 */SysSwapInfo SS_swapIns;/*内向きのスワップactividy。 */word SS_contextSwitches;/*最後の1秒でコンテキストが切り替わります。 */word SS_interrupts;/*最後の1秒間の割り込み。 */word SS_runQueue;/*最後の*秒の終わりに実行可能なスレッド。*/</PRE>
<PRE CLASS="syntax">}システム統計情報;</PRE>
<P>この構造体は<CODE><A HREF="../../CRef/Routines/R_94.htm#IX_SysStatistics()">システム統計()</A></CODE>GEOSの現在のパフォーマンス統計を表します。</P>
</DIV>
<DIV>
          <A NAME="S_3b.htm_IX_SysSwapInfo"></A>
          <A NAME="S_3b.htm_IX_SSI_&ldots;"></A>
        <H1 CLASS="refHeading">SysSwapInfo</H1>
<PRE CLASS="syntax">typedef struct{word SSI_paragraphs;/*スワップされた段落の数。 */word SSI_blocks;/*スワップされたブロックの数。 */}SysSwapInfo</PRE>
<P>現在のスワップ・アクティビティを表すために使用される構造体<CODE>システム統計</CODE>構造。</P>
</DIV>
<HR>
          <A NAME="S_3c.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_3c.htm_IX_SystemDrawMask"></A>
          <A NAME="S_3c.htm_IX_SDM_&ldots;  (SystemDrawMask type)"></A>
          <A NAME="S_3c.htm_IX_SET_CUSTOM_PATTERN"></A>
        <H1 CLASS="refHeading">SystemDrawMask</H1>
<PRE CLASS="syntax">typedef ByteEnum SystemDrawMask;#define SDM_TILE 0#define SDM_SHADED_BAR 1#define SDM_HORIZONTAL 2#define SDM_VERTICAL 3#define SDM_DIAG_NE 4#define SDM_DIAG_NW 5#define SDM_GRID 6#define SDM_BIG_GRID 7#define SDM_BRICK 8#define SDM_SLANT_BRICK 9#define SDM_0 89#define SDM_12_5 81#define SDM_25 73#define SDM_37_5 65#define SDM_50 57#define SDM_62_5 49#define SDM_75 41#define SDM_87_5 33#define SDM_100 25#define SDM_CUSTOM 0x7f#define SET_CUSTOM_PATTERN SDM_CUSTOM</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3c.htm_IX_SystemHatch"></A>
          <A NAME="S_3c.htm_IX_SH_&ldots;  (SystemHatch type)"></A>
        <H1 CLASS="refHeading">SystemHatch</H1>
<PRE CLASS="syntax">typedef ByteEnum SystemHatch;#define SH_VERTICAL 0#define SH_HORIZONTAL 1#define SH_45_DEGREE 2#define SH_135_DEGREE 3#define SH_BRICK 4#define SH_SLOPED_BRICK 5</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3c.htm_IX_TargetLevel"></A>
          <A NAME="S_3c.htm_IX_TL_&ldots;"></A>
        <H1 CLASS="refHeading">ターゲットレベル</H1>
<PRE CLASS="syntax">typedef enum/*word*/{TL_TARGET=0, TL_CONTENT, TL_GENERIC_OBJECTS=1000, TL_GEN_SYSTEM, TL_GEN_FIELD, TL_GEN_APPLICATION, TL_GEN_PRIMARY, TL_GEN_DISPLAY_CTRL, TL_GEN_DISPLAY, TL_GEN_VIEW, TL_LIBRARY_LEVELS=2000, TL_APPLICATION_OBJECTS=3000, }ターゲットレベル;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3c.htm_IX_TcpAccPntExtendedAddress"></A>
        <H1 CLASS="refHeading">TcpAccPntExtendedAddress</H1>
<PRE CLASS="syntax">typedef struct{word TAPEA_linkSize;/*3*/byte TAPEA_LinkType;/*LinkType(LT_ID)*/word TAPEA_accPntID;}TcpAccPntExtendedAddress;</PRE>
<P>これは、TCPアドレスの「不透明な」表現です。具体的には、アクセスポイントIDによってTCPアドレスを識別するために使用される形式です。</P>
<P>設定(Set)<CODE>TAPEA_linkSize</CODE>を3に設定し<CODE>TAPEAリンクタイプ</CODE>LT_IDに;設定<CODE>TAPEA_accPntID</CODE>アクセスポイントのID番号に変換します。</P>
</DIV>
<DIV>
          <A NAME="S_3c.htm_IX_TcpNonAccPntExtendedAddress"></A>
        <H1 CLASS="refHeading">TcpNonAccPntExtendedAddress</H1>
<PRE CLASS="syntax">typedef struct{word TNAPEA_linkSize;byte TNAPEA_LinkType;/*LinkType(LT_ADDR)*//*label byte TNAPEA_addr;link address immed. その後にIPアドレス*/}TcpNonAccPntExtendedAddressが続きます。</PRE>
<P>これは、TCPアドレスの「不透明な」表現です。具体的には、既知のアクセスポイントではないTCPアドレスを識別するために使用される形式です。IPアドレスに加えて、ダイヤルする電話番号を指定する必要があります。</P>
<P>設定(Set)<CODE>TNAPEA_linkSize</CODE>を電話番号文字列のサイズに変更します。 設定(Set)<CODE>TNAPEAリンクタイプ</CODE>をLT_ADDRに設定する。 「15105551234 acme.com」のように、ダイヤルする電話番号とそれに続く人間が読める形式のIPアドレスで構成されるヌル終了文字列で構造を追跡します。</P>
</DIV>
<DIV>
          <A NAME="S_3c.htm_IX_TcpOnlyExtendedAddress"></A>
        <H1 CLASS="refHeading">TcpOnlyExtendedAddress</H1>
<PRE CLASS="syntax">typedef struct{word TOEA_linkSize;/*0*//*label byte TOEA_ipAddr;IP address*/}TcpOnlyExtendedAddress;</PRE>
<P>これはTCPアドレスの「不透明な」表現であり、具体的には、リンクアドレスが必要ない場合にTCPアドレスを識別するために使用される形式である。</P>
<P>設定(Set)<CODE>TOEA_linkSize</CODE>を0に設定し、構造体の後にIPアドレスを指定します。IPアドレスは、「204.156.128.1」や「acme.com」のように、ヌル文字で終端された文字列で指定します。</P>
</DIV>
<DIV>
          <A NAME="S_3c.htm_IX_TestRectReturnType"></A>
        <H1 CLASS="refHeading">TestRectReturnType</H1>
<P>詳細については<CODE>GrTestRectInReg()</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3c.htm_IX_TextAttr"></A>
        <H1 CLASS="refHeading">TextAttr</H1>
<PRE CLASS="syntax">typedef struct{byte TA_colorFlag;RGBValue TA_color;SysDrawMask TA_mask;GraphicPattern TA_pattern;TextStyle TA_styleSet;TextStyle TA_styleClear;TextMode TA_modeSet;TextMode TA_modeClear;WBFixed TA_spacePad;FontID TA_font;WBFixed TA_size;剣TA_trackKern;}TextAttr;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_3d.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_3d.htm_IX_TextMode"></A>
        <H1 CLASS="refHeading">テキストモード</H1>
<PRE CLASS="syntax">typedef ByteFlags TextMode;#define TM_TRACK_KERN 0x40#define TM_PAIR_KERN 0x20#define TM_PAD_SPACES 0x10#define TM_DRAW_BASE 0x08#define TM_DRAW_BOTTOM 0x04#define TM_DRAW_ACCENT 0x02#define TM_DRAW_OPTIONAL_HYPHENS 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3d.htm_IX_TextReference"></A>
          <A NAME="S_3d.htm_IX_TR_&ldots;"></A>
        <H1 CLASS="refHeading">TextReference</H1>
<PRE CLASS="syntax">typedef struct{TR_type TextReferenceType;TR_ref TextReferenceUnion;</PRE>
<PRE CLASS="syntax">}TextReference;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3d.htm_IX_TextReferenceBlock"></A>
          <A NAME="S_3d.htm_IX_TRB_handle"></A>
        <H1 CLASS="refHeading">TextReferenceBlock</H1>
<PRE CLASS="syntax">typedef struct{MemHandle TRB_handle;}TextReferenceBlock;</PRE>
<P>この構造体は<CODE>TextReferenceType</CODE>TRT_BLOCKの MSG_VIS_TEXT_REPLACE_TEXTおよびMSG_VIS_TEXT_GET_TEXT_RANGEとともに使用され、これらのメッセージで使用されるテキストを参照します。</P>
<P>TRB_様<CODE>取手</CODE>には、テキストバッファのハンドルが格納されます。 宛先バッファを割り当てるためにエントリを入力する必要はありません。 ヒープ割り当て要求は、HAF_NO_ERRフラグを使用して行われます。 VTGRF_RESIZEが渡されると、渡されたブロックまたは割り当てられたブロックのいずれかが、テキストに合わせてサイズ変更されます。</P>
</DIV>
<DIV>
          <A NAME="S_3d.htm_IX_TextReferenceBlockChunk"></A>
          <A NAME="S_3d.htm_IX_TRBC_ref"></A>
        <H1 CLASS="refHeading">TextReferenceBlockChunk</H1>
<PRE CLASS="syntax">typedef struct{optr TRBC_ref;}TextReferenceBlockChunk;</PRE>
<P>この構造体は<CODE>TextReferenceType</CODE>TRT_OPTRの MSG_VIS_TEXT_REPLACE_TEXTおよびMSG_VIS_TEXT_GET_TEXT_RANGEとともに使用され、これらのメッセージで使用されるテキストを参照します。</P>
<P>TRBCの<CODE>参照</CODE>はoptrをテキストバッファ(文字のグループ)sに格納する。 TRBCのハンドルフィールド<CODE>参照(_R)</CODE>を入力する必要があります。</P>
<P>LMemヒープはこの割り当てに対応できると想定されています。 発信者は、これが事実であることを確認する責任があります。</P>
<P>VTGRF_RESIZEが渡されると、渡されたブロックまたは割り当てられたブロックのいずれかが、テキストに合わせてサイズ変更されます。</P>
</DIV>
<DIV>
          <A NAME="S_3d.htm_IX_TextReferenceDBItem"></A>
          <A NAME="S_3d.htm_IX_TRDBI_&ldots;"></A>
        <H1 CLASS="refHeading">TextReferenceDBItem</H1>
<PRE CLASS="syntax">typedef struct{FileHandle TRDBI_file;DBItem TRDBI_item;DBGroup TRDBI_group;}TextReferenceDBItem;</PRE>
<P>この構造体は<CODE>TextReferenceType</CODE>TRT_DB_ITEMの MSG_VIS_TEXT_REPLACE_TEXTおよびMSG_VIS_TEXT_GET_TEXT_RANGEとともに使用され、これらのメッセージで使用されるテキストを参照します。</P>
<P>TRDBI__<CODE>やすり</CODE>は、このDB項目に関連付けられたVMファイルを保存します。</P>
<P>TRDBI_<CODE>項目(item)</CODE>DB項目自体が格納されます。</P>
<P>TRDBI_<CODE>集団</CODE>項目が属するDBグループを格納します。</P>
<P>両方のTRDBI_<CODE>やすり</CODE>およびTRDBI_<CODE>集団</CODE>VMブロックを割り当てる場合は、を入力する必要があります。</P>
<P>TRDBI_<CODE>集団</CODE>フィールドがDB_UNGROUPEDに設定されている場合、項目はグループ化されずに割り当てられます。 TRDBI_groupは、戻り時に項目が割り当てられたグループを保持します。</P>
<P>VTGRF_RESIZEが渡されると、渡されたブロックまたは割り当てられたブロックのいずれかが、テキストに合わせてサイズ変更されます。</P>
</DIV>
<DIV>
          <A NAME="S_3d.htm_IX_TextReferenceHugeArray"></A>
          <A NAME="S_3d.htm_IX_TRHA_&ldots;"></A>
        <H1 CLASS="refHeading">TextReferenceHugeArray</H1>
<PRE CLASS="syntax">typedef struct{FileHandle TRHA_file;word TRHA_array;}TextReferenceHugeArray;と入力します。</PRE>
<P>この構造体は<CODE>TextReferenceType</CODE>TRT_HUGE_ARRAYの MSG_VIS_TEXT_REPLACE_TEXTおよびMSG_VIS_TEXT_GET_TEXT_RANGEとともに使用され、これらのメッセージで使用されるテキストを参照します。</P>
<P>TRHA<CODE>ふぁいる</CODE>この巨大なアレイに関連付けられたVMファイルが保存されます。</P>
<P>TRHA_<CODE>配列複写</CODE>巨大配列が格納されます。</P>
<P>TRHA_<CODE>やすり</CODE>巨大配列を割り当てる場合は、フィールドを設定する必要があります。</P>
<P>VTGRF_RESIZEが渡されると、渡されたブロックまたは割り当てられたブロックのいずれかが、テキストに合わせてサイズ変更されます。</P>
</DIV>
<DIV>
          <A NAME="S_3d.htm_IX_TextReferencePointer"></A>
          <A NAME="S_3d.htm_IX_TRP_pointer"></A>
        <H1 CLASS="refHeading">TextReferencePointer</H1>
<PRE CLASS="syntax">typedef struct{char_far*TRP_pointer;}TextReferencePointer;</PRE>
<P>この構造体は<CODE>TextReferenceType</CODE>TRT_POINTERの MSG_VIS_TEXT_REPLACE_TEXTおよびMSG_VIS_TEXT_GET_TEXT_RANGEとともに使用され、これらのメッセージで使用されるテキストを参照します。</P>
<P>トリプトファン<CODE>ポインタ(_P)</CODE>テキストへのポインタを格納します。 このフィールドに入力する必要があります。</P>
<P>この種の参照では、VTGRF_RESIZEは意味を持ちません。 VTGRF_ALLOCATEとVTGRF_ALLOCATE_ALWAYSは、このタイプのテキスト参照で渡すことができる有効なフラグではありません。</P>
<P>この参照は、テキストオブジェクトからテキストをコピーする最も安全な方法です。 呼び出し元はブロックを割り当てるので、割り当てのエラーも処理できます。</P>
</DIV>
<DIV>
          <A NAME="S_3d.htm_IX_TextReferenceSegmentChunk"></A>
          <A NAME="S_3d.htm_IX_TRSC_&ldots;"></A>
        <H1 CLASS="refHeading">TextReferenceSegmentChunk</H1>
<PRE CLASS="syntax">typedef struct{ChunkHandle TRSC_chunk;セグメントTRSC_segment;}TextReferenceSegmentChunk;</PRE>
<P>この構造体は<CODE>TextReferenceType</CODE>TRT_SEGMENT_CHUNKの MSG_VIS_TEXT_REPLACE_TEXTおよびMSG_VIS_TEXT_GET_TEXT_RANGEとともに使用され、これらのメッセージで使用されるテキストを参照します。</P>
<P>ト…<CODE>分節</CODE>には、テキストチャンクのセグメントアドレスが格納されます。 トラック<CODE>チャンク(_K)</CODE>は、チャンクオフセットをテキストに格納します。</P>
<P>LMemヒープはこの割り当てに対応できると想定されています。 発信者は、これが事実であることを確認する責任があります。</P>
<P>VTGRF_RESIZEが渡されると、渡されたブロックまたは割り当てられたブロックのいずれかが、テキストに合わせてサイズ変更されます。</P>
</DIV>
<HR>
          <A NAME="S_3e.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_TextReferenceType"></A>
          <A NAME="S_3e.htm_IX_TRT_&ldots;"></A>
        <H1 CLASS="refHeading">TextReferenceType</H1>
<PRE CLASS="syntax">typedef enum{TRT_POINTER=0, /*TextReferencePointer*/TRT_SEGMENT_CHUNK=2, /*TextReferenceSegmentChunk*/TRT_OPTR=4, /*TextReferenceBlockChunk*/TRT_BLOCK=6, /*TextReferenceBlock*/TRT_VM_BLOCK=8, /*TextReferenceVMBlock*/TRT_DB_ITEM=10, /*TextReferenceDBItem*/TRT_HUGE_ARRAY=12, /*TextReferenceHugeArray*/}TextReferenceType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_TextReferenceUnion"></A>
          <A NAME="S_3e.htm_IX_TRU_&ldots;"></A>
        <H1 CLASS="refHeading">TextReferenceUnion</H1>
<PRE CLASS="syntax">typedef union{TextReferencePointer TRU_pointer;TextReferenceSegmentChunk TRU_segChunk;TextReferenceBlockChunk TRU_blockChunk;TextReferenceBlock TRU_block;TextReferenceVMBlock TRU_vmBlock;TextReferenceDBItem TRU_dbItem;TextReferenceHugeArray TRU_hugeArray;}TextReferenceUnion;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_TextReferenceVMBlock"></A>
          <A NAME="S_3e.htm_IX_TRVMB_&ldots;"></A>
        <H1 CLASS="refHeading">TextReferenceVMBlock</H1>
<PRE CLASS="syntax">typedef struct{FileHandle TRVMB_file;VMBlockHandle TRVMB_block;}TextReferenceVMBlock;</PRE>
<P>この構造体は<CODE>TextReferenceType</CODE>TRT_VM_BLOCKの MSG_VIS_TEXT_REPLACE_TEXTおよびMSG_VIS_TEXT_GET_TEXT_RANGEとともに使用され、これらのメッセージで使用されるテキストを参照します。</P>
<P>TRVMB<CODE>ふぁいる</CODE>は、このVMブロックに関連付けられたVMファイルを保存します。 VMブロックを割り当てる場合は、このエントリを入力する必要があります。</P>
<P>TRVMB<CODE>ぶろっく</CODE>VMブロック自体を格納します。</P>
<P>VTGRF_RESIZEが渡されると、渡されたブロックまたは割り当てられたブロックのいずれかが、テキストに合わせてサイズ変更されます。</P>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_TextStyle"></A>
          <A NAME="S_3e.htm_IX_TS_&ldots;  (TextStyle)"></A>
        <H1 CLASS="refHeading">文字スタイル</H1>
<PRE CLASS="syntax">typedef ByteFlags TextStyle;#define TS_OUTLINE 0x40#define TS_BOLD 0x20#define TS_ITALIC 0x10#define TS_SUPERSCRIPT 0x08#define TS_SUBSCRIPT 0x04#define TS_STRIKE_THRU 0x02#define TS_UNDERLINE 0x01</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_ThreadException"></A>
          <A NAME="S_3e.htm_IX_TE_&ldots;  (ThreadException type)"></A>
        <H1 CLASS="refHeading">ThreadException</H1>
<PRE CLASS="syntax">typedef enum{TE_DIVIDE_BY_ZERO=0, TE_OVERFLOW=4, TE_BOUND=8, TE_FPU_EXCEPTION=12, TE_SINGLE_STEP=16, TE_BREAKPOINT=20}ThreadException;</PRE>
<P>プロセッサ例外は主にデバッグに使用されます。<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadHandleException()">ThreadHandleException()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_ThreadGetInfoType"></A>
        <H1 CLASS="refHeading">ThreadGetInfoType</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetInfo()">ThreadGetInfo()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_ThreadHandle"></A>
        <H1 CLASS="refHeading">ThreadHandle</H1>
<PRE CLASS="syntax">typedefハンドルThreadHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_ThreadLockHandle"></A>
        <H1 CLASS="refHeading">ThreadLockHandle</H1>
<PRE CLASS="syntax">typedefハンドルThreadLockHandle;</PRE>
<P> </P>
</DIV>
<DIV>これらのフラグは、スレッドのどの側面が<A NAME="S_3e.htm_IX_ThreadModifyFlags"></A><A NAME="S_3e.htm_IX_TMF_&ldots;"></A><H1 CLASS="refHeading">ThreadModifyFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ThreadModifyFlags;#define TMF_BASE_PRIO 0x80#define TMF_ZERO_USAGE 0x40</PRE>
<P>とともに使用<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadModify()">ThreadModify()</A></CODE>が変更されました。</P>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_TimerCompressedDate"></A>
        <H1 CLASS="refHeading">TimerCompressedDate</H1>
<PRE CLASS="syntax">typedef WordFlags TimerCompressedDate;#define TCD_YEAR 0xfe00/*1980年からの年数;例:1988は`8&#39;*/#define TCD_MONTH 0x01e0/*月(1-12)(0は不正)*/#define TCD_DAY 0x001f/*日(1-31)(0は不正)*/</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3e.htm_IX_TimerDateAndTime"></A>
          <A NAME="S_3e.htm_IX_TDAT_&ldots;"></A>
        <H1 CLASS="refHeading">TimerDateAndTime</H1>
<PRE CLASS="syntax">typedef struct{word TDAT_year;/*Year*/word TDAT_month;/*月数(1～12)*/word TDAT_day;/*月の日数(1～31)*/DaysOfTheWeek TDAT_dayOfWeek;/*DayOfTheWeek列挙*/word TDAT_hours;/*時刻(0～23)*/word TDAT_minutes;/*時の分(0～59)*/word TDAT_seconds;/*分の秒(0～59)*/}TimerDateAndTime;</PRE>
<P>この構造体は、現在の日時を追跡するために使用されます。</P>
</DIV>
<HR>
          <A NAME="S_3f.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TimerHandle"></A>
        <H1 CLASS="refHeading">TimerHandle</H1>
<PRE CLASS="syntax">typedefハンドルTimerHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TimerType"></A>
        <H1 CLASS="refHeading">TimerType</H1>
<P CLASS="refField"><STRONG><STRONG>以下を参照してください。</STRONG></STRONG><CODE><A HREF="../../CRef/Routines/R_99.htm#IX_TimerStart()">TimerStart()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_ToggleState"></A>
          <A NAME="S_3f.htm_IX_TS_&ldots;  (ToggleState)"></A>
        <H1 CLASS="refHeading">ToggleState</H1>
<PRE CLASS="syntax">typedef ByteFlags ToggleState;#define TS_CAPSLOCK 0x80#define TS_NUMLOCK 0x40#define TS_SCROLLLOCK 0x20</PRE>
<P>この構造体は、入力の解釈方法に影響する特定の「トグル」の状態を記述します。 これらのトグルは、Caps Lock、Num Lock、およびScroll Lockキーに対応しています。</P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TokenChars"></A>
          <A NAME="S_3f.htm_IX_TOKEN_CHARS_LENGTH"></A>
        <H1 CLASS="refHeading">TokenChars</H1>
<PRE CLASS="syntax">typedef char length[TOKEN_CHARS_TokenChars];/*TOKEN_CHARS_LENGTH=4*/</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TokenDBItem"></A>
        <H1 CLASS="refHeading">TokenDBItem</H1>
<PRE CLASS="syntax">typedef DBGroupAndItem TokenDBItem;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TokenEntry"></A>
          <A NAME="S_3f.htm_IX_TE_&ldots;  (TokenEntry structure)"></A>
        <H1 CLASS="refHeading">TokenEntry</H1>
<PRE CLASS="syntax">typedef struct{GeodeToken TE_token;/*このファイルのGeodeToken構造体*/TokenDBItem TE_monikerList;/*このトークンのモニカのリスト*/TokenFlags TE_flags;/*再配置ステータスを示すフラグ*/ReleaseNumber TE_release;/*トークンDBのリリース番号*/ProtocolNumber TE_protocol;/*トケDBのプロトコル番号*/}TokenEntry;</PRE>
<P>この構造体は、トークンデータベースのマップ項目内のトークンエントリに使用され、各トークンの構造体とその他の情報を識別します。 の<CODE>TE_monikerList</CODE>fieldは、トークンのチャンクの項目番号を含むチャンクを指します。</P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TokenFlags"></A>
          <A NAME="S_3f.htm_IX_TF_NEED_RELOCATION"></A>
        <H1 CLASS="refHeading">TokenFlags</H1>
<PRE CLASS="syntax">typedef WordFlags TokenFlags;#define TF_NEED_RELOCATION 0x8000</PRE>
<P>トークン管理ルーチンで使用されるこのフラグレコードは、トークンがロードまたはアンロードされるときに再配置する必要があるフィールドがトークンにあるかどうかを示します。</P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TokenMonikerInfo"></A>
          <A NAME="S_3f.htm_IX_TMI_&ldots;"></A>
        <H1 CLASS="refHeading">TokenMonikerInfo</H1>
<PRE CLASS="syntax">typedef struct{TokenDBItem TMI_moniker;word TMI_fileFlag;/*トークンが共有トークンDBファイルにある場合は0;*ローカルファイルにある場合は0以外*/}TokenMonikerInfo;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TokenRangeFlags"></A>
          <A NAME="S_3f.htm_IX_TRF_&ldots;"></A>
        <H1 CLASS="refHeading">TokenRangeFlags</H1>
<PRE CLASS="syntax">typedef WordFlags TokenRangeFlags;#define TRF_ONLY_GSTRING 0x8000#define TRF_ONLY_PASSED_MANUFID 0x4000#define TRF_UNUSED 0x3fff</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TransError"></A>
          <A NAME="S_3f.htm_IX_TE_&ldots;  (TransError type)"></A>
        <H1 CLASS="refHeading">TransError</H1>
<PRE CLASS="syntax">typedef enum{TE_NO_ERROR, /*No error*/TE_ERROR, /*General error*/TE_INVALID_FORMAT, /*Format is invalid*/TE_IMPORT_NOT_SUPPORTED, /*Format is not supported for export*/TE_EXPORT_NOT_SUPPORTED, /*Format is not supported for export*/TE_IMPORT_ERROR, /*General error during import*/TE_EXPORT_ERROR, /*General error during export*/TE_FILE_ERROR, /*Generic file error*/TE_DISK_FULL, /*The disk is full*/TE_FILE_OPEN, /*Error in opening a file*/TE_FILE_READ, /*Error in reading from a file*/TE_FILE_WRITE, /*Error in writing to a file*/TE_FILE_TOO_LARGE, /*File is too large to process*/TE_OUT_OF_MEMORY, /*Insufficient memory to import/export*/TE_METAFILE_CREATION_ERROR, /*Error in creating the metafile*/TE_EXPORT_FILE_EMPTY, /*File to be exported is empty*/TE_CUSTOM/*Custom error message*/}TransError;</PRE>
<P>この列挙型には、変換時にimpexライブラリが生成する可能性のあるエラー値が含まれています。</P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TransErrorInfo"></A>
          <A NAME="S_3f.htm_IX_transError (TransErrorInfo structure field)"></A>
          <A NAME="S_3f.htm_IX_customMsgHandle (TransErrorInfo structure field)"></A>
        <H1 CLASS="refHeading">TransErrorInfo</H1>
<PRE CLASS="syntax">typedef struct{TransError TransError;/*注:customMsgHandleは、TransErrorがTE_CUSTOMの場合にのみ有効です。 */word customMsgHandle;}TransErrorInfo;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TransferBlockID"></A>
        <H1 CLASS="refHeading">TransferBlockID</H1>
<PRE CLASS="syntax">typedef dword TransferBlockID;#define BlockIDFromFileAndBlock(f,b)(((dword)(f)&lt;&lt;16)(b))#define FileFromTransferBlockID(id)((VMFileHandle)((id)>>16))#define BlockFromTransferBlockID(id)((VMBlockHandle)(id))</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_3f.htm_IX_TransMatrix"></A>
          <A NAME="S_3f.htm_IX_TM_e&ldots;"></A>
        <H1 CLASS="refHeading">行列変換</H1>
<PRE CLASS="syntax">typedef struct{WWFixed TM_e11;WWFixed TM_e12;WWFixed TM_e21;WWFixed TM_e22;DWFixed TM_e31;DWFixed TM_e32;}TransMatrix;</PRE>
<P>座標変換行列の6つの可変要素。</P>
</DIV>
<HR>
          <A NAME="S_40.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_VisTravelOption"></A>
          <A NAME="S_40.htm_IX_TravelOption"></A>
          <A NAME="S_40.htm_IX_GenTravelOption"></A>
          <A NAME="S_40.htm_IX_TO_&ldots;"></A>
        <H1 CLASS="refHeading">TravelOption</H1>
<PRE CLASS="syntax">typedef enum{TO_NULL, TO_SELF, TO_OBJ_BLOCK_OUTPUT, TO_PROCESS}TravelOption;/*VisClassはもう1つの移動オプションを定義します:*/typedef enum{TO_VIS_PARENT=_FIRST_VisClass}VisTravelOption;/*GenClassはさらにいくつかの移動オプションを定義します:*/typedef enum/*word*/{TO_GEN_PARENT=_FIRST_GenClass, TO_FOCUS, TO_TARGET, TO_MODEL, TO_SYS_FOCUS, TO_SYS_TARGET, TO_SYS_MODEL}GenTravelOption;</PRE>
<P>この列挙型は、メッセージの受信者を指定するために使用できます。 で設定した値は<CODE>TravelOption</CODE><CODE>VisTravelOption</CODE>、および<CODE>GenTravelOption</CODE>はデフォルト値として設定されています。</P>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_TRUE"></A>
        <H1 CLASS="refHeading">真</H1>
<PRE CLASS="syntax">#define TRUE-1/*比較ではなく、戻り値として使用*/#define FALSE 0</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_TypeFromFormatID() macro"></A>
        <H1 CLASS="refHeading">TypeFromFormatID</H1>
<PRE CLASS="syntax">単語TypeFromFormatID(タイプ);ClipboardItemFormatIDタイプ;</PRE>
<P>このマクロは、指定されたクリップボードのフォーマットIDと製造元の値からフォーマットIDを抽出します。</P>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_UIFunctionsActive"></A>
          <A NAME="S_40.htm_IX_UIFA_&ldots;"></A>
        <H1 CLASS="refHeading">UIFunctionsActive</H1>
<PRE CLASS="syntax">typedef ByteFlags UIFunctionsActive;#define UIFA_SELECT 0x80#define UIFA_MOVE_COPY 0x40#define UIFA_FEATURES 0x20#define UIFA_CONSTRAIN 0x10#define UIFA_PREF_A 0x08#define UIFA_PREF_B 0x04#define UIFA_PREF_C 0x02#define UIFA_IN 0x01#define UIFA_ADJUST 0x08#define UIFA_EXTEND 0x04#define UIFA_MOVE 0x08#define UIFA_COPY 0x04#define UIFA_POPUP 0x08#define UIFA_PAN 0x04</PRE>
<P>これらのフラグは、ユーザ入力のコンテキストを記述し、モーダル情報を提供します。</P>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_UIInterfaceLevel"></A>
        <H1 CLASS="refHeading">UIInterfaceLevel</H1>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserGetInterfaceLevel()">UserGetInterfaceLevel()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_UndoActionDataFlags"></A>
          <A NAME="S_40.htm_IX_UADF_&ldots;"></A>
        <H1 CLASS="refHeading">UndoActionDataFlags</H1>
<PRE CLASS="syntax">typedef struct{dword UADF_flags;word UADF_extraflags;}UndoActionDataFlags;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_UndoActionDataPtr"></A>
          <A NAME="S_40.htm_IX_UADP_&ldots;"></A>
        <H1 CLASS="refHeading">UndoActionDataPtr</H1>
<PRE CLASS="syntax">typedef struct{void*UADP_ptr;word UADP_size;}UndoActionDataPtr;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_UndoActionDataType"></A>
          <A NAME="S_40.htm_IX_UADT_&ldots;"></A>
        <H1 CLASS="refHeading">UndoActionDataType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{UADT_FLAGS, UADT_PTR, UADT_VM_CHAIN, }UndoActionDataType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_UndoActionDataUnion"></A>
          <A NAME="S_40.htm_IX_UADU_&ldots;"></A>
        <H1 CLASS="refHeading">UndoActionDataUnion</H1>
<PRE CLASS="syntax">typedef union{/*この*unionに格納されているデータの型を調べるには、UndoActionStructの*UAS_dataTypeフィールドの値をチェックします。 */UndoActionDataFlags UADU_flags;UndoActionDataPtr UADU_ptr;UndoActionDataVMChain UADU_vmChain;}UndoActionDataUnion;#define NULL_UNDO_CONTEXT 0</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_40.htm_IX_UndoActionDataVMChain"></A>
          <A NAME="S_40.htm_IX_UADVMC_&ldots;"></A>
        <H1 CLASS="refHeading">UndoActionDataVMChain</H1>
<PRE CLASS="syntax">typedef struct{/*この構造体には*MSG_META_UNDOのコードが入ります。 *MSG_GEN_PROCESS_UNDO_ADD_ACTIONに渡されるVMChainsはundo*ファイル内にある必要があります(これは*MSG_GEN_PROCESS_UNDO_GET_FILEを送信することで取得できます)。 */vmChain UADVMC_vmChain;VMFileHandle UADVMC_ファイル;}UndoActionDataVMChain;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_41.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_41.htm_IX_UndoActionStruct"></A>
          <A NAME="S_41.htm_IX_UAS_&ldots;"></A>
        <H1 CLASS="refHeading">UndoActionStruct</H1>
<PRE CLASS="syntax">typedef struct{UndoActionDataType UAS_dataType;UndoActionDataUnion UAS_data;dword UAS_appType;}UndoActionStruct;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_41.htm_IX_UtilAsciiToHexError"></A>
        <H1 CLASS="refHeading">UtilAsciiToHexError</H1>
<P>詳細については<CODE>UtilAsciiToHex32()</CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_41.htm_IX_UtilHexToAsciiFlags"></A>
          <A NAME="S_41.htm_IX_UHTAF_&ldots;"></A>
        <H1 CLASS="refHeading">UtilHexToAsciiFlags</H1>
<PRE CLASS="syntax">typedef WordFlags UtilHexToAsciiFlags;#define UHTAF_INCLUDE_LEADING_ZEROS 0x0002#define UHTAF_NULL_TERMINATE 0x0001</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_41.htm_IX_VarDataCHandler"></A>
        <H1 CLASS="refHeading">VarDataCHandler</H1>
<PRE CLASS="syntax">typedef struct{word VDCH_dataType;void(*VDCH_handler)(MemHandle mh, ChunkHandle ch, VarDataEntry*extraData, word dataType, void*handlerData);</PRE>
<PRE CLASS="syntax">}VarDataCHandler;</PRE>
<P>詳細については<CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_ObjVarScanData()">ObjVarScanData()</A></CODE>ボタンをクリックし</P>
</DIV>
<DIV>
          <A NAME="S_41.htm_IX_VarDataEntry"></A>
          <A NAME="S_41.htm_IX_VDE_&ldots;"></A>
        <H1 CLASS="refHeading">VarDataEntry</H1>
<PRE CLASS="syntax">typedef struct{word VDE_dataType;/*vardataデータ型*/word VDE_entrySize;/*追加データのサイズ;このフィールドは、*型に追加データがある場合にのみ存在します。*/</PRE>
<PRE CLASS="syntax">}VarDataEntry;#define VDE_extraData sizeof(VarDataEntry);</PRE>
<P>変数データ入力の構造。 データ型に余分なデータがない場合<CODE>VDEエントリサイズ</CODE>見出しページを開きます。 追加データはオフセットから始まります。<CODE>VDE_extraData</CODE>(上記で定義)。</P>
</DIV>
<DIV>
          <A NAME="S_41.htm_IX_VarDataFlags"></A>
          <A NAME="S_41.htm_IX_VDF_&ldots;"></A>
        <H1 CLASS="refHeading">VarDataFlags</H1>
<PRE CLASS="syntax">typedef WordFlags VarDataFlags;#define VDF_TYPE 0 xfffc/*14ビットデータタイプ*/#define VDF_EXTRA_DATA 0x0002/*追加データがある場合に設定*/#define VDF_SAVE_TO_STATE 0x0001/*タイプが状態に保存された場合に設定*/</PRE>
<P>これは、3つのフィールドを含むワードレコードです。 このワードはvardata構造体の<CODE>VDEデータ型</CODE>フィールド(<CODE>VarDataEntry</CODE>(上記参照)。</P>
</DIV>
<DIV>
          <A NAME="S_41.htm_IX_VardataKey"></A>
        <H1 CLASS="refHeading">VarDataKey</H1>
<PRE CLASS="syntax">typedef word VardataKey;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_41.htm_IX_VarObjRelocation"></A>
          <A NAME="S_41.htm_IX_VOR_&ldots;"></A>
        <H1 CLASS="refHeading">VarObjRelocation</H1>
<PRE CLASS="syntax">typedef struct{VarDataFlags VOR_type;/*タイプとタグ*/ワードVOR_offset;}VarObjRelocation;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_42.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_42.htm_IX_VChar"></A>
          <A NAME="S_42.htm_IX_VC_&ldots;"></A>
        <H1 CLASS="refHeading">ベクトル文字</H1>
<PRE CLASS="syntax">typedef ByteEnum VChar;#define VC_NULL 0x0/*NULL*/#define VC_CTRL_A 0x1/*&lt;ctrl>-A*/#define VC_CTRL_B 0x2/*&lt;ctrl>-B*/#define VC_CTRL_C 0x3/*&lt;ctrl>-C*/#define VC_CTRL_C 0x4/*&lt;ctrl>-D*/#define VC_CTRL_E 0x5/*&lt;ctrl>-E*/#define VC_CTRL_F 0x6/*&lt;ctrl>-F*/#define VC_CTRL_G 0x7/*&lt;ctrl>-H*/#define VC_CTRL_J 0 xa/*&lt;ctrl>-J*/#define VC_CTRL_L 0 xc/*&lt;ctrl>-L*/#define VC_CTRL_Q 0x11/*&lt;ctrl>-Q*/#define VC_CTRL_R 0x12/*&lt;ctrl>-R*/#define VC_CTRL_T 0x16/*&lt;ctrl>-W*/#define VC_CTRL_W 0x17/*&lt;ctrl>-X*/#define VC_CTRL_Y 0x19/*&lt;ctrl>-Y*/#define VC_CTRL_Z 0x1a/*&lt;ctrl>-Z*/#define VC_ESCAPE 0x1b/*ESC*/#define VC_CTRLブランク0x20/*スペース*//**テンキーキー*/</PRE>
<PRE CLASS="syntax">#define VC_NUMPAD_ENTER 0 xd/*PS/2キーボードのみ*/#define VC_NUMPAD_DIV`/&#39;/*PS/2キーボードのみ*/#define VC_NUMPAD_MULT`*&#39;#define VC_NUMPAD_PLUS`+&#39;#define VC_NUMPAD_MINUS`-&#39;#define VC_NUMPAD_PERIOD`&#39; #define VC_NUMPAD_0`0&#39;#define VC_NUMPAD_1`1&#39;#define VC_NUMPAD_2`2&#39;#define VC_NUMPAD_3`3&#39;#define VC_NUMPAD_4`4&#39;#define VC_NUMPAD_5`5&#39;#define VC_NUMPAD_6`6&#39;#define VC_NUMPAD_7`7&#39;#define VC_NUMPAD_8`8&#39;#define VC_NUMPAD_9`9&#39;/**拡張キーボードコード--非ASCII*/</PRE>
<PRE CLASS="syntax">#define VC_F1 0x80/*ファンクションキー*/#define VC_F2 0x81#define VC_F3 0x82#define VC_F4 0x83#define VC_F5 0x84#define VC_F6 0x83#define VC_F5 0x84#define VC_F8 0x87#define VC_F9 0x88#define VC_F10 0x89#define VC_F11 0x8a/*PS/2キーボードのみ*/#define VC_F12 0x8b/*PS/2キーボードのみ*/#define VC_F13 0x8c/*非標準キー*/#define VC_F14 0x8d/*非標準キー*/#define VC_F15 0x8e/*非標準キー*/#define VC_RIGHT 0x92#define VC_LEFT 0x93#define VC_HOME 0x90/*カーソルキー*/#define VC_END 0x95#define VC_PREVIOUS 0x96#define VC_NEXT 0x97#define VC_INS 0x98/*INS*/#define VC_PAUSE 0x9c/*from&lt;shift>-NUMPAD_MULT*/#define VC_PAUSE 0x9c/*from&lt;ctrl>-NUMLOCK*/#define VC_BREAK 0x9e/*from&lt;ctrl>-or&lt;alt>-combo*/#define VC_SYSTEMRESET 0x9f/*&lt;ctrl>-&lt;alt>-&lt;del>combo*//**ジョイスティックコントロールキー(0xa0-0xa9)*/#define VC_JOYSTICK_0 0xa0;ジョイスティック0度#define VC_JOYSTICK_45 0xa1;ジョイスティック45度#define VC_JOYSTICK_90 0xa2;ジョイスティック90度#define VC_JOYSTICK_135 0xa3;ジョイスティック135度#define VC_JOYSTICK_180 0xa4;ジョイスティック180度#define VC_JOYSTICK_225 0xa5;ジョイスティック225度#define VC_JOYSTICK_270 0xa6;ジョイスティック270度#define VC_JOYSTICK_315 0xa7;ジョイスティック315度#define VC_FIRE_BUTTON_1 0xa8;fire button#1#define VC_FIRE_BUTTON_2 0xa9;fire button#2/**Shiftキー(0xe0-0xe7)*/</PRE>
<PRE CLASS="syntax">#define VC_LALT 0xe0#define VC_RALT 0xe1#define VC_LCTRL 0xe2#define VC_RCTRL 0xe3#define VC_LSHIFT 0xe4#define VC_RSHIFT 0xe5#define VC_SYSREQ 0xe6/*Not on base PC keyboard*/#define VC_ALT_GR 0xe7/**Toggle state keys(0xe8-0 xef)*/</PRE>
<PRE CLASS="syntax">#define VC_CAPSLOCK 0xe8#define VC_NUMLOCK 0xe9#define VC_SCROLLLOCK 0 xea/**拡張状態キー(0xf0-0xf7)*/</PRE>
<PRE CLASS="syntax">#define VC_INVALID_KEY 0 xff#define VC_BACKSPACE VC_CTRL_H#define VC_TAB VC_CTRL_I#define VC_LF VC_CTRL_J#define VC_ENTER VC_CTRL_M</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_43.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VisRulerType"></A>
          <A NAME="S_43.htm_IX_VRT_&ldots;"></A>
        <H1 CLASS="refHeading">VisRulerType</H1>
<PRE CLASS="syntax">typedef ByteEnum VisRulerType;#define VRT_INCHES 0#define VRT_CENTIMETERS 1#define VRT_POINTS 2#define VRT_PICAS 3#define VRT_CUSTOM CUSTOM_RULER_DEFINITION#define VRT_NONE NO_RULER#define VRT_DEFAULT SYSTEM_DEFAULT</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VisTextVariableType"></A>
        <H1 CLASS="refHeading">VisTextVariableType</H1>
<PRE CLASS="syntax">typedef enum{VTVT_PAGE_NUMBER, VTVT_PAGE_NUMBER_IN_SECTION, VTVT_NUMBER_OF_PAGES, VTVT_NUMBER_OF_PAGES_IN_SECTION, VTVT_SECTION_NUMBER, VTVT_NUMBER_OF_SECTIONS, VTVT_CREATION_DATE_TIME, VTVT_MODIFICATION_DATE_TIME, VTVT_CURRENT_DATE_TIME, VTVT_STORED_DATE_TIME, }VisTextVariableType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VisTravelOption"></A>
          <A NAME="S_43.htm_IX_VisTravelOption"></A>
          <A NAME="S_43.htm_IX_VisTravelOption"></A>
        <H1 CLASS="refHeading">VisTravelOption</H1>
<P>の<CODE>VisClass</CODE>標準の代わりに使用される列挙値を定義します<CODE>TravelOption</CODE>のエントリを参照してください。<CODE>TravelOption</CODE>すべての可能な値を表示します。</P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VisUpdateMode"></A>
          <A NAME="S_43.htm_IX_VUM_&ldots;"></A>
        <H1 CLASS="refHeading">VisUpdateMode</H1>
<PRE CLASS="syntax">typedef ByteEnum VisUpdateMode;#define VUM_MANUAL 0#define VUM_NOW 1#define VUM_DELAYED_VIA_UI_QUEUE 2#define VUM_DELAYED_VIA_APP_QUEUE 3</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VMAccessFlags"></A>
          <A NAME="S_43.htm_IX_VMAF_&ldots;"></A>
        <H1 CLASS="refHeading">VMAccessFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags VMAccessFlags;#define VMAF_FORCE_READ_ONLY 0x80#define VMAF_FORCE_READ_WRITE 0x40#define VMAF_ALLOW_SHARED_MEMORY 0x20#define VMAF_FORCE_DENY_WRITE 0x10#define VMAF_DISALLOW_SHARED_MULTIPLE 0x08#define VMAF_USE_BLOCK_LEVEL_SYNCHRONIZATION 0x04</PRE>
<P>の<CODE>VMAccessFlags</CODE>呼び出し側が必要とするファイルへのアクセスの種類を指定します。 次のフラグを使用できます。</P>
<DL>
<DT>VMAF_FORCE_READ_ONLY(VMAF強制読み取り専用)</DT><DD>設定されている場合、デフォルトで読み取り/書き込みでファイルを開く場合でも、ファイルは読み取り専用で開かれます。 読み取り専用ファイル内のブロックは変更できません。また、メモリー・ブロック内の変更はディスクVMブロックに更新されません。</DD>
<DT>VMAF_FORCE_READ_WRITE(VMAF強制読み取り書き込み)</DT><DD>設定されている場合、デフォルトで読み取り専用アクセスでファイルが開かれる場合でも、読み取り/書き込みアクセスでファイルが開かれます。</DD>
<DT>VMAF共有メモリ</DT><DD>設定されている場合、VMマネージャはVMブロックをロックするときに共有メモリの使用を試みる必要があります。つまり、どのスレッドがブロックをロックしても、同じメモリブロックが特定のVMブロックに使用されます。</DD>
<DT>VMAF_FORCE_DENY_WRITE(VMAF強制拒否書き込み)</DT><DD>設定されている場合は、ファイルdeny-writeを開きます。つまり、他のスレッドは読み取り/書き込みアクセス用にファイルを開くことができません。</DD>
<DT>VMAF_DISALLOW_SHARED_MULTIPLE(複数の共有を許可しない)</DT><DD>このフラグが設定されている場合、ファイル属性GFHF_SHARED_MULTIPLEを持つファイルは開けません。</DD>
<DT>VMAF_USE_BLOCK_LEVEL_SYNCHRONIZATION(VMAF_USE_BLOCK_LEVEL_</DT><DD>設定されている場合、VMマネージャのブロックレベルの同期メカニズムで十分であると見なされます。より制限的なStartExclusive/EndExclusiveメカニズムは使用されません。 これは主にシステムソフトウェアを対象としています。</DD>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VMAttributes"></A>
          <A NAME="S_43.htm_IX_VMA_&ldots;"></A>
        </DL>
<H1 CLASS="refHeading">VMAttributes</H1>
<PRE CLASS="syntax">typedef ByteFlags VMAttributes;#define VMA_SYNC_UPDATE 0x80#define VMA_BACKUP 0x40#define VMA_OBJECT_RELOC 0x20#define VMA_PRESERVE_HANDLES 0x10#define VMA_NOTIFY_DIRTY 0x08#define VMA_NO_DISCARD_IF_IN_USE 0x04#define VMA_COMPACT_OBJ_BLOCK 0x02#define VMA_SINGLE_THREAD_ACCESS 0x01/**オブジェクトブロックに設定する必要がある属性:*/</PRE>
<PRE CLASS="syntax">#define VMA_OBJECT_ATTRS(VMA_OBJECT_RELOC VMA_PRESERVE_HANDLESVA_NO_DISCARD_IF_IN_USE VMA_SINGLE_THREAD_ACCESS)</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VMBlockHandle"></A>
        <H1 CLASS="refHeading">VMBlockHandle</H1>
<PRE CLASS="syntax">typedef word VMBlockHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VMChain"></A>
        <H1 CLASS="refHeading">VMChain</H1>
<PRE CLASS="syntax">typedef dword VMChain;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VMChainLink"></A>
          <A NAME="S_43.htm_IX_VMC_next"></A>
        <H1 CLASS="refHeading">VMChainLink</H1>
<PRE CLASS="syntax">typedef struct{VMBlockHandle VMC_next;}VMChainLink;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VMChainTree"></A>
          <A NAME="S_43.htm_IX_VMCT_&ldots;"></A>
        <H1 CLASS="refHeading">VMChainTree</H1>
<PRE CLASS="syntax">typedef struct{VMChainLink VMCT_meta;word VMCT_offset;word VMCT_count;}VMChainTree;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VMFileHandle"></A>
        <H1 CLASS="refHeading">VMFileHandle</H1>
<PRE CLASS="syntax">typedefハンドルVMFileHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_43.htm_IX_VMInfoStruct"></A>
        <H1 CLASS="refHeading">VMInfoStruct</H1>
<PRE CLASS="syntax">typedef struct{MemHandle mh;word size;word userId;}VMInfoStruct;</PRE>
<P> </P>
</DIV>
<HR>
          <A NAME="S_44.htm"></A>
        <DIV>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_VMOpenType"></A>
          <A NAME="S_44.htm_IX_VMO_&ldots;  (VMOpenType type)"></A>
        <H1 CLASS="refHeading">VMOpenType</H1>
<PRE CLASS="syntax">typedef ByteEnum VMOpenType;#define VMO_OPEN 0#define VMO_TEMP_FILE 1#define VMO_CREATE 2#define VMO_CREATE_ONLY 3#define VMO_CREATE_TRUNCATE 4#define VMO_NATIVE_WITH_EXT_ATTRS 0x80</PRE>
<P>次のタイプを使用できます。</P>
<DL>
<DT>VMO_TEMP_ファイル</DT><DD>これが渡された場合、ファイルは一時データファイルになります。 一時ファイルを作成するときは、ファイル名ではなくディレクトリパスを指定します。 パスの後には、文字列の終端のヌルを含めて、14のヌルバイトが続く必要があります。 システムによって適切なファイル名が選択され、パス文字列に追加されます。</DD>
<DT>VMO_CREATE_ONLY(VMO作成のみ)</DT><DD>これが渡されると、ドキュメントが作成されます。 指定した名前のドキュメントがすでにワーキングディレクトリに存在する場合は<CODE><A HREF="../../CRef/Routines/R_a3.htm#IX_VMOpen()">VMを開く()</A></CODE>はエラー状態を返す。</DD>
<DT>VMO_CREATE[VMO作成]</DT><DD>これが渡されると、ファイルがまだ存在しない場合は作成され、存在しない場合は開かれます。</DD>
<DT>VMO_CREATE_TRUNCATE(省略)</DT><DD>これが渡されると、ファイルがまだ存在しない場合は作成されます。存在しない場合は、開かれて切り捨てられます(すべてのデータ・ブロックが解放されます)。</DD>
<DT>VMO_オープン</DT><DD>既存のファイルを開きます。 ファイルが存在しない場合は、エラー状態を返します。</DD>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_VMOperation"></A>
          <A NAME="S_44.htm_IX_VMO_&ldots;  (VMOperation type)"></A>
        </DL>
<H1 CLASS="refHeading">VMOperation</H1>
<PRE CLASS="syntax">typedef enum{VMO_READ, VMO_INTERNAL, VMO_SAVE, VMO_SAVE_AS, VMO_REVERT, VMO_UPDATE, VMO_WRITE}VMOperation;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_VMRelocType"></A>
          <A NAME="S_44.htm_IX_VMRT_&ldots;"></A>
        <H1 CLASS="refHeading">VMRelocType</H1>
<PRE CLASS="syntax">typedef enum{VMRT_UNRELOCATE_BEFORE_WRITE, VMRT_RELOCATE_AFTER_READ, VMRT_RELOCATE_AFTER_WRITE, VMRT_RELOCATE_FROM_RESOURCE, VMRT_UNRELOCATE_FROM_RESOURCE, }VMRelocType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_VMStartExlusiveReturnValue"></A>
          <A NAME="S_44.htm_IX_VMSERV_&ldots;"></A>
        <H1 CLASS="refHeading">VMStartExclusiveReturnValue</H1>
<PRE CLASS="syntax">typedef enum{VMSERV_NO_CHANGES, VMSERV_CHANGES, VMSERV_TIMEOUT}VMStartExclusiveReturnValue;</PRE>
<P><CODE><A HREF="../../CRef/Routines/R_a3.htm#IX_VMGrabExclusive()">VMGrabExclusive()</A></CODE>は、この列挙型のメンバーを返します。 次のいずれかの値を指定できます。</P>
<DL>
<DT>VMSERV_変更なし</DT><DD>このスレッドが最後にファイルにアクセスして以来、他のスレッドはこのファイルを変更していません。</DD>
<DT>VMSERVの変更</DT><DD>ファイルは、このスレッドが最後にアクセスしたときから変更されている可能性があります。スレッドは適切なアクション(キャッシュされたデータの再読み込みなど)を実行する必要があります。</DD>
<DT>VMSERV_タイムアウト</DT><DD>この呼び出しは<CODE><A HREF="../../CRef/Routines/R_a3.htm#IX_VMGrabExclusive()">VMGrabExclusive()</A></CODE>が失敗し、ファイルにアクセスできないままタイムアウトしました。</DD>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_VolumeName"></A>
          <A NAME="S_44.htm_IX_VOLUME_BUFFER_SIZE"></A>
        </DL>
<H1 CLASS="refHeading">ボリューム名</H1>
<PRE CLASS="syntax">typedef char VolumeName[VOLUME_BUFFER_SIZE];と入力します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WBFixed"></A>
          <A NAME="S_44.htm_IX_WBF_&ldots;"></A>
        <H1 CLASS="refHeading">WBFixed</H1>
<PRE CLASS="syntax">typedef struct{byte WBF_frac;word WBF_int;}WBFixed;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_wchar"></A>
        <H1 CLASS="refHeading">文字</H1>
<PRE CLASS="syntax">typedef unsigned int wchar;と入力します。</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WindowHandle"></A>
        <H1 CLASS="refHeading">ウィンドウハンドル</H1>
<PRE CLASS="syntax">typedefハンドルWindowHandle;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WinInfoType"></A>
          <A NAME="S_44.htm_IX_WIT_&ldots;"></A>
        <H1 CLASS="refHeading">WinInfoType</H1>
<PRE CLASS="syntax">typedef enum/*word*/{WIT_PRIVATE_DATA=0, WIT_COLOR=2, WIT_INPUT_OBJ=4, WIT_EXPOSURE_OBJ=6, WIT_STRATEGY=8, WIT_FLAGS=10, WIT_LAYER_ID=12, WIT_PARENT_WIN=14, WIT_FIRST_CHILD_WIN=16, WIT_LAST_CHILD_WIN=18, WIT_PREV_SIBLING_WIN=20, WIT_NEXT_SIBLING_WIN=22, WIT_PRIORITY=24, }WinInfoType;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WinInvalFlag"></A>
          <A NAME="S_44.htm_IX_WIF_&ldots;"></A>
        <H1 CLASS="refHeading">WinInvalFlag</H1>
<PRE CLASS="syntax">typedef ByteEnum WinInvalFlag;#define WIF_INVALIDATE 0#define WIF_DONT_INVALIDATE 1</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WinPassFlags"></A>
          <A NAME="S_44.htm_IX_WPF_&ldots;"></A>
        <H1 CLASS="refHeading">WinPassFlags</H1>
<PRE CLASS="syntax">typedef WordFlags WinPassFlags;#define WPF_CREATE_GSTATE 0x8000#define WPF_ROOT 0x4000#define WPF_SAVE_UNDER 0x2000#define WPF_INIT_EXCLUDED 0x1000#define WPF_PLACE_BEHIND 0x0800#define WPF_PLACE_LAYER_BEHIND 0x0400#define WPF_LAYER 0x0200#define WPF_ABS 0x0100#define WPF_PRIORITY 0x00ff</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WinPriority"></A>
          <A NAME="S_44.htm_IX_WIN_PRIO_&ldots;"></A>
        <H1 CLASS="refHeading">WinPriority</H1>
<PRE CLASS="syntax">typedef ByteEnum WinPriority;#define WIN_PRIO_POPUP 4#define WIN_PRIO_MODAL 6#define WIN_PRIO_ON_TOP 8#define WIN_PRIO_COMMAND 10#define WIN_PRIO_STD 12#define WIN_PRIO_ON_BOTTOM 14</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_word"></A>
        <H1 CLASS="refHeading">言葉</H1>
<PRE CLASS="syntax">typedef unsigned int word;符号なしint word;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WordAndAHalf"></A>
          <A NAME="S_44.htm_IX_WAAH_&ldots;"></A>
        <H1 CLASS="refHeading">WordAndAHalf</H1>
<PRE CLASS="syntax">typedef struct{word WAAH_low;byte WAAH_high;}WordAndAHalf;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WordFlags"></A>
        <H1 CLASS="refHeading">WordFlags</H1>
<PRE CLASS="syntax">typedef word WordFlags;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WWFixed"></A>
          <A NAME="S_44.htm_IX_WWF_&ldots;"></A>
        <H1 CLASS="refHeading">WWFixed</H1>
<PRE CLASS="syntax">typedef struct{word WWF_frac;word WWF_int;}WWFixed;</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_WWFixedAsDWord"></A>
        <H1 CLASS="refHeading">WWFixedAsDWord</H1>
<PRE CLASS="syntax">typedef dワードWWFixedAsDWord</PRE>
<P> </P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_XYOffset"></A>
          <A NAME="S_44.htm_IX_XYO_&ldots;"></A>
        <H1 CLASS="refHeading">XYオフセット</H1>
<PRE CLASS="syntax">typedef struct{sword XYO_x;sword XYO_y;}XYOffset;&lt;値></PRE>
<P>グラフィックス座標のオフセット。</P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_XYSize"></A>
          <A NAME="S_44.htm_IX_XYS_&ldots;"></A>
        <H1 CLASS="refHeading">XYSize</H1>
<PRE CLASS="syntax">typedef struct{word XYS_width;word XYS_height;}XYSize;</PRE>
<P>2次元でのグラフィックサイズ。</P>
</DIV>
<DIV>
          <A NAME="S_44.htm_IX_XYValueAsDWord"></A>
        <H1 CLASS="refHeading">XYValueAsDWord</H1>
<PRE CLASS="syntax">typedef dword XYValueAsDWord;</PRE>
<P>DWordで表された2次元のグラフィックサイズ。</P>
</DIV>
<HR>このドキュメントは<A HREF="index.htm">複数ページのドキュメント</A>簡単な印刷に適しています。</BODY>
</HTML>
