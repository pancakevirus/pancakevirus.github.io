<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><meta http-equiv="Content-Type" content="text/html; charset=utf8">
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>スレッドとセマフォー</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">このドキュメントは<A HREF="index.htm">複数ページのドキュメント</A>簡単な印刷に適しています。<A NAME="index.htm"></A><H1 CLASS="chapterTitle"><A NAME="index.htm_38783"></A>スレッドとセマフォー</H1>
<P><A NAME="index.htm_IX_Threads"></A><A NAME="index.htm_IX_Multithreading"></A>GEOSの最も印象的な機能の1つは、最も処理能力の低いPCでも複数のタスクを同時に実行できることです。 もちろん、PCにはプロセッサが1つしかなく、一度に実行できる命令は1つだけです。 GEOSは、さまざまなタスクを追跡します。<EM>スレッド</EM>1秒間に何度もスレッドを切り替えることで、PCが実際にすべてのジョブを同時に実行しているような錯覚を引き起こします。</P>
<P>この章では、次の内容について説明</P>
<UL>
<LI>マルチタスキングの基本概念</LI>
<LI>GEOSマルチタスキング・スキーム</LI>
<LI>マルチスレッド・アプリケーションを作成する手順</LI>
<LI>セマフォーを使用してスレッドを同期し、デッドロックを回避する。</LI>
</UL>
<P>マルチスレッドアプリケーションを作成する場合は、この付録に記載されている情報を知っておく必要があります。 アプリケーションがシングルスレッドの場合、または標準のGEOSデュアルスレッドアーキテクチャを使用する場合は、付録の情報は必須ではありません。 デュアルスレッドアプリケーションの場合<CODE>@呼び出し</CODE>ユーザー・インターフェース・スレッドによって実行されるオブジェクトから、アプリケーションの他のスレッドによって実行されるオブジェクトへ。</P>
<P CLASS="sectionlinks">
          <STRONG>
            <A HREF="#MultiThread_1.htm">1 マルチタスクの目標</A>
            <BR>
            <A HREF="#MultiThread_2.htm">2 マルチタスクの2つのモデル</A>
            <BR>
            <A HREF="#MultiThread_3.htm">2.1 協調型マルチタスク処理</A>
            <BR>
            <A HREF="#MultiThread_4.htm">2.2 プリエンプティブ・マルチタスク処理</A>
            <BR>
            <A HREF="#MultiThread_5.htm">3 GEOSマルチタスク処理</A>
            <BR>
            <A HREF="#MultiThread_6.htm">3.1 GEOSスレッド</A>
            <BR>
            <A HREF="#MultiThread_7.htm">3.2 コンテキストスイッチ</A>
            <BR>
            <A HREF="#MultiThread_8.htm">3.3 スレッドのスケジューリング</A>
            <BR>
            <A HREF="#MultiThread_9.htm">3.4 アプリケーションとスレッド</A>
            <BR>
            <A HREF="#MultiThread_a.htm">4 複数スレッドの使用</A>
            <BR>
            <A HREF="#MultiThread_b.htm">4.1 GEOSスレッドの作成方法</A>
            <BR>
            <A HREF="#MultiThread_c.htm">4.2 優先度値の管理</A>
            <BR>
            <A HREF="#MultiThread_d.htm">4.3 スレッドでのエラー処理</A>
            <BR>
            <A HREF="#MultiThread_e.htm">4.4 スレッドが終了したとき</A>
            <BR>
            <A HREF="#MultiThread_f.htm">5 スレッドの同期</A>
            <BR>
            <A HREF="#MultiThread_10.htm">5.1 セマフォ: コンセプト</A>
            <BR>
            <A HREF="#MultiThread_11.htm">5.2 GEOSのセマフォ</A>
            <BR>
          </STRONG>
        </P> <!-- end of sectionlinks blob -->

<HR>
          <A NAME="MultiThread_1.htm"></A>
        <H2 CLASS="sectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:1マルチタスクの目標</H2>
<P>GEOSマルチタスクシステムは、今日のPCで利用可能な最も洗練されたシステムの1つである。 最新のテクノロジーを使用して設計され、次の2つの主な目標を達成するために作成されました。</P>
<UL>
<LI>迅速な対応<BR>GEOSマルチタスクシステムは、ユーザ入力への迅速な応答に重点を置いて設計された。 ユーザーの行動に対する迅速で目に見える反応は、スピードの知覚に寄与する唯一の最も重要な要素である。 たとえば、ユーザーがスプレッドシート内の要素を変更し(スプレッドシート全体を再計算する必要があります)、メニューをプルダウンした場合、ユーザーはそのメニューをすぐに表示したいと考えます。 計算が終了するまでメニューが表示されない場合は、システムの動作が遅くなります。 計算に数秒以上かかる場合、ユーザーはシステムが完全にクラッシュしたのではないかと考えるかもしれません。</LI>
<LI>プログラミングの容易さ<BR>プログラマーの仕事を簡単にすることが、GEOSのマルチタスク設計のもう1つの動機です。 理想的には、プログラマーは自分のプログラムがマルチタスク環境で実行されることを認識する必要がないはずです。 プログラムは、システム上で実行されている唯一のプログラムであるかのように処理されます。 ある種の「善良な市民」の規則に加えて、アプリケーションプログラムはマルチタスク環境から分離されている。 一方、プログラマが(複数のタスクを同時に実行するようにプログラムを設計することによって)GEOSのマルチタスク機能を利用したい場合、システムはこれを可能な限り単純かつ効率的にするように設計されている。</LI>
</UL>
<HR>
          <A NAME="MultiThread_2.htm"></A>
        <H2 CLASS="sectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:2マルチタスクの2つのモデル</H2>
<P>多くのオペレーティング・システムでは、複数のタスクを同時に実行する機能が提供されています。 各オペレーティング・システムにはこれを管理する独自の方法がありますが、マルチタスクには2つの基本的なタイプがあります。協調型(Microsoft Windowsで使用)とプリエンプティブ型(GEOSで使用)です。</P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_3.htm">協調型マルチタスク処理</A>
        </P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_4.htm">プリエンプティブなマルチタスク処理</A>
        </P>
<HR>
          <A NAME="MultiThread_3.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:2.1人<A HREF="#MultiThread_2.htm">マルチタスク処理の2つのモデル</A>:協調型マルチタスク処理</H3>
<P>協調型マルチタスクシステムは、その名が示すように、さまざまなプログラムが協調するシステムである。 彼らはシステムとその資源を共有することに同意する。 システムの下で実行される各プログラムは、実際に実行されている間、完全な制御を持ちます。 都合の良い場所に到達すると、特別なシステムルーチン(コンテキストスイッチルーチンと呼ばれる)を呼び出して、他のプログラムが作業を行っているかどうかを確認することがよくあります。 もしそうであれば、そのプログラムは都合の良い停止点に達するまでシステムを制御し、次の待機中のプログラムに制御を渡す。 複数のプログラムの実行準備ができている場合は、最初のプログラムが再び実行される前に各プログラムが実行される機会を得られるように、キューで待機します。 (また、あるプログラムが他のプログラムよりも高い優先度を持つ協調的マルチタスクシステムを実装することも可能である。 この場合、コンテキストスイッチルーチンでは、次に実行するプログラムを決定するために、より複雑なアルゴリズムが使用される可能性があります)。</P>
<P>協調型マルチタスクシステムの円滑な動作には、すべてのプログラムがコンテキストスイッチルーチンを頻繁に呼び出すように記述されている必要がある。 大規模な計算が実行されている場合、プログラマはこの要件を不便に感じる傾向があります。 適切に動作するプログラム(すなわち、あまりにも長い間プロセッサの制御を維持しないプログラム)を書くことは、特に困難である。なぜなら、ほとんどの協調的マルチタスクシステムは、コンテキストスイッチがいつ発生するかについて制限を課しているからである。</P>
<HR>
          <A NAME="MultiThread_4.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:2.2人<A HREF="#MultiThread_2.htm">マルチタスク処理の2つのモデル</A>:プリエンプティブ・マルチタスク</H3>
<P>プリエンプティブ・マルチタスク・システムでは、プログラムはシステムの制御を自発的に放棄する必要はない。 コンテキストスイッチルーチンを呼び出す代わりに、プログラムは最初から最後まで連続して実行されるように書かれています。 ハードウェアは1秒間に何度もタイマー割り込みを生成し、その割り込みがカーネルのコンテキストスイッチメカニズムをトリガします。</P>
<P>コンテキストスイッチは、他の割り込みによってトリガすることもできます。 たとえば、ユーザーがGEOSでマウスを動かすと、マウスは割り込みを生成します。 GEOSは、入力スレッドを実行可能とマークすることで応答します。スレッドは、割り込みが完了した後に実行されます。 このようにして、GEOSはユーザー入力に対して並外れた応答時間を実現している。</P>
<P>プリエンプティブ・マルチタスクでは、各プログラムが連続して実行されているように錯覚し、システムを完全に制御することができる。 また、アプリケーションが新しい結果を忙しく計算している場合でも、システムはユーザーと迅速に対話することができる。</P>
<P>たとえば、スプレッドシートプログラムは、タイマー割り込みによってコンテキストスイッチが発生するまで実行を続けることができます。 その後、メニューの描画を担当するプログラムなど、他のプログラムが順番に実行されます。 ユーザーがプルダウンメニューをクリックすると、そのメニューが表示されます。 表計算プログラムがシステムの制御を取り戻すと、中断された場所から続行することができ、幸いなことに、このいずれかが行われたことに気づかない。</P>
<P>プリエンプティブ・マルチタスキングは、ユーザーとアプリケーション・プログラマーにとってほとんどのことを簡単にしますが、GEOSのようなプリエンプティブ・マルチタスキング・システム用のプログラムを作成する際に考慮すべき重要な問題がいくつかあります。 コンテキストスイッチがタイマー割り込みによって制御される場合、それらは任意の2つの命令の間に発生する可能性があります。 データ構造の更新中にプログラムが中断された場合、別のスレッドが実行されている間、そのデータ構造は矛盾した状態のままになる可能性があります。 システム上で実行されている他のプロセスがデータ構造にアクセスしていない場合は、問題はありません。プログラムが再開されると、更新は完了します。 ただし、一部のデータ構造(システムリソースを含む)は、複数のプログラムによってアクセスされる場合があります。 同じデータに対する2つの更新が同時に行われないようにすることが重要です。</P>
<P>この問題は、ネットワークユーザがよく経験する問題に似ています。 テキストファイルが2人の異なるユーザによって同時に編集されていて、両方のユーザがファイルへの変更を保存する場合、最初に保存したユーザのバージョンはもう一方のユーザによって上書きされます。 多くのシステムには、ファイルの編集中にファイルをロックする手段があります。ロックされている間は、他のユーザーはファイルの編集を開始できません。 プリエンプティブ・マルチタスク・システムは、同じデータ構造への2つのアクセスが同時に発生するのを防ぐために、同様のロック・スキームを持たなければならない。 ロック機構は、プログラマに対してできる限り透過的であるべきである。 たとえば、システム・リソースのロックとロック解除は自動的に行われるため、アプリケーション・プログラマーはそれに関与する必要はありません。</P>
<P>これはまさに、GEOSがリソースを調整する方法です。これについては、次のセクションで説明します。</P>
<HR>
          <A NAME="MultiThread_5.htm"></A>
        <H2 CLASS="sectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:3 GEOSマルチタスク処理</H2>
<P><A NAME="MultiThread_5.htm_IX_Applications:multithreaded"></A>GEOSは、プリエンプティブ・マルチタスク方式を実装している。 アプリケーションプログラムは、ある種の「善良な市民」の規則に従うことを要求され、そうでなければ、システム上に自分だけがいるという幻想を与えられる。 アプリケーション自体は、ほとんどの場合、マルチタスク環境から分離されています。</P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_6.htm">GEOSスレッド</A>
        </P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_7.htm">コンテキストスイッチ</A>
        </P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_8.htm">スレッドのスケジューリング</A>
        </P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_9.htm">アプリケーションとスレッド</A>
        </P>
<HR>
          <A NAME="MultiThread_6.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:3.1人<A HREF="#MultiThread_5.htm">GEOSマルチタスク処理</A>:GEOSスレッド</H3>
<P><A NAME="MultiThread_6.htm_IX_Event queues"></A>GEOSでは、システム内で順番に実行されるさまざまなユニットを「スレッド」と呼びます。 スレッドは異なる優先順位を持つことができます。優先順位の高いスレッド(低い優先順位番号で示されます)は、一般にプロセッサ時間が長くなります。</P>

<H4 CLASS="HeadingCApp">スレッドの追跡</H4>
<P>スレッド間を切り替えるために、システムは各スレッドに関する特定の事柄を追跡する必要があります。 スレッドごとに、システムは優先順位、レジスタの最新の値、およびフラグを追跡します。 優先順位は、次に実行されるスレッドを決定するために使用されます。 スレッドが実行されると、適切なレジスタは、スレッドが最後に停止したときの値にリセットされます。 これにより、スレッドは中断されなかったかのように実行を再開できます。</P>
<P>GEOSの他のものと同様に、各スレッドにはハンドルがあります。ハンドルとは、プログラムがスレッドを参照するために使用する16ビットの値です。 スレッド関連のルーチンを呼び出すとき(たとえば、スレッドの優先順位を設定するため)、プログラムはハンドルを使用してスレッドを指定します。</P>


<H4 CLASS="HeadingCApp">イベント駆動型スレッドと手続き型スレッド</H4>
<P>GEOSでは、2種類のスレッドが使用されます。 この2つのタイプは、順番が来たときの走り方と、作成方法が異なるだけです。 この章の他の部分で説明されているプライオリティ、コンテキストスイッチ、および同期は、両方のタイプに等しく適用されます。</P>
<P>最初のタイプのGEOSスレッドは、「イベント駆動型」スレッドです。 イベント駆動型スレッドは通常、1つまたは複数のオブジェクトのコードを実行します。 各イベント駆動型スレッドにはイベントキューがあります。スレッドによって作成されたオブジェクトにメッセージが送信されると、メッセージはスレッドのイベントキューに配置されます。 スレッドは、オブジェクトのクラス定義から適切なメッセージハンドラを実行することによって受信された順序で各イベントを処理します。</P>
<P>メッセージは、スレッドによって作成されたオブジェクトではなく、スレッド自体に送信することもできます。 スレッドが作成されると、クラス(通常はサブクラス)が割り当てられます。<CODE>プロセスクラス</CODE>(非アプリケーション・スレッドの場合)または<CODE>GenProcessClass</CODE>(アプリケーションスレッドの場合)--メッセージがスレッドに直接送信されるときに使用するハンドラを決定します。 この意味で、スレッドは特定のクラスのインスタンスと考えることができます。</P>
<P>2番目のタイプのスレッドは手続き型です。 オブジェクト指向スキームでメッセージのハンドラーを実行するのではなく、単純に手続き型コードを実行します。<BR>システムは手続きスレッドにイベントキューを提供せず、メッセージをそのようなスレッドに送信することはできません。</P>

<HR>
          <A NAME="MultiThread_7.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:3.2人<A HREF="#MultiThread_5.htm">GEOSマルチタスク処理</A>:コンテキストスイッチ</H3>
<P>GEOSでは、コンテキストスイッチは2つの方法でトリガーされます。 1つ目は、タイマーやその他のハードウェア割り込みです。 2番目は、スレッドが終了したときや、ロックされたリソースにアクセスしようとしたときなど、スレッドがすぐに続行できないポイントに達したときに発生します。</P>
<P>PCハードウェアは、1秒間に60回のタイマー割り込みを生成します。 タイマー割り込み間の時間は<EM>刻み</EM>各スレッドは、タイマー割り込みルーチンが制御を別のスレッドに転送する前に、指定された数のティックで実行できます。 このティック数は、すべてのスレッドで同じです。<EM>タイムスライス</EM>ボタンをクリックし</P>
<P>スレッドが順番を開始すると、GEOSはカウンタをタイムスライス内のティック数に設定します。 タイマー割り込みのたびに、GEOSはカウンタをデクリメントします。 カウンタがゼロに達していない場合、制御はただちに実行中のスレッドに戻されます。 カウンタが0に達すると、GEOSは他のスレッドが現在のスレッドよりも高い優先度に達したかどうかを確認します。 もしそうであれば、現在のスレッドはシステムの実行可能スレッドのリスト(<EM>実行待ち行列</EM>)、最も優先度の高いスレッドが実行を開始します。 それ以外の場合、現在のスレッドは別のタイムスライスで実行されます。</P>
<P>スレッドは、別のスレッドによって現在使用されているシステムリソース(または共有データオブジェクト)にアクセスしようとすることがあります。 この場合、スレッドは目的のリソースが使用可能になるまで待機する必要があります。 スレッドはキューに置かれ、新しいスレッドが実行キューから選択されます。 現在実行されていないすべてのスレッドは、実行キュー(実行を待っている)にあるか、必要なリソースが利用可能になるのを待っている別のキューにあります。 リソースが使用可能になると、スレッドは実行キューに移動され、再実行の準備が整います。 このプロセスの詳細については<A HREF="#MultiThread_f.htm_68129">スレッドの同期</A>ボタンをクリックし</P>
<HR>
          <A NAME="MultiThread_8.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:3.3人<A HREF="#MultiThread_5.htm">GEOSマルチタスク処理</A>:スレッドのスケジューリング</H3>
<P>コンテキストスイッチがある場合、GEOSは次に実行されるスレッドを決定する必要があります。 これは、実行キューを調べ、実行する最も重要なスレッドを選択することによって行われます。 スレッドの重要度は優先順位に反映されます。優先順位の数値が小さいほど、スレッドの重要度が高くなります。</P>

<H4 CLASS="HeadingCApp">基本優先度</H4>
<P>各スレッドは、0から255までの値である基本優先度を取得します。 一般に、アプリケーションの優先順位は128～191です。 迅速なシステム応答に不可欠なスレッド(プルダウン・メニューやダイアログ・ボックスなどを管理するユーザー入力スレッドなど)には、小さい番号が割り当てられます。 印刷スプールやその他のバックグラウンド・アクティビティに使用されるスレッドなど、タイム・クリティカルでないスレッドには、より高い数値を指定できます。 ユーザーに対してより高速な応答を提供するために、GEOSは、ユーザーがアプリケーションと対話するときに、アプリケーションの基本優先度を一時的に32だけ下げます(より高い優先度を与えます)。 ユーザーが別のアプリケーションと対話するように切り替えると、最初のアプリケーションの基本優先度は通常に戻り、新しいアプリケーションの基本優先度番号は小さくなります。</P>


<H4 CLASS="HeadingCApp">最近のCPU使用率</H4>
<P>GEOSは、スレッドの最近のCPU使用率を0から60までの数値で追跡します。 0から始まり、スレッドの実行中にタイマー割り込みが発生するたびに番号が増分されます。 1秒に1回、最近のCPU使用率が半分になるため、スレッドのCPU使用率が過去に戻るにつれて、最近のCPU使用率は減少します。 結果の数値は、スレッドがCPUを制御していた時間と、この時間がどのくらい前であったかを反映します。</P>


<H4 CLASS="HeadingCApp">現在の優先度</H4>
<P>1秒ごとに、各スレッドの現在の優先順位が再計算されます。これは、最近のCPU使用率に基本優先順位を追加することによって行われます。 結果の番号は、実行キューからスレッドを選択するときに使用される番号です。</P>
<P>コンテキスト・スイッチの時間になると、GEOSは現在の優先度番号が最も低いスレッドを実行キューから選択します。同点の場合、選択は任意です。 ただし、最近のCPU使用率は1つのスレッドに対してカウントされるため、同じ優先度の2つのスレッドが同じ状態を維持することはありません。 1つを実行すると、最近のCPU使用率(したがって現在の優先順位番号)が増加します。 したがって、もう一方のスレッドには実行の機会が与えられます。</P>

<HR>
          <A NAME="MultiThread_9.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:3.4人<A HREF="#MultiThread_5.htm">GEOSマルチタスク処理</A>:アプリケーションとスレッド</H3>
<P>GEOSアプリケーションには、次の2つの標準アーキテクチャがあります。 シングルスレッドとデュアルスレッドです。 シングル・スレッド・オプションの方がプログラミングは多少容易ですが、デュアル・スレッド方式には明らかな利点があります。</P>
<P>デュアル・スレッド・アーキテクチャーでは、一方のスレッドがアプリケーションのユーザー・インターフェースを管理し、もう一方のスレッドがアプリケーションの残りの機能を管理します。 どちらのスレッドもイベント・ドリブンであるため、それぞれにイベント・キューがあります。 (マウス・クリックやキーボード入力などによって)ユーザー・インターフェース・オブジェクトに送信されるメッセージは、アプリケーション内の他のタスクの完了を待たずに処理することができます。 これにより、アプリケーションは、現在の非ユーザー・インターフェース・タスク(多くの計算を伴う場合があります)を最初に完了することなく、ユーザー入力に応答することができます(メニューの設定、ウィンドウの移動など)。</P>
<P>しかし、デュアル・スレッド・アーキテクチャーには同期の問題があり、一方のスレッドが他方のスレッドよりも先に進むことがあります。 相互に依存するスレッドは、これを回避するために相互の進行状況を追跡する必要があります。潜在的な問題が特定された場合は、セマフォーを使用してスレッドを一致させます(<A HREF="#MultiThread_f.htm_68129">スレッドの同期</A>)をクリックします。</P>
<HR>
          <A NAME="MultiThread_a.htm"></A>
        <H2 CLASS="sectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:4複数スレッドの使用</H2>
<P>アプリケーションは、さまざまな目的のために追加のスレッドを作成することができます。 例えば、端末エミュレーション・プログラムには、シリアル・ラインで入力文字をモニターすることだけを目的としたスレッドがあるかもしれません。 これにより、アプリケーションがディスクからテキストファイルをロードするなどの複雑なタスクを実行している間に、シリアル入力バッファまたはストリームがオーバーフローする危険を回避できます。また、シリアルドライバの入力バッファに大量の固定メモリを必要としません。</P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_b.htm">GEOSスレッドの作成方法</A>
        </P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_c.htm">優先度値の管理</A>
        </P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_d.htm">スレッド内のエラーの処理</A>
        </P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_e.htm">スレッドが終了したとき</A>
        </P>
<HR>
          <A NAME="MultiThread_b.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:4.1人<A HREF="#MultiThread_a.htm">複数スレッドの使用</A>:GEOSスレッドの作成方法</H3>
<P>GEOSスレッドは、3つの異なる方法で作成できます。 各アプリケーションの最初のスレッド(デュアル・スレッド・アーキテクチャーではスレッドのペア)は、アプリケーションの起動時に自動的に作成されます。 適切なルーチンを呼び出すことで、アプリケーションは、特定のオブジェクトに送信されるメッセージを処理したり、手続き型コードを実行したりするための追加のスレッドを作成できます。</P>

<H4 CLASS="HeadingCApp">アプリケーションのプライマリ・スレッド</H4>
<P>アプリケーションのプライマリ・スレッドは、アプリケーションの起動時にGEOSによって自動的に作成されます(<A HREF="../../Kernel/Geodes/index.htm">アプリケーションと測地の章</A>」を参照してください。) たとえば、ユーザーがGeoManagerのウィンドウでアプリケーションのアイコンをダブルクリックすると、GeoManagerはライブラリルーチンを呼び出します。<CODE>UserLoadApplication()</CODE>geodeファイルとその他のパラメータを指定します。 これにより<CODE>GeodeLoad()</CODE>GEOSカーネルのルーチン</P>
<P>プログラムが単一スレッド・モデルを使用して作成されている場合、GEOSはイベント・ドリブン・スレッドを作成して、プログラム内の任意のオブジェクトに送信されるメッセージを処理します。 プログラムがデュアル・スレッド・モデルを使用して作成されている場合、GEOSは、プログラムのユーザー・インターフェース・オブジェクトに送信されるメッセージを処理するイベント・ドリブン・スレッドと、プログラム内の他のオブジェクトに送信されるメッセージを処理する別のイベント・ドリブン・スレッドを作成します。</P>
<P>プログラムに2つ以上のスレッドが必要な場合は、起動時に余分なスレッドを手動で割り当て、アプリケーションが完全に終了する前に破棄する必要があります。</P>


<H4 CLASS="HeadingCApp">イベント駆動型スレッド</H4>
<PRE>ThreadAttachToQueue()</PRE>
<P><A NAME="MultiThread_b.htm_IX_Event queues"></A>イベント・ドリブン・スレッド(特定のオブジェクトに送信されるメッセージを処理するスレッド)を作成するには<CODE>MSG_PROCESS_CREATE_EVENT_THREAD(イベントスレッドの作成)</CODE>新しいスレッドのオブジェクトクラス(のsublass)を引数として渡します。<CODE>プロセスクラス</CODE>)と新しいスレッドのスタック・サイズ(通常は1 Kバイトが適切な値で、キーボード・ナビゲーションを処理したりテキスト・オブジェクトを管理したりするスレッドの場合は約3 Kバイト)です。 このメッセージの詳細については、を参照してください。<A HREF="../../SysObjects/Process/index.htm">「プロセスオブジェクト」の章</A>ボタンをクリックし</P><P>GEOSは新しいスレッドを作成し、イベントキューを指定して<CODE>MSG_META_ATTACH[メッセージメタアタッチ]</CODE>ボタンをクリックし 最初は、スレッドは自身に送信されたメッセージのみを処理します。 ただし、スレッドが新しいオブジェクトを作成した場合は、それらのオブジェクトに送信されたメッセージも処理されます。 新しいスレッドの動作を制御するには<CODE>プロセスクラス</CODE>新しいハンドラ<CODE>MSG_META_ATTACH[メッセージメタアタッチ]</CODE>新しいハンドラは、オブジェクトを作成したり、必要なタスクを実行したりできます。<CODE></CODE>新しいハンドラは、必ず次のコマンドで起動してください。<CODE>@callsuper()</CODE>事前に定義された初期化も同様に行われます。</P>
<P><A NAME="MultiThread_b.htm_IX_ThreadAttachToQueue()"></A>別のイベントキューにアタッチするスレッドがある場合は<CODE>ThreadAttachToQueue()</CODE>このルーチンは、アプリケーションがシャットダウンし、オブジェクトが何も返さずにメッセージの処理を継続する必要がある場合を除いて、広く使用されていません。 このルーチンを使用することはまずありません。</P>


<H4 CLASS="HeadingCApp">手続き型コードを実行するスレッド</H4>
<PRE>ThreadCreate()メソッド</PRE>
<P>手続き型コードを実行するスレッドを作成するには、最初に初期関数を固定メモリーにロードします。<A NAME="MultiThread_b.htm_IX_ThreadCreate()"></A>システムルーチンを呼び出す<CODE>ThreadCreate()メソッド</CODE>次の引数を渡します。 新しいスレッドの基本優先度、新しいスレッドに渡すオプションの16ビット引数、コードのエントリポイント、GEOSが新しいスレッドに割り当てる必要があるスタック空間の量、および新しいスレッドの所有者。</P>

<HR>
          <A NAME="MultiThread_c.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:4.2人<A HREF="#MultiThread_a.htm">複数スレッドの使用</A>:優先度値の管理</H3>
<PRE>ThreadGetInfo x、ThreadModify x、ThreadGetInfoType</PRE>
<P>スレッドのハンドルを指定すると、システム内の任意のスレッドの優先順位を確認して変更できます。 ハンドルはスレッドを作成するルーチンによって提供され、メッセージ内のあるスレッドから別のスレッドに提供することができます。 次のシステム・ルーチンは、スレッドの優先順位に関連しています。</P>
<P><CODE>ThreadGetInfo()</CODE><A NAME="MultiThread_c.htm_IX_ThreadGetInfo()"></A>スレッドに関する情報を返します。 通話中<CODE>ThreadGetInfo()</CODE><A NAME="MultiThread_c.htm_IX_ThreadGetInfoType"></A>問題のスレッドのハンドルと型の値を渡す<CODE>ThreadGetInfoType</CODE>(下記参照)。 スレッドハンドルとして0が渡された場合<CODE>ThreadGetInfo()</CODE>は、呼び出しを実行したスレッドに関する情報を返す。</P>
<P><CODE>ThreadGetInfoType</CODE>は、次の3つの値を持つ列挙型です。</P>
<DL>
<DT>TGIT_PRIORITY_AND_USAGE[優先順位と使用法]</DT><DD><A NAME="MultiThread_c.htm_IX_TGIT_&ldots;"></A>これは、スレッドの基本優先度と最新のCPU使用率を要求します。 (現在の優先順位を決定するには、最近のCPU使用率に基本優先順位を追加します)。</DD>
<DT>「ねじハンドル」(TGIT_THREAD_HANDLE)</DT><DD>これはスレッドのハンドルを要求します。 呼び出し元自身のスレッドハンドルを取得するには、これを使用します(スレッドハンドルを0にします)。</DD>
<DT>TGIT_QUEUEハンドル</DT><DD><A NAME="MultiThread_c.htm_IX_Event queues:accessing"></A>これは、イベント駆動型スレッドのイベント・キューのハンドルを要求します。 スレッドがイベント駆動型でない場合は、ゼロハンドルを返します。</DD>
</DL>
<P><CODE>Tキー</CODE><A NAME="MultiThread_c.htm_IX_ThreadModify()"></A><CODE>hreadModify()</CODE>スレッドの優先度を変更します。 渡す引数には、変更するスレッドのハンドル(呼び出しを実行するスレッドの場合は0)、スレッドの新しいベース優先度、および次の2つのフラグが含まれます。 1つはスレッドの基本優先度を変更するかどうかを示し、もう1つはスレッドの最近のCPU使用率を0にリセットするかどうかを示します。 スレッドのベース優先度を変更するフラグが設定されていない場合、新しいベース優先度引数は無視されます。 一般的には、スレッドの優先度を下げる(つまり、ベースの優先度番号を上げる)だけです。 アプリケーション自体の優先度を上げると、システム全体のパフォーマンスが低下します。 GEOSは、ユーザーが対話しているスレッドをすでに優先していることに注意してください。</P>
<P><A NAME="MultiThread_c.htm_IX_Debugging:multithreaded applications"></A>スレッドの優先度を設定するために使用できる、いくつかの事前定義された優先度レベルがあります。 効率的なデバッグのために、バグの可能性があるスレッドの優先度を上げるために、デバッグ時にこれらを使用することができます。 これらは次のとおりで、それぞれ異なる定数です。</P>
<UL>
<LI>優先度_時間_クリティカル<BR><A NAME="MultiThread_c.htm_IX_PRIORITY_&ldots;"></A>スレッドは、一定時間プロセッサを独占的に所有する必要がない限り、タイムクリティカルに設定しないでください。 他のスレッドを除外すると、望ましくない副作用が発生する可能性があります。</LI>
<LI>優先度-高</LI>
<LI>優先度UI</LI>
<LI>「優先度フォーカス」(PRIORITY_FOCUS)</LI>
<LI>「優先度標準」(PRIORITY_STANDARD)</LI>
<LI>優先度-低</LI>
<LI>PRIORITY_LOWEST(優先度</LI>
</UL>
<HR>
          <A NAME="MultiThread_d.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:4.3人<A HREF="#MultiThread_a.htm">複数スレッドの使用</A>:スレッド内のエラーの処理</H3>
<PRE>ThreadHandleException()、ThreadException</PRE>
<P><A NAME="MultiThread_d.htm_IX_ThreadHandleException()"></A>GEOSの一部のスレッドでは、特定のエラーを特別な方法で処理する必要があります。<A NAME="MultiThread_d.htm_IX_ThreadException"></A>特定のスレッドがインターセプトして処理できるエラーは、以下のように列挙されます。<CODE>ThreadException</CODE>その要素を以下に示す:</P>
<UL>
<LI>「TE_DIVIDE_BY_ZERO」と入力します。<A NAME="MultiThread_d.htm_IX_TE_&ldots;  (ThreadException type)"></A></LI>
<LI>TE_オーバーフロー</LI>
<LI>TE_境界</LI>
<LI>TE_FPU例外</LI>
<LI>「単一ステップ」(TE_SINGLE_STEP)</LI>
<LI>TE_BREAKPOINT(ブレークポイント)</LI>
</UL>
<P>スレッドは、特定の例外を処理するために、特殊なハンドラルーチンを設定し<CODE>ThreadHandleException()</CODE>これらの例外のいずれかが発生した場合。 これは、多数のオブジェクトが同じスレッドによって実行され、すべてのオブジェクトが特定の例外を同じ方法で処理する必要がある場合に便利です。ルーチンは、オブジェクト固有ではなくスレッド固有にすることができます。<CODE>ThreadHandleException()</CODE>には、スレッドのハンドル、例外タイプ、ハンドラルーチンのエントリポイントへのポインタを渡す必要があります。</P>
<HR>
          <A NAME="MultiThread_e.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:4.4人<A HREF="#MultiThread_a.htm">複数スレッドの使用</A>:スレッドが終了したとき</H3>
<PRE>ThreadDestroy()</PRE>
<P>アプリケーションが追加のスレッドを<CODE>MSG_PROCESS_CREATE_EVENT_THREAD(イベントスレッドの作成)</CODE>または<CODE>ThreadCreate()メソッド</CODE>の場合、スレッドが終了したときに終了することを確認する必要があります。 アプリケーションを終了しただけでは、追加のスレッドが削除されない場合があります。また、これらのスレッドにより、システムのシャットダウン時にGEOSがハングする可能性があります。</P>
<P>スレッドが終了したら、まず、ロックしたセマフォやスレッドロックを解放し、不要になったメモリやその他のリソースを解放する必要があります。 メモリー内のリソースは、割り当てたスレッドと同じスレッドで解放する必要はありませんが、アプリケーションが終了する前に解放されていることを確認する必要があります。</P>
<P><A NAME="MultiThread_e.htm_IX_ThreadDestroy()"></A>手続き型スレッドは<CODE>ThreadDestroy()</CODE>エラー・コード、optr、データ・ワードの3つの引数があります。 スレッドが終了すると、(最後の動作として)<CODE>MSG_PROCESS_NOTIFY_THREAD_EXIT[メッセージプロセス通知スレッド終了]</CODE>アプリケーションのプライマリスレッドと<CODE>MSG_META_ACKメッセージ</CODE>を渡されたオブジェクト記述子に渡します(<CODE>ThreadDestroy()</CODE>のデータ引数のワードは、MSG_META_ACKのoptr引数の下位ワードとして渡されます)。 各メッセージには、引数としてエラー・コードがあります。 マルチスレッド・アプリケーションの設計では<CODE>MSG_PROCESS_NOTIFY_THREAD_EXIT[メッセージプロセス通知スレッド終了]</CODE>(プライマリスレッドのクラス)または<CODE>MSG_META_ACKメッセージ</CODE>(任意のクラスで)スレッド間の通信に使用でき、選択した任意のデータに対してエラーコードを使用できます。 慣例では、ゼロのエラー・コードはスレッドのタスクが正常に完了したことを表します。</P>
<P>イベント駆動型スレッドは<CODE>ThreadDestroy()</CODE>これは、イベント・キューをシステムからクリーンに除去する必要があるためです。 代わりに<CODE>MSG_META_DETACH(メタデタッチ)</CODE>と同じ引数をスレッドに渡します。<CODE>ThreadDestroy()</CODE>のハンドラ。<CODE>MSG_META_DETACH(メタデタッチ)</CODE>の<CODE>メタクラス</CODE>はイベントキューをクリーンに削除してスレッドを終了し、上記と同じメッセージを送信します。 のための特別なハンドラを書くことができます。<CODE>MSG_META_DETACH(メタデタッチ)</CODE>サブクラス化する場合<CODE>プロセスクラス</CODE>としますが、ハンドラの最後には必ず<CODE></CODE><CODE>@callsuper()</CODE>スレッドは適切に終了します。</P>
<HR>
          <A NAME="MultiThread_f.htm"></A>
        <H2 CLASS="sectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:5個<A NAME="MultiThread_f.htm_68129"></A>スレッドの同期</H2>
<P>GEOSはプリエンプティブ・マルチタスク環境であるため、2つのスレッドがシステム・リソース(または他の共有データ)に同時にアクセスするのを防ぐ方法が必要です。 そうしないと、データが破損する可能性があります。 GEOSはセマフォーを使用して、スレッドが競合する操作を同時に実行しないようにします。</P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_10.htm">セマフォ: コンセプト</A>
        </P>
<P CLASS="subsectionLink">
          <A HREF="#MultiThread_11.htm">GEOSのセマフォー</A>
        </P>
<HR>
          <A NAME="MultiThread_10.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:5.1人<A HREF="#MultiThread_f.htm">スレッドの同期</A>:セマフォ: コンセプト</H3>
<P><A NAME="MultiThread_10.htm_IX_Semaphores:threads"></A>セマフォーは、3つの基本操作が実行されるデータ構造です。 これらの操作により、スレッドは他のスレッドとの競合を避けることができます。 セマフォーは、一部のリソースがロックされていることを示すためにプログラムが設定できるフラグと考えてください。 そのリソースを使用したい人は、フラグを設定した人がそれをリセットするまで、列に並んで待たなければなりません。 セマフォーに対する3つの基本操作は、初期化、設定、およびリセットです。</P>

<H4 CLASS="HeadingCApp">初期化(Initialize)</H4>
<P>「初期化」操作は、セマフォーを作成して名前を付けます。 初期状態では、セマフォは「ロック解除」されています。これは、セマフォにアクセスしようとする最初のプロセスがすぐに成功することを意味します。 セマフォーは、使用する前に初期化する必要があります。ただし、初期化は、プログラマーに対して透過的であるように、オペレーティング・システムによって処理できます。</P>


<H4 CLASS="HeadingCApp">設定(「P」操作)</H4>
<P>「P」操作は、プログラムが続行を許可されていることを確認するために実行するものです。 たとえば、プログラムが共有データにアクセスしようとしている場合、そのデータを保護するセマフォに対して「P」操作を実行し、他のプログラムがそのデータにアクセスしていないことを確認します。</P>
<P>セマフォーのロックが解除され、スレッドがそのセマフォーに対して「P」操作を実行した場合、スレッドはそのセマフォーにロック済みのマークを付けるだけで、正常に処理を続行します。 セマフォーがロックされている場合、「P」操作を実行するスレッドは<EM>ブロック(block)</EM>これは、スレッドが実行を停止し、セマフォーに関連付けられたスレッドキューで待機することを意味します。 保護された操作を実行する順番が来ると、スレッドは先に進みます。</P>


<H4 CLASS="HeadingCApp">リセット(「V」操作)</H4>
<P>スレッドは保護された操作を終了すると、「V」操作を実行してセマフォーのロックを解除します。 このセマフォーのキューに他のスレッドがある場合、そのスレッドの1つが再始動されて引き継ぎ、セマフォーはロックされたままになります。 したがって、保護された操作を実行するのは一度に1つのスレッドだけです。 スレッドがセマフォーに対して「V」操作を実行し、そのセマフォーのキューで待機しているスレッドが他にない場合、スレッドはそのセマフォーにロック解除のマークを付けて処理を続行します。</P>
<P>プログラムは、セマフォの使用が終了したときには必ずリセットしなければなりません。 セマフォーのリセットに失敗すると、他のスレッドが永久に待機する可能性があります。</P>
<P>保護された操作を実行しているのは一度に1つのスレッドだけであり、このスレッドはセマフォのロックを解除する責任があるため、このスレッドはセマフォを「持っている」と呼ばれることがあります。 「P」および「V」操作は、多くの場合、それぞれセマフォーの「グラブ」および「リリース」と呼ばれます。</P>


<H4 CLASS="HeadingCApp">恐ろしいデッドロック問題</H4>
<P><A NAME="MultiThread_10.htm_IX_Deadlock"></A>セマフォーを慎重に使用しないと、プログラムの実行が完全に停止することがあります。 スレッドAが、スレッドBがロックしたセマフォーを獲得しようとしたとします。 スレッドAは、スレッドBがセマフォーを解放するまで実行を停止します。 次にスレッドBは、スレッドAが以前にロックした2番目のセマフォを獲得しようとします。 スレッドBは、スレッドAが2番目のセマフォーを解放するのを待ちますが、スレッドAは、スレッドBが最初のセマフォーを解放するのを待っています。 どちらのスレッドもウェイクアップしません。 この状態を「デッドロック」と呼びます。</P>
<P>デッドロックを回避するには、次のガイドラインに従ってください。</P>
<UL>
<LI>可能であれば、すでに別のセマフォーがロックされているときに、スレッドが別のセマフォーをロックしようとしないようにします。</LI>
<LI>複数のセマフォーが同じスレッドによって同時にロックされる可能性がある場合は、常に同じ順序で使用する必要があります。 多くの場合、セマフォーは階層的に配置され、最も粗いもの(最も多くのリソースへのアクセスを制御するもの)が一番上に、最も細かいものが一番下に配置されます。 この階層内の複数のセマフォをグラブするスレッドは、常に上から下へとグラブする必要があります。つまり、どのスレッドも、すでにロックされているセマフォーの「上」にあるセマフォーをグラブしてはなりません。</LI>
<LI>状況によっては、セマフォーが2つのスレッドの「間」で使用されます。 あるスレッドは、別のスレッドが特定のアクションを実行するまで待機する必要があります。 最初のスレッドは、2番目のスレッドで「ブロックする」と言われます。 もちろん、2つのスレッドが互いにブロックしてはなりません。 このような状況が発生しないようにするには、1つのスレッドだけが<CODE>@呼び出し</CODE>キーワードを使用してメッセージを送信する必要があります。<CODE>@送信</CODE>そして、リターン情報を取得したときに、何らかの通知メッセージを返信します。</LI>
<LI>GEOSメッセージングシステムを使用してメッセージを送信する場合<CODE>@呼び出し</CODE>を別のスレッドのオブジェクトに渡すと、送信スレッドは受信スレッドを自動的にブロックします。 いくつかのユーザインタフェースオブジェクトは<CODE>@呼び出し</CODE>アプリケーション・スレッドは、ユーザー・インターフェース・スレッドでブロックされることがあります。 デッドロックを回避するために、ユーザー・インターフェース・スレッドで実行されるコードは<CODE>@呼び出し</CODE>をアプリケーションスレッド内のオブジェクトに適用します。 (これは、上記の規則が実装されている特定の例です)。</LI>
</UL>

<HR>
          <A NAME="MultiThread_11.htm"></A>
        <H3 CLASS="subsectionTitle"><A HREF="#index.htm">スレッドとセマフォー</A>:5.2人<A HREF="#MultiThread_f.htm">スレッドの同期</A>:GEOSのセマフォー</H3>
<P>GEOSには、セマフォーによって保護されているいくつかのシステム・リソースが含まれています。 アプリケーションプログラムはライブラリルーチンを介してのみこれらのリソースにアクセスできるので、プログラマはこれらのセマフォを認識する必要はなく、必要な操作はライブラリルーチンによって実行される。 システムリソース(ファイル、メモリ、ハンドルなど)に対して、GEOSはセマフォを定義し、それらを設定およびリセットするための特別なルーチンを提供する。 各システムリソースを説明する章では、リソースを保護する特殊なセマフォーの使用方法について説明します。</P>
<P>この節で説明するルーチンは、GEOSセマフォーについて説明しており、マルチスレッドアプリケーション内で定義されたリソースを保護するためのセマフォーを作成するために使用できます。 操作(初期化、P、V)ごとにルーチンがあり、同じスレッド内の複数のオブジェクトによるセマフォーの使用を単純化する特別なルーチンがあります。</P>
<P>1より大きい開始値を持つセマフォーを作成できることに注意してください。 つまり、複数のスレッドが一度にそれを獲得できるようなセマフォーを作成することができます。 通常、1つのスレッドだけがセマフォーを獲得できる場合、そのスレッドは「相互排他」または「mutex」セマフォーと呼ばれます。これは、通常、2つのスレッドが特定のリソースを相互に獲得しないようにするために使用されるためです。</P>
<P>複数のスレッドでグラブできるセマフォーは、スケジュールされたリソースを簡単に操作できるため、一般に「スケジューリング・セマフォー」と呼ばれます。 この典型的な例は、あるスレッドがバッファを生成し、別のスレッドがそれを消費するという「プロデューサとコンシューマの問題」です。 最初はバッファが存在しないので、セマフォは0から始まります。 コンシューマはループに入り、そこで単にセマフォをP(バッファが存在するまでブロックする)し、キューの最初のバッファを取り、バッファを処理し、バッファを破棄し、ループの先頭に戻る。 一方、プロデューサは、任意の数のバッファを生成し、それらをキューに入れ、消費可能なバッファごとに一度セマフォをVすることができる。 コンシューマー・スレッドは、すべてのバッファーが消費されるまで処理を続け、その後ブロックして、さらにバッファーが消費されるのを待ちます。</P>

<H4 CLASS="HeadingCApp">セマフォーに対する操作</H4>
<PRE>ThreadAllocSem()、ThreadPSem()、ThreadPTimedSem()、ThreadVSem()、ThreadFreeSem()</PRE>
<P><A NAME="MultiThread_11.htm_IX_ThreadAllocSem()"></A>セマフォーを作成するには、次のルーチンを呼び出します。<CODE>ThreadAllocSem()</CODE>セマフォの初期値を渡します。 これは通常、セマフォがロックされていないことを示す値である。 セマフォーを最初にロックする場合は、初期値として0を渡します。 どちらの場合も、返される値は新しく作成されたセマフォのハンドルになります。 このハンドルは、以下で説明するルーチンで使用します。<IMG SRC="Multithread_11_sidebar.gif"></P>
<P><A NAME="MultiThread_11.htm_IX_ThreadPSem()"></A>セマフォーが作成されると、スレッドはルーチンを呼び出してそのセマフォーをロックできます(つまり、「P」操作を実行できます)。<CODE>ThreadPSem()</CODE>を呼び出し、セマフォーのハンドルを引数として渡します。 セマフォーがアンロックされている場合、スレッドはそのセマフォーをロックして処理を続行します。ロックされていない場合、スレッドはセマフォーのスレッド・キューで待機します。</P>
<P><A NAME="MultiThread_11.htm_IX_ThreadPTimedSem()"></A>「P」オペレーションを実行する別のルーチンは<CODE>ThreadPTimedSem()</CODE>このルーチンを呼び出すときは、セマフォーのハンドルとティックの数を表す整数を引数として渡します。 この整数は時間制限です。 別のスレッドがセマフォをロックしていて、指定されたティック数以内にロックを解除しない場合、ルーチンはロックが失敗したことを示すフラグを返します。 を使用するプログラム<CODE>ThreadPTimedSem()</CODE>はこのフラグをチェックしなければならず、設定されている場合は保護された操作を実行してはならない。 このルーチンの最も一般的な使用法は、時間制限をゼロにすることです。つまり、セマフォーは、すぐに使用可能になった場合にのみロックされます。使用可能になっていない場合、スレッドは他のアクションを続行します。</P>
<P><A NAME="MultiThread_11.htm_IX_ThreadVSem()"></A>(&quot;V&quot;操作を実行して)セマフォを解放するために、スレッドは以下を呼び出す。<CODE>ThreadVSem()</CODE>を呼び出し、再びセマフォーのハンドルを渡します。 セマフォーを待っているスレッドが他にもある場合は、現在の優先順位番号が最も小さいスレッドが引き継ぎます。</P>
<P><A NAME="MultiThread_11.htm_IX_ThreadFreeSem()"></A>セマフォーが不要になった場合は、次のように呼び出して破棄できます。<CODE>ThreadFreeSem()</CODE>セマフォのハンドルを引数として使用します。</P>


<H4 CLASS="HeadingCApp">スレッド・ロックに対する操作</H4>
<PRE>ThreadAllocThreadLock x、ThreadGrabThreadLock x、ThreadReleaseThreadLock x、ThreadFreeThreadLock x</PRE>
<P>プログラムがすでにロックしているセマフォをロックすると便利な場合があります。 例えば、あるルーチンがメモリーの一部を保護するセマフォーをロックしてから、自分自身を再帰的に呼び出す場合があります。 スレッドロックは、各ロックが同じスレッドによって実行される限り、何度でもロックできるセマフォーです。 別のスレッドがスレッドロックを獲得しようとした場合、「P」操作を実行するたびに、最初のスレッドが「V」操作を1回実行するまで待機します。 スレッドロックを使用してリエントラントルーチンを記述することは可能ですが、通常のセマフォを使用することはできません。</P>
<P><A NAME="MultiThread_11.htm_IX_ThreadAllocThreadLock()"></A>スレッドロックは<CODE>ThreadAllocThreadLock()</CODE>このルーチンは引数を取りません。 スレッドロックは常にロック解除された状態で作成されます。 スレッドロックに対して「P」および「V」操作を実行するには<CODE>ThreadGrabThreadLock()</CODE><A NAME="MultiThread_11.htm_IX_ThreadGrabThreadLock()"></A>および<A NAME="MultiThread_11.htm_IX_ThreadReleaseThreadLock()"></A><CODE>ThreadReleaseThreadLock()</CODE>を呼び出し、セマフォのハンドルを引数として渡す。 これらのルーチンは以下に類似している。<CODE>ThreadPSem()</CODE>および<CODE>ThreadVSem()</CODE>セマフォ用。 スレッドロックが不要になると<A NAME="MultiThread_11.htm_IX_ThreadFreeThreadLock()"></A>次の呼び出しで解放する必要があります。<CODE>ThreadFreeThreadLock()</CODE>ボタンをクリックし</P>

<HR>このドキュメントは<A HREF="index.htm">複数ページのドキュメント</A>簡単な印刷に適しています。</BODY>
</HTML>
