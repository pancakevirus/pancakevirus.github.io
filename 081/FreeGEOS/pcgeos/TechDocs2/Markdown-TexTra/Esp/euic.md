## 4 UIコンパイラ

アセンブリ言語は、本質的に非常に低レベルです。
通常はオブジェクト指向プログラミングをサポートしていません。
GEOSは、OOPを完全にサポートするために、アセンブリ言語に特別な機能を追加する必要がありました。

このサポートの一部については、すでに説明しました。
GEOSカーネルはオブジェクトを管理し、メッセージを送信するためのルーチンを提供します。
アプリケーションは、オブジェクトを作成、操作、または破棄するための特別なルーチンを呼び出すことができます。
ただし、ほとんどのアプリケーションでは、実行を開始する前に多くのオブジェクトを作成する必要があります。
特に、ほとんどのアプリケーションでは、実行を開始する前に多くのUIオブジェクトを作成する必要があります。
UICファイルで新しいオブジェクトクラスを宣言することもできますが、その必要があるのは、コンパイル時にこれらのクラスからオブジェクトを作成する場合だけです。

そこで登場するのが、UIC(User-Interface Compiler)です。
UICを使用すると、アプリケーションの起動時に作成する必要があるオブジェクトをソース・コードで指定できます。
これらのオブジェクトはすべてコンパイル時に作成され、実行可能ファイルに格納されます。
アプリケーションが起動されると、オブジェクトはそこにあり、使用できる状態になります。

UICは、ユーザインタフェースオブジェクトを作成するために最も一般的に使用されます。
ただし、GEOSシステムクラスであれ、自分で定義したクラスであれ、任意のクラスの任意の種類のオブジェクトを作成できます。
また、オブジェクトブロックに保持される可能性のある他のチャンクを作成することもできる(例:Vis
monikers)。

さまざまなGEOSクラスのアセンブリ参照情報については、PCGEOS\*.DEFおよび\*.UIHファイルを参照してください。

### 4.1 UICの概要

基本的にUICは、特殊なオブジェクト記述言語であるEspireで書かれたファイルを読み取り、特殊なGEOSオブジェクト・アセンブリー・ファイルを書き込みます。
これらのファイル(拡張子は.rdf)は、実行可能ファイルのコンパイル時に自動的に組み込まれます。

アセンブリでアプリケーションを作成する場合は、オブジェクトをUICソースファイルに配置して指定できます。
このファイルの名前はuiを実行すると**モデム**UICへの適切な呼び出しを含むようにmakefileが自動的に設定されます。
アプリケーションをコンパイルすると、.rdfファイルが生成され、アプリケーションに組み込まれます。

UICにはCプリプロセッサが組み込まれています。
これは、標準のC前処理ディレクティブを使用できることを意味します。特に、UICヘッダーファイルを作成し、.uihファイルに含めることができます。**#include(インクルード)**指令。
これらのヘッダーファイルには、通常、拡張子.uihが付いています。
すべての.uiファイルには、標準GEOSヘッダファイルgeneric.uihが含まれている必要があります。このファイルには、すべての標準GEOS
GenクラスとVisクラスに関するUI情報が含まれています。

コメントはCの規則に従います。つまり、/\*で始まり、\*/で終わります。
Cと同様に、改行は文の終端文字としてではなく、空白文字として扱われます。

ui(および.uih)ファイルの規則の一部は、GEOSの他の部分とは異なります。
まず、すべてのクラスの名前は短縮されます。「クラス」という単語は含まれません。
たとえば、.uihファイルでは**GenTriggerClass**単に「GenTrigger」と呼ばれていました

また、.uiファイルでは、インスタンスデータフィールドの名前は切り捨てられます。最初の大文字とそれに続くアンダースコアは削除されます。
たとえば、クラス**GenTriggerClass**にはGTI_destinationという名前のフィールドがあります.uiファイルでは、このフィールドは単に\"destination\"と呼ばれます。
この規則は、すべてのGEOSクラスで適用されます。作成するすべてのクラスで、この規則に従う必要があります。
(クラスのEspireフィールド名がわからない場合は、PCGEOSのクラスの.uihファイルを参照してください。

最後に、インスタンス・データ・レコード内のフラグの名前には、異なる表記規則があります。
Cおよびアセンブリファイルでは、フラグの名前はインスタンスデータフィールドのイニシャルで始まり、その後に大文字のフラグ名が続きます。
たとえば、アセンブリでは**生成クラス**レコードGI_attrsには、GA_READ_ONLYというフィールドがあります。
uiファイル内の対応するフィールドは「readOnly」と呼ばれます。
列挙型のメンバーの名前も同様に変更されています。
たとえば、アセンブリでは、フィールドはMET_AN_ENUM_VALUEと呼ばれます。タイプが.uihファイルで宣言されている場合、メンバーは「anEnumValue」と呼ばれます。

### 4.2クラスの宣言

新しいクラスを作成するには、.uiファイルでクラスを指定します。
これを行うには、特別なEspireディレクティブを記述します。これらのディレクティブは、そのクラスのオブジェクトを作成する方法をEspに指示します。
これらのディレクティブは、多くの場合、アプリケーションの.uiファイルに含まれる.uihファイルに配置されます。

これは、必ずしもすべてのクラスで行う必要はありません。
特に、.uihファイルでプロセスクラスを宣言する必要はありません。また、コンパイル時にそのクラスのオブジェクトを作成する必要がない場合は、クラスを宣言する必要はありません。
ただし、コンパイル時にクラスのサブクラスからオブジェクトを作成する場合は、.uihファイルでクラスとサブクラスの両方を宣言する必要があります。

uihファイルでクラスを指定する場合は、「」の説明に従って、通常のアセンブリコードで宣言する必要があります。[第2章第2.4節](ebasics.md#24-defining-classes)ボタンをクリックし

クラス指定は、次のような行で始まります。

```
class <classRoot> = <superClassRoot> [, master] [,variant]{
```

**classRoot**\
これは、宣言するクラスの名前で、「class」という語は含まれません。
たとえば、MyTriggerClassを宣言する場合MyTriggerになります。

**superClassRoot**\
これはクラスのスーパークラスの名前であり、ここでも「クラス」という単語は含まれません。たとえば、スーパークラスがGenTriggerClassの場合、これはGenTriggerになります。

クラスがマスタークラスまたはバリアントクラスである場合は、この行で指定する必要があります。

    クラスMyMasterVis=Vis、バリアント{

マスタークラスの仕様の最初の行になります。**MyMasterVisClass**これは**VisClass**ボタンをクリックし

一番上の行の後に、クラスのすべてのインスタンスデータフィールドを指定します。
クラスのスーパークラスから継承されたフィールドのデフォルト値を変更することもできます。

#### 4.2.1フィールドの宣言

そのサブクラスに追加されるすべてのインスタンス・データ・フィールドをリストする必要があります。
フィールドを指定する基本的な形式は、次のとおりです。

    <field>=<fieldRootの種類>:<既定値>

**fieldRoot**\
これは、クラスの頭字語を除いたインスタンスデータフィールドの名前です(で説明されているように[第4.1項](#41-uic-overview))をクリックします。
たとえば、フィールドがMASMファイルでMCI_aFieldと呼ばれている場合、ここでは「aField」と呼ばれます。

**フィールドタイプ**\
これは、単純型でも定義型でもかまいません。
単純型はMASMと同じですが、「Comp」で終わる点が異なります。たとえば、MASM型の「byte」はEspire型の「byteComp」に対応します。

**デフォルト値**\
このオプションフィールドでは、インスタンスデータフィールドのデフォルト値を指定します。
このクラスのオブジェクトを.uiファイルに作成し、フィールドの値を指定しない場合、デフォルト値が使用されます。

たとえば、MASMコードでは**GenViewControlClass**には、次の定義を持つフィールドがあります。

    GVCIスケールワード100

uihファイル内のクラスのEspire定義には、次の対応する行があります。

    尺度=wordComp:100

デフォルト値は式にすることもできます。

    myField=byteComp:(3*20)

フィールドに列挙型が含まれている場合、形式は次のようになります。

    <fieldRoot>=enumComp<size>[(<first>[,<step>])]{<member>,<member>.}:<default;

**fieldRoot**\
これは、クラスの頭字語を除いたインスタンスデータフィールドの名前です(で説明されているように[第4.1項](#41-uic-overview))をクリックします。
たとえば、フィールドがMASMファイルでMCI_aFieldと呼ばれている場合、ここでは「aField」と呼ばれます。

**寸法**\
列挙型のサイズです。 バイト、ワード、dwordのいずれかです。

**最初の**\
これが存在する場合は、列挙型の最初のメンバーの値を指定します。
デフォルトの最初の値は0です。

**段**\
これが存在する場合は、列挙型の連続するメンバー間のステップを指定します。
デフォルトのステップは1です。

**成員**\
これは、列挙型のメンバーの名前です。
に示すように、名前はアセンブリ形式から変更されています。[第4.1項](#41-uic-overview)たとえば、アセンブリ内のメンバーの名前がEspireでの名前である場合、「blueEnum」となります。
列挙型のすべてのメンバーは、型のアセンブリ仕様に表示されるのと同じ順序でリストする必要があります。

**デフォルト(default)**インスタンス・フィールドのデフォルト値を指定します。

フィールドにレコードが含まれている場合、形式は次のようになります。

    <fieldRoot>=bitFieldComp<サイズ>{<フィールド>,<フィールド>.}:<デフォルト>,<デフォルト>.;

**fieldRoot**\
これは、クラスの頭字語を除いたインスタンスデータフィールドの名前です(で説明されているように[第4.1項](#41-uic-overview))をクリックします。
たとえば、フィールドがMASMファイルでMCI_aFieldと呼ばれている場合、ここでは「aField」と呼ばれます。

**寸法**\
これがレコードのサイズです。 バイト、ワード、dwordのいずれかです。

**畑**\
これが旗の名前です。 前述のように、名前はMASM形式から変更されています。
たとえば、(MASMで)フラグがMBF_A\_BITFIELD_FLAGと呼ばれている場合、Espでは\"aBitfieldFlag\"と呼ばれます。

**デフォルト(default)**\
これは、レコード内の1つ以上のフラグです。デフォルトでは、ここにリストされているフラグが設定され、他のすべてのフラグがクリアされます。

フィールドの幅は1ビットを超える場合があります。
レコード内のフィールドが次のように指定されている場合:

    <フィールド>:<幅>

の場合、widthはフィールドのバイト単位の幅になります。
レコード内のフィールドには、列挙値の範囲を含めることもできます。
フィールドは次のように指定されます。

    <フィールド>:<幅>={<値>,<値>.}

それぞれの値は、そのフィールドに設定可能な値です。

フィールドの幅が1ビットを超える場合は
\";値は、整数、またはそのフィールドに指定された列挙型のいずれかです。
デフォルト値を指定しない場合、フィールドはデフォルトのゼロに設定されます。

たとえば、オブジェクト**GenDocumentControl**には、次の定義を持つフィールドがあります。

    dcAttributes=bitFieldCompワード{multipleOpenFiles, モード:2={viewer, sharedSingle, sharedMultiple},dosFileDenyWrite, vmFile, ネイティブ,supportsSaveAsRevert, documentExists, currentTask:4={none, new, open, useTemplate, saveAs, dialog},doNotSaveFiles}:モードsharedSingle, vmFile, supportsSaveAsRevert, currentTask new;

この場合、レコードの各フィールドは、2ビット幅のモードと4ビット幅のcurrentTaskを除いて、1ビット幅です。
デフォルトでは、モードはsharedSingle(1など)に設定され、currentTaskは新規(1など)に設定されます。フラグvmFileとsupportsSaveAsRevertが設定され、他のすべてのフラグがクリアされます。

#### 4.2.2デフォルト値の変更

クラスを作成するときに、スーパークラスから継承されたインスタンスフィールドのデフォルト値を変更したい場合があります。
これを行うための形式は次のとおりです。

    default<fieldRoot>=<値>;

**fieldRoot**\
これは、スーパークラスのEspire宣言で指定されたインスタンスデータフィールドの名前です。

**値(value)**\
これは、そのフィールドの新しいデフォルト値です。
前述したように、デフォルト値をMASMで解釈したい場合は、次のように引用符で囲む必要があります。

    default superField="6*SOME_MASM_CONSTANT";に設定します。

フィールドがレコードの場合は、一部のフラグをオンまたはオフにして、残りを変更しないようにすることができます。
これは、次のような行で行うことができます。

    default<recordRoot>=default+<flagName>,-<flagName>.;

**recordRoot**\
これは、スーパークラスのEspire宣言で指定されたインスタンスデータフィールドの名前です。

**フラグ名**\
オン/オフを切り替えるフラグです。
フラグの前に「+」を付けると、フラグのデフォルト値が設定されます。「-」を付けると、フラグのデフォルト値がクリアされます。

たとえば、次のような行があります。

    default superRecord=default+aFlag, -anotherFlag;

スーパークラスのフィールドsuperRecordのデフォルト値を変更します。
サブクラスのsuperRecordフィールドでは、aFlagはデフォルトでオンになっており、anotherFlagはオフになっています。
他のすべてのフラグは、スーパークラスと同じデフォルト値を持ちます。

------------------------------------------------------------------------

コード表示3-1スーパークラスの変更\~\~\~/\*GentriggerClassのサブクラスを作成しています。
このクラスは新しい\*フィールドを持ち、GenTriggerClassのフィールドの1つのデフォルト値を変更します。\*/

#include\"generic.uih\"/\*これはEspireのGenTriggerClassの定義です\*/

クラスMyTrigger=GenTrigger{

/\*フィールドのデフォルト値を変更する:\*/genStates=default+enabled;

/\*新しいフィールドを追加する\*/myDatum=wordComp:0;

}をクリックし

/\*.defファイルには、対応するEspクラス定義が含まれます。これは\*次のようになります:

MyTriggerClass GenTriggerClass

    MTI_myDatumワード

MyTriggerClassエンド\~\~\~

### 4.3オブジェクトおよびチャンクの作成

UICの要点は、実行時にオブジェクトをインスタンス化する代わりに、geodeのソースコードでオブジェクトを作成できるということです。
ソースファイルには、親子リンクの完全なセットを持つオブジェクトブロック全体を指定できます。コンパイラはこれらをGEOSブロックに変換します。

オブジェクトを指定するだけでなく、オブジェクトブロックに入れる他のチャンクを指定することもできます。
例えば、テキストをオブジェクトブロックのチャンクに入れたい場合があります。そうすれば、リソースエディタはテキストを修正できます(例えば、アプリケーションを別の国に翻訳する場合など)。
データリソース、つまりチャンクを含むがオブジェクトを含まないLMemヒープを設定することもできます。

#### 4.3.1リソースの設定

開始、終了

すべてのオブジェクトはオブジェクトブロック内にある必要があります。
非オブジェクトチャンクは、オブジェクトブロック内にある場合もあれば、非オブジェクトリソース(すなわち、LMemヒープ)内にある場合もある。
これらのリソースは**スタート**および**終わり**ディレクティブ。
uiファイル内のすべてのオブジェクトは**スタート**および対応する**終わり**ボタンをクリックし

の**スタート**および**終わり**ディレクティブの形式は次のとおりです。

    start<resourceName>[,<resourceFlag>];/*オブジェクト定義. */end<リソース名>;

**リソース名**\
リソースの名前です。
そのリソースを初めて「起動」すると、UICはLMemヒープの制御情報を出力します。
uiファイルでは、リソースを何度も起動および停止できます。

**resourceFlag**\
これは、「data」、「ui」、または「app」の3つの単語のいずれかです。
「data」は、ブロックに非オブジェクトチャンクのみが含まれていることを示します。
「ui」は、リソースがユーザー・インターフェース・スレッドによって実行されるべきオブジェクト・ブロックであることを示します。
\"app\"は、リソースがアプリケーションスレッドによって実行されるオブジェクトブロックであることを示します。

uiファイルでは、1つのリソースが何度も「開始」および「終了」する場合があります。
したがって、オブジェクト宣言をリソースごとに強制的にグループ化するのではなく、明確で便利な順序でグループ化することができます。

#### 4.3.2オブジェクトの作成

Espireでオブジェクトを作成するのは簡単です。
オブジェクトの名前と、デフォルト設定を持たないフィールドの初期設定を指定するだけです。
UICはこれを適切なEspディレクティブに変換します。

オブジェクト定義の基本フォーマットは、次のとおりです。

    <objName>=<className>[<ObjChunkFlag>]*{/*インスタンスデータ.*/}

**オブジェクト名**\
オブジェクトの名前です。

**クラス名**\
これは、.uihファイルで定義されているオブジェクトのクラス名です。

**ObjChunkFlag**\
これは、Espire規約で指定されたObjChunksFlagsビットフィールドの1つ以上のフラグである可能性があります。
これは通常、vardataRelocかignoreDirty、またはその両方です。

オブジェクトのクラスは.uihファイルで定義されている必要があり、.uihファイルはインクルードされている必要があります。
GEOS標準クラスの場合は、単にファイルgeneric.uihを含めることができます。

オブジェクトのすべてのインスタンスデータフィールドを指定する必要はありません。
フィールドを指定しない場合、フィールドにはデフォルト値が設定されます。

フィールドを初期化するには、次のような行を入力します。

    <フィールド名>=<値>;

**フィールド名**\
これは、クラスのEspire指定で指定されたインスタンスデータフィールドの名前です。

**値(value)**\
これが(UICではなく)Espによって解釈されなければならない値である場合は、「二重引用符」で囲みます。
例えば、フィールドの値が(おそらく.defファイルで定義されているために)アセンブラだけが知っている定数であるとします。
次に、定数を二重引用符で囲みます。

    myField="MFC_CONSTANT_QUUX_FACTOR";と入力します。

レコード内の特定のビットをオンまたはオフにして、残りのフラグはデフォルト設定のままにすることができます。
これは、クラスを指定するときとほぼ同じ方法で行います。

=デフォルト+、-...;

**記録**\
これは、クラスのEspire宣言で指定されたインスタンスデータフィールドの名前です。

**フラグ名**\
オン/オフを切り替えるフラグです。
フラグの前に「+」を付けると、フラグのデフォルト値が設定されます。「-」を付けると、フラグのデフォルト値がクリアされます。

たとえば、次のような行があります。

    aRecord=default+aFlag, -anotherFlag;

フィールドaFlagが設定され、anotherFlagがクリアされることを除き、フィールドaRecordがデフォルト設定を持つことを指定します。

##### 4.3.2.1親子リンクの設定

GenオブジェクトとVisオブジェクトは、子の階層に配置されます。
GEOSは、最初の子と次の兄弟への特別なリンクを使用してこれを実装します。
ただし、このことを気にする必要はありません。
オブジェクトの子を設定するには、Espire
childrenディレクティブを使用するだけです。

オブジェクトの子を指定するには、オブジェクトのデータに次の行を追加します。

    children=<子の名前>[,<子の名前>]*;

**子の名前**\
これらは子の名前で、順番にコンマで区切られています。

UICは、親と子のリンクを適切な方法で相互に自動的に設定します。

##### 4.3.2.2ヒントとVardata

uiファイルには、オブジェクトのヒントやその他の変数データを指定できます。
これを行うには、instance-dataセクションに「hints」ディレクティブを置きます。
このディレクティブの形式は次のとおりです。

    hints={<hintOrVardataName>[{<値>}]/*必要に応じて繰り返し. */}と入力します。

**hintOrVardataName**\
これは、クラスのアセンブリ定義で指定されたヒントまたはvardataフィールドの名前です。

**値(value)**\
このフィールドはオプションです。vardataフィールドが値を取る場合は、ここで指定できます。
中括弧の間にあるものはすべて.rdfファイルに書き込まれます。つまり、UICによって解釈されません。

#### 4.3.3チャンクの作成

チャンクはオブジェクトに非常によく似ています。
これらはオブジェクトブロックに配置され、名前で参照されます。
また、LMemデータブロックに配置することもできます。

文字列を含むチャンクを作成するには、次の形式を使用します。

    chunk<chunkName>="テキスト.";

**chunkName**\
これはチャンクの名前です。
この名前は、チャンクのoptrとして使用できます。

UICは、テキストをヌル終端文字列として含むチャンクを作成します。

チャンクに他の種類のデータが含まれている場合、フォーマットは次のようになります。

    chunk<chunkName>={<dataType><value>/*必要に応じて繰り返す*/}

**chunkName**\
これはチャンクの名前です。
この名前は、チャンクのoptrとして使用できます。

**データ型**\
これがデータの種類です。
これは標準のEspデータ型であり、Espire型ではありません。
また、アプリケーション定義の構造、レコードなどの場合もあります。

**値(value)**\
これはデータの値です。 これは、Espでのように指定します。

イニシャライザはUICではなくEspで評価されることに注意してください。
これらは、で説明されているように、Espグローバル変数であるかのように指定する必要があります。[第2章第2.3.1節](ebasics.md#231-data-types)ボタンをクリックし

オブジェクトのインスタンス・データ・フィールドに、そのフィールド用に作成されたチャンクへのoptrを含めたい場合があります。
チャンクが名前を必要とせず、そのオブジェクトによってのみ使用される場合は、次のように、そのインスタンスフィールドの初期化子でチャンクを定義できます。

    <field>=チャンク{/*チャンク・データ*/}

または

    <field>=chunk"文字列."

**畑**\
これはインスタンスデータフィールドの名前です。
このフィールドにはoptrを含めることができる必要があります。

チャンクは、オブジェクトと同じリソースに作成されます。
チャンクには名前がなく、フィールドにはチャンクへのoptrが含まれます。
つまり、Espireコード

    AnObject=MyVis{chunkPtr=chunk{dw 1, 2, 3, 4}}

機能的には

    AnObject=MyVis{chunkPtr=MyChunk;}chunk MyChunk={dw 1, 2, 3, 4}

唯一の違いは、2番目の例では、MyChunkという名前がチャンクに対するoptrとして評価されることです。
(これにより、Swatでチャンクを名前で調べることができます)。

#### 4.3.4 VisMonikersの創造

**VisMoniker**は、Gocとほぼ同じ方法で作成されます。
Gocと同様に**VisMoniker**は、単一のモニカ、またはモニカのリストです。モニカのリストがある場合、システムは、特定のUIおよびモニタに最も適したモニカを選択します。

名前が単純なテキストの場合、フォーマットは次のようになります。

    visMoniker<monikerName>="Text moniker";

**monikerName**\
これがその呼び名です。
この名前は、ニックネームのオプションとして使用できます。

これにより、単純なテキスト・モニカが作成されます。
特殊な属性を持つ、より複雑な名前を作成するには、次の形式を使用します。

    visMoniker<monikerName>={[<attr>=<initializer>;]*"Text moniker";/*これはオプションです*/}

**monikerName**\
これがその呼び名です。
この名前は、ニックネームのオプションとして使用できます。

**属性**\
これはVisMonikerアトリビュートの名前です。
これらについては、で説明します。[『Object Reference
Book』の第2章「GenClass」の「Visual
Monikers」](../Objects/ogen.md)ボタンをクリックし

**イニシャライザ**\
これは、フィールドに設定する値です。

オブジェクト内のフィールドの型がVisMonikerCompの場合は、VisMonikerの名前で初期化するか、次のようにオンザフライでVisMonikerを作成できます。

    <fieldName>="テキスト名";

または

    <fieldName>={/*属性とイニシャライザ*/}

**フィールド名**\
これはインスタンスデータフィールドの名前です。
フィールドのタイプはVisMonikerCompである必要があります。

UICは、指定されたVisMonikerを持つチャンクを自動的に作成し、インスタンスデータフィールドがそのチャンクを指すように設定します。

インスタンスデータフィールドにVisMonikersのリストを含めることができます。
GEOSは、最も適切な名前を自動的に使用します。
これを行うには、次のようにインスタンスデータフィールドを初期化します。

    <fieldName>=list{<monikerName>[,<monikerName>]*}

**フィールド名**\
これはインスタンスデータフィールドの名前です。
フィールドはタイプである必要があります**VisMonikerComp**ボタンをクリックし

**monikerName**\
これは**VisMoniker**この名前は、同じリソースにある場合もあれば、別のリソースにある場合もあります。

[定型文](erout.md)\<-[目次](../esp.md)-\>(英語)[CとAssemblyの混合](emixing.md)
