<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=utf8"
 http-equiv="content-type">
  <title>GTKサーバクイックスタートマニュアル</title>
  <meta content="Peter van Eerten" name="author">
</head>
<body>
<h1>GTKサーバクイックスタートマニュアル。</h1>
          <br>
        <hr style="width: 100%; height: 2px;">
<h2>1.GTKサーバのバイナリ。</h2>このバイナリは、システム上のGTKライブラリを開こうとします。&#39;gtk-server.cfg&#39;ファイルに記述されているGTKライブラリを探します。Windowsの場合、GTK DLLは別のインストールパッケージで提供されています。<br><br>Linux版とWindows版のGTKサーバは、名前付きパイプ、TCP、UDPの2-wayパイプによる通信をサポートしています。2-wayパイプの場合、GTKサーバは引数&#39;stdin&#39;で起動する必要があります。名前付きパイプの場合、GTKサーバは引数&#39;fifo&#39;で起動する必要があり、その後にパイプの名前を指定する必要があります。Windowsでは、名前付きパイプの名前は省略できます。GTKサーバは、事前に定義された名前&quot;\\.\pipe\out&quot;と&quot;\\.\pipe\in&quot;を持つ2つの独立したパイプを設定します。最後に、TCPまたはUDP通信を有効にするには、引数は&#39;&lt;-tcp=ipaddress:port>&#39;または&#39;&lt;-udp= ipaddress:port>&#39;の形式である必要があります。<br><br>TCPモードのLinuxバージョンのみが、1つのサーバへの複数の接続をサポートします。この機能を有効にするには、引数&#39;&lt;-tcp=ipaddress:port:max>&#39;でGTKサーバを起動します。&#39;max&#39;は、接続できるクライアントの最大数を決定します。&#39;max&#39;引数が省略された場合、接続できるプログラムは1つだけです。ただし、Win32の場合、&#39;max&#39;引数は使用できません。ここでは、クライアントプログラムごとに個別のサーバを起動する必要があります。<br><br>最後の引数が&#39;-log=file.txt&#39;の場合、GTKサーバは&#39;file.txt&#39;というタイトルのログファイルを生成します。もちろん、ここでは任意の名前を使用できます。このログファイルには、GTKサーバが受信した文字列と、それらの文字列に対するGTKサーバの応答が含まれます。これにより、スクリプトでGTKエラーをチェックできます。<br><br><br><hr style="width: 100%; height: 2px;">
<h2>2.GTKサーバーの構成ファイル</h2>構成ファイルでは、呼び出すGTK関数を記述する必要があります。&#39;#&#39;で始まるエントリはスキップされます。&#39;#&#39;を使用して、構成ファイルにコメントを入力できます。すべてのGTK関数には特定のプロパティがあります。例を見てみましょう。<br><br><small><b>FUNCTION_NAME=gtk_toggle_button_new_with_label,クリック,WIDGET,1,STRING</b></small><br><br>この行には、GTK関数「gtk_toggle_button_new_with_label」が記述されています(GTK関数のプロパティについては、次の場所にあるGTKドキュメントを参照してください)。<a href="http://www.gtk.org/">http://www.gtk.org</a>)次の引数は、このウィジェットのコールバックのタイプを記述します。コールバックは、GTKライブラリがリッスンする必要があるシグナルです。この場合、トグルボタンは既定で「クリックされた」シグナルに応答します。このシグナルは、このボタンをマウスでクリックしたときに発生します。GTK関数とシグナルの名前を除き、ここでは大文字を使用する必要があることに注意してください!<br><br>コールバックシグナルの後に、GTK関数から返される値(戻り値)を入力する必要があります。上の例では、ウィジェットがスクリプトに返されます。その他の戻り値は、&#39;STRING&#39;、&#39;BOOL&#39;、&#39;LONG&#39;、&#39;FLOAT&#39;および&#39;NONE&#39;です。<br><br>その後、このGTK関数に必要な引数の数を指定する必要があります。この例では、引数は1つだけです。ここでの引数のタイプは&#39;STRING&#39;です。その他の引数のタイプは&#39;LONG&#39;、&#39;WIDGET&#39;、&#39;FLOAT&#39;、&#39;DOUBLE&#39;、&#39;BASE64&#39;、および&#39;NULL&#39;です。したがって、各引数に対してタイプを宣言する必要があります-正しい順序で!3つの引数の場合は、指定する順序がGTK関数の実際の順序と同じであることに注意してください。<br><br><br><hr style="width: 100%; height: 2px;">
<h2>3.コールバックシグナルをキャッチする</h2>ウィジェットからのコールバック信号をキャッチするには、内部GTKサーバー関数を使用する必要があります。関数の名前は&#39;gtk_server_callback&#39;です。この関数は、&#39;0&#39;、&#39;1&#39;、または&#39;2&#39;の1つの引数のみを取ります。&#39;1&#39;の代わりに単語&#39;wait&#39;を使用することもでき、&#39;2&#39;の代わりに単語&#39;update&#39;を使用できます。この関数は、ユーザー・インタフェースがコールバック信号を受信したかどうかをチェックします。<br><br>&#39;gtk_server_callback&#39;の引数が&#39;2&#39;の場合、GTKサーバーはキューで待機中のすべてのイベントを更新し、待機中のコールバックがあるかどうかをチェックします。この引数を指定すると、&#39;gtk_server_callback&#39;はすぐに戻ります。コールバックがない場合は&#39;0&#39;が返され、コールバックがない場合はwidgetIDが返されます。引数が&#39;1&#39;の場合、GTKサーバーはキュー内のすべてのイベントを更新し、イベントが発生するまで待機します。その場合にのみ、&#39;gtk_server_callback&#39;はシグナルが発生したwidgetIDを返します。最後に、引数が&#39;0&#39;の場合、この関数はユーザーインターフェイスを更新しませんが、イベントをチェックしてすぐに戻るだけです。この場合、クライアントプログラムはユーザーインターフェイスの更新を独自に処理する必要があります。これは、GUIイベントではなく他のイベント(ネットワークイベントなど)を待機する必要がある場合に必要になることがあります。<br><br>したがって、トグルボタンが「クリック」信号を発したかどうかをKSHでチェックする必要がある場合は、次のように記述できます。<br><br><small><b>print-p&quot;gtk_server_callback wait&quot;;read-p EVENT if[EVENT-eq BUTTON]then print&quot;マウスボタンが押されました!&quot;fi</b></small><br>上記のコードでは、イベントが発生した場合、呼び出しはウィジェットIDを返します。それ以外の場合は待機します。結果は変数「EVENT」に格納されます。この結果を既存のウィジェットIDと比較して、適切なアクションを実行できます。<br><br>&#39;gtk-server.cfg&#39;ファイルの既定のコールバックシグナルとは別に、シグナルを手動でウィジェットに接続することもできます。このためには、関数&#39;gtk_server_connect&#39;を使用できます。この関数は、ウィジェットID、シグナル名、およびシグナルを識別する文字列の3つの引数を取ります。次に例を示します。<br><br><small><b>print-p&quot;gtk_server_connect BUTTON enter hello&quot;;read-p RESULT print-p&quot;gtk_server_callback wait&quot;;read-p EVENT if[EVENT-eq&quot;hello&quot;]then print&quot;Mouse entered button region!&quot;fi</b></small><br>GTKサーバは常にそのデータを文字列として返すことを覚えておいてください。返された結果を数値として使用するために、一部の言語(Scriptbasicなど)ではタイプキャストが必要です。<br><br><br><hr style="width: 100%; height: 2px;">
<h2>4.Glade XMLファイルの使用</h2>Gladeを使用してユーザー・インターフェースを設計した場合、GTKサーバーは結果のXMLファイルを読み取り、インターフェースを実現することができます。最初に、XMLファイルの場所を指定します。<br><br><small><b>print-p&quot;glade_xml_new mygui.glade$NULL$NULL&quot;;読み込み-p XML</b></small><br>次に、メインループで使用できるwidgetIDをGladeに問い合わせます。すべてのウィジェットの名前は、Glade XMLファイルに記載されています:<br><br><small><b>print-p&quot;glade_xml_get_widget$XML nameofwidget&quot;;read-p WIDGET</b></small><br>ここから、通常の方法でプログラムをセットアップし、widgetIDを使用してシグナルを接続し、メインループでキャッチすることができます。<br><br><hr style="width: 100%; height: 2px;"><br>(c)2003年12月～2008年12月、Peter van Eerten-http://www.gtk-server.org/<br><br><hr style="width: 100%; height: 2px;">
          <br>
        </body>
</html>
